#ifndef header_math_extra_semisimple_lie_subalgebras_sltwos_ALREADY_INCLUDED
#define header_math_extra_semisimple_lie_subalgebras_sltwos_ALREADY_INCLUDED

#include "math_extra_algebraic_numbers.h"
#include "math_extra_semisimple_lie_algebras.h"
#include "math_extra_semisimple_lie_algebras_root_subalgebras.h"
#include "math_general.h"
#include "math_polynomials.h"

class CartanElementCandidate {
  friend std::ostream& operator<<(
    std::ostream& output, const CartanElementCandidate& element
  ) {
    output << element.toString(nullptr);
    return output;
  }
public:
  ElementSemisimpleLieAlgebra<AlgebraicNumber> h;
  Matrix<AlgebraicNumber> adjointAction;
  ElementSemisimpleLieAlgebra<AlgebraicNumber> e;
  ElementSemisimpleLieAlgebra<AlgebraicNumber> f;
  static unsigned int hashFunction(const CartanElementCandidate& input) {
    return input.h.hashFunction();
  }
  int hashFunction() const {
    return this->h.hashFunction();
  }
  bool operator==(const CartanElementCandidate& other) const {
    return this->h == other.h;
  }
  AlgebraicNumber scalarProductKilling(const CartanElementCandidate& other)
  const;
  Rational scalarProductKillingMustBeRational(
    const CartanElementCandidate& other
  ) const;
  std::string toMathMLVerification() const;
  std::string toStringVerification() const;
  std::string toHTML(FormatExpressions* format) const;
  std::string toString(FormatExpressions* format) const;
  CartanElementCandidate operator-(const CartanElementCandidate& other) const {
    CartanElementCandidate result;
    result.h = this->h - other.h;
    result.adjointAction = this->adjointAction - other.adjointAction;
    return result;
  }
};

class CentralizerComputer;

// Represents a reductive Lie subalgebra that is either a
// simple component or a 1-dimensional subalgebra
// generated by a semisimple element.
class SimpleSubalgebraComponent {
  Rational computeSimpleRootScalarProductAmbientKilling(int i, int j) const;
  // A helper method for determining whether dual element to
  // a root space is simple.
  bool isSimpleIndex(int i);
  friend std::ostream& operator<<(
    std::ostream& output, const SimpleSubalgebraComponent& element
  ) {
    output << element.toString(nullptr);
    return output;
  }
public:
  SemisimpleLieAlgebra* owner;
  AlgebraicClosureRationals* algebraicClosure;
  // Used for debugging, an optional centalizer computer that
  // contains the component.
  CentralizerComputer* optionalContainer;
  // Elements of the cartan scaled so they act on their root spaces by
  // a scalar of \pm 2.
  List<CartanElementCandidate> dualsToRoots;
  List<Vector<AlgebraicNumber> > dualsToRootsAlgebraic;
  // Defining semisimple elment.
  // This is the element whose eigenvalues and eigenspaces
  // were used to compute the dualsToRoots
  CartanElementCandidate definingSemisimpleElement;
  HashedList<CartanElementCandidate> positiveDualsOfRootSpaces;
  List<CartanElementCandidate> simpleDualsOfRootSpaces;
  List<CartanElementCandidate> simpleDualsOfRootSpacesAmbientAdjoint;
  DynkinDiagramRootSubalgebra dynkinDiagramComputer;
  Matrix<Rational> coSymmetricCartanMatrixCentralizerAmbientKilling;
  DynkinType simpleType;
  // The killing square of the shortest Cartan element.
  // The shortest Cartan element corresponds to the longest root
  // of the root system.
  Rational killingSquareProductShortestDual;
  // A label for this centralizer to be used in internal printouts
  // to help us with debugging when the simpleType is not computed yet.
  std::string label;
  void initialize(
    SemisimpleLieAlgebra* inputOwner,
    AlgebraicClosureRationals* inputAlgebraicClosure,
    const CartanElementCandidate& inputDefiningSemisimpleElement,
    CentralizerComputer* inputOptionalContainer
  );
  bool isLinkedTo(const CartanElementCandidate& maybeBelongsToComponent) const;
  std::string toString(FormatExpressions* format) const;
  bool compute();
  SimpleSubalgebraComponent();
};

struct RootSpacePair {
  // Suppose the positive root space is given by vectors v_1, ..., v_k
  // and the negative root space is given by w_1, ..., w_k.
  // Given coordinates (a_1, ..., a_k) and (b_1, ..., b_k), constructs the
  // vectors a_1v_1+...+a_kv_k and b_1w_1+...+b_kw_k and appends them to the
  // output pair.
private:
  void appendLinearCombinations(
    const Vector<AlgebraicNumber>& positiveCoordinates,
    const Vector<AlgebraicNumber>& negativeCoordinates,
    RootSpacePair& output
  ) const;
public:
  List<Vector<AlgebraicNumber> > positiveSpace;
  List<Vector<AlgebraicNumber> > negativeSpace;
  // Constructs a root space pair from a list of positive
  // and negative coordinates, where the coordinates follow the same convention
  // as that
  // of function [appendLinearCombinations].
  RootSpacePair constructFromLinearCombinations(
    const List<Vector<AlgebraicNumber> >& positiveCoordinates,
    const List<Vector<AlgebraicNumber> >& negativeCoordinates
  ) const;
};

class CentralizerComputer {
  SemisimpleLieAlgebra* owner;
  AlgebraicClosureRationals* algebraicClosureRationals;
  bool intersectAmbientCartanWithCentralizer();
  bool trySemisimpleElement(ElementSemisimpleLieAlgebra<Rational>& candidate);
  bool findSemisimpleElementEigenvalues();
  // Computes the root spaces of the candidate semisimple element.
  bool computeRootSpaces();
  // Computes the cartan of the centralizer from the given semisimple element.
  // Will fail if the element is not semisimple or not generic enough;
  // when that happens the elements that commute with the semisimple element
  // do not all pairwise commute.
  bool computeCartanOfCentalizerFromSemisimpleElement();
  bool computeOnDemandCartanOfCentralizerMatrixForm();
  bool computeRootSpaceForNonZeroEigenvalue(const AlgebraicNumber& eigenvalue);
  bool subsplitRootSpaces(
    const AlgebraicNumber& startingEigenvalue,
    const List<Vector<AlgebraicNumber> >& rootSpace,
    const List<Vector<AlgebraicNumber> >& negativeRootSpace
  );
  bool subsplitRootSpacesOnce(
    const RootSpacePair& rootSpacePair, List<RootSpacePair>& output
  );
  bool subsplitRootSpacesOnceAgainstCartanElement(
    const RootSpacePair& rootSpacePair,
    const CartanElementCandidate& splittingElementCentralizerCartan,
    List<RootSpacePair>& output
  );
  bool computeRootSpaceFromEAndF(
    const AlgebraicNumber& eigenvalue,
    const Vector<AlgebraicNumber>& eInCentralizerCoordinates,
    const Vector<AlgebraicNumber>& fInCentralizerCoordinates
  );
  // Computes the dynkin type of the centralizer
  // from the dualsOfRootSpaces.
  bool computeTypes();
  // Computes the bases of the reductive components of
  // the centralizer from the dualsOfRootSpaces.
  void computeReductiveComponentsBases();
  void mergeOneRootSpaceCandidate(const CartanElementCandidate& candidate);
  // Combines reductive components currently being grown
  // into a single reductive component.
  void mergeReductiveComponents(
    List<int>& indicesOfComponentsToBeMergedSorted
  );
  // For this function, we are given a simple type A_1^b,
  // a Cartan subalgebra H, and a basis of the centralizer of
  // A_1^b intersected with H, that is,
  // a basis h_1, ..., h_k of C(A_1^b) \cap H.
  // Our mathematical goal is to select a sufficiently generic
  // linear combination h_s=a_1h_1 + ... + a_kh_k so that C(A_1^b)
  // decomposes into root spaces with respect to h_s. Here,
  // by "root spaces with respect to h_s" we mean
  // eigenvectors of ad(h_s) that no multiplicities.
  // The present function returns an arbitrarily chosen number
  // a_index, where we aim to choose a_index as small as possible
  // (so that computations run fast), and as large as possible
  // so that h_s has no eigenvalue multiplicities and has
  // sufficiently simple eigenvalues that we can compute them easily.
  // The coefficients were selected through manual experimentation
  // by running the end-to-end centralizer computation
  // and checking that the entire computation goes through.
  // - index gives the index of the coefficient a_index.
  // - ambientSimple type gives the ambient Simple Lie algebra.
  //   If the ambient Lie algebra is not simple, just pass an
  //   invalid type such as 'X'.
  // - ambientRank gives the rank of the ambient semisimple Lie algebra.
  // - dynkinIndexOfSlTwo gives the Dynkin index b of the sl(2).
  static int arbitraryCartanWeight(
    int index,
    char ambientSimpleType,
    int ambientRank,
    const Rational& dynkinIndexOfSlTwo
  );
  // Helper method for the implementation of arbitraryCartanWeight.
  static List<int> hardCodedArbitraryCoefficientsCartan(
    char ambientSimpleType, int ambientRank, const Rational& dynkinIndexOfSlTwo
  );
  // Returns an arbitrary coefficient used when forming a semisimple element
  static Rational arbitraryCoefficientToFormSemisimpleElement(
    int coefficientIndex,
    char type,
    int rank,
    const Rational& hElementLength,
    int centralizerDimension
  );
  // Returns an arbitrary coefficient used when forming a semisimple element
  static List<int> hardCodedCoefficientsToFormSemisimpleElement(
    char type,
    int rank,
    const Rational& hElementLength,
    int centralizerDimension
  );
  static List<int> onesAtPositions(
    const List<int>& positions, int desiredSize
  );
  std::string label;
  // The dynkin index of the simple subalgebra being centralized, if known.
  // If the subalgebra being centralized is not simple, this can be set to 0.
  Rational dynkinIndexOfCentralizedComponent;
  List<ElementSemisimpleLieAlgebra<Rational> > generatorsToCentralize;
  List<ElementSemisimpleLieAlgebra<Rational> > centralizerBasis;
  List<ElementSemisimpleLieAlgebra<AlgebraicNumber> >
  centralizerBasisOverAlgebraicNumbers;
  List<ElementSemisimpleLieAlgebra<Rational> >
  centralizerIntersectedWithAmbientCartan;
  // A semisimple element of the centalizer whose centralizer can serve as a
  // Cartan subalgebra.
  CartanElementCandidate semisimpleElement;
  List<ElementSemisimpleLieAlgebra<Rational> > centralizerCartan;
  List<CartanElementCandidate> centralizerCartanCandidates;
  // A computational structure to find the eigenvalues and eigenspaces of the
  // preceding element.
  MatrixEigenvalueFinder semisimpleElementAdjointEigenvalueFinder;
  // Elements of the Cartan. When the elements have
  // defining sl(2)-root spaces,
  // the elements are scaled so they act by a scalar of \pm 2.
  // If the element has no defining sl(2)-triple and therefore
  // is an element of the toral part of the centralizer, then
  // the scale is arbitrary.
  List<CartanElementCandidate> dualsOfRootSpaces;
  List<SimpleSubalgebraComponent> simpleComponents;
  DynkinType typeIfKnown;
  bool flagBasisComputed;
  bool flagCartanSelected;
  void getCentralizerElementFromCoordinates(
    const Vector<AlgebraicNumber>& vector,
    ElementSemisimpleLieAlgebra<AlgebraicNumber>& output
  );
  bool makeCartanCandidate(
    const ElementSemisimpleLieAlgebra<AlgebraicNumber>& inputH,
    const ElementSemisimpleLieAlgebra<AlgebraicNumber>& inputE,
    const ElementSemisimpleLieAlgebra<AlgebraicNumber>& inputF,
    CartanElementCandidate& output
  );
  bool makeCartanCandidate(
    const ElementSemisimpleLieAlgebra<Rational>& inputH,
    const ElementSemisimpleLieAlgebra<Rational>& inputE,
    const ElementSemisimpleLieAlgebra<Rational>& inputF,
    CartanElementCandidate& output
  );
  void makeCartanCandidateNoFailure(
    const ElementSemisimpleLieAlgebra<Rational>& inputH,
    const ElementSemisimpleLieAlgebra<Rational>& inputE,
    const ElementSemisimpleLieAlgebra<Rational>& inputF,
    CartanElementCandidate& output
  );
  bool doCompute();
public:
  bool flagTypeComputed;
  bool flagComputationAttempted;
  CentralizerComputer();
  bool computeType(DynkinType* outputType);
  void setCentralizerType(const DynkinType& knownType);
  void initialize(
    SemisimpleLieAlgebra* inputOwner,
    AlgebraicClosureRationals* inputAlgebraicClosure,
    List<ElementSemisimpleLieAlgebra<Rational> >& inputGeneratorsToCentralize,
    Rational* inputDynkinIndexOfCentralizedComponent,
    const std::string& inputLabel
  );
  std::string toStringType(FormatExpressions* format) const;
  std::string toString(FormatExpressions* format) const;
  bool compute();
};

// The sl(2)-subalgebra candidate from which the sl(2) is to be realized.
// Contains internal information about the computation,
// intermediate systems of equations, etc.
class SlTwoSubalgebraCandidate {
  // Returns a list of arbitrarily chosen small numbers that, when
  // chosen as arbitrary coefficients for forming the element f
  // result in an H, E, F triple.
  // The numbers were found by quick manual experimentation with small integers
  // of approximate value less than 20 and running the calculator to
  // inspect if so formed H, F elements extend to H, E, F-triples.
  static List<Rational> fArbitraryCoefficients(
    char type, int rank, int dynkinIndex, const Vector<Rational>& targetH
  );
  // Returns an arbitrary coefficient to use when forming the element f
  // in a potential h,e,f-triple.
  static Rational fArbitraryCoefficient(
    int coefficientIndex,
    char type,
    int rank,
    int dynkinIndex,
    const Vector<Rational>& targetH
  );
public:
  // Owner semisimple Lie algebra.
  SemisimpleLieAlgebra* owner;
  // sl(2)-subalgebra container.
  SlTwoSubalgebras* container;
  // Algebraic closure. Not needed over the complex numbers
  // as sl(2)'s are realizable
  // as rational linear combinations of the Chevalley generators.
  // However, we need this for real form computations.
  AlgebraicClosureRationals* algebraicClosure;
  Rational lengthHSquared;
  Vector<Rational> candidateH;
  ElementSemisimpleLieAlgebra<AlgebraicNumber> hAlgebraic;
  Vectors<Rational> participatingPositiveRoots;
  Vectors<Rational> rootsWithScalar2WithH;
  Vectors<Rational> preferredAmbientSimpleBasis;
  ElementSemisimpleLieAlgebra<Rational> hElement;
  // One possible element e for which [e, f] = h
  // [h, e] = 2e.
  ElementSemisimpleLieAlgebra<Rational> eElement;
  // One possible element f for which [e, f] = h
  // [h, f] = -2f.
  ElementSemisimpleLieAlgebra<Rational> fElement;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > eUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > fUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > eArbitraryUnknown;
  // Mathematically equal to the previous.
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > hPolynomialRational;
  // Mathematically equal to the previous.
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  hPolynomialAlgebraic;
  // Arbitrarily chosen coefficients of the F element over the rationals.
  // This arbitrary choice of F allows to reduce
  // the polynomial system needed to realize the E and F
  // to a linear one.
  // The rationale for this arbitrary choice:
  // 1) Speed (linear systems are easer to solve than polynomial systems).
  // 2) Algorithmic simplicity. When this function was first designed,
  // we did not have machinery for solving polynomial systems
  // so this used to be an algorithmic necessity.
  //
  // Here, we recall that the element H is known and computed by algorithms
  // following Dynkin.
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > fArbitrary;
  // The matrix of the linear system given by systemToSolveArbitrary.
  Matrix<Rational> systemArbitraryMatrix;
  // The column-vector of the linear system given by systemToSolveArbitrary.
  Matrix<Rational> systemArbitraryColumnVector;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> >
  eBracketFMinusHArbitraryUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > eBracketFMinusHUnknown;
  // An element of the form x_1 g_{k_1} + ... + x_s g_{k_s} where
  // x_1, ..., x_s are unknowns and g_{?} are the Chevalley generators
  // of the root spaces given by participatingPositiveRoots.
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  eKostantSekiguchiUnknown;
  // An element of the form x_1 g_{-k_1} + ... + x_s g_{-k_s} where
  // x_1, ..., x_s are unknowns and g_{-?} are the Chevalley generators
  // of the root spaces given by the negatives of the
  // participatingPositiveRoots.
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  fKostantSekiguchiUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  eBracketFMinusHUnknownKostantSekiguchi;
  // The polynomial system required to solve to find a Kostant-sekiguchi triple
  // e, f, h.
  // Here, we assume that theta(h) = - h is already satisfied.
  PolynomialSubstitution<AlgebraicNumber> systemToSolveKostantSekiguchi;
  // The polynomial (actually, linear) system required to solve for
  // eArbitraryUnknown.
  PolynomialSubstitution<Rational> systemToSolveArbitrary;
  // The polynomial system required to solve to find e, f.
  PolynomialSubstitution<Rational> systemToSolve;
  // Fix one Cartan involution theta for which theta(h) = -h.
  //
  // The following element has all properties that the rational element e has,
  // as well as the following additional property:
  //
  // 1) e - f is invariant with respect the cartan involution, i.e.,
  // theta(e-f)=e-f.
  //
  // An h, e, f-triple as above is called a Kostant-Sekiguchi sl(2)-triple.
  ElementSemisimpleLieAlgebra<AlgebraicNumber> eKostantSekiguchi;
  // F element of the Kostant-Sekiguchi sl(2)-triple.
  ElementSemisimpleLieAlgebra<AlgebraicNumber> fKostantSekiguchi;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> > eMinusFUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  involutionAppliedToEMinusF;
  // A global label for the candidate; includes the type of
  // the ambient Lie algebra and the h element.
  std::string globalLabel;
  // Initializes the h,e,f computation with f arbitrarily chosen.
  // See the preceding comments on why f is chosen arbitrarily.
  void initializeUnknownTriples(const Vector<Rational>& targetH);
  bool attemptExtendingHFtoHEFWithRespectToSubalgebra(
    Vectors<Rational>& rootsWithCharacteristic2,
    Selection& zeroCharacteristics,
    Vectors<Rational>& simpleBasisSubalgebras,
    Vector<Rational>& h,
    bool computeRealForm,
    MapReferences<std::string, AlgebraicClosureRationals>& algebraicClosures
  );
  SemisimpleLieAlgebra& getOwnerSemisimpleAlgebra();
  void initializeHEFSystemFromFCoefficients(
    const Vector<Rational>& targetH,
    LinearMapSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >*
    cartanInvolutionPreservedByEMinusF
  );
  void initializeHEFSystemFromFCoefficientsPartTwo();
  void computeLieBracketsUnknowns();
  void computePolynomialSystems();
  const WeylGroupData& getOwnerWeyl() const;
  bool attemptRealizingKostantSekiguchi();
  bool checkConsistencyParticipatingRoots(const Vector<Rational>& targetH);
  void adjoinKostantSekiguchiRelationsToPolynomialSystem(
    LinearMapSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >*
    cartanInvolutionPreservedByEMinusF
  );
};

class SlTwoSubalgebra {
public:
  friend std::ostream& operator<<(
    std::ostream& output, const SlTwoSubalgebra& sl2
  ) {
    output << sl2.toString();
    return output;
  }
  SemisimpleLieAlgebra* owner;
  SlTwoSubalgebras* container;
  AlgebraicClosureRationals* algebraicClosure;
  CharacterSemisimpleLieAlgebraModule<Rational>
  moduleDecompositionAmbientSubalgebra;
  List<int> moduleDimensions;
  int indexInContainer;
  int dimensionCentralizer;
  Rational dimensionCentralizerToralPart;
  bool flagCentralizerIsRegular;
  HashedList<int> indicesContainingRootSubalgebras;
  List<int> indicesMinimalContainingRootSubalgebras;
  Vectors<Rational> participatingPositiveRoots;
  // Mathematically equal to the previous.
  ElementSemisimpleLieAlgebra<AlgebraicNumber> hAlgebraic;
  // Used to check our work over the rationals
  ElementSemisimpleLieAlgebra<Rational> hBracketE;
  ElementSemisimpleLieAlgebra<Rational> hBracketF;
  ElementSemisimpleLieAlgebra<Rational> eBracketF;
  // The following describes an optional Cartan involution.
  // A map \theta is a Cartan involution if the following hold.
  // \theta is linear
  // \theta^2 = id.
  // \theta is a lie bracket automorphism, i.e., [\theta(a), \theta(b)] =
  // \theta([a,b]).
  // Here, if theta is not null, we request that it
  // correspond to the maximally compact real form and have the property
  // \theta(h) = -h.
  // TODO(tmilev): does the property above need to be tweaked when
  // we compute outside of the maximally compact real form?
  LinearMapSemisimpleLieAlgebra<Rational>* cartanInvolutionPreservedByEMinusF;
  // Same as hKostantSekiguchi but with polynomial coefficients.
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  hKnownKostantSekiguchi;
  List<CharacterSemisimpleLieAlgebraModule<Rational> >
  moduleDecompositionMinimalContainingRootSubalgebras;
  Vector<Rational> hElementCorrespondingToCharacteristic;
  Vectors<Rational> hCommutingRootSpaces;
  DynkinDiagramRootSubalgebra diagramM;
  int dynkinsEpsilon;
  bool flagDeallocated;
  // A list of desired scalar product of the h element with the simple roots.
  // The terminology comes from Dynkin's paper on semisimple Lie subalgebras.
  Vector<Rational> hCharacteristic;
  Vectors<Rational> preferredAmbientSimpleBasis;
  Matrix<Rational> systemArbitraryMatrix;
  Matrix<Rational> systemArbitraryColumnVector;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  hPolynomialAlgebraic;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > fArbitrary;
  ElementSemisimpleLieAlgebra<Rational> hElement;
  ElementSemisimpleLieAlgebra<Rational> eElement;
  ElementSemisimpleLieAlgebra<Rational> fElement;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > eArbitraryUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > eUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > fUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > eBracketFMinusHUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  eKostantSekiguchiUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  fKostantSekiguchiUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  eBracketFMinusHUnknownKostantSekiguchi;
  PolynomialSubstitution<Rational> systemToSolve;
  PolynomialSubstitution<AlgebraicNumber> systemToSolveKostantSekiguchi;
  ElementSemisimpleLieAlgebra<AlgebraicNumber> eKostantSekiguchi;
  ElementSemisimpleLieAlgebra<AlgebraicNumber> fKostantSekiguchi;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> > eMinusFUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  involutionAppliedToEMinusF;
  Rational lengthHSquared;
  CentralizerComputer centralizerComputer;
  void fromSlTwoSubalgebraCandidate(SlTwoSubalgebraCandidate& input);
  void initialize();
  SlTwoSubalgebra() {
    this->flagDeallocated = false;
    this->initialize();
  }
  ~SlTwoSubalgebra() {
    this->flagDeallocated = true;
  }
  void computeDynkinTypeEmbedded(DynkinType& output) const;
  bool checkConsistency() const;
  SlTwoSubalgebras& getContainerSl2s() {
    if (this->container == nullptr) {
      global.fatal
      << "Attempt to "
      << "access the container list of "
      << "a non-initialized sl(2)-subalgebra. "
      << global.fatal;
    }
    return *this->container;
  }
  const WeylGroupData& getOwnerWeyl() const;
  SemisimpleLieAlgebra& getOwnerSemisimpleAlgebra() {
    if (this->owner == nullptr) {
      global.fatal
      << "Attempt to access "
      << "the ambient Lie algebra of a "
      << "non-initialized sl(2)-subalgebra. "
      << global.fatal;
    }
    return *this->owner;
  }
  std::string toMathMLTriple(FormatExpressions* format) const;
  std::string toMathMLFinalTriple(FormatExpressions* format) const;
  std::string toStringTriple(FormatExpressions* format) const;
  std::string toStringTripleStandardRealization(
    Matrix<AlgebraicNumber> matrixH,
    Matrix<AlgebraicNumber> matrixE,
    Matrix<AlgebraicNumber> matrixF,
    FormatExpressions* format
  ) const;
  std::string toMathMLTripleStandardRealization(
    Matrix<AlgebraicNumber> matrixH,
    Matrix<AlgebraicNumber> matrixE,
    Matrix<AlgebraicNumber> matrixF,
    FormatExpressions* format
  ) const;
  std::string toStringTripleStandardRealization(
    Matrix<Rational> matrixH,
    Matrix<Rational> matrixE,
    Matrix<Rational> matrixF,
    FormatExpressions* format
  ) const;
  std::string toMathMLTripleStandardRealization(
    Matrix<Rational> matrixH,
    Matrix<Rational> matrixE,
    Matrix<Rational> matrixF,
    FormatExpressions* format
  ) const;
  std::string toHTMLTripleStandardRealization() const;
  std::string toStringTripleVerification(FormatExpressions* format) const;
  std::string toMathMLTripleVerification(FormatExpressions* format) const;
  std::string toHTMLTripleVerification(FormatExpressions* format) const;
  std::string toStringCentralizer(FormatExpressions* format) const;
  std::string toHTMLTripleUnknowns(FormatExpressions* format) const;
  std::string toStringTripleUnknowns(FormatExpressions* format) const;
  std::string toMathMLTripleUnknowns(FormatExpressions* format) const;
  std::string toStringEBracketFMinusHUnknown(FormatExpressions* format) const;
  std::string toMathMLEBracketFMinusHUnknown(FormatExpressions* format) const;
  std::string toHTMLTripleUnknownsPolynomialSystem(
    FormatExpressions* format = nullptr
  ) const;
  template <typename Coefficient>
  std::string toStringPolynomialSystem(
    const PolynomialSubstitution<Coefficient>& system,
    FormatExpressions* format = nullptr
  ) const;
  template <typename Coefficient>
  std::string toMathMLPolynomialSystem(
    const PolynomialSubstitution<Coefficient>& system,
    FormatExpressions* format = nullptr
  ) const;
  std::string toStringTripleArbitrary(FormatExpressions* format) const;
  std::string toMathMLTripleArbitrary(FormatExpressions* format) const;
  std::string toHTMLTripleArbitrary(FormatExpressions* format) const;
  std::string toStringTripleArbitraryMatrix() const;
  std::string toMathMLTripleArbitraryMatrix() const;
  std::string toHTMLTripleArbitraryMatrix(FormatExpressions* format) const;
  std::string toStringDynkinType() const;
  std::string toMathMLFinalDynkinType(FormatExpressions* format) const;
  std::string toString(FormatExpressions* format = nullptr) const;
  std::string toStringTripleArbitraryKostantSekiguchi(
    FormatExpressions* format
  ) const;
  std::string toMathMLTripleArbitraryKostantSekiguchi(
    FormatExpressions* format
  ) const;
  std::string toStringEMinusFKostantSekiguchi(FormatExpressions* format) const;
  std::string toMathMLEMinusFKostantSekiguchi(FormatExpressions* format) const;
  std::string toStringInvolutionAppliedToEMinusF(FormatExpressions* format)
  const;
  std::string toMathMLInvolutionAppliedToEMinusF(FormatExpressions* format)
  const;
  std::string toHTMLKostantSekiguchiTripleInternals(FormatExpressions* format)
  const;
  std::string toStringKostantSekiguchiTriple(FormatExpressions* format) const;
  std::string toStringKostantSekiguchiTripleStandardRealization() const;
  void toHTML(std::string& filePath);
  void toStringModuleDecompositionMinimalContainingRegularSubalgebras(
    bool useLatex, bool useHtml, SlTwoSubalgebras& owner, std::string& output
  ) const;
  std::string toStringMinimalContainingRootSubalgebras(
    const std::string& displayPathAlgebra, FormatExpressions* format
  ) const;
  std::string toStringContainingRootSubalgebras(
    const std::string& displayPathAlgebra, FormatExpressions* format
  ) const;
  void computeModuleDecomposition(
    const Vectors<Rational>& positiveRootsContainingRegularSubalgebra,
    int dimensionContainingRegularSubalgebra,
    CharacterSemisimpleLieAlgebraModule<Rational>& outputHighestWeights,
    List<int>& outputModuleDimensions
  );
  Rational getDynkinIndex() const;
  bool checkIndicesMinimalContainingRootSubalgebras() const;
  void computeModuleDecompositionsitionAmbientLieAlgebra();
  bool attemptToComputeCentralizer(DynkinType* whichCentralizer);
  bool moduleDecompositionFitsInto(const SlTwoSubalgebra& other) const;
  static bool moduleDecompositionLeftFitsIntoRight(
    const CharacterSemisimpleLieAlgebraModule<Rational>& moduleDecompoLeft,
    const CharacterSemisimpleLieAlgebraModule<Rational>& moduleDecompoRight
  );
  bool operator==(const SlTwoSubalgebra& right) const;
  bool operator>(const SlTwoSubalgebra& right) const;
  unsigned int hashFunction() const;
  static inline unsigned int hashFunction(const SlTwoSubalgebra& input) {
    return input.hashFunction();
  }
  void computeModuleDecompositionMinimalContainingRegularSubalgebras(
    SlTwoSubalgebras& owner
  );
  void makeReportPrecomputations(
    RootSubalgebra& minimalContainingRegularSubalgebra
  );
};

class SlTwoSubalgebras {
  friend class SemisimpleSubalgebras;
  SemisimpleLieAlgebra* owner;
public:
  static std::string descriptionHCharacteristic;
  static std::string descriptionModuleDecompositionOverSl2;
  static std::string descriptionHRealization;
  static std::string descriptionMinimalContainingRegularSubalgebras;
  HashedList<SlTwoSubalgebra> allSubalgebras;
  HashedList<Vector<Rational> > allRealizedHs;
  List<List<int> > sl2sPerRootSubalgebras;
  List<int> indicesSl2DecompositionFormulas;
  // A map from each unsuitable H into all root subalgebras
  // for whom the H was an S-subalgebra candidate
  // but we couldn't realize it.
  MapList<Vector<Rational>, List<int> > unsuitableHs;
  int indexZeroWeight;
  int millisecondsRootSubalgebraComputation;
  RootSubalgebras rootSubalgebras;
  ~SlTwoSubalgebras() {}
  SlTwoSubalgebras():
  owner(nullptr),
  millisecondsRootSubalgebraComputation(0) {}
  SlTwoSubalgebras(SemisimpleLieAlgebra& inputOwner): owner(&inputOwner) {}
  bool operator==(const SlTwoSubalgebras& other) const {
    if (this->owner == nullptr) {
      return other.owner == nullptr;
    }
    if (other.owner == nullptr) {
      return false;
    }
    return this->getOwner() == other.getOwner();
  }
  bool checkConsistency() const;
  bool checkMinimalContainingRootSubalgebras() const;
  void checkInitialization() const;
  WeylGroupData& getOwnerWeyl() const {
    return this->getOwner().weylGroup;
  }
  SemisimpleLieAlgebra& getOwner() const {
    this->checkInitialization();
    return *this->owner;
  }
  void computeModuleDecompositionsitionsOfAmbientLieAlgebra();
  void reset(SemisimpleLieAlgebra& inputOwners);
  bool containsSl2WithGivenH(Vector<Rational>& elementH, int* outputIndex);
  // Writes HTML in a file.
  void writeHTML();
  std::string toHTML(FormatExpressions* format);
  bool isHOfConstructedSlTwo(const Vector<Rational>& h) const;
  std::string toString(FormatExpressions* format = nullptr);
  std::string toHTMLSummaryTable(FormatExpressions* format = nullptr);
  std::string toHTMLSummary(FormatExpressions* format = nullptr);
  std::string toHTMLFieldReport(FormatExpressions* format) const;
  std::string toStringModuleDecompositionMinimalContainingRegularSubalgebras(
    bool useLatex, bool useHtml
  );
  void computeAllRealizedHs();
  // Some H elements were not successfully realized as S-subalgebras
  // of root subalgebras that were eligible to contain the h.
  // We hereby assume that the realization is actually possible
  // and account the root subalgebras as containers of the
  // unsuitable Hs.
  void computeRootSubalgebraContainersFromUnsuitableHs();
  void computeRootSubalgebraContainersFromOneUnsuitableH(
    const Vector<Rational>& h
  );
  void getSlTwosOfGivenDynkinIndex(
    const Rational& dynkinIndex, List<SlTwoSubalgebra*>& output
  );
  void computeRootSubalgebraContainers();
  void computeOneRootSubalgebraContainers(SlTwoSubalgebra& output);
  void computeCentralizers();
  // Finds all sl(2) subalgebras up to conjugation of the given semisimple
  // Lie algebra.
  // If computeRealForm is set, will use real forms (work in progress).
  // When restrictToThisSl2Triple is set, will restrict the computation to the
  // type given by restrictToThisSl2Triple; all other sl(2)-triples will
  // be ignored. Used to speed up computations when interested in one
  // particular triple.
  // For computational reasons we are forced to operate with multiple
  // algebraic closures, despite algebraic closures being designed
  // as being shared by an entire computation.
  static void findSl2SubalgebrasWithoutCentralizers(
    SemisimpleLieAlgebra& inputOwner,
    SlTwoSubalgebras& output,
    bool computeRealForm,
    MapReferences<std::string, AlgebraicClosureRationals>& algebraicClosures,
    DynkinSimpleType* restrictToThisSl2Triple = nullptr
  );
  static void findSl2SubalgebrasAndCentralizers(
    SemisimpleLieAlgebra& inputOwner,
    SlTwoSubalgebras& output,
    bool computeRealForm,
    MapReferences<std::string, AlgebraicClosureRationals>& algebraicClosures,
    DynkinSimpleType* restrictToThisSl2Triple = nullptr
  );
  // Appends all S-sl(2) subalgebras of the given root subalgebra.
  static void appendSSl2SubalgebrasFromRootSubalgebra(
    RootSubalgebra& container,
    SlTwoSubalgebras& output,
    int indexRootSubalgebraInContainer,
    bool computeRealForm,
    MapReferences<std::string, AlgebraicClosureRationals>& algebraicClosures,
    DynkinSimpleType* restrictToThisSl2Triple
  );
};

#endif // header_math_extra_semisimple_lie_subalgebras_sltwos_ALREADY_INCLUDED
