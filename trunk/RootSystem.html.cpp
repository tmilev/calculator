#include<sstream>
void static_html2(std::stringstream& output){
output << " <html>\n";
output << " <head> \n";
output << " <title>\n";
output << " Root systems\n";
output << " </title>\n";
output << " </head>\n";
output << " <body>\n";
}
void static_html3(std::stringstream& output){
output << " <!>\n";
output << " <script type=\"text/javascript\"> \n";
output << " var timeOutCounter=0;\n";
output << " window.setTimeout(\"progressReport()\",1000);\n";
output << " var newReportString=\"\";\n";
output << " function progressReport()\n";
output << " { timeOutCounter++;\n";
output << "   var oRequest = new XMLHttpRequest();\n";
output << "   var sURL  = \"/tmp/report.txt\";\n";
output << "   oRequest.open(\"GET\",sURL,false);\n";
output << "   oRequest.setRequestHeader(\"User-Agent\",navigator.userAgent);\n";
output << "   oRequest.send(null)\n";
output << "   if (oRequest.status==200)\n";
output << "     newReportString= oRequest.responseText;\n";
output << "   el = document.getElementById(\"idProgressReport\").innerHTML= \"Number of clock ticks since last open: \"+ timeOutCounter+\"<br>Status file content:<br>\" +newReportString;\n";
output << "   window.setTimeout(\"progressReport()\",1000);\n";
output << " }\n";
output << " </script>\n";
output << " <div id=\"idProgressReport\">\n";
output << " </div>\n";
output << " </script>\n";
output << " <div id=\"idProgressReport\">\n";
output << " </div>\n";
output << " \n";
}
void static_html4(std::stringstream& output){
output << " <!>\n";
output << " <script src=\"http://ajax.googleapis.com/ajax/libs/dojo/1.6.1/dojo/dojo.xd.js\" type=\"text/javascript\"></script>\n";
output << " \n";
output << "  <select name=\"textType\" id=\"textType\" onchange=\"makeCartanArbitrary(document.getElementById('textType'), document.getElementById(textDim));  this.form.submit();\">\n";
output << "   <option>A</option>\n";
output << "   <option selected=\"1\">B</option>\n";
output << "   <option>C</option>\n";
output << "   <option>D</option>\n";
output << "   <option>E</option>\n";
output << "   <option>F</option>\n";
output << "   <option>G</option>\n";
output << " </select>\n";
output << " <select name=\"textDim\" id=\"textDim\" onchange=\"makeCartanArbitrary(document.getElementById('textType'), document.getElementById(textDim));  this.form.submit();\">\n";
output << "   <option>1</option>\n";
output << "   <option>2</option>\n";
output << "   <option selected=\"1\">3</option>\n";
output << "   <option>4</option>\n";
output << "   <option>5</option>\n";
output << "   <option>6</option>\n";
output << "   <option>7</option>\n";
output << "   <option>8</option>\n";
output << " </select> Root system.\n";
output << " <script type=\"text/javascript\"> \n";
output << " function switchMenu(obj){ var el = document.getElementById(obj);	if ( el.style.display != \"none\" ) { el.style.display = 'none'; } else { el.style.display = '';}}\n";
output << " </script>\n";
}
void static_html5(std::stringstream& output){
output << " <!>\n";
output << "   <script language=\"javascript\">\n";
output << "     //The script is courtesy of Madan Chaudhary. The original code was hosted at http://simpleandeasycodes.blogspot.com/ .\n";
output << "     //The code is slightly modified from the original, and will continue to be modified.\n";
output << "     //Many thanks to Madan Chaudhary for allowing the use of his code!\n";
output << "     //****************************************************************************\n";
output << "     function actb(obj,ca){\n";
output << "     /* ---- Public Variables ---- */\n";
output << "     this.saec_timeOut = -1; // Autocomplete Timeout in ms (-1: autocomplete never time out)\n";
output << "     this.saec_lim = 4;    // Number of elements autocomplete can show (-1: no limit)\n";
output << "     this.saec_firstText = false; // should the auto complete be limited to the beginning of keyword?\n";
output << "     this.saec_mouse = true; // Enable Mouse Support\n";
output << "     this.saec_delimiter = new Array(';',' ');  // Delimiter for multiple autocomplete. Set it to empty array for single autocomplete\n";
output << "     this.saec_startcheck = 1; // Show widget only after this number of characters is typed in.\n";
output << "     /* ---- Public Variables ---- */\n";
output << "     \n";
output << "     //Customize style according to your requirement\n";
output << "     /* --- Styles --- */\n";
output << "     this.saec_bgColor = '#999999';\n";
output << "     this.saec_textColor = '#ffffff';\n";
output << "     this.saec_hColor = '#000000';\n";
output << "     this.saec_fFamily = 'verdana';\n";
output << "     this.saec_fSize = '15px';\n";
output << "     this.saec_hStyle = 'text-decoration:underline;font-weight:bold';\n";
output << "     /* --- Styles --- */\n";
output << " \n";
output << "     /* ---- Private Variables ---- */\n";
output << "     var saec_delimwords = new Array();\n";
output << "     var saec_cdelimword = 0;\n";
output << "     var saec_delimchar = new Array();\n";
output << "     var saec_display = false;\n";
output << "     var saec_pos = 0;\n";
output << "     var saec_total = 0;\n";
output << "     var saec_curr = null;\n";
output << "     var saec_rangeu = 0;\n";
output << "     var saec_ranged = 0;\n";
output << "     var saec_bool = new Array();\n";
output << "     var saec_pre = 0;\n";
output << "     var saec_toid;\n";
output << "     var saec_tomake = false;\n";
output << "     var saec_getpre = \"\";\n";
output << "     var saec_mouse_on_list = 1;\n";
output << "     var saec_kwcount = 0;\n";
output << "     var saec_caretmove = false;\n";
output << "     this.saec_keywords = new Array();\n";
output << "     /* ---- Private Variables---- */\n";
output << "     \n";
output << "     this.saec_keywords = ca;\n";
output << "     var saec_self = this;\n";
output << " \n";
output << "     saec_curr = obj;\n";
output << "     \n";
output << "     addEvent(saec_curr,\"focus\",saec_setup);\n";
output << "     function saec_setup(){\n";
output << "         addEvent(document,\"keydown\",saec_checkkey);\n";
output << "         addEvent(saec_curr,\"blur\",saec_clear);\n";
output << "         addEvent(document,\"keypress\",saec_keypress);\n";
output << "     }\n";
output << " \n";
output << "     function saec_clear(evt){\n";
output << "         if (!evt) evt = event;\n";
output << "         removeEvent(document,\"keydown\",saec_checkkey);\n";
output << "         removeEvent(saec_curr,\"blur\",saec_clear);\n";
output << "         removeEvent(document,\"keypress\",saec_keypress);\n";
output << "         saec_removedisp();\n";
output << "     }\n";
output << "     function saec_parse(n){\n";
output << "         if (saec_self.saec_delimiter.length > 0){\n";
output << "             var t = saec_delimwords[saec_cdelimword].trim().addslashes();\n";
output << "             var plen = saec_delimwords[saec_cdelimword].trim().length;\n";
output << "         }else{\n";
output << "             var t = saec_curr.value.addslashes();\n";
output << "             var plen = saec_curr.value.length;\n";
output << "         }\n";
output << "         var tobuild = '';\n";
output << "         var i;\n";
output << " \n";
output << "         if (saec_self.saec_firstText){\n";
output << "             var re = new RegExp(\"^\" + t, \"i\");\n";
output << "         }else{\n";
output << "             var re = new RegExp(t, \"i\");\n";
output << "         }\n";
output << "         var p = n.search(re);\n";
output << "                 \n";
output << "         for (i=0;i<p;i++){\n";
output << "             tobuild += n.substr(i,1);\n";
output << "         }\n";
output << "         tobuild += \"<font style='\"+(saec_self.saec_hStyle)+\"'>\"\n";
output << "         for (i=p;i<plen+p;i++){\n";
output << "             tobuild += n.substr(i,1);\n";
output << "         }\n";
output << "         tobuild += \"</font>\";\n";
output << "             for (i=plen+p;i<n.length;i++){\n";
output << "             tobuild += n.substr(i,1);\n";
output << "         }\n";
output << "         return tobuild;\n";
output << "     }\n";
output << "     function saec_VPFspecific_generate(){ \n";
output << " 	if (saec_kwcount>10)\n";
output << " 		return;\n";
output << " 	for (i=0; i<saec_self.saec_keywords.length; i++)\n";
output << " 	{	currentName=\"functionBox\"+saec_keywords[i];\n";
output << " 		currentBox=document.getElementById(currentName);\n";
output << " 		if (saec_bool[i] )			\n";
output << " 			currentBox.style.display=\"inline\";	\n";
output << " 		else\n";
output << " 			currentBox.style.display=\"none\";	\n";
output << " 	}\n";
output << " \n";
output << "     }\n";
output << "     function saec_generate(){\n";
output << "         if (document.getElementById('tat_table')){ saec_display = false;document.body.removeChild(document.getElementById('tat_table')); } \n";
output << " 	saec_VPFspecific_generate();        \n";
output << " 	if (saec_kwcount == 0){\n";
output << "             saec_display = false;\n";
output << "             return;\n";
output << "         }\n";
output << "         a = document.createElement('table');\n";
output << "         a.cellSpacing='1px';\n";
output << "         a.cellPadding='2px';\n";
output << "         a.style.position='absolute';\n";
output << "         a.style.top = eval(curTop(saec_curr) + saec_curr.offsetHeight) + \"px\";\n";
output << "         a.style.left = curLeft(saec_curr) + \"px\";\n";
output << "         a.style.backgroundColor=saec_self.saec_bgColor;\n";
output << "         a.id = 'tat_table';\n";
output << "         document.body.appendChild(a);\n";
output << "         var i;\n";
output << "         var first = true;\n";
output << "         var j = 1;\n";
output << "         if (saec_self.saec_mouse){\n";
output << "             a.onmouseout = saec_table_unfocus;\n";
output << "             a.onmouseover = saec_table_focus;\n";
output << "         }\n";
output << "         var counter = 0;\n";
output << "         for (i=0;i<saec_self.saec_keywords.length;i++){\n";
output << "             if (saec_bool[i]){\n";
output << "                 counter++;\n";
output << "                 r = a.insertRow(-1);\n";
output << "                 if (first && !saec_tomake){\n";
output << "                     r.style.backgroundColor = saec_self.saec_hColor;\n";
output << "                     first = false;\n";
output << "                     saec_pos = counter;\n";
output << "                 }else if(saec_pre == i){\n";
output << "                     r.style.backgroundColor = saec_self.saec_hColor;\n";
output << "                     first = false;\n";
output << "                     saec_pos = counter;\n";
output << "                 }else{\n";
output << "                     r.style.backgroundColor = saec_self.saec_bgColor;\n";
output << "                 }\n";
output << "                 r.id = 'tat_tr'+(j);\n";
output << "                 c = r.insertCell(-1);\n";
output << "                 c.style.color = saec_self.saec_textColor;\n";
output << "                 c.style.fontFamily = saec_self.saec_fFamily;\n";
output << "                 c.style.fontSize = saec_self.saec_fSize;\n";
output << "                 c.innerHTML = saec_parse(saec_self.saec_keywords[i]);\n";
output << "                 c.id = 'tat_td'+(j);\n";
output << "                 c.setAttribute('pos',j);\n";
output << "                 if (saec_self.saec_mouse){\n";
output << "                     c.style.cursor = 'pointer';\n";
output << "                     c.onclick=saec_mouseclick;\n";
output << "                     c.onmouseover = saec_table_highlight;\n";
output << "                 }\n";
output << "                 j++;\n";
output << "             }\n";
output << "             if (j - 1 == saec_self.saec_lim && j < saec_total){\n";
output << "                 r = a.insertRow(-1);\n";
output << "                 r.style.backgroundColor = saec_self.saec_bgColor;\n";
output << "                 c = r.insertCell(-1);\n";
output << "                 c.style.color = saec_self.saec_textColor;\n";
output << "                 c.style.fontFamily = 'arial narrow';\n";
output << "                 c.style.fontSize = saec_self.saec_fSize;\n";
output << "                 c.align='center';\n";
output << "                 replaceHTML(c,'\\\\/');\n";
output << "                 if (saec_self.saec_mouse){\n";
output << "                     c.style.cursor = 'pointer';\n";
output << "                     c.onclick = saec_mouse_down;\n";
output << "                 }\n";
output << "                 break;\n";
output << "             }\n";
output << "         }\n";
output << "         saec_rangeu = 1;\n";
output << "         saec_ranged = j-1;\n";
output << "         saec_display = true;\n";
output << "         if (saec_pos <= 0) saec_pos = 1;\n";
output << "     }\n";
output << "     function saec_remake(){\n";
output << "         document.body.removeChild(document.getElementById('tat_table'));\n";
output << "         a = document.createElement('table');\n";
output << "         a.cellSpacing='1px';\n";
output << "         a.cellPadding='2px';\n";
output << "         a.style.position='absolute';\n";
output << "         a.style.top = eval(curTop(saec_curr) + saec_curr.offsetHeight) + \"px\";\n";
output << "         a.style.left = curLeft(saec_curr) + \"px\";\n";
output << "         a.style.backgroundColor=saec_self.saec_bgColor;\n";
output << "         a.id = 'tat_table';\n";
output << "         if (saec_self.saec_mouse){\n";
output << "             a.onmouseout= saec_table_unfocus;\n";
output << "             a.onmouseover=saec_table_focus;\n";
output << "         }\n";
output << "         document.body.appendChild(a);\n";
output << "         var i;\n";
output << "         var first = true;\n";
output << "         var j = 1;\n";
output << "         if (saec_rangeu > 1){\n";
output << "             r = a.insertRow(-1);\n";
output << "             r.style.backgroundColor = saec_self.saec_bgColor;\n";
output << "             c = r.insertCell(-1);\n";
output << "             c.style.color = saec_self.saec_textColor;\n";
output << "             c.style.fontFamily = 'arial narrow';\n";
output << "             c.style.fontSize = saec_self.saec_fSize;\n";
output << "             c.align='center';\n";
output << "             replaceHTML(c,'/\\\\');\n";
output << "             if (saec_self.saec_mouse){\n";
output << "                 c.style.cursor = 'pointer';\n";
output << "                 c.onclick = saec_mouse_up;\n";
output << "             }\n";
output << "         }\n";
output << "         for (i=0;i<saec_self.saec_keywords.length;i++){\n";
output << "             if (saec_bool[i]){\n";
output << "                 if (j >= saec_rangeu && j <= saec_ranged){\n";
output << "                     r = a.insertRow(-1);\n";
output << "                     r.style.backgroundColor = saec_self.saec_bgColor;\n";
output << "                     r.id = 'tat_tr'+(j);\n";
output << "                     c = r.insertCell(-1);\n";
output << "                     c.style.color = saec_self.saec_textColor;\n";
output << "                     c.style.fontFamily = saec_self.saec_fFamily;\n";
output << "                     c.style.fontSize = saec_self.saec_fSize;\n";
output << "                     c.innerHTML = saec_parse(saec_self.saec_keywords[i]);\n";
output << "                     c.id = 'tat_td'+(j);\n";
output << "                     c.setAttribute('pos',j);\n";
output << "                     if (saec_self.saec_mouse){\n";
output << "                         c.style.cursor = 'pointer';\n";
output << "                         c.onclick=saec_mouseclick;\n";
output << "                         c.onmouseover = saec_table_highlight;\n";
output << "                     }\n";
output << "                     j++;\n";
output << "                 }else{\n";
output << "                     j++;\n";
output << "                 }\n";
output << "             }\n";
output << "             if (j > saec_ranged) break;\n";
output << "         }\n";
output << "         if (j-1 < saec_total){\n";
output << "             r = a.insertRow(-1);\n";
output << "             r.style.backgroundColor = saec_self.saec_bgColor;\n";
output << "             c = r.insertCell(-1);\n";
output << "             c.style.color = saec_self.saec_textColor;\n";
output << "             c.style.fontFamily = 'arial narrow';\n";
output << "             c.style.fontSize = saec_self.saec_fSize;\n";
output << "             c.align='center';\n";
output << "             replaceHTML(c,'\\\\/');\n";
output << "             if (saec_self.saec_mouse){\n";
output << "                 c.style.cursor = 'pointer';\n";
output << "                 c.onclick = saec_mouse_down;\n";
output << "             }\n";
output << "         }\n";
output << "     }\n";
output << "     function saec_goup(){\n";
output << "         if (!saec_display) return;\n";
output << "         if (saec_pos == 1) return;\n";
output << "         document.getElementById('tat_tr'+saec_pos).style.backgroundColor = saec_self.saec_bgColor;\n";
output << "         saec_pos--;\n";
output << "         if (saec_pos < saec_rangeu) saec_moveup();\n";
output << "         document.getElementById('tat_tr'+saec_pos).style.backgroundColor = saec_self.saec_hColor;\n";
output << "         if (saec_toid) clearTimeout(saec_toid);\n";
output << "         if (saec_self.saec_timeOut > 0) saec_toid = setTimeout(function(){saec_mouse_on_list=0;saec_removedisp();},saec_self.saec_timeOut);\n";
output << "     }\n";
output << "     function saec_godown(){\n";
output << "         if (!saec_display) return;\n";
output << "         if (saec_pos == saec_total) return;\n";
output << "         document.getElementById('tat_tr'+saec_pos).style.backgroundColor = saec_self.saec_bgColor;\n";
output << "         saec_pos++;\n";
output << "         if (saec_pos > saec_ranged) saec_movedown();\n";
output << "         document.getElementById('tat_tr'+saec_pos).style.backgroundColor = saec_self.saec_hColor;\n";
output << "         if (saec_toid) clearTimeout(saec_toid);\n";
output << "         if (saec_self.saec_timeOut > 0) saec_toid = setTimeout(function(){saec_mouse_on_list=0;saec_removedisp();},saec_self.saec_timeOut);\n";
output << "     }\n";
output << "     function saec_movedown(){\n";
output << "         saec_rangeu++;\n";
output << "         saec_ranged++;\n";
output << "         saec_remake();\n";
output << "     }\n";
output << "     function saec_moveup(){\n";
output << "         saec_rangeu--;\n";
output << "         saec_ranged--;\n";
output << "         saec_remake();\n";
output << "     }\n";
output << " \n";
output << "     /* Mouse */\n";
output << "     function saec_mouse_down(){\n";
output << "         document.getElementById('tat_tr'+saec_pos).style.backgroundColor = saec_self.saec_bgColor;\n";
output << "         saec_pos++;\n";
output << "         saec_movedown();\n";
output << "         document.getElementById('tat_tr'+saec_pos).style.backgroundColor = saec_self.saec_hColor;\n";
output << "         saec_curr.focus();\n";
output << "         saec_mouse_on_list = 0;\n";
output << "         if (saec_toid) clearTimeout(saec_toid);\n";
output << "         if (saec_self.saec_timeOut > 0) saec_toid = setTimeout(function(){saec_mouse_on_list=0;saec_removedisp();},saec_self.saec_timeOut);\n";
output << "     }\n";
output << "     function saec_mouse_up(evt){\n";
output << "         if (!evt) evt = event;\n";
output << "         if (evt.stopPropagation){\n";
output << "             evt.stopPropagation();\n";
output << "         }else{\n";
output << "             evt.cancelBubble = true;\n";
output << "         }\n";
output << "         document.getElementById('tat_tr'+saec_pos).style.backgroundColor = saec_self.saec_bgColor;\n";
output << "         saec_pos--;\n";
output << "         saec_moveup();\n";
output << "         document.getElementById('tat_tr'+saec_pos).style.backgroundColor = saec_self.saec_hColor;\n";
output << "         saec_curr.focus();\n";
output << "         saec_mouse_on_list = 0;\n";
output << "         if (saec_toid) clearTimeout(saec_toid);\n";
output << "         if (saec_self.saec_timeOut > 0) saec_toid = setTimeout(function(){saec_mouse_on_list=0;saec_removedisp();},saec_self.saec_timeOut);\n";
output << "     }\n";
output << "     function saec_mouseclick(evt){\n";
output << "         if (!evt) evt = event;\n";
output << "         if (!saec_display) return;\n";
output << "         saec_mouse_on_list = 0;\n";
output << "         saec_pos = this.getAttribute('pos');\n";
output << "         saec_penter();\n";
output << "     }\n";
output << "     function saec_table_focus(){\n";
output << "         saec_mouse_on_list = 1;\n";
output << "     }\n";
output << "     function saec_table_unfocus(){\n";
output << "         saec_mouse_on_list = 0;\n";
output << "         if (saec_toid) clearTimeout(saec_toid);\n";
output << "         if (saec_self.saec_timeOut > 0) saec_toid = setTimeout(function(){saec_mouse_on_list = 0;saec_removedisp();},saec_self.saec_timeOut);\n";
output << "     }\n";
output << "     function saec_table_highlight(){\n";
output << "         saec_mouse_on_list = 1;\n";
output << "         document.getElementById('tat_tr'+saec_pos).style.backgroundColor = saec_self.saec_bgColor;\n";
output << "         saec_pos = this.getAttribute('pos');\n";
output << "         while (saec_pos < saec_rangeu) saec_moveup();\n";
output << "         while (saec_pos > saec_ranged) saec_movedown();\n";
output << "         document.getElementById('tat_tr'+saec_pos).style.backgroundColor = saec_self.saec_hColor;\n";
output << "         if (saec_toid) clearTimeout(saec_toid);\n";
output << "         if (saec_self.saec_timeOut > 0) saec_toid = setTimeout(function(){saec_mouse_on_list = 0;saec_removedisp();},saec_self.saec_timeOut);\n";
output << "     }\n";
output << "     /* ---- */\n";
output << " \n";
output << "     function saec_insertword(a){\n";
output << "         if (saec_self.saec_delimiter.length > 0){\n";
output << "             str = '';\n";
output << "             l=0;\n";
output << "             for (i=0;i<saec_delimwords.length;i++){\n";
output << "                 if (saec_cdelimword == i){\n";
output << "                     prespace = postspace = '';\n";
output << "                     gotbreak = false;\n";
output << "                     for (j=0;j<saec_delimwords[i].length;++j){\n";
output << "                         if (saec_delimwords[i].charAt(j) != ' '){\n";
output << "                             gotbreak = true;\n";
output << "                             break;\n";
output << "                         }\n";
output << "                         prespace += ' ';\n";
output << "                     }\n";
output << "                     for (j=saec_delimwords[i].length-1;j>=0;--j){\n";
output << "                         if (saec_delimwords[i].charAt(j) != ' ') break;\n";
output << "                         postspace += ' ';\n";
output << "                     }\n";
output << "                     str += prespace;\n";
output << "                     str += a;\n";
output << "                     l = str.length;\n";
output << "                     if (gotbreak) str += postspace;\n";
output << "                 }else{\n";
output << "                     str += saec_delimwords[i];\n";
output << "                 }\n";
output << "                 if (i != saec_delimwords.length - 1){\n";
output << "                     str += saec_delimchar[i];\n";
output << "                 }\n";
output << "             }\n";
output << "             saec_curr.value = str;\n";
output << "             setCaret(saec_curr,l);\n";
output << "         }else{\n";
output << "             saec_curr.value = a;\n";
output << "         }\n";
output << "         saec_mouse_on_list = 0;\n";
output << "         saec_removedisp();\n";
output << "     }\n";
output << "     function saec_penter(){\n";
output << "         if (!saec_display) return;\n";
output << "         saec_display = false;\n";
output << "         var word = '';\n";
output << "         var c = 0;\n";
output << "         for (var i=0;i<=saec_self.saec_keywords.length;i++){\n";
output << "             if (saec_bool[i]) c++;\n";
output << "             if (c == saec_pos){\n";
output << "                 word = saec_self.saec_keywords[i];\n";
output << "                 break;\n";
output << "             }\n";
output << "         }\n";
output << "         saec_insertword(word);\n";
output << "         l = getCaretStart(saec_curr);\n";
output << "     }\n";
output << " function saec_VPF_isDelim(input)\n";
output << " { delimChars=\" ()+-/,*_\";\n";
output << "   for (i=0; i<delimChars.length; i++)\n";
output << "     if (input==delimChars[i])\n";
output << "       return true;\n";
output << "   return false;\n";
output << " }\n";
output << "     function saec_VPFspecific_removeDisp(){ \n";
output << " 	if (saec_curr.value.length>0)\n";
output << " 	{	if (!saec_VPF_isDelim(saec_curr.value[saec_curr.value.length-1]))\n";
output << " 			return;\n";
output << " 	}\n";
output << " 	for (i=0; i<saec_self.saec_keywords.length; i++)\n";
output << " 	{	currentName=\"functionBox\"+saec_keywords[i];\n";
output << " 		currentBox=document.getElementById(currentName);\n";
output << " 		currentBox.style.display=\"inline\";	\n";
output << " 	}\n";
output << "     }\n";
output << "     function saec_removedisp(){\n";
output << " 	saec_VPFspecific_removeDisp();\n";
output << "         if (saec_mouse_on_list==0){\n";
output << "             saec_display = 0;\n";
output << "             if (document.getElementById('tat_table')){ document.body.removeChild(document.getElementById('tat_table')); }\n";
output << "             if (saec_toid) clearTimeout(saec_toid);\n";
output << "         }\n";
output << "     }\n";
output << "     function saec_keypress(e){\n";
output << "         if (saec_caretmove) stopEvent(e);\n";
output << "         return !saec_caretmove;\n";
output << "     }\n";
output << "     function saec_checkkey(evt){\n";
output << "         if (!evt) evt = event;\n";
output << "         a = evt.keyCode;\n";
output << "         caret_pos_start = getCaretStart(saec_curr);\n";
output << "         saec_caretmove = 0;\n";
output << "         switch (a){\n";
output << "             case 38:\n";
output << "                 saec_goup();\n";
output << "                 saec_caretmove = 1;\n";
output << "                 return false;\n";
output << "                 break;\n";
output << "             case 40:\n";
output << "                 saec_godown();\n";
output << "                 saec_caretmove = 1;\n";
output << "                 return false;\n";
output << "                 break;\n";
output << "             case 13: case 9:\n";
output << "                 if (saec_display){\n";
output << "                     saec_caretmove = 1;\n";
output << "                     saec_penter();\n";
output << "                     return false;\n";
output << "                 }else{\n";
output << "                     return true;\n";
output << "                 }\n";
output << "                 break;\n";
output << "             default:\n";
output << "                 setTimeout(function(){saec_tocomplete(a)},50);\n";
output << "                 break;\n";
output << "         }\n";
output << "     }\n";
output << " \n";
output << "     function saec_tocomplete(kc){\n";
output << "         if (kc == 38 || kc == 40 || kc == 13) return;\n";
output << "         var i;\n";
output << " 	\n";
output << "         if (saec_display){ \n";
output << "             var word = 0;\n";
output << "             var c = 0;\n";
output << "             for (var i=0;i<=saec_self.saec_keywords.length;i++){\n";
output << "                 if (saec_bool[i]) c++;\n";
output << "                 if (c == saec_pos){\n";
output << "                     word = i;\n";
output << "                     break;\n";
output << "                 }\n";
output << "             }\n";
output << "             saec_pre = word;\n";
output << "         }else{ saec_pre = -1};\n";
output << "         \n";
output << "         if (saec_curr.value == ''){\n";
output << "             saec_mouse_on_list = 0;\n";
output << "             saec_removedisp();\n";
output << "             return;\n";
output << "         }\n";
output << "         if (saec_self.saec_delimiter.length > 0){\n";
output << "             caret_pos_start = getCaretStart(saec_curr);\n";
output << "             caret_pos_end = getCaretEnd(saec_curr);\n";
output << "             \n";
output << "             delim_split = '';\n";
output << "             for (i=0;i<saec_self.saec_delimiter.length;i++){\n";
output << "                 delim_split += saec_self.saec_delimiter[i];\n";
output << "             }\n";
output << "             delim_split = delim_split.addslashes();\n";
output << "             delim_split_rx = new RegExp(\"([\"+delim_split+\"])\");\n";
output << "             c = 0;\n";
output << "             saec_delimwords = new Array();\n";
output << "             saec_delimwords[0] = '';\n";
output << "             for (i=0,j=saec_curr.value.length;i<saec_curr.value.length;i++,j--){\n";
output << "                 if (saec_curr.value.substr(i,j).search(delim_split_rx) == 0){\n";
output << "                     ma = saec_curr.value.substr(i,j).match(delim_split_rx);\n";
output << "                     saec_delimchar[c] = ma[1];\n";
output << "                     c++;\n";
output << "                     saec_delimwords[c] = '';\n";
output << "                 }else{\n";
output << "                     saec_delimwords[c] += saec_curr.value.charAt(i);\n";
output << "                 }\n";
output << "             }\n";
output << " \n";
output << "             var l = 0;\n";
output << "             saec_cdelimword = -1;\n";
output << "             for (i=0;i<saec_delimwords.length;i++){\n";
output << "                 if (caret_pos_end >= l && caret_pos_end <= l + saec_delimwords[i].length){\n";
output << "                     saec_cdelimword = i;\n";
output << "                 }\n";
output << "                 l+=saec_delimwords[i].length + 1;\n";
output << "             }\n";
output << "             var ot = saec_delimwords[saec_cdelimword].trim(); \n";
output << "             var t = saec_delimwords[saec_cdelimword].addslashes().trim();\n";
output << "         }else{\n";
output << "             var ot = saec_curr.value;\n";
output << "             var t = saec_curr.value.addslashes();\n";
output << "         }\n";
output << "         if (ot.length == 0){\n";
output << "             saec_mouse_on_list = 0;\n";
output << "             saec_removedisp();\n";
output << "         }\n";
output << "         if (ot.length < saec_self.saec_startcheck) return this;\n";
output << "         if (saec_self.saec_firstText){\n";
output << "             var re = new RegExp(\"^\" + t, \"i\");\n";
output << "         }else{\n";
output << "             var re = new RegExp(t, \"i\");\n";
output << "         }\n";
output << " \n";
output << "         saec_total = 0;\n";
output << "         saec_tomake = false;\n";
output << "         saec_kwcount = 0;\n";
output << "         for (i=0;i<saec_self.saec_keywords.length;i++){\n";
output << "             saec_bool[i] = false;\n";
output << "             if (re.test(saec_self.saec_keywords[i])){\n";
output << "                 saec_total++;\n";
output << "                 saec_bool[i] = true;\n";
output << "                 saec_kwcount++;\n";
output << "                 if (saec_pre == i) saec_tomake = true;\n";
output << "             }\n";
output << "         }\n";
output << " \n";
output << "         if (saec_toid) clearTimeout(saec_toid);\n";
output << "         if (saec_self.saec_timeOut > 0) saec_toid = setTimeout(function(){saec_mouse_on_list = 0;saec_removedisp();},saec_self.saec_timeOut);\n";
output << "         saec_generate();\n";
output << "     }\n";
output << "     return this;\n";
output << " }\n";
output << " \n";
output << " \n";
output << "     /* Event Functions */\n";
output << " \n";
output << "     // Add an event to the obj given\n";
output << "     // event_name refers to the event trigger, without the \"on\", like click or mouseover\n";
output << "     // func_name refers to the function callback when event is triggered\n";
output << "     function addEvent(obj,event_name,func_name){\n";
output << "         if (obj.attachEvent){\n";
output << "             obj.attachEvent(\"on\"+event_name, func_name);\n";
output << "         }else if(obj.addEventListener){\n";
output << "             obj.addEventListener(event_name,func_name,true);\n";
output << "         }else{\n";
output << "             obj[\"on\"+event_name] = func_name;\n";
output << "         }\n";
output << "     }\n";
output << " \n";
output << "     // Removes an event from the object\n";
output << "     function removeEvent(obj,event_name,func_name){\n";
output << "         if (obj.detachEvent){\n";
output << "             obj.detachEvent(\"on\"+event_name,func_name);\n";
output << "         }else if(obj.removeEventListener){\n";
output << "             obj.removeEventListener(event_name,func_name,true);\n";
output << "         }else{\n";
output << "             obj[\"on\"+event_name] = null;\n";
output << "         }\n";
output << "     }\n";
output << " \n";
output << "     // Stop an event from bubbling up the event DOM\n";
output << "     function stopEvent(evt){\n";
output << "         evt || window.event;\n";
output << "         if (evt.stopPropagation){\n";
output << "             evt.stopPropagation();\n";
output << "             evt.preventDefault();\n";
output << "         }else if(typeof evt.cancelBubble != \"undefined\"){\n";
output << "             evt.cancelBubble = true;\n";
output << "             evt.returnValue = false;\n";
output << "         }\n";
output << "         return false;\n";
output << "     }\n";
output << " \n";
output << "     // Get the obj that starts the event\n";
output << "     function getElement(evt){\n";
output << "         if (window.event){\n";
output << "             return window.event.srcElement;\n";
output << "         }else{\n";
output << "             return evt.currentTarget;\n";
output << "         }\n";
output << "     }\n";
output << "     // Get the obj that triggers off the event\n";
output << "     function getTargetElement(evt){\n";
output << "         if (window.event){\n";
output << "             return window.event.srcElement;\n";
output << "         }else{\n";
output << "             return evt.target;\n";
output << "         }\n";
output << "     }\n";
output << "     // For IE only, stops the obj from being selected\n";
output << "     function stopSelect(obj){\n";
output << "         if (typeof obj.onselectstart != 'undefined'){\n";
output << "             addEvent(obj,\"selectstart\",function(){ return false;});\n";
output << "         }\n";
output << "     }\n";
output << " \n";
output << "     /*    Caret Functions     */\n";
output << " \n";
output << "     // Get the end position of the caret in the object. Note that the obj needs to be in focus first\n";
output << "     function getCaretEnd(obj){\n";
output << "         if(typeof obj.selectionEnd != \"undefined\"){\n";
output << "             return obj.selectionEnd;\n";
output << "         }else if(document.selection&&document.selection.createRange){\n";
output << "             var M=document.selection.createRange();\n";
output << "             try{\n";
output << "                 var Lp = M.duplicate();\n";
output << "                 Lp.moveToElementText(obj);\n";
output << "             }catch(e){\n";
output << "                 var Lp=obj.createTextRange();\n";
output << "             }\n";
output << "             Lp.setEndPoint(\"EndToEnd\",M);\n";
output << "             var rb=Lp.text.length;\n";
output << "             if(rb>obj.value.length){\n";
output << "                 return -1;\n";
output << "             }\n";
output << "             return rb;\n";
output << "         }\n";
output << "     }\n";
output << "     // Get the start position of the caret in the object\n";
output << "     function getCaretStart(obj){\n";
output << "         if(typeof obj.selectionStart != \"undefined\"){\n";
output << "             return obj.selectionStart;\n";
output << "         }else if(document.selection&&document.selection.createRange){\n";
output << "             var M=document.selection.createRange();\n";
output << "             try{\n";
output << "                 var Lp = M.duplicate();\n";
output << "                 Lp.moveToElementText(obj);\n";
output << "             }catch(e){\n";
output << "                 var Lp=obj.createTextRange();\n";
output << "             }\n";
output << "             Lp.setEndPoint(\"EndToStart\",M);\n";
output << "             var rb=Lp.text.length;\n";
output << "             if(rb>obj.value.length){\n";
output << "                 return -1;\n";
output << "             }\n";
output << "             return rb;\n";
output << "         }\n";
output << "     }\n";
output << "     // sets the caret position to l in the object\n";
output << "     function setCaret(obj,l){\n";
output << "         obj.focus();\n";
output << "         if (obj.setSelectionRange){\n";
output << "             obj.setSelectionRange(l,l);\n";
output << "         }else if(obj.createTextRange){\n";
output << "             m = obj.createTextRange();        \n";
output << "             m.moveStart('character',l);\n";
output << "             m.collapse();\n";
output << "             m.select();\n";
output << "         }\n";
output << "     }\n";
output << "     // sets the caret selection from s to e in the object\n";
output << "     function setSelection(obj,s,e){\n";
output << "         obj.focus();\n";
output << "         if (obj.setSelectionRange){\n";
output << "             obj.setSelectionRange(s,e);\n";
output << "         }else if(obj.createTextRange){\n";
output << "             m = obj.createTextRange();        \n";
output << "             m.moveStart('character',s);\n";
output << "             m.moveEnd('character',e);\n";
output << "             m.select();\n";
output << "         }\n";
output << "     }\n";
output << " \n";
output << "     /*    Escape function   */\n";
output << "     String.prototype.addslashes = function(){\n";
output << "         return this.replace(/([\"\\\\\\.\\|\\[\\]\\^\\*\\+\\?\\$\\(\\)])/g, '\\\\$1');\n";
output << "     }\n";
output << "     String.prototype.trim = function () {\n";
output << "         return this.replace(/^\\s*(\\S*(\\s+\\S+)*)\\s*$/, \"$1\");\n";
output << "     };\n";
output << "     /* --- Escape --- */\n";
output << " \n";
output << "     /* Offset position from top of the screen */\n";
output << "     function curTop(obj){\n";
output << "         toreturn = 0;\n";
output << "         while(obj){\n";
output << "             toreturn += obj.offsetTop;\n";
output << "             obj = obj.offsetParent;\n";
output << "         }\n";
output << "         return toreturn;\n";
output << "     }\n";
output << "     function curLeft(obj){\n";
output << "         toreturn = 0;\n";
output << "         while(obj){\n";
output << "             toreturn += obj.offsetLeft;\n";
output << "             obj = obj.offsetParent;\n";
output << "         }\n";
output << "         return toreturn;\n";
output << "     }\n";
output << "     /* ------ End of Offset function ------- */\n";
output << " \n";
output << "     /* Types Function */\n";
output << " \n";
output << "     // is a given input a number?\n";
output << "     function isNumber(a) {\n";
output << "         return typeof a == 'number' && isFinite(a);\n";
output << "     }\n";
output << " \n";
output << "     /* Object Functions */\n";
output << " \n";
output << "     function replaceHTML(obj,text){\n";
output << "         while(el = obj.childNodes[0]){\n";
output << "             obj.removeChild(el);\n";
output << "         };\n";
output << "         obj.appendChild(document.createTextNode(text));\n";
output << "     }\n";
output << " \n";
output << "     //****************************************************************************\n";
output << "   </script>\n";
output << " \n";
}
void static_html6(std::stringstream& output){
output << " <!>\n";
output << " <div style=\"width:400;height:400;border:solid 1px\" id=\"idCanvasMain\" onmousemove=\"mouseMoveRedraw(event.clientX, event.clientY);\" onmousedown=\"\n";
output << " clickCanvasMain(event.clientX, event.clientY);\n";
output << " //changeBasis(1, 50, 50); drawOnCanvasMain();\" onmouseup=\"ButtonIsDown=false; selectedBasisIndex=-1;\"></div>\n";
output << " <br>\n";
output << " The basis vectors correspond to the vertices of the Dynkin diagram.<br>\n";
output << " You can drag the center and the basis vectors.<button onclick=\"switchMenu('rotationExplanation')\">More info</button>\n";
output << " <br>\n";
output << " <div id=\"rotationExplanation\" style=\"display: none\">\n";
output << " The i^th vector corresponds to the i^th node of the Dynkin diagram of the root system.<br>\n";
output << " The nodes are labeled in Bourbaki order.<br>\n";
output << " Let the two dimensional plane we project onto be spanned by vectors e_1 and e_2.<br>\n";
output << " Let v be a basis vector which you drag, with orthogonal projection in the (e_1,e_2) plane equal to v' <br>\n";
output << " and with orthogonal complement v'':=v-v'.<br>\n";
output << " When you drag a basis vector v, you do two things.<br>\n";
output << " 1) You rotate e_1 and e_2 in the (e_1,e_2) plane, to match the rotation angle given by your mouse pointer<br>\n";
output << " 2) Then you apply a rotation in the (v,v'')-plane that preserves the orthogonal complement of the (v,v'')-plane <br> \n";
output << " such as to match the length of v' determined by your mouse pointer. <br>\n";
output << " Note that this operation is not defined if v lies in the (e_1, e_2) plane. <br>\n";
output << " If the above is the case, you will not be able to modify the length of v'. <br>  \n";
output << " <textarea id=\"debugField\" cols=\"128\" rows=\"15\">\n";
output << " </textarea><br>\n";
output << " </div><br>\n";
output << " The root system in simple basis coordinates follows. <br>\n";
output << " \n";
output << " \n";
output << " <textarea id=\"outputField\">\n";
output << " </textarea>\n";
output << " \n";
output << " <script type=\"text/javascript\">\n";
output << " var CartanSymmetric;\n";
output << " var InvertedCartan;\n";
output << " var theRootSystem;\n";
output << " var theRootSystemLongLength;\n";
output << " var theRootSystemLengths;\n";
output << " var theRootSystemSize;\n";
output << " var theRootSystemHashes;\n";
output << " var theRootSystemHashesSizes;\n";
output << " var HashSize=1000;\n";
output << " var theWeylLetter;\n";
output << " var theWeylDim;\n";
output << " var VectorE1;\n";
output << " var VectorE2;\n";
output << " \n";
output << " function generateRootSystemFromWeylLetterAndDim(WeylLetter, WeylDim)\n";
output << " { if (WeylLetter!=\"A\" && WeylLetter!=\"B\" && WeylLetter!=\"C\" && WeylLetter!=\"D\" && WeylLetter!=\"E\" && WeylLetter!=\"F\" && WeylLetter!=\"G\" )\n";
output << "     return;\n";
output << "   if (WeylDim>9 || WeylDim<1)\n";
output << "     return;\n";
output << "   makeCartanArbitrary(WeylLetter, WeylDim);\n";
output << "   InvertedCartan=invertMatrix(CartanSymmetric);\n";
output << "   VectorE1= new Array(theWeylDim);\n";
output << "   VectorE2= new Array(theWeylDim);\n";
output << "   for (var i=0; i<theWeylDim; i++)\n";
output << "   { VectorE1[i]=(i+1)*(i+1)+1;\n";
output << "     VectorE2[i]=i*3+1;\n";
output << "   }\n";
output << "   AddVectorTimes(VectorE1, VectorE2, -getScalarProduct(VectorE1, VectorE2)/getScalarProduct(VectorE2, VectorE2));\n";
output << "   MultiplyVector(VectorE1, Math.sqrt(1/(getScalarProduct(VectorE1, VectorE1))));\n";
output << "   MultiplyVector(VectorE2, Math.sqrt(1/(getScalarProduct(VectorE2, VectorE2))));\n";
output << "   GenerateRootSystem();\n";
output << "   theRootSystemLengths= new Array(theRootSystem.length);\n";
output << "   theRootSystemLongLength= getScalarProduct(theRootSystem[0], theRootSystem[0]);\n";
output << "   for (var i=0; i<theRootSystemSize; i++)\n";
output << "   { theRootSystemLengths[i]= getScalarProduct(theRootSystem[i], theRootSystem[i]);\n";
output << "     if (theRootSystemLengths[i]>theRootSystemLongLength)\n";
output << "       theRootSystemLongLength=theRootSystemLengths[i];\n";
output << "   }\n";
output << "   ComputeProjections();\n";
output << " }\n";
output << " \n";
output << " function ComputeProjections()\n";
output << " { for (var i=0; i<theWeylDim; i++)\n";
output << "   { Basis[i][0]=GraphicsUnit*getScalarProduct(VectorE1, theRootSystem[i]);\n";
output << "     Basis[i][1]=GraphicsUnit*getScalarProduct(VectorE2, theRootSystem[i]);\n";
output << "   }\n";
output << " }\n";
output << " \n";
output << " function MultiplyVector(output, coeff)\n";
output << " { for (var i=0; i<output.length; i++)\n";
output << "     output[i]*=coeff;\n";
output << " }\n";
output << " \n";
output << " function AddVectorTimes(output, inputVector, coeff)\n";
output << " { for (var i=0; i<output.length; i++)\n";
output << "     output[i]+=inputVector[i]*coeff;\n";
output << " }\n";
output << " \n";
output << " function makeCartanArbitrary(WeylLetter, WeylDim)\n";
output << " { theWeylLetter=WeylLetter;\n";
output << "   theWeylDim= WeylDim;\n";
output << "   if (theWeylLetter==\"E\")\n";
output << "   { if (theWeylDim<6)\n";
output << "       theWeylDim=6;\n";
output << "     if (theWeylDim>8)\n";
output << "       theWeylDim=8;\n";
output << "   }\n";
output << "   if (theWeylLetter==\"G\")\n";
output << "     theWeylDim=2;\n";
output << "   if (theWeylLetter==\"F\")\n";
output << "     theWeylDim=4;\n";
output << "   makeCartanAn(theWeylDim);\n";
output << "   if (theWeylLetter==\"B\")\n";
output << "   { CartanSymmetric[theWeylDim-1][theWeylDim-1]=1;\n";
output << "   }\n";
output << "   if (theWeylLetter==\"C\")\n";
output << "   {CartanSymmetric[theWeylDim-1][theWeylDim-1]=4;\n";
output << "    CartanSymmetric[theWeylDim-1][theWeylDim-2]=-2;\n";
output << "    CartanSymmetric[theWeylDim-2][theWeylDim-1]=-2;\n";
output << "   }\n";
output << "   if (theWeylLetter==\"F\")\n";
output << "   { CartanSymmetric[0][0]=2 ; CartanSymmetric[0][1]=-1;\n";
output << "     CartanSymmetric[1][0]=-1; CartanSymmetric[1][1]=2 ; CartanSymmetric[1][2]=-2;\n";
output << "     CartanSymmetric[2][1]=-2; CartanSymmetric[2][2]=4 ; CartanSymmetric[2][3]=-2;\n";
output << "     CartanSymmetric[3][2]=-2; CartanSymmetric[3][3]=4 ;\n";
output << "   }\n";
output << "   if (theWeylLetter==\"D\")\n";
output << "   { CartanSymmetric[theWeylDim-2][theWeylDim-1]=0;\n";
output << "     CartanSymmetric[theWeylDim-1][theWeylDim-2]=0;\n";
output << "     CartanSymmetric[theWeylDim-3][theWeylDim-1]=-1;\n";
output << "     CartanSymmetric[theWeylDim-1][theWeylDim-3]=-1;\n";
output << "   }\n";
output << "   if (theWeylLetter==\"E\")\n";
output << "   { CartanSymmetric[0][1]=0; CartanSymmetric[1][0]=0;\n";
output << "     CartanSymmetric[1][2]=0; CartanSymmetric[2][1]=0;\n";
output << "     CartanSymmetric[0][2]=-1; CartanSymmetric[2][0]=-1;\n";
output << "     CartanSymmetric[1][3]=-1; CartanSymmetric[3][1]=-1;\n";
output << "   }  \n";
output << "   if (theWeylLetter==\"G\")\n";
output << "   { CartanSymmetric[0][0]=6; CartanSymmetric[0][1]=-3;\n";
output << "     CartanSymmetric[1][0]=-3; CartanSymmetric[1][1]=2;\n";
output << "   }\n";
output << "   document.getElementById(\"textDim\").value=theWeylDim;\n";
output << "   document.getElementById(\"textType\").value=theWeylLetter;  \n";
output << " }\n";
output << " \n";
output << " function makeCartanAn(WeylDim)\n";
output << " { CartanSymmetric= new Array(WeylDim);\n";
output << "   for (var i=0; i<WeylDim; i++)\n";
output << "   { CartanSymmetric[i]= new Array(WeylDim);\n";
output << "     for (var j=0; j<WeylDim; j++)\n";
output << "       CartanSymmetric[i][j]=0;\n";
output << "     CartanSymmetric[i][i]=2;\n";
output << "     if (i<WeylDim-1)\n";
output << "       CartanSymmetric[i][i+1]=-1;\n";
output << "     if (i>0)\n";
output << "       CartanSymmetric[i][i-1]=-1;\n";
output << "   }\n";
output << " }\n";
output << " \n";
output << " function ClearRootSystem()\n";
output << " { theRootSystemHashes= new Array(HashSize);\n";
output << "   theRootSystemHashesSizes= new Array(HashSize);\n";
output << "   theRootSystem= new Object(Array(HashSize));\n";
output << "   for (var i=0; i<HashSize; i++)\n";
output << "   { theRootSystemHashesSizes[i]=0;\n";
output << "     theRootSystemHashes[i]= new Array();\n";
output << "   }\n";
output << "   theRootSystemSize=0;\n";
output << " }\n";
output << " \n";
output << " function HashFunctionRoot(theRoot, theWeylDim)\n";
output << " { var result=0;\n";
output << "   for (var i=0; i<theWeylDim; i++)\n";
output << "     result+=(i+6)*(6+1)*theRoot[i];\n";
output << "   result= result % HashSize;\n";
output << "   if (result<0)\n";
output << "     result+=HashSize;\n";
output << "   return result;\n";
output << " }\n";
output << " \n";
output << " function getRootIndex(theRoot, theWeylDim)\n";
output << " { var theHash = HashFunctionRoot(theRoot, theWeylDim);\n";
output << "   var hashArraySize=theRootSystemHashesSizes[theHash];\n";
output << "   for (var i=0; i<hashArraySize; i++)\n";
output << "   { theIndex=theRootSystemHashes[theHash][i];\n";
output << "     if (AreEqualRoots(theRootSystem[theIndex], theRoot, theWeylDim))\n";
output << "       return theIndex;\n";
output << "   }\n";
output << "   return -1;\n";
output << " }\n";
output << " \n";
output << " function AreEqualRoots(root1, root2, theDim)\n";
output << " { for (var i=0; i<theDim; i++)\n";
output << "     if (root1[i]!=root2[i])\n";
output << "       return false;\n";
output << "   return true;\n";
output << " }\n";
output << " \n";
output << " function addToRootSystemNoRepetition(theRoot)\n";
output << " { var theIndex=getRootIndex(theRoot, theWeylDim);\n";
output << "   if (theIndex==-1)\n";
output << "   { theRootSystem[theRootSystemSize]=new Array(theWeylDim);\n";
output << "     for (var i=0; i<theWeylDim; i++)\n";
output << "       theRootSystem[theRootSystemSize][i]=theRoot[i];\n";
output << "     var theHashIndex=HashFunctionRoot(theRoot, theWeylDim);\n";
output << "     var theHashSize=theRootSystemHashesSizes[theHashIndex];\n";
output << "     theRootSystemHashes[theHashIndex][theHashSize]=theRootSystemSize;\n";
output << "     theRootSystemHashesSizes[theHashIndex]++;\n";
output << "     theRootSystemSize++;\n";
output << "   }\n";
output << "   return false;\n";
output << " }\n";
output << " \n";
output << " function getScalarProduct(root1, root2)\n";
output << " { var result=0; \n";
output << "   for (var i=0; i<theWeylDim; i++)\n";
output << "     for (var j=0; j<theWeylDim; j++)\n";
output << "       result+= root1[i]*root2[j]*CartanSymmetric[i][j];\n";
output << "   \n";
output << "   return result;\n";
output << " }\n";
output << " \n";
output << " function ActOnARootGenIndex(theIndex, input, output)\n";
output << " { for (i=0; i<theWeylDim; i++)\n";
output << "     output[i]= input[i];\n";
output << "   theScalarProduct=getScalarProduct(theRootSystem[theIndex], input);\n";
output << "   output[theIndex]-= theScalarProduct*2/getScalarProduct(theRootSystem[theIndex],theRootSystem[theIndex]);\n";
output << "   return output;\n";
output << " }\n";
output << " \n";
output << " function GenerateRootSystem()\n";
output << " { var theOutputRoot= new Object(Array(theWeylDim));\n";
output << "   ClearRootSystem();\n";
output << "   for (var j=0; j<theWeylDim; j++)\n";
output << "   { for (var i=0; i<theWeylDim; i++)\n";
output << "       theOutputRoot[i]=0;\n";
output << "     theOutputRoot[j]=1;\n";
output << "     addToRootSystemNoRepetition(theOutputRoot);\n";
output << "   }\n";
output << "   for (var l=0; l<theRootSystemSize; l++)\n";
output << "   { for (var j=0; j<theWeylDim; j++)\n";
output << "     { theOutputRoot=ActOnARootGenIndex(j, theRootSystem[l], theOutputRoot);\n";
output << "       addToRootSystemNoRepetition(theOutputRoot);\n";
output << "     }\n";
output << "   }\n";
output << "   WriteRootSystem();\n";
output << "   drawOnCanvasMain();\n";
output << " }\n";
output << " \n";
output << " function WriteRootSystem()\n";
output << " { var output = document.getElementById(\"outputField\");\n";
output << "   output.value=\"\";\n";
output << "   output.rows=theRootSystemSize;\n";
output << "   var tempS;\n";
output << "   for (var i=0; i<theRootSystemSize; i++)\n";
output << "   { tempS=\"(\";\n";
output << "     for (var j=0; j<theWeylDim; j++)\n";
output << "     { tempS=tempS+theRootSystem[i][j];\n";
output << "       if (j!=theWeylDim-1)\n";
output << "         tempS=tempS+\",\";\n";
output << "     }\n";
output << "     tempS=tempS+\")\";\n";
output << "     output.value+=tempS;\n";
output << "     if (i!=theRootSystemSize-1)\n";
output << "       output.value+=\"\\n\";\n";
output << "   }  \n";
output << " }\n";
output << " </script>\n";
output << " \n";
output << " <script type=\"text/javascript\">\n";
output << " var NumElements=0;\n";
output << " var node;\n";
output << " var surface;\n";
output << " var MaxNumCoords=8;\n";
output << " var Basis= new Array(MaxNumCoords);\n";
output << " var Xshift=200;\n";
output << " var Yshift=200;\n";
output << " var selectedBasisIndex=-1;//-2 = center of coord system is selected\n";
output << " var GraphicsUnit=80;\n";
output << " var clickTolerance=5;\n";
output << " var RootsArray;\n";
output << " var ZeroRoot;\n";
output << " var ButtonIsDown=false;\n";
output << " var DebugString;\n";
output << " var canvasMain=document.getElementById(\"idCanvasMain\");\n";
output << " for (tempCounter=0; tempCounter<MaxNumCoords; tempCounter++)\n";
output << "   Basis[tempCounter]= new Array(2);\n";
output << " tempCounter=0;\n";
output << " Basis[tempCounter][0]=0.3;  Basis[tempCounter][1]=0; tempCounter++; \n";
output << " Basis[tempCounter][0]=0.4;  Basis[tempCounter][1]=-0.1; tempCounter++; \n";
output << " Basis[tempCounter][0]=0.4;  Basis[tempCounter][1]=0.1; tempCounter++; \n";
output << " Basis[tempCounter][0]=-0.8; Basis[tempCounter][1]=1.4; tempCounter++; \n";
output << " Basis[tempCounter][0]=1.6;  Basis[tempCounter][1]=0.9; tempCounter++; \n";
output << " Basis[tempCounter][0]=1.6;  Basis[tempCounter][1]=0.8; tempCounter++; \n";
output << " Basis[tempCounter][0]=1.5;  Basis[tempCounter][1]=0.8; tempCounter++; \n";
output << " Basis[tempCounter][0]=1.4;  Basis[tempCounter][1]=0.8; tempCounter++; \n";
output << " for (tempCounter=0; tempCounter<MaxNumCoords; tempCounter++)\n";
output << " { Basis[tempCounter][0]*= GraphicsUnit;\n";
output << "   Basis[tempCounter][1]*= GraphicsUnit;\n";
output << " } \n";
output << " \n";
output << " function ptsWithinClickTolerance(x1, y1, x2, y2)\n";
output << " { if (x1-x2>clickTolerance || x2-x1>clickTolerance || y1-y2>clickTolerance || y2-y1>clickTolerance )\n";
output << "     return false;\n";
output << "   return true;\n";
output << " }\n";
output << " \n";
output << " function clickCanvasMain(cx,cy)\n";
output << " { var divPosX=0;\n";
output << "   var divPosY=0;\n";
output << "   var thePointer= canvasMain;\n";
output << "   while(thePointer)\n";
output << "   { divPosX += thePointer.offsetLeft;\n";
output << "     divPosY += thePointer.offsetTop;\n";
output << "     thePointer = thePointer.offsetParent;\n";
output << "   }\n";
output << "   var posx=(cx-divPosX+document.body.scrollLeft-Xshift);\n";
output << "   var posy=-(cy-divPosY+document.body.scrollTop-Yshift);\n";
output << "   selectedBasisIndex=-1;\n";
output << "   if (ptsWithinClickTolerance(posx,posy,0,0))\n";
output << "     selectedBasisIndex=-2;\n";
output << "   for (i=0;i<MaxNumCoords;i++)\n";
output << "   { if (ptsWithinClickTolerance(posx, posy, Basis[i][0], Basis[i][1]))\n";
output << "       selectedBasisIndex=i;\n";
output << "   }\n";
output << " }\n";
output << " \n";
output << " function RotateOutOfPlane(input, orthoBasis1, orthoBasis2, oldTanSquared, newTanSquared)\n";
output << " { var projection= dojo.clone(orthoBasis1);\n";
output << "   var vComponent= dojo.clone(input);\n";
output << "   var scal1= getScalarProduct(orthoBasis1, input);\n";
output << "   var scal2= getScalarProduct(orthoBasis2, input);\n";
output << "   MultiplyVector(projection, scal1);\n";
output << "   AddVectorTimes(projection, orthoBasis2, scal2);\n";
output << "   AddVectorTimes(vComponent, projection, -1);\n";
output << "   DebugString+=\"\\ngetScalarProd=\"+getScalarProduct(projection, vComponent);\n";
output << "   var oldAngle=Math.atan(Math.sqrt(oldTanSquared));\n";
output << "   var newAngle=Math.atan(Math.sqrt(newTanSquared));\n";
output << "   if (isNaN(oldAngle) || isNaN(newAngle))\n";
output << "     return input;\n";
output << "   var angleChange=-oldAngle+newAngle;  \n";
output << "   projection=dojo.clone(orthoBasis1);\n";
output << "   MultiplyVector(projection,              Math.cos(angleChange)*scal1-Math.sin(angleChange)*scal2);\n";
output << "   AddVectorTimes(projection, orthoBasis2, Math.sin(angleChange)*scal1+Math.sin(angleChange)*scal2);\n";
output << "   var result= vComponent;\n";
output << "   AddVectorTimes(result, projection, 1);  \n";
output << "   return result;\n";
output << " }\n";
output << " \n";
output << " function ScaleToUnitLength(vector)\n";
output << " { MultiplyVector(vector, 1/Math.sqrt(getScalarProduct(vector,vector)));\n";
output << " }\n";
output << " \n";
output << " function RootToString(theRoot)\n";
output << " {  var output=\"(\";\n";
output << "   for (var i=0; i<theWeylDim; i++)\n";
output << "   { output=output+ theRoot[i].toFixed(2);\n";
output << "     if (i!=theWeylDim-1)\n";
output << "      output+=\",\";\n";
output << "   }\n";
output << "   output+=\")\";\n";
output << "   return output;\n";
output << " }\n";
output << " \n";
output << " function getQuadrantFromXandY(theX, theY)\n";
output << " { if (theX>0 && theY>=0)\n";
output << "     return 1;\n";
output << "   if (theX<=0 && theY>0)\n";
output << "     return 2;\n";
output << "   if (theX<0 && theY<=0)\n";
output << "     return 3;\n";
output << "   return 4;\n";
output << " }\n";
output << " \n";
output << " function getAngleFromXandY(x, y, neighborX, neighborY)\n";
output << " { var result;\n";
output << "   if (x!=0)\n";
output << "    result= Math.atan(y/x);\n";
output << "   else \n";
output << "     if (y>0)\n";
output << "       result= Math.PI/2;\n";
output << "     else\n";
output << "       result= -Math.PI/2;\n";
output << "   return result;     \n";
output << " }\n";
output << " \n";
output << " function changeBasis(selectedIndex, newX, newY)\n";
output << " { if (newX==0 && newY==0)\n";
output << "     return;\n";
output << "   DebugString=\"\";\n";
output << "   var selectedRoot=theRootSystem[selectedIndex];\n";
output << "   var selectedRootLength=getScalarProduct(selectedRoot,selectedRoot);  \n";
output << "   var oldX=Basis[selectedIndex][0]/GraphicsUnit;\n";
output << "   var oldY=Basis[selectedIndex][1]/GraphicsUnit; \n";
output << "   newX/=GraphicsUnit;\n";
output << "   newY/=GraphicsUnit;\n";
output << "   var oldAngle= getAngleFromXandY(oldX, oldY, newX, newY);\n";
output << "   var newAngle= getAngleFromXandY(newX, newY, oldX, oldY);    \n";
output << "   var AngleChange= -newAngle+oldAngle;\n";
output << "   var epsilon=0.000015;\n";
output << "   while (AngleChange>=Math.PI/2+epsilon)\n";
output << "   { AngleChange-=Math.PI;}\n";
output << "   while (AngleChange<=-Math.PI/2-epsilon)\n";
output << "   { AngleChange+=Math.PI;}\n";
output << "   DebugString+=\"\\nold angle:\"+ oldAngle.toFixed(2);\n";
output << "   DebugString+=\"\\nnew angle: \"+newAngle.toFixed(2);\n";
output << "   var NewVectorE1=dojo.clone(VectorE1);\n";
output << "   var NewVectorE2= dojo.clone(VectorE2);\n";
output << "   MultiplyVector(NewVectorE1, Math.cos(AngleChange));\n";
output << "   AddVectorTimes(NewVectorE1, VectorE2, Math.sin(AngleChange));\n";
output << "   MultiplyVector(NewVectorE2, Math.cos(AngleChange));\n";
output << "   AddVectorTimes(NewVectorE2, VectorE1, -Math.sin(AngleChange));\n";
output << "   VectorE1=NewVectorE1;\n";
output << "   VectorE2=NewVectorE2;\n";
output << "   var RootTimesE1=getScalarProduct(selectedRoot, VectorE1);\n";
output << "   var RootTimesE2=getScalarProduct(selectedRoot, VectorE2);\n";
output << "   var vOrthogonal=dojo.clone(selectedRoot);\n";
output << "   var vProjection=dojo.clone(VectorE1); \n";
output << "   MultiplyVector(vProjection, RootTimesE1);\n";
output << "   AddVectorTimes(vProjection, VectorE2, RootTimesE2);\n";
output << "   AddVectorTimes(vOrthogonal, vProjection, -1);\n";
output << "   var oldRatioProjectionOverHeightSquared = (oldX*oldX+oldY*oldY)/ (selectedRootLength-oldX*oldX-oldY*oldY);\n";
output << "   var newRatioProjectionOverHeightSquared = (newX*newX+newY*newY)/ (selectedRootLength-newX*newX-newY*newY);\n";
output << "   DebugString+=\"\\noldRatio: \"+oldRatioProjectionOverHeightSquared;\n";
output << "   DebugString+=\"\\nnewRatio: \"+newRatioProjectionOverHeightSquared;\n";
output << "   if (getScalarProduct(vOrthogonal, vOrthogonal)>epsilon || getScalarProduct(vOrthogonal, vOrthogonal)<-epsilon)\n";
output << "   { ScaleToUnitLength(vProjection);\n";
output << "     ScaleToUnitLength(vOrthogonal);\n";
output << "     DebugString+=\"\\nscaled vOrthogonal=\"+RootToString(vOrthogonal)+\"->\"+getScalarProduct(vOrthogonal,vOrthogonal);\n";
output << "     DebugString+=\"\\nscaled vProjection=\"+RootToString(vProjection)+\"->\"+getScalarProduct(vProjection,vProjection); \n";
output << "     DebugString+=\"\\ntheScalarProd: \"+getScalarProduct(vOrthogonal, vProjection);  \n";
output << "     VectorE1=RotateOutOfPlane(VectorE1, vProjection, vOrthogonal, oldRatioProjectionOverHeightSquared, newRatioProjectionOverHeightSquared);\n";
output << "     VectorE2=RotateOutOfPlane(VectorE2, vProjection, vOrthogonal, oldRatioProjectionOverHeightSquared, newRatioProjectionOverHeightSquared);\n";
output << "   }\n";
output << "   AddVectorTimes(VectorE2, VectorE1, -getScalarProduct(VectorE1, VectorE1)*getScalarProduct(VectorE1, VectorE2));\n";
output << "   ScaleToUnitLength(VectorE1);\n";
output << "   ScaleToUnitLength(VectorE2);\n";
output << "   \n";
output << "   DebugString+=\"\\ne1=\"+RootToString(VectorE1);\n";
output << "   DebugString+=\"\\ne2=\"+RootToString(VectorE2);\n";
output << "   DebugString+=\"\\ne1*e2=\"+getScalarProduct(VectorE1, VectorE2);  \n";
output << "   ComputeProjections();\n";
output << " }\n";
output << " \n";
output << " function fixE1AndE2andComputeProjections()\n";
output << " { var tempE1= new Array(theWeylDim);\n";
output << "   var tempE2= new Array(theWeylDim);\n";
output << "   for (var i=0; i<theWeylDim; i++)\n";
output << "   { tempE1[i]=Basis[i][0];\n";
output << "     tempE2[i]=Basis[i][1];\n";
output << "   }\n";
output << "   VectorE1=matrixActOnRow(InvertedCartan, tempE1);\n";
output << "   VectorE2=matrixActOnRow(InvertedCartan, tempE2);\n";
output << "   var tempLength1=getScalarProduct(VectorE1, VectorE1);\n";
output << "   var tempLength2=getScalarProduct(VectorE2, VectorE2);\n";
output << "   \n";
output << " }\n";
output << " \n";
output << " function matrixActOnRow(theMatrix, theRow)\n";
output << " { var output=new Array(theRow.length);\n";
output << "   for (var i=0; i<theMatrix.length; i++)\n";
output << "   { output[i]=0;\n";
output << "     for (var j=0; j<theMatrix.length; j++)\n";
output << "       output[i]+=theMatrix[j][i]*theRow[j];\n";
output << "   }\n";
output << "   return output;\n";
output << " }\n";
output << " \n";
output << " function swapTwoRows(theMatrix, index1, index2)\n";
output << " { var temp;\n";
output << "   for (var i=0; i<theMatrix.length; i++)\n";
output << "   { temp=theMatrix[index1][i];\n";
output << "     theMatrix[index1][i]=theMatrix[index2][i];\n";
output << "     theMatrix[index2][i]=temp;\n";
output << "   }\n";
output << " }\n";
output << " \n";
output << " function addToRowRowTimesCoeff(theMatrix, indexModified, indexOther, coeff)\n";
output << " { for (var i=0; i<theMatrix.length; i++)\n";
output << "     theMatrix[indexModified][i]+=coeff*theMatrix[indexOther][i];\n";
output << " }\n";
output << " \n";
output << " function multiplyRowBy(theMatrix, rowIndex, coeff)\n";
output << " { for (var i=0; i<theMatrix.length; i++)\n";
output << "     theMatrix[rowIndex][i]*=coeff;\n";
output << " }\n";
output << " \n";
output << " function findPivot(theMatrix, columnIndex, minPossibleAnswer)\n";
output << " { for (var i=minPossibleAnswer; i<theMatrix.length; i++)\n";
output << "     if (theMatrix[i][columnIndex]!=0)\n";
output << "       return i;\n";
output << "   return -1;\n";
output << " }\n";
output << " \n";
output << " function getIdentityMatrix(dimension)\n";
output << " { var answer= new Array(dimension);\n";
output << "   for (var i=0; i<dimension; i++)\n";
output << "   { answer[i]= new Array(dimension);\n";
output << "     for (var j=0; j<dimension; j++)\n";
output << "       if (i==j)\n";
output << "         answer[i][j]=1;\n";
output << "       else\n";
output << "         answer[i][j]=0;\n";
output << "   }\n";
output << "   return answer;\n";
output << " }\n";
output << " \n";
output << " function invertMatrix(theInputMatrix)\n";
output << " { var theMatrix= dojo.clone(theInputMatrix);\n";
output << "   var theDim=theMatrix.length;\n";
output << "   var answer= getIdentityMatrix(theDim);\n";
output << "   for (var i=0; i<theDim; i++)\n";
output << "   { var thePivotIndex=findPivot(theMatrix, i, i);\n";
output << "     if (thePivotIndex==-1)\n";
output << "       return;\n";
output << "     swapTwoRows(answer, thePivotIndex, i);\n";
output << "     swapTwoRows(theMatrix, thePivotIndex, i);\n";
output << "     multiplyRowBy(answer, i, 1/theMatrix[i][i]);    \n";
output << "     multiplyRowBy(theMatrix, i, 1/theMatrix[i][i]);\n";
output << "     for (var j=0; j<theDim; j++)\n";
output << "       if (i!=j)\n";
output << "       { addToRowRowTimesCoeff(answer, j, i, -theMatrix[j][i]);\n";
output << "         addToRowRowTimesCoeff(theMatrix, j, i, -theMatrix[j][i]);\n";
output << "       }\n";
output << "   }\n";
output << "   return answer;\n";
output << " }\n";
output << " \n";
output << " function solveTwoByTwoSystem(a11, a12, a21, a22, coeff1, coeff2)\n";
output << " { var answer= new Array(2);\n";
output << "   var theDeterminant=a11*a22-a21*a12;\n";
output << "   answer[0]=(coeff1*a22-coeff2*a12)/theDeterminant;\n";
output << "   answer[1]=(a11*coeff2-a21*coeff1)/theDeterminant;\n";
output << "   return answer;\n";
output << " } \n";
output << "  \n";
output << " function mouseMoveRedraw(cx, cy)\n";
output << " { if (selectedBasisIndex!=-1)\n";
output << "   { var divPosX=0;\n";
output << "     var divPosY=0;\n";
output << "     var thePointer= canvasMain;\n";
output << "     while(thePointer)\n";
output << "     { divPosX += thePointer.offsetLeft;\n";
output << "       divPosY += thePointer.offsetTop;\n";
output << "       thePointer = thePointer.offsetParent;\n";
output << "     }\n";
output << "     var posx=(cx-divPosX+document.body.scrollLeft-Xshift);\n";
output << "     var posy=-(cy-divPosY+document.body.scrollTop-Yshift);\n";
output << "     if (selectedBasisIndex==-2)\n";
output << "     { Xshift=(cx-divPosX+document.body.scrollLeft);\n";
output << "       Yshift=(cy-divPosY+document.body.scrollTop);\n";
output << "     }\n";
output << " 		else\n";
output << "     {	//posx=50; posy=50;\n";
output << "       changeBasis(selectedBasisIndex, posx, posy);\n";
output << "     }\n";
output << "     drawOnCanvasMain();\n";
output << "   }\n";
output << " }\n";
output << " \n";
output << " function getCoord(thePoint, Coord)\n";
output << " { var result=Number(0);\n";
output << "   for (var counterI=0; counterI<theWeylDim; counterI++)\n";
output << "     result= result+ thePoint[counterI]*Basis[counterI][Coord];\n";
output << "   result=Math.floor(result);\n";
output << "   return result;\n";
output << " }\n";
output << " \n";
output << " function drawLineBetweenZeroAndRoot(theRoot)\n";
output << " { xCoord1=getCoord(ZeroRoot,0)+Xshift;\n";
output << "   yCoord1=-getCoord(ZeroRoot,1)+Yshift;\n";
output << "   xCoord2=getCoord(theRoot,0)+Xshift;\n";
output << "   yCoord2=-getCoord(theRoot,1)+Yshift;\n";
output << "   var theColor;\n";
output << "   if (getScalarProduct(theRoot, theRoot)==theRootSystemLongLength)\n";
output << "     theColor =\"blue\";\n";
output << "   else\n";
output << "     theColor =\"#C0C0FF\"; \n";
output << "   surface.createLine({ x1 : xCoord1, y1 : yCoord1, x2 : xCoord2, y2 : yCoord2 }).setStroke({color : theColor});\n";
output << " }\n";
output << " \n";
output << " function drawCircleAtRoot(theRoot)\n";
output << " { xCoord1=getCoord(theRoot,0)+Xshift;\n";
output << "   yCoord1=-getCoord(theRoot,1)+Yshift;\n";
output << "   surface.createEllipse({ cx : xCoord1, cy : yCoord1, rx : 2, ry : 2 }).setStroke({color : \"red\"});\n";
output << " }\n";
output << " \n";
output << " function drawTextAtRoot(theRoot, theText)\n";
output << " { xCoord1=getCoord(theRoot,0)+Xshift;\n";
output << "   yCoord1=-getCoord(theRoot,1)+Yshift;\n";
output << "   var tempText=surface.createText({x: xCoord1, y: yCoord1, text: theText});\n";
output << "   tempText.setFont({family : \"Arial\", size : \"9pt\"});\n";
output << "   tempText.setStroke(\"black\");\n";
output << " }\n";
output << " \n";
output << " function drawOnCanvasMain()\n";
output << " {//	alert(\"paint\");\n";
output << "   surface.clear();\n";
output << "   ZeroRoot= new Array(theWeylDim);\n";
output << "   var tempRoot=new Array(theWeylDim);\n";
output << "   surface.createLine({ x1 : Xshift, y1 : Yshift, x2 : Xshift, y2 : Yshift-GraphicsUnit }).setStroke({color : \"#EFEFEF\"});\n";
output << "   surface.createLine({ x1 : Xshift, y1 : Yshift, x2 : Xshift+GraphicsUnit, y2 : Yshift }).setStroke({color : \"#EFEFEF\"});\n";
output << "   for (var i=0; i<theWeylDim; i++)\n";
output << "   { ZeroRoot[i]=0;\n";
output << "     tempRoot[i]=0;\n";
output << "   }\n";
output << "   for (var i=0; i<theWeylDim; i++)\n";
output << "   { tempRoot[i]=1;\n";
output << "     drawCircleAtRoot(tempRoot);\n";
output << "     drawTextAtRoot(tempRoot, i+1);\n";
output << "     tempRoot[i]=0;\n";
output << "   }\n";
output << "   for (var CounterK=0; CounterK<theRootSystemSize; CounterK++)\n";
output << "     drawLineBetweenZeroAndRoot(theRootSystem[CounterK]);  \n";
output << "   var debugLog = document.getElementById(\"debugField\");\n";
output << "   debugLog.value=DebugString;\n";
output << " }\n";
output << " \n";
output << " function initDojo()\n";
output << " { node = dojo.byId(\"idCanvasMain\");\n";
output << "   surface = dojox.gfx.createSurface(node, 400, 400);\n";
output << "   initRecompute();\n";
output << " }\n";
output << " \n";
output << " function initRecompute()\n";
output << " { var tempWeylLetter=document.getElementById(\"textType\").value;\n";
output << "   var tempWeylDim=document.getElementById(\"textDim\").value;\n";
output << "   tempWeylDim=Number(tempWeylDim);\n";
output << "   tempWeylLetter=tempWeylLetter.toUpperCase();\n";
output << "   generateRootSystemFromWeylLetterAndDim(tempWeylLetter, tempWeylDim); \n";
output << "   drawOnCanvasMain();\n";
output << " }\n";
output << " dojo.require(\"dojox.gfx\");\n";
output << " dojo.addOnLoad(initDojo);\n";
output << " </script>\n";
}
void static_html7(std::stringstream& output){
output << " <!>\n";
output << " </body>\n";
output << " </html>\n";
output << " \n";
output << " \n";
}
