//*********************************************************************************************************
//*********************************************************************************************************
//Vector partition function - computes an algebraic expression
//                            for the vector partition function
//CopyRight (C) 2009: Todor Milev
//email: t.milev@jacobs-university.de
//
//Contributors: Thomas Bliem, Todor Milev
//
//This is free software. You are warmly welcome to use, modify and redistribute this code
//and the resulting program any way you wish, as long as you provide the same rights
//as those given to you to any future recipients of your modifications (in case you
//decide to pass on those modifications).
//The code is licensed under the Library General Public License version 3.0
//(summarized in the preceding sentence).
//You should have received a copy of the GNU Library General Public License
//along with this program.
//If not, see <http://www.gnu.org/licenses/>.
//
//Todor Milev would like to thank http://www.cplusplus.com/forum/ for the valuable
//advice and help with C++. Special thanks to helios, Disch, Grey Wolf, jsmith,
//Hammurabi and Duoas!
//*********************************************************************************************************
//*********************************************************************************************************
//DISCLAIMER
//
//THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
//EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
//PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND,
//EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
//THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.
//SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
//REPAIR OR CORRECTION.
//*********************************************************************************************************
//*********************************************************************************************************

#include "polyhedra.h"

//the below gives upper limit to the amount of pointers that are allowed to be allocated by the program. Can be changed dynamically.
//used to guard the web server from abuse.
#ifdef CGIversionLimitRAMuse
int ParallelComputing::cgiLimitRAMuseNumPointersInList=1000000;
#endif

Controller ParallelComputing::controllerLockThisMutexToSignalPause;

GlobalVariables::GlobalVariables()
{ this->FeedDataToIndicatorWindowDefault=0;
}

bool Stop()
{ return true;
}

int ParallelComputing::GlobalPointerCounter=0;
int ParallelComputing::PointerCounterPeakRamUse=0;
Integer Integer::TheRingUnit(1) ;
Integer Integer::TheRingMUnit(-1);
Integer Integer::TheRingZero(0) ;
Integer& IOne =Integer::TheRingUnit ;
Integer& IMOne=Integer::TheRingMUnit;
Integer& IZero=Integer::TheRingZero ;

LargeInt LargeInt::TheRingUnit (1 );
LargeInt LargeInt::TheRingMUnit(-1);
LargeInt LargeInt::TheRingZero (0 );
LargeInt& LIOne =LargeInt::TheRingUnit ;
LargeInt& LIMOne=LargeInt::TheRingMUnit;
LargeInt& LIZero=LargeInt::TheRingZero ;

Rational Rational::TheRingUnit(1, 1);
Rational Rational::TheRingMUnit(-1, 1);
Rational Rational::TheRingZero(0, 1);
Rational& ROne=Rational::TheRingUnit ;
Rational& RMOne=Rational::TheRingMUnit;
Rational& RZero =Rational::TheRingZero ;
Rational RHalf(1, 2);
Rational RMHalf(-1, 2);

Rational& LROne=Rational::TheRingUnit;
Rational& LRMOne=Rational::TheRingMUnit;
Rational& LRZero=Rational::TheRingZero;

QuasiNumber QuasiNumber::TheRingUnit ;
QuasiNumber QuasiNumber::TheRingMUnit;
QuasiNumber QuasiNumber::TheRingZero ;
QuasiNumber& QNOne =QuasiNumber::TheRingUnit ;
QuasiNumber& QNMOne=QuasiNumber::TheRingMUnit;
QuasiNumber& QNZero=QuasiNumber::TheRingZero ;

CompositeComplexQN CompositeComplexQN::TheRingUnit (1);
CompositeComplexQN CompositeComplexQN::TheRingZero (1);
CompositeComplexQN CompositeComplexQN::TheRingMUnit(1);
CompositeComplexQN& CQNOne =CompositeComplexQN::TheRingUnit ;
CompositeComplexQN& CQNMOne=CompositeComplexQN::TheRingMUnit;
CompositeComplexQN& CQNZero=CompositeComplexQN::TheRingZero ;

PrecomputedTauknPointersKillOnExit* QuasiPolynomialOld::PrecomputedTaus;
PolynomialsRationalCoeff*
PrecomputedQuasiPolynomialIntegrals::PreComputedBernoulli;
PolynomialsRationalCoeff PreComputedBernoulliLocal;
PrecomputedTauknPointersKillOnExit PrecomputedTausLocal;

bool CombinatorialChamber::flagPrintWallDetails=true;
bool CombinatorialChamberContainer::PrintLastChamberOnly=true;
bool CombinatorialChamberContainer::flagAnErrorHasOcurredTimeToPanic=false;

bool CombinatorialChamber::flagIncludeVerticesInDebugString=true;
bool CombinatorialChamber::flagAnErrorHasOccurredTimeToPanic=false;
bool CombinatorialChamberContainer::flagMakingConsistencyCheck=true;
int CombinatorialChamberContainer::NumTotalCreatedCombinatorialChambersAtLastDefrag;
int CombinatorialChamberContainer::LastReportedMemoryUse;
int CombinatorialChamberContainer::DefragSpacing;
int CombinatorialChamberContainer::flagMaxNumCharsAllowedInStringOutput=100000; //16777216;
std::fstream CombinatorialChamberContainer::TheBigDump;

ListPointers<QuasiPolynomialOld> QuasiPolynomialOld::GlobalCollectorsPolys;
ListPointers<ComplexQN> ComplexQN::GlobalCollectorsComplexQNs;
//CombinatorialChamberContainer GlobalCollectorChambers;
//FacetPointers GlobalCollectorFacets;

intRoot partFraction::theVectorToBePartitioned;
bool partFraction::MakingConsistencyCheck=false;
bool partFraction::UncoveringBrackets=true;
Rational partFractions::CheckSum;
Rational partFraction::CheckSum;
Rational partFraction::CheckSum2;

PolynomialsRationalCoeff PrecomputedPolys;
PrecomputedQuasiPolynomialIntegrals PrecomputedQuasiPolys;
int PolynomialOutputFormat::LatexMaxLineLength=100;
int PolynomialOutputFormat::LatexCutOffLine=15;
bool PolynomialOutputFormat::UsingLatexFormat=true;
bool PolynomialOutputFormat::CarriageReturnRegular=true;
PolynomialOutputFormat PolyFormatNumFrac;
int QuasiPolynomialOld::TotalCreatedPolys=0;
int ComplexQN::NumTotalCreated=0;

CyclotomicList CompositeComplex::PrecomputedCyclotomic;
ListPointers<BasicQN> BasicQN::GlobalCollectorsBasicQuasiNumbers;
int BasicQN::NumTotalCreated=0;
template < > bool Matrix<Rational>::flagComputingDebugInfo=true;
template < > bool Polynomial<Integer>::flagAnErrorHasOccuredTimeToPanic=true;
template < > bool Polynomial<Rational>::flagAnErrorHasOccuredTimeToPanic=true;
template < > int HashedList<Monomial<CompositeComplexQN> >::PreferredHashSize=1000;
template < > int HashedList<BasicQN>::PreferredHashSize= 1;
template < > int HashedList<partFraction>::PreferredHashSize=10000;
template < > int HashedList<intRoot>::PreferredHashSize = 10000;
template < > int HashedList<oneFracWithMultiplicitiesAndElongations>::PreferredHashSize= 10;
template < > int HashedList<ElementWeylGroup>::PreferredHashSize=10000;
template < > int HashedList<root>::PreferredHashSize=1000;
template < > int HashedList<Monomial<LargeInt> >::PreferredHashSize=1;
template < > int HashedList<Monomial<Rational> >::PreferredHashSize=10000;
template < > int HashedList<Monomial<Integer> >::PreferredHashSize=100;
template < > int HashedList<Monomial<QuasiNumber> >::PreferredHashSize=1000;
template < > int HashedList<MonomialInCommutativeAlgebra<Integer, GeneratorsPartialFractionAlgebra, GeneratorPFAlgebraRecord> >::PreferredHashSize=100;
template < > int HashedList<GeneratorPFAlgebraRecord>::PreferredHashSize = 1000;
template < > int HashedList<GeneratorsPartialFractionAlgebra>::PreferredHashSize=100;
template < > int HashedList<Selection>::PreferredHashSize=20;
template < > int HashedList<affineHyperplane>::PreferredHashSize=100;
template < > int HashedList<coneRelation>::PreferredHashSize=1000;
template < > int HashedList<slTwo>::PreferredHashSize=1000;
template < > int HashedList<ElementSimpleLieAlgebra>::PreferredHashSize=100;
template < > int HashedList<MonomialUniversalEnveloping>::PreferredHashSize=10000;
template < > int HashedList<MonomialUniversalEnvelopingOrdered<PolynomialRationalCoeff> >::PreferredHashSize=20;
template < > int HashedList<GeneralizedMonomialRational>::PreferredHashSize=20;
template < > int HashedList<MonomialUniversalEnvelopingOrdered<RationalFunction> >::PreferredHashSize=20;
template < > int HashedList<Monomial<RationalFunction> >::PreferredHashSize=20;
template < > int HashedList<roots>::PreferredHashSize=10000;
template < > int HashedList<Cone>::PreferredHashSize=10000;


template < > int List<Cone>::ListActualSizeIncrement=100;
template < > int List<affineCone>::ListActualSizeIncrement=1;
template < > int List<CombinatorialChamber*>::ListActualSizeIncrement=1000;
template < > int List<ComplexQN>::ListActualSizeIncrement=1;
template < > int List<int>::ListActualSizeIncrement=1;
template < > int List<char>::ListActualSizeIncrement=5;
template < > int List<Monomial<CompositeComplexQN> >::ListActualSizeIncrement=10;
template < > int List<BasicQN*>::ListActualSizeIncrement=1000;
template < > int List<ComplexQN*>::ListActualSizeIncrement=10000;
template < > int List<QuasiPolynomialOld*>::ListActualSizeIncrement=1;
template < > int List<PrecomputedTaukn*>::ListActualSizeIncrement=1;
template < > int List<BasicComplexNumber>::ListActualSizeIncrement=1;
template < > int List<MonomialInCommutativeAlgebra<Integer, GeneratorsPartialFractionAlgebra, GeneratorPFAlgebraRecord> >::ListActualSizeIncrement=100;
template < > int List<GeneratorsPartialFractionAlgebra>::ListActualSizeIncrement=1;
template < > int List<GeneratorPFAlgebraRecord>::ListActualSizeIncrement=1;
template < > int List<partFraction>::ListActualSizeIncrement=1000;
template < > int List<BasicQN>::ListActualSizeIncrement=1;
template < > int List<Monomial<QuasiNumber> >::ListActualSizeIncrement=1000;
template < > int List<intRoot>::ListActualSizeIncrement= 20;
template < > int List<oneFracWithMultiplicitiesAndElongations>::ListActualSizeIncrement=1;
template < > int List<ElementWeylGroup>::ListActualSizeIncrement= 101680;
template < > int List<PolynomialsRationalCoeff>::ListActualSizeIncrement=1;
template < > int List<root>::ListActualSizeIncrement=10;
template < > int List<QuasiPolynomialOld>::ListActualSizeIncrement=100;
template < > int List<PolynomialRationalCoeff>::ListActualSizeIncrement=1;
template < > int List<Monomial<LargeInt> >::ListActualSizeIncrement=1;
template < > int List<Polynomial<Rational> >::ListActualSizeIncrement=1;
template < > int List<Monomial<Integer> >::ListActualSizeIncrement=10;
template < > int List<Monomial<Rational> >::ListActualSizeIncrement=100;
template < > int List<rootWithMultiplicity>::ListActualSizeIncrement=1;
template < > int List<std::string>::ListActualSizeIncrement=100;
template < > int List<unsigned int>::ListActualSizeIncrement=1;
template < > int List<roots>::ListActualSizeIncrement=5;
template < > int List<Selection>::ListActualSizeIncrement=5;
template < > int List<affineHyperplane>::ListActualSizeIncrement=1000;
template < > int List<WallData*>::ListActualSizeIncrement=1;
template < > int List<WallData>::ListActualSizeIncrement=6;
template < > int List<rootsWithMultiplicity>::ListActualSizeIncrement=10;
template < > int List<Rational>::ListActualSizeIncrement=10;
template < > int List<coneRelation>::ListActualSizeIncrement=1000;
template < > int List<DynkinDiagramRootSubalgebra>::ListActualSizeIncrement=100;
template < > int List<rootSubalgebra>::ListActualSizeIncrement=77;
template < > int List<List<int> >::ListActualSizeIncrement=10;
template < > int List<List<char> >::ListActualSizeIncrement=30;
template < > int List<slTwo>::ListActualSizeIncrement=1000;
template < > int List<ElementSimpleLieAlgebra>::ListActualSizeIncrement=100;
template < > int List<ReflectionSubgroupWeylGroup>::ListActualSizeIncrement=5;
template < > int List<minimalRelationsProverState>::ListActualSizeIncrement=800;
template < > int List<minimalRelationsProverStateFixedK>::ListActualSizeIncrement=10;
//template < > int List<VermaModuleMonomial>::ListActualSizeIncrement=10;
template < > int List<MonomialUniversalEnveloping>::ListActualSizeIncrement=20;
template < > int List<ElementUniversalEnveloping>::ListActualSizeIncrement=20;
template < > int List<List<PolynomialRationalCoeff> >::ListActualSizeIncrement=20;
template < > int List<TemplatePolynomial<Monomial<Rational>, Rational> >::ListActualSizeIncrement=20;
template < > int List<TemplatePolynomial<Monomial<Integer>, Integer> >::ListActualSizeIncrement=20;
template < > int List<TemplatePolynomial<MonomialInCommutativeAlgebra<Integer, GeneratorsPartialFractionAlgebra, GeneratorPFAlgebraRecord>, Integer> >::ListActualSizeIncrement=20;
template < > int List<LargeIntUnsigned>::ListActualSizeIncrement=20;
template < > int List<double>::ListActualSizeIncrement=20;
template < > int List<MonomialUniversalEnvelopingOrdered<RationalFunction> >::ListActualSizeIncrement=20;
template < > int List<GeneralizedMonomialRational>::ListActualSizeIncrement=20;
template < > int List<ElementWeylAlgebra>::ListActualSizeIncrement=20;
template < > int List<ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff> >::ListActualSizeIncrement=20;
template < > int List<ElementVermaModuleOrdered<PolynomialRationalCoeff> >::ListActualSizeIncrement=20;
template < > int List<MonomialUniversalEnvelopingOrdered<PolynomialRationalCoeff> >::ListActualSizeIncrement=20;
template < > int List<ElementVermaModuleOrdered<RationalFunction> >::ListActualSizeIncrement=20;
template < > int List<RationalFunction>::ListActualSizeIncrement=20;
template < > int List<Vector<RationalFunction> >::ListActualSizeIncrement=20;
template < > int List<ElementUniversalEnvelopingOrdered<RationalFunction> >::ListActualSizeIncrement=20;
template < > int List<Vector<Rational> >::ListActualSizeIncrement=10;
template < > int List<Monomial<RationalFunction> >::ListActualSizeIncrement=20;
template < > int List<TemplatePolynomial<Monomial<RationalFunction>, RationalFunction> >::ListActualSizeIncrement=20;
template < > int List<MatrixLargeRational>::ListActualSizeIncrement=10;
template < > int List<QPSub>::ListActualSizeIncrement=1000;

template <class ElementLeft, class ElementRight, class CoefficientType>
class TensorProductMonomial;
template < > int List<TensorProductMonomial<ElementVermaModuleOrdered<PolynomialRationalCoeff>, ElementSimpleLieAlgebra, RationalFunction> >::ListActualSizeIncrement=20;

std::fstream partFraction::TheBigDump;
std::fstream partFractions::ComputedContributionsList;
template < > std::string Matrix<Rational>::MatrixElementSeparator= ", \t";
template < > std::string Matrix<LargeInt>::MatrixElementSeparator= ", \t";
template < > std::string Matrix<PolynomialRationalCoeff>::MatrixElementSeparator= ", \t";
template < > std::string Matrix<RationalFunction>::MatrixElementSeparator= ", \t";

//template < > int ListPointers<partFraction>::MemoryAllocationIncrement=100;
ListPointers<partFraction> partFraction::GlobalCollectorPartFraction;
bool partFraction::UseGlobalCollector=true;
bool partFraction::flagAnErrorHasOccurredTimeToPanic=false;
bool partFractions::flagSplitTestModeNoNumerators=false;
bool partFractions::flagAnErrorHasOccurredTimeToPanic=false;
bool partFractions::flagUsingCheckSum=true;
int partFractions::NumMonomialsInNumeratorsRelevantFractions=0;
int partFractions::NumProcessedForVPFMonomialsTotal=0;
int partFractions::flagMaxNumStringOutputLines=500;
//int partFraction::lastApplicationOfSVformulaNumNewGenerators=0;
//int partFraction::lastApplicationOfSVformulaNumNewMonomials=0;
bool QuasiPolynomialOld::flagAnErrorHasOccurredTimeToPanic=false;
bool Rational::flagAnErrorHasOccurredTimeToPanic=false;
bool Rational::flagMinorRoutinesOnDontUseFullPrecision=false;
bool partFractions::flagMakingProgressReport=true;
HashedList<GeneratorPFAlgebraRecord> GeneratorsPartialFractionAlgebra::theGenerators;
bool WeylGroup::flagAnErrorHasOcurredTimeToPanic=false;
bool WallData::flagDisplayWallDetails=true;
int RankGlobal;
//FacetPointers TheBigFacetOutput;
//DrawingVariables TDV(200, 400);
bool QuasiNumber::flagAnErrorHasOccurredTimeToPanic=false;
bool IntegerPoly::flagAnErrorHasOccurredTimeToPanic=false;
root oneFracWithMultiplicitiesAndElongations::CheckSumRoot;
bool MatrixLargeRational::flagAnErrorHasOccurredTimeToPanic=false;
int rootSubalgebras::ProblemCounter=0;

void CombinatorialChamberContainer::GlueOverSubdividedChambersCheckLowestIndex(GlobalVariables& theGlobalVariables)
{ for (; ; )
  { if (this->indexLowestNonCheckedForGlueing>=this->size)
      return;
    if (this->TheObjects[this->indexLowestNonCheckedForGlueing]==0)
      this->indexLowestNonCheckedForGlueing++;
    else
    { if (this->TheObjects[this->indexLowestNonCheckedForGlueing]->flagPermanentlyZero || this->TheObjects[this->indexLowestNonCheckedForGlueing]->flagHasZeroPolynomiaL)
        this->indexLowestNonCheckedForGlueing++;
      else
        break;
    }
  }
  List<int> IndicesToGlue; roots theNormalsToBeKilled;
  if (this->TheObjects[this->indexLowestNonCheckedForGlueing]->GetNonSeparableChamberIndicesOrReturnFalseIfUnionNotConvex(*this, IndicesToGlue, theNormalsToBeKilled, theGlobalVariables))
  { this->Glue(IndicesToGlue, theNormalsToBeKilled, theGlobalVariables);
    this->NumTotalGlued++;
  }
  this->MakeReportGlueing(theGlobalVariables, this->indexLowestNonCheckedForGlueing, this->NumTotalGlued);
  this->indexLowestNonCheckedForGlueing++;
  //this->ComputeDebugString();
  //this->ConsistencyCheck();
}

void CombinatorialChamberContainer::Glue(List<int>& IndicesToGlue, roots& normalsToBeKilled, GlobalVariables& theGlobalVariables)
{ //this->ConsistencyCheck(true);
//  this->WriteReportToFile("BadMoment.html", false);
//  this->ComputeDebugString();
  CombinatorialChamber* newChamber= new CombinatorialChamber;
#ifdef CGIversionLimitRAMuse
  ParallelComputing::GlobalPointerCounter++;
  ParallelComputing::CheckPointerCounters();
#endif
  int totalWalls=0;
  for (int i=0; i<IndicesToGlue.size; i++)
    totalWalls+= this->TheObjects[IndicesToGlue.TheObjects[i]]->Externalwalls.size;
  //this->ComputeDebugString();
  newChamber->Externalwalls.MakeActualSizeAtLeastExpandOnTop(totalWalls-normalsToBeKilled.size);
  newChamber->IndexInOwnerComplex= this->size;
  this->AddObjectOnTop(newChamber);
  for (int i=0; i<IndicesToGlue.size; i++)
  { this->TheObjects[IndicesToGlue.TheObjects[i]]->ComputeDebugString(*this);
    this->TheObjects[IndicesToGlue.TheObjects[i]]->ReplaceMeByAddExtraWallsToNewChamber(*this, newChamber, IndicesToGlue, normalsToBeKilled);
    newChamber->AllVertices.AddRootSnoRepetition(this->TheObjects[IndicesToGlue.TheObjects[i]]->AllVertices);
  }
  //newChamber->ComputeDebugString(*this);
//  newChamber->AllVertices.ComputeDebugString();
  for (int i=0; i<newChamber->AllVertices.size; i++)
    if (!newChamber->PointIsAVertex(newChamber->AllVertices.TheObjects[i], theGlobalVariables))
    { newChamber->AllVertices.PopIndexSwapWithLast(i);
      i--;
    }
  newChamber->AllVertices.average(newChamber->InternalPoint, this->AmbientDimension);
  newChamber->flagExplored=true;
  newChamber->flagHasZeroPolynomiaL= this->TheObjects[IndicesToGlue.TheObjects[0]]->flagHasZeroPolynomiaL;
  newChamber->IndexStartingCrossSectionNormal= this->TheObjects[IndicesToGlue.TheObjects[0]]->IndexStartingCrossSectionNormal;
  for (int i=0; i<IndicesToGlue.size; i++)
  { delete this->TheObjects[IndicesToGlue.TheObjects[i]];
    this->TheObjects[IndicesToGlue.TheObjects[i]]=0;
#ifdef CGIversionLimitRAMuse
  ParallelComputing::GlobalPointerCounter--;
  ParallelComputing::CheckPointerCounters();
#endif
  }
  newChamber->ConsistencyCheck(this->AmbientDimension, true, *this, theGlobalVariables);

//  this->ComputeDebugString();
  //this->ComputeDebugString();
  //newChamber->ComputeDebugString(*this);
  //this->WriteReportToFile("BadMoment2.html", false);
/*  if (!this->flagSpanTheEntireSpace && this->flagStoringVertices && this->flagUsingVerticesToDetermineBogusNeighborsIfPossible)
    newChamber->CheckForAndRemoveBogusNeighbors(*this, theGlobalVariables);*/
  //this->WriteReportToFile("BadMoment2.html", false);
  //this->ConsistencyCheck(true);
}

void CombinatorialChamberContainer::PurgeZeroPointers()
{ int ActualIndex=0;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[ActualIndex]= this->TheObjects[i];
    if(this->TheObjects[i]!=0)
    { this->TheObjects[ActualIndex]->IndexInOwnerComplex=ActualIndex;
      ActualIndex++;
    }
  }
  this->size= ActualIndex;
}

void CombinatorialChamberContainer::SliceOneDirection(root* theIndicatorRoot, GlobalVariables& theGlobalVariables)
{ if (this->theCurrentIndex<this->theDirections.size)
  { int oldindex= this->theCurrentIndex;
    this->PreferredNextChambers.MakeActualSizeAtLeastExpandOnTop(this->size*this->AmbientDimension+100);
    while(oldindex==this->theCurrentIndex)
    { if (this->flagMustStop)
        return;
      this->OneSlice(theIndicatorRoot, theGlobalVariables);
    }
  }
}

void CombinatorialChamberContainer::SliceTheEuclideanSpace(root* theIndicatorRoot, GlobalVariables& theGlobalVariables, bool SpanTheEntireSpace)
{ if (this->theDirections.size==0)
    return;
  if (this->theDirections.TheObjects[0].size==1)
    return;
  if (this->theCurrentIndex==-1)
    this->flagSpanTheEntireSpace=SpanTheEntireSpace;
  this->flagSpanTheEntireSpace=SpanTheEntireSpace;
  while(this->theCurrentIndex<this->theDirections.size)
  { if (this->flagMustStop)
      return;
    this->SliceOneDirection(theIndicatorRoot, theGlobalVariables);
  }
  this->ComputeNonConvexActualChambers(theGlobalVariables);
  this->LabelChambersForDisplayAndGetNumVisibleChambers();
  this->ComputeDebugString(false);
  this->ConsistencyCheck(true, theGlobalVariables);
  if (this->flagMakeGrandMasterConsistencyCheck)
    this->GrandMasterConsistencyCheck(theGlobalVariables);
}

void CombinatorialChamberContainer::ComputeNonConvexActualChambers(GlobalVariables& theGlobalVariables)
{ this->NonConvexActualChambers.MakeActualSizeAtLeastExpandOnTop(this->size);
  this->NonConvexActualChambers.size=0;
  this->IndicesInActualNonConvexChamber.initFillInObject(this->size, -1);
  int oldLowestIndexNonCheckedForGlueing=this->indexLowestNonCheckedForGlueing;
  this->indexLowestNonCheckedForGlueing=-1;
  this->LabelChamberIndicesProperly();
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0 && this->IndicesInActualNonConvexChamber.TheObjects[i]==-1)
      if (!this->TheObjects[i]->flagHasZeroPolynomiaL)
      { this->IndicesInActualNonConvexChamber.TheObjects[i]=this->NonConvexActualChambers.size;
        this->NonConvexActualChambers.AddObjectOnTopCreateNew();
        this->NonConvexActualChambers.LastObject()->size=0;
        this->NonConvexActualChambers.LastObject()->AddObjectOnTop(i);
        this->TheObjects[i]->GetNonSeparableChamberIndicesAppendList(*this, *this->NonConvexActualChambers.LastObject(), theGlobalVariables);
        for (int j=0; j<this->NonConvexActualChambers.LastObject()->size; j++)
          this->IndicesInActualNonConvexChamber.TheObjects[this->NonConvexActualChambers.LastObject()->TheObjects[j]]=this->NonConvexActualChambers.size-1;
      }
    this->indexLowestNonCheckedForGlueing=oldLowestIndexNonCheckedForGlueing;
}

int DrawingVariables::GetColorFromChamberIndex(int index, std::fstream* LaTexOutput)
{ int tempI=index%this->NumColors;
  if (tempI<0) tempI+=this->NumColors;
  if (LaTexOutput==0)
    return this->Colors[tempI];
  return tempI;
}

void DrawingVariables::initDrawingVariables(int cX1, int cY1)
{ this->theDrawLineFunction=0;
  this->theDrawTextFunction=0;
  this->fontSizeNormal=10;
  this->fontSizeSubscript=6;
  this->flagLaTeXDraw= false;
  this->flagDisplayingCreationNumbersInsteadOfDisplayNumbers=false;
  this->flagDrawChamberIndices=true;
  this->flagDrawingInvisibles=false;
  this->flagDrawingLinkToOrigin=true;
  this->ColorDashes=CGIspecificRoutines::RedGreenBlue(200, 200, 200);
  this->flag2DprojectionDraw=true;
  this->ColorChamberIndicator=CGIspecificRoutines::RedGreenBlue(220, 220, 0);
  this->ColorWeylChamberWalls=CGIspecificRoutines::RedGreenBlue(220, 220, 0);
  this->ColorTextPermanentlyZeroChamber = CGIspecificRoutines::RedGreenBlue(250, 220, 220);
  this->ColorTextZeroChamber = CGIspecificRoutines::RedGreenBlue(200, 100, 100);
  this->ColorTextDefault= CGIspecificRoutines::RedGreenBlue(0, 0, 0);
  this->Selected=-2;
  this->textX=0;
  this->textY=15;
  this->centerX= (double) cX1; //(double(X2)-double(X1));
  this->centerY= (double) cY1;
  this->scale=1;
//  Projections[0][0]=(0+50)*tempI;
//  Projections[0][1]=(0-50)*tempI;
//  Projections[1][0]=(50+50)*tempI;
//  Projections[1][1]=(87-50)*tempI;
//  Projections[2][0]=(100+50)*tempI;
//  Projections[2][1]=(0-50)*tempI;
  this->Projections.init(100, 2);
  this->Projections.elements[0][0]=100;
  this->Projections.elements[0][1]=0;
  this->Projections.elements[1][0]=-50;
  this->Projections.elements[1][1]=86.66;
//  this->Projections[0][0]=200;
//  this->Projections[0][1]=-200;
//  this->Projections[1][0]=200;
//  this->Projections[1][1]=200;
  this->Projections.elements[2][0]=0;
  this->Projections.elements[2][1]=100;
  this->Projections.elements[3][0]=92;
  this->Projections.elements[3][1]=-29;
  this->Projections.elements[4][0]=88;
  this->Projections.elements[4][1]=-49;
  this->Projections.elements[5][0]=50;
  this->Projections.elements[5][1]=-88;
  this->Projections.elements[6][0]=28;
  this->Projections.elements[6][1]=-92;
  this->ApplyScale(1);
  int i=0;
  this->ColorsR[i]=0;
  this->ColorsG[i]=0;
  this->ColorsB[i]=0;
  i++;
////////////////////
  this->ColorsR[i]=50;
  this->ColorsG[i]=50;
  this->ColorsB[i]=200;
  i++;
////////////////////
  this->ColorsR[i]=200;
  this->ColorsG[i]=50;
  this->ColorsB[i]=200;
  i++;
////////////////////
  this->ColorsR[i]=50;
  this->ColorsG[i]=200;
  this->ColorsB[i]=50;
  i++;
////////////////////
  this->ColorsR[i]=50;
  this->ColorsG[i]=200;
  this->ColorsB[i]=200;
  i++;
////////////////////
  this->ColorsR[i]=200;
  this->ColorsG[i]=50;
  this->ColorsB[i]=50;
  i++;
////////////////////
  this->ColorsR[i]=200;
  this->ColorsG[i]=0;
  this->ColorsB[i]=200;
  i++;
////////////////////
  this->ColorsR[i]=0;
  this->ColorsG[i]=200;
  this->ColorsB[i]=200;
  i++;
  for (int i=0; i<DrawingVariables::NumColors; i++)
    this->Colors[i]=CGIspecificRoutines::RedGreenBlue(this->ColorsR[i], this->ColorsG[i], this->ColorsB[i]);
////////////////////
}

void DrawingVariables::SetCoordsForA2()
{ this->scale=1;
  this->Projections.elements[0][0]=100;
  this->Projections.elements[0][1]=0;
  this->Projections.elements[1][0]=-50;
  this->Projections.elements[1][1]=86.66;
}

void DrawingVariables::SetCoordsOrthogonal()
{ this->scale=1;
  this->Projections.elements[0][0]=100;
  this->Projections.elements[0][1]=0;
  this->Projections.elements[1][0]=0;
  this->Projections.elements[1][1]=100;
}

void DrawingVariables::SetCoordsForB2()
{ this->scale=1;
  this->Projections.elements[0][0]=120;
  this->Projections.elements[0][1]=0;
  this->Projections.elements[1][0]=-60;
  this->Projections.elements[1][1]=60;
}

void DrawingVariables::SetCoordsForC2()
{ this->scale=1;
  this->Projections.elements[0][0]=100;
  this->Projections.elements[0][1]=0;
  this->Projections.elements[1][0]=-100;
  this->Projections.elements[1][1]=100;
}

void DrawingVariables::SetCoordsForG2()
{ this->scale=1;
  this->Projections.elements[0][0]=120;
  this->Projections.elements[0][1]=0;
  this->Projections.elements[1][0]=-60;
  this->Projections.elements[1][1]=34.64;
}

void DrawingVariables::ApplyScale(double inputScale)
{ if (inputScale==0)
    return;
  double ScaleChange= inputScale/this->scale;
  this->scale= inputScale;
  for (int i =0; i<7; i++)
  { this->Projections.elements[i][0]*=ScaleChange;
    this->Projections.elements[i][1]*=ScaleChange;
  }
}

void ComputationSetup::WriteReportToFile(DrawingVariables& TDV, std::fstream& theFile, GlobalVariables& theGlobalVariables)
{ theFile.clear();
  PolynomialOutputFormat PolyFormatLocal;
  LaTeXProcedures::beginDocument(theFile);
  if (this->thePartialFraction.size>0)
    this->WriteToFilePFdecomposition(theFile, false);
  std::string tempS;
  this->VPVectors.ElementToString(tempS);
  theFile << "\\title{" << this->WeylGroupLetter << (int)(this->WeylGroupIndex) << "}" << "\\maketitle ";
  this->thePartialFraction.theChambers.WriteReportToFile(TDV, this->VPVectors, theFile);
  this->thePartialFraction.ElementToString(tempS, theGlobalVariables);
  theFile << "\n\n";
  theFile << tempS;
  theFile << "\n\n";
  tempS.clear();
  this->theOutput.StringPrintOutAppend(tempS, PolyFormatLocal, true);
  theFile << "\\begin{eqnarray*}&&" << tempS << "\\end{eqnarray*}";
  LaTeXProcedures::endLatexDocument(theFile);
}

void ComputationSetup::SetupCustomNilradicalInVPVectors(GlobalVariables& theGlobalVariables)
{ this->VPVectors.size=0;
  this->WeylGroupIndex= (this->NumColsNilradical+this->NumRowsNilradical-1);
  this->WeylGroupLetter='A';
  for (int i=0; i<this->NumRowsNilradical; i++)
    for(int j=0; j<this->NumColsNilradical; j++)
    { root tempRoot; tempRoot.MakeZero(this->WeylGroupIndex);
      for (int k=i; k<this->NumRowsNilradical+j; k++)
        tempRoot.TheObjects[k].MakeOne();
      this->VPVectors.AddRoot(tempRoot);
    }
  this->VPVectors.ComputeDebugString();
}

std::stringstream  CGIspecificRoutines::outputStream;
int CGIspecificRoutines::numLinesAll;
int CGIspecificRoutines::shiftX=0;
int CGIspecificRoutines::numDashedLines=0;
int CGIspecificRoutines::numRegularLines=0;
int CGIspecificRoutines::numDottedLines=0;
int CGIspecificRoutines::shiftY=-200;
int CGIspecificRoutines::scale=100;

void CGIspecificRoutines::clearDollarSigns(std::string& theString, std::string& output)
{ std::stringstream out;
  for(unsigned int i=0; i<theString.size(); i++)
    if(theString[i]!='$')
      out << theString[i];
  output=out.str();
}

void CGIspecificRoutines::subEqualitiesWithSimeq(std::string& theString, std::string& output)
{ std::stringstream out;
  for(unsigned int i=0; i<theString.size(); i++)
    if(theString[i]!='=')
      out << theString[i];
    else
      out << "\\simeq ";
  output=out.str();
}

void CGIspecificRoutines::drawlineInOutputStreamBetweenTwoRoots(root& r1, root& r2, unsigned long thePenStyle, int r, int g, int b)
{ if (thePenStyle!=DrawingVariables::PenStyleInvisible)
  { //do not add extra spaces in the following string! we use the fact that the string is one piece later in the code with the stringstream::operator>>
    CGIspecificRoutines::outputStream << thePenStyle << " [" << r << "," << g << "," << b << "] ";
    for (int i=0; i<r1.size; i++)
      CGIspecificRoutines::outputStream << (int)(CGIspecificRoutines::scale* r1.TheObjects[i].DoubleValue()) << " " << (int)(CGIspecificRoutines::scale* r2.TheObjects[i].DoubleValue()) << " ";
    CGIspecificRoutines::numLinesAll++;
    switch(thePenStyle)
    { case DrawingVariables::PenStyleNormal: CGIspecificRoutines::numRegularLines++; break;
      case DrawingVariables::PenStyleLinkToOrigin:
      case DrawingVariables::PenStyleDashed: CGIspecificRoutines::numDashedLines++; break;
      case DrawingVariables::PenStyleZeroChamber:
      case DrawingVariables::PenStyleLinkToOriginZeroChamber:
      case DrawingVariables::PenStyleDotted: CGIspecificRoutines::numDottedLines++; break;
      default: CGIspecificRoutines::numDottedLines++; break;
    }
  }
}

void CGIspecificRoutines::PrepareOutputLineJavaScriptSpecific(const std::string& lineTypeName, int numberLines)
{ std::cout << "\n\tvar num" << lineTypeName << "Lines=" << numberLines << "; ";
  std::cout << "\n\tvar " << lineTypeName << "1= new Array(" << numberLines << "); " << "  \tvar " << lineTypeName << "2= new Array(" << numberLines << "); " << "  \tvar clr"  << lineTypeName << "= new Array("  << numberLines << "); ";
}

void CGIspecificRoutines::outputLineJavaScriptSpecific(const std::string& lineTypeName, int theDimension, std::string& stringColor, int& lineCounter)
{ std::string tempS;
  std::cout  << "\n\t" << lineTypeName << "1["  << lineCounter << "]= new Array(" << theDimension << "); " << "\t" << lineTypeName << "2[" << lineCounter << "]= new Array(" << theDimension << "); " << "\tclr" << lineTypeName << "[" << lineCounter << "]= new Array(" << 3 << "); \n";
  for (int j=0; j< theDimension; j++)
  { CGIspecificRoutines::outputStream >> tempS;
    std::cout << "\t" << lineTypeName << "1[" << lineCounter << "][" << j << "]=" << tempS << "; ";
    CGIspecificRoutines::outputStream >> tempS;
    std::cout << "\t" << lineTypeName << "2[" << lineCounter << "][" << j << "]=" << tempS << "; ";
  }
  std::cout << "\tclr" << lineTypeName << "[" << lineCounter << "]=" << stringColor << "; ";
  lineCounter++;
}

void CGIspecificRoutines::MakeVPReportFromComputationSetup(ComputationSetup& input)
{  std::string tempS;
  //input.thePartialFraction.IndicatorRoot.ComputeDebugString();
  input.thePartialFraction.theChambers.RootBelongsToChamberIndex(input.IndicatorRoot, &tempS);
  std::cout << "\n<br>\nVector partition function in LaTeX format\n<br>\n" << "of chamber <a href=\"/tmp/chambers.html#" << tempS << "\">" << tempS << "</a>; " << "&nbsp; &nbsp; &nbsp; <a href=\"/tmp/vector_partition.pdf\">pdf</a>\n<br>\n" << "<textarea name=\"vp_output\" cols=\"50\" rows=\"30\">" << input.theOutput.DebugString << "</textarea>";
}

void CGIspecificRoutines::MakePFAndChamberReportFromComputationSetup(ComputationSetup& input)
{ CGIspecificRoutines::numLinesAll=0;
  CGIspecificRoutines::numRegularLines=0;
  CGIspecificRoutines::numDottedLines=0;
  GlobalVariables& theGlobalVariables=*input.theGlobalVariablesContainer->Default();
  theGlobalVariables.theDrawingVariables.flag2DprojectionDraw=false;
  input.thePartialFraction.theChambers.drawOutput(theGlobalVariables.theDrawingVariables, input.thePartialFraction.theChambers.IndicatorRoot, 0);
  std::string tempS;
  std::string stringColor;
  CGIspecificRoutines::outputStream.seekg(0);
  std::cout << "\n<script>";
  std::cout << "\n\tvar numDrawLines=" << CGIspecificRoutines::numLinesAll << "; ";
  CGIspecificRoutines::PrepareOutputLineJavaScriptSpecific("l", CGIspecificRoutines::numRegularLines);
  CGIspecificRoutines::PrepareOutputLineJavaScriptSpecific("da", CGIspecificRoutines::numDashedLines);
  CGIspecificRoutines::PrepareOutputLineJavaScriptSpecific("do", CGIspecificRoutines::numDottedLines);
  int theDimension=input.thePartialFraction.theChambers.AmbientDimension;
  int numLlines=0;  int numDalines=0;  int numDolines=0;
  std::string debuggerBugger=outputStream.str();
  int thePenStyle;
  for (int i=0; i<CGIspecificRoutines::numLinesAll; i++)
  { CGIspecificRoutines::outputStream >> thePenStyle >> stringColor;
    switch(thePenStyle)
    { case DrawingVariables::PenStyleNormal: CGIspecificRoutines::outputLineJavaScriptSpecific("l", theDimension, stringColor, numLlines); break;
      case DrawingVariables::PenStyleLinkToOrigin:
      case DrawingVariables::PenStyleDashed: CGIspecificRoutines::outputLineJavaScriptSpecific("da", theDimension, stringColor, numDalines); break;
      case DrawingVariables::PenStyleLinkToOriginZeroChamber:
      case DrawingVariables::PenStyleDotted: CGIspecificRoutines::outputLineJavaScriptSpecific("do", theDimension, stringColor, numDolines); break;
      default: CGIspecificRoutines::outputLineJavaScriptSpecific("do", theDimension, stringColor, numDolines); break;
    }
  }
  std::cout << "</script>";
#ifdef CGIversionLimitRAMuse
  std::cout << "<br>Total number of pointers allocated: " << ::ParallelComputing::GlobalPointerCounter << "<br>\n";
#endif
  std::cout << "Number of partial fractions: " << input.thePartialFraction.size << "<br>\n";
  std::cout << "Number of monomials in the numerators: " << input.thePartialFraction.NumMonomialsInTheNumerators << "<br>\n" << "Partial fraction decomposition &nbsp; &nbsp; &nbsp; " << "<a href=\"/tmp/partial_fraction.pdf\">pdf</a>\n<br>\n<textarea name=\"pf_output\" cols=\"50\" rows=\"30\">" << input.thePartialFraction.DebugString << "</textarea>";
}

void CGIspecificRoutines::ElementToStringTooltip(const std::string& input, const std::string& inputTooltip, std::string& output, bool useHtml)
{ std::stringstream out;
  if (useHtml)
    out << "<span title=\"" << inputTooltip << "\">" << input << "</span>";
  output=out.str();
}

void CGIspecificRoutines::CivilizedStringTranslationFromVPold(std::string& input, std::string& output)
{ output.clear();
  int oldindex=0;
  int tempSize=(signed) input.size();
  //std::cout << "   "<<tempSize <<" asdfdafadsfadsf";
  //  return;
  if (tempSize>1000)
    return;
  for (int i=0; i<tempSize; i++)
    if (input[i]=='=')
    { for (int j=oldindex; j<i; j++)
      { if (input[j]=='&')
          output.append(" ");
        else
          output.push_back(input.at(j));
      }
      oldindex=i+1;
      output.append(" = ");
    }
  for (int j=oldindex; j<tempSize; j++)
    output.push_back(input.at(j));
}

void CGIspecificRoutines::FormatCPPSourceCode(const std::string& FileName)
{ std::fstream fileIn, fileOut;
  CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(fileIn, FileName, false, false, false);
  assert(fileIn.is_open());
  fileIn.clear(std::ios::goodbit);
  fileIn.seekg(0, std::ios_base::end);
  int theSize= fileIn.tellg();
  fileIn.seekg(0);
  char* buffer= new char[theSize*2+1];
  fileIn.read(buffer, theSize*2);
  std::string nameFileOut= FileName;
  nameFileOut.append(".new");
  ::CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(fileOut, nameFileOut, false, true, false);
  for (int i=0; i<theSize; i++)
  { char lookAhead= (i< theSize-1)? buffer[i+1] : ' ';
    switch(buffer[i])
    { case'\t':  fileOut << "  "; break;
      case ',':
        fileOut << buffer[i];
        if (lookAhead!=' ' && lookAhead!='\n' && lookAhead!='\'')
          fileOut << " ";
        break;
      case ';':
        fileOut << buffer[i];
        if (lookAhead!=' ' && lookAhead!='\n' && lookAhead!='\'')
          fileOut << " ";
        break;
      default:  fileOut << buffer[i]; break;
    }
  }
  delete [] buffer;
}

bool CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(std::fstream& theFile, const std::string& theFileName, bool OpenInAppendMode, bool truncate, bool openAsBinary)
{ if (OpenInAppendMode)
  { if (openAsBinary)
      theFile.open(theFileName.c_str(), std::fstream::in|std::fstream::out|std::fstream::app| std::fstream::binary);
    else
      theFile.open(theFileName.c_str(), std::fstream::in|std::fstream::out|std::fstream::app);
  } else
  { if (openAsBinary)
      theFile.open(theFileName.c_str(), std::fstream::in|std::fstream::out| std::fstream::binary);
    else
    { if (truncate)
        theFile.open(theFileName.c_str(), std::fstream::in|std::fstream::out| std::fstream::trunc);
      else
        theFile.open(theFileName.c_str(), std::fstream::in|std::fstream::out);
    }
  }
  if(theFile.is_open())
  { theFile.clear(std::ios::goodbit); // false);
    theFile.seekp(0, std::ios_base::end);
    //theFile.seekg(0);
    int tempI=theFile.tellp();
    if (tempI>=1)
      return true;
  }
  theFile.close();
  theFile.open(theFileName.c_str(), std::fstream::out | std::fstream::in | std::fstream::trunc);
  theFile.clear();
  return false;
}

bool CGIspecificRoutines::FileExists(const std::string& theFileName)
{ std::fstream theFile;
  theFile.open(theFileName.c_str(), std::fstream::in);
  if(theFile.is_open())
    return true;
  else
    return false;
}

void CGIspecificRoutines::WeylGroupToHtml(WeylGroup& input, std::string& path)
{ std::fstream output;
  std::string tempS;
  CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(output, path, false, true, false);
  output << "<HTML><BODY>In preparation</BODY></HTML>";
  output.close();
}

bool CGIspecificRoutines::CheckForInputSanity(ComputationSetup& input)
{ if (input.VPVectors.size>15 || input.VPVectors.size<1)
    return false;
  if (input.thePartialFraction.theChambers.AmbientDimension>10 || input.thePartialFraction.theChambers.AmbientDimension<1)
    return false;
  if (!input.VPVectors.CheckForElementSanity())
    return false;
  for (int i=0; i<input.VPVectors.size; i++)
    if (input.VPVectors.TheObjects[i].IsEqualToZero())
      return false;
  return true;
}

//outputs: one of the tokens in CGIspecificRoutines::TheChoicesWeMake
int CGIspecificRoutines::ReadDataFromCGIinput(std::string& inputBad, ComputationSetup& output, std::string& thePath)
{ if (inputBad.length()<2)
    return CGIspecificRoutines::choiceInitAndDisplayMainPage;
  if (inputBad=="experiments")
  {
#ifdef CGIversionLimitRAMuse
    ParallelComputing::cgiLimitRAMuseNumPointersInList=1000000000;
#endif
    return CGIspecificRoutines::choiceExperiments;
  }
  std::string inputGood;
  std::string tempS3;
  tempS3=inputBad;
  if (tempS3.size()>7)
    tempS3.resize(7);
  bool InputDataOK=false;
  if (tempS3=="textDim")
    InputDataOK=true;
  //std::cout.flush();
  //std::cout<< inputBad<<"\n<br>\n";
  //std::cout.flush();
  //std::cout <<"  tempS3: "<< tempS3<<"   ";
#ifdef CGIversionLimitRAMuse
  ParallelComputing::cgiLimitRAMuseNumPointersInList=2000000;
#endif
  CGIspecificRoutines::CivilizedStringTranslationFromVPold(inputBad, inputGood);
//  std::cout<<inputGood;
  if (tempS3=="rootSAs")
    return CGIspecificRoutines::choiceDisplayRootSApage;
  if (tempS3=="textTyp")
  { std::stringstream tempStream1;
    tempStream1 << inputGood;
    std::string tempS; tempStream1.seekg(0);
    tempStream1 >> tempS >> tempS >> output.WeylGroupLetter;
    tempStream1 >> tempS >> tempS >> output.WeylGroupIndex;
    if (output.WeylGroupLetter=='a') output.WeylGroupLetter='A';
    if (output.WeylGroupLetter=='b') output.WeylGroupLetter='B';
    if (output.WeylGroupLetter=='c') output.WeylGroupLetter='C';
    if (output.WeylGroupLetter=='d') output.WeylGroupLetter='D';
    if (output.WeylGroupLetter=='e') output.WeylGroupLetter='E';
    if (output.WeylGroupLetter=='f') output.WeylGroupLetter='F';
    if (output.WeylGroupLetter=='g') output.WeylGroupLetter='G';
    if (output.WeylGroupLetter=='A' || output.WeylGroupLetter=='B' || output.WeylGroupLetter=='C' || output.WeylGroupLetter=='D' || output.WeylGroupLetter=='E' || output.WeylGroupLetter=='F' || output.WeylGroupLetter=='G')
      InputDataOK=true;
    if (output.WeylGroupIndex<1 || output.WeylGroupIndex>8)
      InputDataOK=false;
    WeylGroup::TransformToAdmissibleDynkinType(output.WeylGroupLetter, output.WeylGroupIndex);
    if (!InputDataOK)
    { std::cout << "<br><b>Bad input:</b> " << inputBad << "<br>\n";
      return CGIspecificRoutines::choiceInitAndDisplayMainPage;
    }
    tempStream1>> tempS;
    int theChoiceIsYours=CGIspecificRoutines::choiceInitAndDisplayMainPage;
    if (tempS=="buttonGoRootSA")
      theChoiceIsYours=CGIspecificRoutines::choiceGenerateDynkinTables;
    if (tempS=="buttonGoSl2SAs")
      theChoiceIsYours=CGIspecificRoutines::choiceGosl2;
    tempStream1 >> tempS >> tempS;
    output.flagExecuteSystemCommandsCGIapplication=false;
    output.flagCGIRecomputeAll = true;
    for (int i=0; i<2; i++)
    { tempStream1 >> tempS;
      if (tempS=="checkUsePNG")
        output.flagExecuteSystemCommandsCGIapplication=true;
      if (tempS=="checkUseDatabase")
        output.flagCGIRecomputeAll=false;
      tempStream1 >> tempS >> tempS;
    }
//    std::cout << "<br>Usepng: " << output.flagExecuteSystemCommandsCGIapplication;
//    std::cout << "<br>Recompute: " << output.flagCGIRecomputeAll;
    //std::cout<<inputGood<<"<br>";
    //std::cout<<"<br><br>"<< "The choices we make: " << theChoiceIsYours;
    std::cout.flush();
#ifdef CGIversionLimitRAMuse
    ParallelComputing::cgiLimitRAMuseNumPointersInList=300000000;
#endif
    return theChoiceIsYours;
  }
  if (!InputDataOK==true)
  { std::cout << "<br><b>Bad input:</b> " << inputBad << "<br>\n";
    return CGIspecificRoutines::choiceInitAndDisplayMainPage;
  }
//  std::cout<< input<<"\n";
  std::stringstream tempStream;
  //std::cout<<"\n<br>\n input good: <br>\n"<<inputGood<<"\n<br>\n";
  tempStream << inputGood;
  std::string tempS; int tempI;  tempStream.seekg(0);
  tempStream >> tempS >> tempS >> output.thePartialFraction.theChambers.AmbientDimension;
  tempStream >> tempS >> tempS >> tempI;
  output.VPVectors.SetSize(tempI);
  //std::cout<<"Dim: "<<output.theChambers.AmbientDimension<<"Num: "<<tempI;
  for (int i=0; i<output.VPVectors.size; i++)
  { output.VPVectors.TheObjects[i].SetSize(output.thePartialFraction.theChambers.AmbientDimension);
    for(int j=0; j<(signed int)output.thePartialFraction.theChambers.AmbientDimension; j++)
    { tempStream >> tempS >> tempS >> tempI;
      output.VPVectors.TheObjects[i].TheObjects[j].AssignInteger(tempI);
    }
  }
  if (!CGIspecificRoutines::CheckForInputSanity(output))
  { std::cout << "<br><b>Bad input:</b> " << inputBad << "<br>\n";
    return CGIspecificRoutines::choiceInitAndDisplayMainPage;
  }
  tempStream >> tempS;
   output.flagComputingVectorPartitions=true;
  output.DisplayNumberChamberOfInterest=-1;
  if (tempS=="buttonGo" || tempS=="buttonSplitChambers")
    if (tempS=="buttonSplitChambers")
      output.flagComputingVectorPartitions=false;
  if (tempS=="buttonOneChamber")
  { tempStream >> tempS >> tempS >> tempS >> tempS >> output.DisplayNumberChamberOfInterest;
   // std::cout<< "Chamber of interest: "<< output.DisplayNumberChamberOfInterest;
  }
  int theDimension=output.thePartialFraction.theChambers.AmbientDimension;
  if (output.flagComputingVectorPartitions && output.DisplayNumberChamberOfInterest==-1)
  { output.VPVectors.average(output.IndicatorRoot, theDimension);
    output.IndicatorRoot.MultiplyByInteger(output.VPVectors.size);
  }
  //output.VPVectors.ComputeDebugString();
  //std::cout<<output.VPVectors.size<<output.theChambers.AmbientDimension<< output.VPVectors.DebugString;
  output.flagComputationInitialized=false;
  output.WeylGroupIndex=output.thePartialFraction.theChambers.AmbientDimension;
  output.flagComputingPartialFractions=true;
  output.thePartialFraction.flagUsingOrlikSolomonBasis=false;
  output.flagUsingCustomVectors=true;
  output.flagDoingWeylGroupAction=false;
  output.thePartialFraction.flagUsingCheckSum=true;
  output.thePartialFraction.flagMaxNumStringOutputLines=200000;
  output.flagPartialFractionSplitPrecomputed=false;
  output.flagComputationInitialized=false;
  output.flagUseHtml=true;
//  std::cout<<"\n<br><br>"<<output.VPVectors.DebugString;
//  std::cout<<"\n<br><br>"<<output.VPVectors.TheObjects[1].DebugString;
//  std::cout<<"\n<br><br>"<<output.VPVectors.TheObjects[2].DebugString;
//  std::cout<<"\n<br><br>"<<output.VPVectors.TheObjects[3].DebugString;
  return CGIspecificRoutines::choiceDefaultNeedComputation;
}

ComputationSetup::ComputationSetup()
{ this->theFunctionToRun=0;
  this->flagExecuteSystemCommandsCGIapplication=false;
  this->flagDyckPathComputationLoaded=false;
  this->flagOpenProverData=false;
  this->flagSavingProverData=false;
  this->flagProverUseFixedK=false;
  this->flagProverDoingFullRecursion=false;
  this->flagUsingProverDoNotCallOthers=false;
  this->flagAllowRepaint=true;
  this->flagHavingNotationExplanation=true;
  this->flagUseHtml=false;
  this->flagUsingCustomVectors=false;
  this->DisplayNumberChamberOfInterest=-1;
//  this->flagComputingPartialFractions=true;
  this->flagComputingPartialFractions=false;
  this->flagComputingVectorPartitions=true;
  this->flagComputingChambers=true;
  this->flagPartialFractionSplitPrecomputed=false;
  this->flagComputationInProgress=false;
  this->flagComputationDone=true;
  this->flagComputationInitialized=false;
  this->flagChopOneDirection=false;
  this->flagChopFully=true;
  this->flagHavingBeginEqnForLaTeXinStrings=true;
  this->flagSliceTheEuclideanSpaceInitialized=false;
  this->flagDisplayingPartialFractions=true;
  this->flagDisplayingCombinatorialChambersTextData=false;
  this->flagHavingDocumentClassForLaTeX=true;
  this->flagHavingStartingExpression=true;
  this->flagComputationIsDoneStepwise=true;
  this->flagUsingIndicatorRoot=false;
  //this->flagAffineComputationDone=false;
  this->flagSuperimposingComplexes=true;
  this->flagCustomNilradicalInitted=false;
  this->flagDoCustomNilradical=false;
  this->flagOneSteChamberSliceInitialized=false;
  this->flagDoingWeylGroupAction=false;
  this->WeylGroupLetter='A';
  this->WeylGroupIndex=3;
  this->NumRowsNilradical=2;
  this->NumColsNilradical=2;
  this->theGlobalVariablesContainer= new GlobalVariablesContainer;
  std::stringstream out1, out2, out3, out4;
  out1 << "Denote by $P_I(x_1, \\dots, x_n)$ the number of ways to split the vector with coordinates $(x_1, \\dots, x_n)$ into non-negative integral sum of the integral vectors $I$, where $I$ is the set given by the following list.\n\n";
  out2 << " \n\n For given integers $N$, $m$ and integral matrices $A:=\\left(\\begin{array}{ccc}a_{11}&\\dots&a_{1n}\\\\ &\\dots& \\\\ a_{m1}&\\dots& a_{mn}\\end{array}\\right)$, "
          << " $B:=\\left( \\begin{array}{c} b_1\\\\\\vdots\\\\b_m\\end{array}\\right)$, let \n\\[{\\tau_{N}}_{[(a_{11}x_1+\\dots a_{1n}x_n=b_1), \\dots, (a_{m1}x_1+\\dots a_{mn}x_n=b_m) ]} "
          << " (x_1, \\dots, x_n)\\]\n denote the function that takes value 1 if $A\\left( \\begin{array}{c} x_1\\\\\\vdots\\\\x_n\\end{array}\\right)\\equiv B (\\textrm{mod}~ N\\mathbb{Z}^n)$ and zero otherwise (where $N\\mathbb{Z}^n$ stands for an integral stretch of the starting integral lattice). "
          << " The arguments of the $\\tau$ function will be suppressed in the output. Let $n= ";
  out3 << "$. Let in addition $x_1, \\dots x_n$ satisfty the following inequalities. ";
  out4 << "\n\n Then $P_I(x_1, \\dots, x_n)$ equals:";
  this->NotationExplanationLatex1 = out1.str();
  this->NotationExplanationLatex2 = out2.str();
  this->NotationExplanationLatex3 = out3.str();
  this->NotationExplanationLatex4 = out4.str();
#ifdef CGIversionLimitRAMuse
  ParallelComputing::GlobalPointerCounter++;
  ParallelComputing::CheckPointerCounters();
#endif
  this->theGlobalVariablesContainer->SetSize(1);
//  this->RankEuclideanSpaceGraphics=3;
}

ComputationSetup::~ComputationSetup()
{ delete this->theGlobalVariablesContainer;
  this->theGlobalVariablesContainer=0;
#ifdef CGIversionLimitRAMuse
  ParallelComputing::GlobalPointerCounter--;
  ParallelComputing::CheckPointerCounters();
#endif
}


void ComputationSetup::WriteToFilePFdecomposition(std::fstream& output, bool includeLatexHeaderAndFooter)
{ std::string tempS;
  this->thePartialFraction.ElementToString(tempS, true, false, true, *this->theGlobalVariablesContainer->Default());
  if (includeLatexHeaderAndFooter)
    output << "\\documentclass{article}\n\\begin{document}" << tempS << "\n\\end{document}";
}

void ComputationSetup::oneIncrement(GlobalVariables& theGlobalVariables)
{ this->flagAllowRepaint=false;
  for (this->oneStepChamberSlice(theGlobalVariables); this->thePartialFraction.theChambers.PreferredNextChambers.size!=0; this->oneStepChamberSlice(theGlobalVariables))
  {}
  this->flagAllowRepaint=true;
}

void ComputationSetup::FullChop(GlobalVariables& theGlobalVariables)
{ this->flagAllowRepaint=false;
  this->thePartialFraction.theChambers.flagDrawingProjective=true;
  while (this->thePartialFraction.theChambers.flagDrawingProjective)
    this->oneIncrement(theGlobalVariables);
  this->flagAllowRepaint=true;
}

void ComputationSetup::initWeylActionSpecifics(GlobalVariables& theGlobalVariables)
{ this->thePartialFraction.theChambers.flagDrawingProjective=true;
  CombinatorialChamberContainer tempComplex;
  this->thePartialFraction.theChambers.NumAffineHyperplanesProcessed=-1;
  this->thePartialFraction.theChambers.AmbientDimension=this->WeylGroupIndex;
  this->thePartialFraction.theChambers.theDirections.CopyFromBase(this->VPVectors);
  this->thePartialFraction.theChambers.theCurrentIndex = -1;
  tempComplex.SliceTheEuclideanSpace(&this->IndicatorRoot, *this->theGlobalVariablesContainer->Default(), false);
  this->initGenerateWeylAndHyperplanesToSliceWith(theGlobalVariables, tempComplex);
  this->flagComputationInitialized=true;
  this->thePartialFraction.theChambers.flagSliceWithAWallInitDone=false;
}

void ComputationSetup::initGenerateWeylAndHyperplanesToSliceWith(GlobalVariables& theGlobalVariables, CombinatorialChamberContainer& inputComplex)
{ assert(&inputComplex!=&this->thePartialFraction.theChambers);
  this->thePartialFraction.theChambers.flagDrawingProjective=true;
  this->flagAllowRepaint=false;
  this->thePartialFraction.theChambers.InduceFromLowerDimensionalAndProjectivize(inputComplex, *this->theGlobalVariablesContainer->Default());
  this->thePartialFraction.theChambers.ConvertHasZeroPolyToPermanentlyZero();
  WeylGroup tempWeyl;
  tempWeyl.MakeArbitrary(this->WeylGroupLetter, this->WeylGroupIndex);
  tempWeyl.ComputeWeylGroup();
  tempWeyl.ComputeDebugString();
  this->thePartialFraction.theChambers.theWeylGroupAffineHyperplaneImages.SetSize(0);
  this->thePartialFraction.theChambers.AffineWallsOfWeylChambers.ClearTheObjects();
  inputComplex.AddWeylChamberWallsToHyperplanes(theGlobalVariables, tempWeyl);
  this->thePartialFraction.theChambers.WeylChamber.CopyFromBase(inputComplex.WeylChamber);
  for (int i=0; i<inputComplex.theHyperplanes.size; i++)
  { affineHyperplane tempH;
    root tempRoot; tempRoot.MakeZero(inputComplex.AmbientDimension);
    int start = 1;
    if (i>=inputComplex.NumProjectiveHyperplanesBeforeWeylChamberWalls)
    { this->thePartialFraction.theChambers.NumAffineHyperplanesBeforeWeylChamberWalls = this->thePartialFraction.theChambers.theWeylGroupAffineHyperplaneImages.size;
      start= 0;
    }
    inputComplex.theHyperplanes.ComputeDebugString();
    for (int j=start; j<tempWeyl.size; j++)
    { tempH.MakeFromNormalAndPoint(tempRoot, inputComplex.theHyperplanes.TheObjects[i]);
      tempH.ComputeDebugString();
//      tempWeyl.ActOnAffineHyperplaneByGroupElement(j, tempH, true, true);
      tempWeyl.ActOnRootByGroupElement(j, tempH.affinePoint, true, true);
      if (tempH.HasACommonPointWithPositiveTwoToTheNth_ant())
        if (this->thePartialFraction.theChambers.theWeylGroupAffineHyperplaneImages.AddOnTopNoRepetition(tempH))
          if (start==0)
            this->thePartialFraction.theChambers.AffineWallsOfWeylChambers.AddObjectOnTopNoRepetitionOfObjectHash(tempH);
      //tempH.ComputeDebugString();
    }
    std::string tempS;
    this->thePartialFraction.theChambers.theWeylGroupAffineHyperplaneImages.ComputeDebugString();
    this->thePartialFraction.theChambers.AffineWallsOfWeylChambers.ElementToStringGeneric(tempS);
    this->thePartialFraction.theChambers.ComputeDebugString();
  }
  this->thePartialFraction.theChambers.NewHyperplanesToSliceWith.size=0;
  this->thePartialFraction.theChambers.NewHyperplanesToSliceWith.MakeActualSizeAtLeastExpandOnTop(this->thePartialFraction.theChambers.theWeylGroupAffineHyperplaneImages.size);
  this->thePartialFraction.theChambers.theWeylGroupAffineHyperplaneImages.ComputeDebugString();
  for (int i=0; i<this->thePartialFraction.theChambers.theWeylGroupAffineHyperplaneImages.size; i++)
  { root tempRoot;
    tempRoot.MakeNormalInProjectivizationFromAffineHyperplane(this->thePartialFraction.theChambers.theWeylGroupAffineHyperplaneImages.TheObjects[i]);
    //tempRoot.ComputeDebugString();
    tempRoot.ScaleToIntegralMinHeightFirstNonZeroCoordinatePositive();
    this->thePartialFraction.theChambers.NewHyperplanesToSliceWith.AddRootNoRepetition(tempRoot);
  }
  this->thePartialFraction.theChambers.flagSliceWithAWallInitDone=false;
}

void ComputationSetup::oneStepChamberSlice(GlobalVariables& theGlobalVariables)
{ this->flagAllowRepaint=false;
  this->flagComputationInProgress=true;
  this->thePartialFraction.theChambers.flagDrawingProjective=true;
  if (!this->thePartialFraction.theChambers.oneStepChamberSlice(theGlobalVariables))
    this->flagComputationDone=true;
  this->flagAllowRepaint=true;
}

void ComputationSetup::AdjustGraphicsForTwoDimensionalLieAlgebras(DrawingVariables& theDV)
{ if (this->WeylGroupIndex!=2)
    return;
  if (this->WeylGroupLetter=='A')
    theDV.SetCoordsForA2();
  if (this->WeylGroupLetter=='B')
    theDV.SetCoordsForB2();
  if (this->WeylGroupLetter=='C')
    theDV.SetCoordsForC2();
  if (this->WeylGroupLetter=='G')
    theDV.SetCoordsForG2();
}

void ComputationSetup::InitComputationSetup()
{ if(!this->flagComputationInitialized)
  { this->thePartialFraction.theChambers.flagDrawingProjective=!this->flagDoingWeylGroupAction;
    if (this->flagDoingWeylGroupAction)
      this->initWeylActionSpecifics(*this->theGlobalVariablesContainer->Default());
    else
    { this->thePartialFraction.theChambers.AmbientDimension=this->WeylGroupIndex;
      this->thePartialFraction.theChambers.theDirections.CopyFromBase(this->VPVectors);
      this->thePartialFraction.theChambers.theCurrentIndex=-1;
    }
    this->AdjustGraphicsForTwoDimensionalLieAlgebras(this->theGlobalVariablesContainer->Default()->theDrawingVariables);
    this->flagComputationInitialized=true;
    this->flagComputationDone=false;
    this->flagComputationInProgress=true;
    this->thePartialFraction.theChambers.NumAffineHyperplanesProcessed=0;
    this->theGlobalVariablesContainer->Default()->theIndicatorVariables.Nullify();
    PolynomialOutputFormat::LatexMaxLineLength=100;
    PolynomialOutputFormat::UsingLatexFormat=true;
    this->flagDoneComputingPartialFractions=false;
  //    this->theChambers.SliceTheEuclideanSpace
  //                          (  ::InputRoots, ::NextDirectionIndex, root::AmbientDimension,
  //                            this->thePartialFraction.IndicatorRoot);
  //    this->theChambers.ComputeDebugString();
  }
  //the below line clears the drawing buffer
  this->GetGlobalVars()->theDrawingVariables.theBuffer.init();
}

GlobalVariables* ComputationSetup::GetGlobalVars()
{ return this->theGlobalVariablesContainer->Default();
}

void ComputationSetup::DoTheRootSAComputation()
{  //rootSubalgebra theRootSA, theRootSA2;
  this->theRootSubalgebras.flagUsingActionsNormalizerCentralizerNilradical=true;
  this->theRootSubalgebras.flagComputeConeCondition=true;
  this->theRootSubalgebras.flagLookingForMinimalRels=false;
  this->theRootSubalgebras.theGoodRelations.flagIncludeCoordinateRepresentation=true;
  this->theRootSubalgebras.theBadRelations.flagIncludeCoordinateRepresentation=true;
  this->theRootSubalgebras.theMinRels.flagIncludeCoordinateRepresentation=true;
  this->theRootSubalgebras.theGoodRelations.flagIncludeSubalgebraDataInDebugString=false;
  this->theRootSubalgebras.theBadRelations.flagIncludeSubalgebraDataInDebugString=false;
  this->theRootSubalgebras.GenerateAllReductiveRootSubalgebrasUpToIsomorphism(*this->theGlobalVariablesContainer->Default(), this->WeylGroupLetter, this->WeylGroupIndex, true, true);
  //this->theRootSubalgebras.ComputeLProhibitingRelations
  //  (*this->theGlobalVariablesContainer->Default(), 0, this->theRootSubalgebras.size-1);
  //    (*this->theGlobalVariablesContainer->Default(), 0, this->theRootSubalgebras.size-1);
}

void ComputationSetup::Run()
{ this->flagAllowRepaint=false;
  this->InitComputationSetup();
  std::string BeginString;
  //this->thePartialFraction.flagAnErrorHasOccurredTimeToPanic=true;
  //partFraction::flagAnErrorHasOccurredTimeToPanic=true;
  if (this->theFunctionToRun!=0)
  { this->theFunctionToRun(*this, *this->theGlobalVariablesContainer->Default());
    this->ExitComputationSetup();
    this->flagAllowRepaint=true;
    this->flagComputationInProgress=false;
    return;
  }
  this->thePartialFraction.flagUsingOrlikSolomonBasis=false;
  if (this->flagUsingProverDoNotCallOthers)
  { if (this->flagSavingProverData)
    { this->theProverFixedK.WriteToFile(this->theProverFixedK.ProverFileName, *this->theGlobalVariablesContainer->Default());
      this->theProver.WriteToFileAppend(*this->theGlobalVariablesContainer->Default());
      this->flagSavingProverData=false;
    }  else if (this->flagOpenProverData)
    { this->theProverFixedK.ReadFromFile(this->theProverFixedK.ProverFileName, *this->theGlobalVariablesContainer->Default());
      this->theProver.ReadFromFile(*this->theGlobalVariablesContainer->Default());
      this->flagOpenProverData=false;
    } else
    { GlobalVariables* tgv= this->theGlobalVariablesContainer->Default();
      if (!this->flagProverDoingFullRecursion)
      { if (!this->flagProverUseFixedK && !this->theProver.flagComputationIsInitialized)
          this->theProver.GenerateStartingState (*this, *tgv, 'E', 8);
        if(!this->flagProverUseFixedK && this->theProver.flagComputationIsInitialized )
          this->theProver.RecursionStep(this->theProver.theWeylGroup, *tgv);
        if (!this->theProverFixedK.flagComputationIsInitialized && this->flagProverUseFixedK)
          this->theProverFixedK.GenerateStartingStatesFixedK(*this, *tgv, 'E', 8);
        if (this->theProverFixedK.flagComputationIsInitialized && this->flagProverUseFixedK)
          this->theProverFixedK.RecursionStepFixedK(this->theProverFixedK.theWeylGroup, *tgv);
      } else
      { if(!this->flagProverUseFixedK)
        { this->theProver.GenerateStartingState(*this, *tgv, 'E', 8);
          this->theProver.TheFullRecursion(this->theProver.theWeylGroup, *tgv);
        } else
        { this->theProverFixedK.GenerateStartingStatesFixedK(*this, *tgv, 'E', 8);
          this->theProverFixedK.TheFullRecursionFixedK(this->theProverFixedK.theWeylGroup, *tgv);
        }
      }
      if(!this->flagProverUseFixedK)
      { int currentIndex=*this->theProver.theIndexStack.LastObject();
        if (currentIndex>=0)
          this->theProver.TheObjects[currentIndex].ComputeDebugString(this->theProver.theWeylGroup, *tgv);
        if (this->theProver.theIndexStack.size>0)
          this->theProver.MakeProgressReportCurrentState(*this->theProver.theIndexStack.LastObject(), *tgv, this->theProver.theWeylGroup);
      } else
      { int currentIndex=*this->theProverFixedK.theIndexStack.LastObject();
        if (currentIndex>=0)
          this->theProverFixedK.TheObjects[currentIndex].ComputeDebugString(this->theProverFixedK.theWeylGroup, *tgv);
        if (this->theProverFixedK.theIndexStack.size>0)
          this->theProverFixedK.MakeProgressReportCurrentState(*this->theProverFixedK.theIndexStack.LastObject(), *tgv, this->theProverFixedK.theWeylGroup);
      }
    }
    this->ExitComputationSetup();
    this->flagAllowRepaint=true;
    this->flagComputationInProgress=false;
    return;
  }

  //partFraction::flagAnErrorHasOccurredTimeToPanic=true;
  //this->thePartialFraction.IndicatorRoot.InitFromIntegers(6, 10, 0, 0, 0);
  //this->VPVectors.ComputeDebugString();
  this->IndexChamberOfInterest=-1;
  if (this->flagComputingChambers)
  { /*root tempRoot; tempRoot.MakeEi(this->thePartialFraction.theChambers.AmbientDimension, 0);
    if (this->thePartialFraction.theChambers.theDirections.TheObjects[0].IsEqualTo(tempRoot))
      this->thePartialFraction.theChambers.theDirections.ReverseOrderElements();*/
    if (!this->flagDoingWeylGroupAction)
    { if (this->flagChopFully)
        this->thePartialFraction.theChambers.SliceTheEuclideanSpace(0, *this->theGlobalVariablesContainer->Default(), false);
      else
      { if (this->flagChopOneDirection)
          this->thePartialFraction.theChambers.SliceOneDirection(0, *this->theGlobalVariablesContainer->Default());
        else
          this->thePartialFraction.theChambers.OneSlice(0, *this->theGlobalVariablesContainer->Default());
      }
      this->thePartialFraction.theChambers.ComputeDebugString(false, this->flagUseHtml);
      if (this->DisplayNumberChamberOfInterest!=-1)
      { this->IndexChamberOfInterest=this->thePartialFraction.theChambers.FindVisibleChamberWithDisplayNumber(this->DisplayNumberChamberOfInterest);
        if (this->IndexChamberOfInterest!=-1)
          this->thePartialFraction.theChambers.TheObjects[this->IndexChamberOfInterest]->ComputeInternalPoint(this->IndicatorRoot, this->thePartialFraction.theChambers.AmbientDimension);
        else
        { this->IndicatorRoot.MakeZero(this->thePartialFraction.theChambers.AmbientDimension);
          this->DisplayNumberChamberOfInterest=-1;
        }
        //this->thePartialFraction.IndicatorRoot.ComputeDebugString();
      } else
        this->IndicatorRoot.MakeZero(this->thePartialFraction.theChambers.AmbientDimension);
    } else
    { if (this->flagChopFully)
        this->FullChop(*this->theGlobalVariablesContainer->Default());
      else
      { if (this->flagChopOneDirection)
          this->oneIncrement(*this->theGlobalVariablesContainer->Default());
        else
          this->oneStepChamberSlice(*this->theGlobalVariablesContainer->Default());
      }
    }
    this->thePartialFraction.theChambers.drawOutput(this->GetGlobalVars()->theDrawingVariables, this->IndicatorRoot, 0);
  }
  if (this->flagComputingPartialFractions && ! this->flagDoneComputingPartialFractions)
  { if (!this->flagUsingCustomVectors)
    { this->thePartialFraction.ComputeKostantFunctionFromWeylGroup (this->WeylGroupLetter, this->WeylGroupIndex, this->theOutput, &this->IndicatorRoot, false, false, *this->theGlobalVariablesContainer->Default());
      this->theOutput.ComputeDebugString();
    }
    else
    { intRoots tempRoots;
      tempRoots.AssignRoots(this->VPVectors);
      if (!this->flagPartialFractionSplitPrecomputed)
      { this->thePartialFraction.initFromRootSystem(tempRoots, tempRoots, 0, *this->theGlobalVariablesContainer->Default());
        if (this->flagHavingStartingExpression)
          this->thePartialFraction.ElementToString(BeginString, *this->theGlobalVariablesContainer->Default());
        if (this->IndexChamberOfInterest!=-1)
        { roots tempRoots;
          tempRoots.AssignHashedIntRoots(this->thePartialFraction.RootsToIndices);
          root oldIndicator; oldIndicator.Assign(this->IndicatorRoot);
          tempRoots.PerturbVectorToRegular(this->IndicatorRoot, *this->theGlobalVariablesContainer->Default(), this->thePartialFraction.theChambers.AmbientDimension);
          while (!this->thePartialFraction.theChambers.TheObjects[this->IndexChamberOfInterest]->PointIsInChamber(this->IndicatorRoot))
            this->IndicatorRoot.Add(oldIndicator);
          while (!tempRoots.IsRegular(this->IndicatorRoot, *this->theGlobalVariablesContainer->Default(), this->thePartialFraction.theChambers.AmbientDimension))
            this->IndicatorRoot.Add(oldIndicator);
          //this->thePartialFraction.IndicatorRoot.ComputeDebugString();
        }
        root* tempPt=0;
        if (this->flagUsingIndicatorRoot)
        { this->thePartialFraction.AssureIndicatorRegularity(*this->theGlobalVariablesContainer->Default(), this->IndicatorRoot);
          tempPt = &this->IndicatorRoot;
        }
        this->thePartialFraction.split(*this->theGlobalVariablesContainer->Default(), tempPt);
      }
    }
    if (this->flagComputingVectorPartitions)
    { this->thePartialFraction.partFractionsToPartitionFunctionAdaptedToRoot(this->theOutput, this->IndicatorRoot, false, false, *this->theGlobalVariablesContainer->Default(), !this->flagUsingIndicatorRoot);
      this->IndexChamberOfInterest=this->thePartialFraction.theChambers.RootBelongsToChamberIndex(this->IndicatorRoot, 0);
      this->theOutput.ComputeDebugString();
    }
    if (this->flagHavingBeginEqnForLaTeXinStrings)
    { std::stringstream out;
      std::string tempS;
      if (this->flagHavingDocumentClassForLaTeX)
      { out << "\\documentclass{article}\\usepackage{latexsym}\\usepackage{amssymb}\n\\addtolength{\\hoffset}{-3.8cm}\\addtolength{\\textwidth}{7.3cm}\\addtolength{\\voffset}{-3.5cm} \\addtolength{\\textheight}{7cm} \\begin{document}\n";
        if (this->flagHavingNotationExplanation)
        { this->VPVectors.ElementToString(tempS, true, false, false);
          out  << this->NotationExplanationLatex1 << tempS << this->NotationExplanationLatex2 << this->thePartialFraction.AmbientDimension << this->NotationExplanationLatex3;
          if (this->flagComputingChambers)
          { int tempI =this->thePartialFraction.theChambers.RootBelongsToChamberIndex(this->IndicatorRoot, 0);
            PolynomialOutputFormat PolyFormatLocal;
            this->thePartialFraction.theChambers.TheObjects[tempI]->ElementToInequalitiesString(tempS, this->thePartialFraction.theChambers, true, false, PolyFormatLocal);
            out << tempS;
          } else
            out << "\n\n(Inequalities missing)\n\n";
          out << this->NotationExplanationLatex4;
        }
      }
      out << "\\begin{eqnarray*}&&\n" << this->theOutput.DebugString << "\\end{eqnarray*}";
      if (this->IndexChamberOfInterest!=-1 && !this->flagHavingNotationExplanation)
      { PolynomialOutputFormat PolyFormatLocal;
        this->thePartialFraction.theChambers.TheObjects[this->IndexChamberOfInterest]->ElementToInequalitiesString(tempS, this->thePartialFraction.theChambers, true, false, PolyFormatLocal);
        out << "\n\n\n" << tempS;
      }
      if (this->flagHavingDocumentClassForLaTeX)
        out << "\n\\end{document}";
      this->theOutput.DebugString= out.str();
    }
    if (this->flagDisplayingPartialFractions)
    { std::stringstream out2;
      if (this->flagHavingBeginEqnForLaTeXinStrings)
        out2 << "\\documentclass{article}\n \\addtolength{\\hoffset}{-3.8cm}\\addtolength{\\textwidth}{7.3cm}\\addtolength{\\voffset}{-3.5cm}\\addtolength{\\textheight}{7cm} \\begin{document}";
      if (this->flagHavingStartingExpression)
        out2 << BeginString << "=";
      this->thePartialFraction.ComputeDebugString(*this->theGlobalVariablesContainer->Default());
      out2 << this->thePartialFraction.DebugString;
      if (this->flagHavingBeginEqnForLaTeXinStrings)
         out2 << "\n\\end{document}";
      this->thePartialFraction.DebugString= out2.str();
    }
    this->flagDoneComputingPartialFractions=true;
  }
  //TheBigOutput.InduceFromLowerDimensionalAndProjectivize(this->theChambers);
  this->ExitComputationSetup();
  //std::stringstream out;
  //List<roots> tempRoots;
  //this->thePartialFraction.ComputeSupport(tempRoots, out);
  //std::string tempS;
//  tempS=out.str();
}

void ComputationSetup::ExitComputationSetup()
{ if (!this->flagDoingWeylGroupAction)
    if(this->thePartialFraction.theChambers.theCurrentIndex>=this->thePartialFraction.theChambers.theDirections.size)
    { //Computation is done and we must reset
      this->flagComputationDone=true;
    //  this->flagComputationInitialized=false;
    }
  this->flagAllowRepaint=true;
  this->flagComputationInProgress=false;
}

void ComputationSetup::Reset()
{ this->flagComputationInProgress=false;
  this->flagComputationDone=true;
  this->flagComputationInitialized=false;
}

void ComputationSetup::ComputeRootSAs(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ inputData.theRootSubalgebras.flagUsingActionsNormalizerCentralizerNilradical=true;
  inputData.theRootSubalgebras.flagComputeConeCondition=false;
  inputData.theRootSubalgebras.GenerateAllReductiveRootSubalgebrasUpToIsomorphism(theGlobalVariables, inputData.WeylGroupLetter, inputData.WeylGroupIndex, true, true);
  inputData.theRootSubalgebras.ComputeDebugString(true, false, true, 0 , 0, theGlobalVariables);
  theGlobalVariables.theIndicatorVariables.StatusString1=inputData.theRootSubalgebras.DebugString;
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void ComputationSetup::ComputeGroupPreservingKintersectBIsos(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ inputData.theRootSubalgebras.GenerateAllReductiveRootSubalgebrasUpToIsomorphism(theGlobalVariables, inputData.WeylGroupLetter, inputData.WeylGroupIndex, true, true);
  std::string tempS;
  inputData.theRootSubalgebras.ElementToStringCentralizerIsomorphisms(tempS, true, false, 0, inputData.theRootSubalgebras.size, theGlobalVariables);
  theGlobalVariables.theIndicatorVariables.StatusString1=tempS;
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void ComputationSetup::EvaluatePoly()
{ //Rational::flagAnErrorHasOccurredTimeToPanic=true;
  this->theOutput.Evaluate(this->ValueRoot, this->Value);
  this->Value.ElementToString(this->ValueString);
}

void DrawingVariables::GetCoordsForDrawing(DrawingVariables& TDV, root& r, double& x, double& y)
{ x=TDV.centerX;
  y=TDV.centerY;
  for (int k=0; k<r.size; k++)
  { x+=(r.TheObjects[k].DoubleValue())*(TDV.Projections.elements[k][0]);
    y-=(r.TheObjects[k].DoubleValue())*(TDV.Projections.elements[k][1]);
  }
}

void DrawingVariables::drawLineBetweenTwoVectorsBuffer(root& r1, root& r2, int PenStyle, int PenColor, std::fstream* LatexOutFile)
{ if (this->flag2DprojectionDraw)
  { this->theBuffer.drawLineBetweenTwoVectorsBuffer(r1, r2, PenStyle, PenColor);
    if (LatexOutFile!=0)
    {//to do: this block of code!
    }
  }
  else
  { int r, g, b;
    r=PenColor/65536;
    g=(PenColor/256)%256;
    b=PenColor%256;
    ::CGIspecificRoutines::drawlineInOutputStreamBetweenTwoRoots(r1, r2, PenStyle, r, g, b);
  }
}

void DrawingVariables::drawCoordSystemBuffer(DrawingVariables& TDV, int theDimension, std::fstream* LatexOutFile)
{ for (int i=0; i<theDimension; i++)
  { root tempRoot;
    tempRoot.MakeEi(theDimension, i);
    std::string tempS; std::stringstream out;
    tempRoot.ElementToString(tempS);
    out << tempS;
    tempS=out.str();
    TDV.drawTextAtVectorBuffer(tempRoot, tempS, 0, TDV.TextStyleNormal, LatexOutFile);
  }
}

void DrawingVariables::drawLineBufferOld(double X1, double Y1, double X2, double Y2, unsigned long thePenStyle, int ColorIndex, std::fstream* LatexOutFile)
{ this->theBuffer.drawLineBuffer(X1, Y1, X2, Y2, thePenStyle, ColorIndex);
  if (LatexOutFile!=0)
    LaTeXProcedures::drawline(X1, Y1, X2, Y2, thePenStyle, ColorIndex, *LatexOutFile, *this);
}

void DrawingVariables::drawTextAtVectorBuffer(root& point, const std::string& inputText, int textColor, int theTextStyle, std::fstream* LatexOutFile)
{ this->theBuffer.drawTextAtVectorBuffer(point, inputText, textColor, this->fontSizeNormal, theTextStyle);
}

void DrawingVariables::drawTextDirectly(double X1, double Y1, const std::string& inputText, int color, std::fstream* LatexOutFile)
{ if (this->theDrawTextFunction!=0)
    this->theDrawTextFunction(X1-7, Y1-7, inputText.c_str(), inputText.length(), color, this->fontSizeNormal);
  if (LatexOutFile!=0)
    LaTeXProcedures::drawTextDirectly(X1, Y1, inputText, color, *LatexOutFile);
}

void CombinatorialChamberContainer::drawFacetVerticesMethod2(DrawingVariables& TDV, roots& r, roots& directions, int ChamberIndex, WallData& TheFacet, int DrawingStyle, int DrawingStyleDashes, std::fstream* outputLatex)
{ root tempRoot;
  root Projection1;
  root tempRoot2;
  root zeroRoot; zeroRoot.MakeZero(r.TheObjects[0].size);
  root Projection2;
  for (int i = 0; i<r.size; i++)
    if (TheFacet.IsInFacetNoBoundaries(r.TheObjects[i]))
    { tempRoot.Assign(r.TheObjects[i]);
      TDV.ProjectOnToHyperPlaneGraphics(tempRoot, Projection1, directions);
      TDV.drawLineBetweenTwoVectorsBuffer(zeroRoot, Projection1, DrawingStyleDashes, TDV.ColorDashes, outputLatex);
      for (int j=i+1; j<r.size; j++)
        if (TheFacet.IsInFacetNoBoundaries(r.TheObjects[j]))
        { tempRoot2.Assign(r.TheObjects[j]);
          TDV.ProjectOnToHyperPlaneGraphics(tempRoot2, Projection2, directions);
          TDV.drawLineBetweenTwoVectorsBuffer(Projection1, Projection2,  DrawingStyle, TDV.Colors[ChamberIndex%TDV.NumColors], outputLatex);
        }
    }
}

void CombinatorialChamberContainer::drawOutput(DrawingVariables& TDV, root& ChamberIndicator, std::fstream* LaTeXOutput)
{ if (LaTeXOutput!=0)
    LaTeXProcedures::beginPSTricks(*LaTeXOutput);
  for(int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
      this->TheObjects[i]->DisplayNumber=i;
  if (this->flagDrawingProjective)
    CombinatorialChamberContainer::DrawOutputProjective(TDV, ChamberIndicator, LaTeXOutput);
  else
    CombinatorialChamberContainer::drawOutputAffine(TDV, LaTeXOutput);
  if (LaTeXOutput!=0)
    LaTeXProcedures::endPSTricks(*LaTeXOutput);
}

void CombinatorialChamberContainer::drawOutputAffine(DrawingVariables& TDV, std::fstream* LaTeXoutput)
{ if(this->AffineWallsOfWeylChambers.size>0)
    this->LabelChambersAndGetNumChambersInWeylChamber(this->WeylChamber);
  else
    this->LabelChambersForDisplayAndGetNumVisibleChambers();
  for(int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
      this->TheObjects[i]->drawOutputAffine(TDV, *this, LaTeXoutput);
  TDV.drawCoordSystemBuffer(TDV, this->AmbientDimension-1, LaTeXoutput);
}

void CombinatorialChamberContainer::DrawOutputProjective(DrawingVariables& TDV, root& ChamberIndicator, std::fstream* outputLatex)
{ Rational::flagMinorRoutinesOnDontUseFullPrecision=true;
  int NumTrueChambers=this->LabelChambersForDisplayAndGetNumVisibleChambers();
  int NumZeroChambers=0;
  for (int j=0; j<this->size; j++)
    if (this->TheObjects[j]!=0)
      if (this->TheObjects[j]->flagHasZeroPolynomiaL)
        NumZeroChambers++;
  if (CombinatorialChamberContainer::flagAnErrorHasOcurredTimeToPanic)
    this->ComputeDebugString();
  std::string tempS;
  std::stringstream out, out1, out3, out2, out4;
  out << "#Drawn chambers: " << NumTrueChambers;
  tempS=out.str();
  TDV.drawTextBuffer(TDV.textX, TDV.textY, tempS, TDV.ColorTextDefault, 0);
  out1 << "#Zero chambers: " << NumZeroChambers;
  tempS=out1.str();
  TDV.drawTextBuffer(TDV.textX, TDV.textY+30, tempS, TDV.ColorTextDefault, 0);
  out2 << "#Next chamber: ";
  if (this->indexNextChamberToSlice!=-1)
    if (this->TheObjects[this->indexNextChamberToSlice]!=0)
    { if (this->TheObjects[this->indexNextChamberToSlice]->flagHasZeroPolynomiaL)
        out2 << "i";
      else
        out2 << "c";
      out2 << this->TheObjects[this->indexNextChamberToSlice]->DisplayNumber;
    }
  if (this->flagMakingASingleHyperplaneSlice)
    out2  << "; " << "Plane: " << this->NumAffineHyperplanesProcessed+1 << " out of " << this->theWeylGroupAffineHyperplaneImages.size;
  tempS=out2.str();
  TDV.drawTextBuffer(TDV.textX, TDV.textY+15, tempS, TDV.ColorTextDefault, 0);
  out4 << "#Non convex: " << this->NonConvexActualChambers.size;
  tempS=out4.str();
  TDV.drawTextBuffer(TDV.textX, TDV.textY+45, tempS, TDV.ColorTextDefault, 0);
  if (this->size>1000)
    return;
  if (this->flagStoringVertices)
  { for (int j=0; j<this->size; j++)
    { if (this->TheObjects[j]!=0)
      { root tempRoot;
        this->TheObjects[j]->ComputeInternalPoint(tempRoot, this->AmbientDimension);
        root Proj;
        TDV.ProjectOnToHyperPlaneGraphics(tempRoot, Proj, this->theDirections);
        std::stringstream out; std::string tempS;
        if (TDV.flagDisplayingCreationNumbersInsteadOfDisplayNumbers)
          out << this->TheObjects[j]->CreationNumber;
        else
          out << this->TheObjects[j]->DisplayNumber;
        tempS=out.str();
        int TextColor = TDV.ColorTextDefault;
        int TextStyle = TDV.TextStyleChamber;
        int thePenStyle = TDV.PenStyleNormal;
        int thePenStyleLinkToOrigin= TDV.PenStyleLinkToOrigin;
        if (this->TheObjects[j]->flagHasZeroPolynomiaL)
        { TextColor = TDV.ColorTextZeroChamber; TextStyle = TDV.TextStyleZeroChamber;
          thePenStyle = TDV.PenStyleZeroChamber; thePenStyleLinkToOrigin = TDV.PenStyleLinkToOriginZeroChamber;
        }
        if (this->TheObjects[j]->flagPermanentlyZero)
        { TextColor = TDV.ColorTextPermanentlyZeroChamber; TextStyle = TDV.TextStylePermanentlyZeroChamber;
          thePenStyle = TDV.PenStylePermanentlyZeroChamber; thePenStyleLinkToOrigin = TDV.PenStyleLinkToOriginPermanentlyZeroChamber;
        }
        TDV.drawTextAtVectorBuffer(Proj, tempS, TextColor, TextStyle, outputLatex);
        for (int i =0; i<this->TheObjects[j]->Externalwalls.size; i++)
          CombinatorialChamberContainer::drawFacetVerticesMethod2(TDV, this->TheObjects[j]->AllVertices, this->theDirections, j, this->TheObjects[j]->Externalwalls.TheObjects[i], thePenStyle, thePenStyleLinkToOrigin, outputLatex);
      }
    }
    if (this->size>0 && ChamberIndicator.size==this->AmbientDimension && TDV.flag2DprojectionDraw)
    { root tempRootX;
      root zeroRoot; zeroRoot.MakeZero(this->AmbientDimension);
      TDV.ProjectOnToHyperPlaneGraphics(ChamberIndicator, tempRootX, this->theDirections);
      TDV.drawTextAtVectorBuffer(tempRootX, "Indicator", TDV.ColorTextDefault, TDV.TextStyleNormal, 0);
      TDV.drawLineBetweenTwoVectorsBuffer(zeroRoot, tempRootX, TDV.PenStyleNormal, TDV.ColorChamberIndicator, 0);
    }
  }
  TDV.drawCoordSystemBuffer(TDV, this->AmbientDimension, outputLatex);
  Rational::flagMinorRoutinesOnDontUseFullPrecision=false;
}

void DrawingVariables::ProjectOnToHyperPlaneGraphics(root& input, root& output, roots& directions)
{ output.Assign(input);
  root normal; root basepoint;
  Rational tempRat2, tempRat, tempRat3;
  normal.MakeZero(input.size);
  for (int i=0; i<input.size; i++)
  { if (input.TheObjects[i].IsNonNegative())
      normal.TheObjects[i]+=(ROne);
    else
      normal.TheObjects[i]+=(RMOne);
  }
  basepoint.MakeZero(input.size);
  basepoint.TheObjects[0].AssignInteger(1);
  if (input.TheObjects[0].IsNegative())
    basepoint.MinusRoot();
//////////////////////////////////////////////////
  root::RootScalarEuclideanRoot(output, normal, tempRat2);
  root::RootScalarEuclideanRoot(basepoint, normal, tempRat);
  if (!tempRat2.IsEqualToZero())
  { tempRat3.Assign(tempRat);
    tempRat3.DivideBy(tempRat2);
    output.MultiplyByLargeRational(tempRat3);
  }
  else
    output.MakeZero(input.size);
}

void root::ElementToString(std::string& output)
{ this->ElementToString(output, false);
}

void root::ElementToString(std::string& output, bool useLaTeX)
{ output.clear();
  std::string tempStr;
  output.append("(");
  for(int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempStr);
    output.append(tempStr);
    if (i!=this->size-1)
      output.append(", ");
  }
  output.append(")");
}

std::string root::ElementToStringLetterFormat(const std::string& inputLetter, bool useLatex)
{ if (this->IsEqualToZero())
    return "0";
  std::stringstream out;
  std::string tempS;
  bool found=false;
  for(int i=0; i<this->size; i++)
    if (!this->TheObjects[i].IsEqualToZero())
    { this->TheObjects[i].ElementToString(tempS);
      if (tempS=="1")
        tempS="";
      if (tempS=="-1")
        tempS="-";
      if (found)
      { if (tempS.size()>0)
        { if (tempS[0]!='-')
            out << "+";
        } else
          out << "+";
      }
      found=true;
      out << tempS;
      out << inputLetter << "_{" << i+1 << "}";
    }
  return out.str();
}

void root::ElementToStringEpsilonForm(std::string& output, bool useLatex, bool useHtml)
{ if (useLatex)
    output= this->ElementToStringLetterFormat("\\varepsilon", useLatex);
  else
    output = this->ElementToStringLetterFormat("e", useLatex);
}

void root::MinusRoot()
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].Minus();
}

void root::MultiplyByInteger(int a)
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].MultiplyByInt(a);
}

void root::MultiplyByLargeInt(LargeInt& a)
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].MultiplyByLargeInt(a);
}

void root::MultiplyByLargeIntUnsigned(LargeIntUnsigned& a)
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].MultiplyByLargeIntUnsigned(a);
}

void root::ScaleToIntegralMinHeight()
{ LargeIntUnsigned numGCD, tempUI;
  bool foundNonZero=false;
  for (int i=0; i<this->size; i++)
    if (!this->TheObjects[i].IsEqualToZero())
    { if (foundNonZero)
      { if(!numGCD.IsEqualToOne())
        { this->TheObjects[i].GetNumUnsigned(tempUI);
          LargeIntUnsigned::gcd(numGCD, tempUI, numGCD);
        }
      } else
      { this->TheObjects[i].GetNumUnsigned(numGCD);
        foundNonZero=true;
      }
      this->TheObjects[i].GetDen(tempUI);
      if (!tempUI.IsEqualToOne())
        this->MultiplyByLargeIntUnsigned(tempUI);
    }
  if (foundNonZero)
    if (!numGCD.IsEqualToOne())
      this->DivByLargeIntUnsigned(numGCD);
}

bool root::IsStronglyPerpendicularTo(root &right, WeylGroup& theWeyl)
{ root tempRoot;
  tempRoot.Assign(*this);
  tempRoot.Add(right);
  if (tempRoot.IsEqualToZero() || theWeyl.RootSystem.ContainsObjectHash(tempRoot))
    return false;
  tempRoot.Assign(*this);
  tempRoot.Subtract(right);
  if (tempRoot.IsEqualToZero() ||theWeyl.RootSystem.ContainsObjectHash(tempRoot))
    return false;
  return true;
}

bool root::IsEqualTo(const root& right) const
{ if (this->size!=right.size)
    return false;
  for (int i=0; i<this->size; i++)
    if (!this->TheObjects[i].IsEqualTo(right.TheObjects[i]))
      return false;
  return true;
}

bool root::IsProportionalTo(const root& input, Rational& outputTimesMeEqualsInput)const
{ if (this->size!= input.size)
    return false;
  int IndexFirstNonZero=-1;
  for(int i=0; i<this->size; i++)
    if (!this->TheObjects[i].IsEqualToZero())
    { IndexFirstNonZero=i;
      break;
    }
  if (IndexFirstNonZero==-1)
  { if (input.IsEqualToZero())
    { outputTimesMeEqualsInput.MakeZero();
      return true;
    }
    return false;
  }
  root tempRoot=*this;
  outputTimesMeEqualsInput= input.TheObjects[IndexFirstNonZero]/this->TheObjects[IndexFirstNonZero];
  tempRoot*=outputTimesMeEqualsInput;
  return tempRoot.IsEqualTo(input);
}

bool root::IsProportionalTo(root& r)
{ if (this->size!=r.size)
    return false;
  //r.ComputeDebugString();
  int IndexFirstNonZero=-1;
  for(int i=0; i<this->size; i++)
    if (!this->TheObjects[i].IsEqualToZero())
    { IndexFirstNonZero=i;
      break;
    }
  if (IndexFirstNonZero==-1)
    return false;
  root tempRoot;
  tempRoot.Assign(*this);
  tempRoot.DivByLargeRational(this->TheObjects[IndexFirstNonZero]);
  tempRoot.MultiplyByLargeRational( r.TheObjects [IndexFirstNonZero]);
  return tempRoot.IsEqualTo(r);
}

void root::FindLCMDenominators(LargeIntUnsigned& output)
{ LargeIntUnsigned tempI, tempI2;
  output.MakeOne();
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].GetDen(tempI2);
    LargeIntUnsigned::gcd(output, tempI2, tempI);
    output.MultiplyBy(tempI2);
    output.DivPositive(tempI, output, tempI2);
  }
}

int root::FindLCMDenominatorsTruncateToInt()
{ int result=1;
  for (int i=0; i<this->size; i++)
  { result = MathRoutines::lcm(result, this->TheObjects[i].DenShort);
    assert(this->TheObjects[i].Extended==0);
  }
  return result;
}

void root::ScaleToFirstNonZeroCoordinatePositive()
{ for (int i=0; i<this->size; i++)
  { if (this->TheObjects[i].IsPositive())
      return;
    if (this->TheObjects[i].IsNegative())
    { this->MultiplyByInteger(-1);
      return;
    }
  }
}

void root::ScaleToIntegralMinHeightFirstNonZeroCoordinatePositive()
{ this->ScaleToIntegralMinHeight();
  this->ScaleToFirstNonZeroCoordinatePositive();
}

void root::ReadFromFile(std::fstream& input)
{ std::string tempS;
  input >> tempS; assert(tempS=="root_dim:");
  int tempI;
  input >> tempI;
  this->SetSize(tempI);
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].ReadFromFile(input);
}

void root::WriteToFile(std::fstream& output)
{ output << "root_dim: " << this->size << " ";
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].WriteToFile(output);
    output << " ";
  }
}

void root::DivByLargeIntUnsigned(LargeIntUnsigned& a)
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].DivideByLargeIntegerUnsigned(a);
}

void root::MultiplyByLargeRational(const Rational& a)
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].MultiplyBy(a);
}

void root::operator=(const SelectionWithMultiplicities& other)
{ this->SetSize(other.Multiplicities.size);
  for (int i=0; i<this->size; i++)
    this->TheObjects[i]=other.Multiplicities.TheObjects[i];
}

void root::Add(const root& r)
{ assert(r.size==this->size);
  for (int i=0; i<this->size; i++)
    this->TheObjects[i]+=(r.TheObjects[i]);
}

bool root::OurScalarProductIsPositive(const root& right)
{ Rational tempRat;
  root::RootScalarEuclideanRoot(*this, right, tempRat);
  return tempRat.IsPositive();
}

bool root::OurScalarProductIsNegative(const root& right)
{ Rational tempRat;
  root::RootScalarEuclideanRoot(*this, right, tempRat);
  return tempRat.IsNegative();
}

bool root::OurScalarProductIsZero(const root& right)
{ Rational tempRat;
  root::RootScalarEuclideanRoot(*this, right, tempRat);
  return tempRat.IsEqualToZero();
}

void root::Subtract(const root& r)
{ assert(r.size==this->size);
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].Subtract(r.TheObjects[i]);
}

void root::MakeZero(int DesiredDimension)
{ this->SetSize(DesiredDimension);
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].MakeZero();
}

void root::MakeEi(int DesiredDimension, int NonZeroIndex)
{ this->MakeZero(DesiredDimension);
  this->TheObjects[NonZeroIndex].MakeOne();
}

void root::AssignIntRoot(intRoot& r)
{ this->SetSize(r.size);
  for (int i=0; i<r.size; i++)
    this->TheObjects[i].AssignInteger(r.TheObjects[i]);
}

bool root::CheckForElementSanity()
{ for (int i=0; i<this->size; i++)
    if (!this->TheObjects[i].CheckForElementSanity())
      return false;
  return true;
}

void root::AssignWithoutLastCoordinate(root& right)
{ this->SetSize(right.size-1);
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].Assign(right.TheObjects[i]);
}

void root::InitFromIntegers(int Dimension, int x1, int x2, int x3, int x4, int x5)
{ this->SetSize(5);
  this->TheObjects[0].AssignInteger(x1);
  this->TheObjects[1].AssignInteger(x2);
  this->TheObjects[2].AssignInteger(x3);
  this->TheObjects[3].AssignInteger(x4);
  this->TheObjects[4].AssignInteger(x5);
  this->SetSize(Dimension);
}

void root::InitFromIntegers(int Dimension, int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8)
{ this->SetSize(8);
  this->TheObjects[0].AssignInteger(x1);
  this->TheObjects[1].AssignInteger(x2);
  this->TheObjects[2].AssignInteger(x3);
  this->TheObjects[3].AssignInteger(x4);
  this->TheObjects[4].AssignInteger(x5);
  this->TheObjects[5].AssignInteger(x6);
  this->TheObjects[6].AssignInteger(x7);
  this->TheObjects[7].AssignInteger(x8);
  this->SetSize(Dimension);
}

void root::InitFromIntegers(int Dimension, int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8, int x9, int x10, int x11, int x12)
{ this->SetSize(12);
  this->TheObjects[0].AssignInteger(x1);
  this->TheObjects[1].AssignInteger(x2);
  this->TheObjects[2].AssignInteger(x3);
  this->TheObjects[3].AssignInteger(x4);
  this->TheObjects[4].AssignInteger(x5);
  this->TheObjects[5].AssignInteger(x6);
  this->TheObjects[6].AssignInteger(x7);
  this->TheObjects[7].AssignInteger(x8);
  this->TheObjects[8].AssignInteger(x9);
  this->TheObjects[9].AssignInteger(x10);
  this->TheObjects[10].AssignInteger(x11);
  this->TheObjects[11].AssignInteger(x12);
  this->SetSize(Dimension);
}

void root::GetHeight(Rational& output)
{ output.MakeZero();
  for(int i=0; i<this->size; i++)
    output+=(this->TheObjects[i]);
}

Rational root::GetHeight()
{ Rational tempRat;
  this->GetHeight(tempRat);
  return tempRat;
}

int root::HashFunction() const
{ int result=0;
  int theSize= MathRoutines::Minimum(this->size, SomeRandomPrimesSize);
  for (int i=0; i<theSize; i++)
    result+=  this->TheObjects[i].HashFunction()*  ::SomeRandomPrimes[i];
  return result;
}

inline bool root::IsPositiveOrZero() const
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].IsNegative())
      return false;
  return true;
}

inline bool root::IsNegativeOrZero()
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].IsPositive())
      return false;
  return true;
}

inline bool root::IsGreaterThanOrEqualTo(root& r)
{ root tempRoot;
  tempRoot.Assign(*this);
  tempRoot.Subtract(r);
  return tempRoot.IsPositiveOrZero();
}

std::string* root::ElementToStringDebuggerCallOnly()
{ this->ComputeDebugString();
  return &this->DebugString;
};

void root::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

inline void root::MakeNormalInProjectivizationFromAffineHyperplane(affineHyperplane& input)
{ this->MakeNormalInProjectivizationFromPointAndNormal(input.affinePoint, input.normal);
}

void root::MakeNormalInProjectivizationFromPointAndNormal(root& point, root& normal)
{ //the extra dimension is going to be the last dimension
  int newDimension= normal.size+1;
  this->SetSize(newDimension);
  root::RootScalarEuclideanRoot(normal, point, this->TheObjects[newDimension-1]);
  this->TheObjects[newDimension-1].Minus();
  for (int j=0; j<newDimension-1; j++)
    this->TheObjects[j].Assign(normal.TheObjects[j]);
}

bool root::ProjectToAffineSpace(root &output)
{ if (this->TheObjects[this->size-1].IsEqualToZero())
    return false;
  output.SetSize(this->size-1);
  for (int i=0; i<this->size-1; i++)
    output.TheObjects[i].Assign(this->TheObjects[i]);
  output.DivByLargeRational(this->TheObjects[this->size-1]);
  return true;
}

bool root::MakeAffineProjectionFromNormal(affineHyperplane& output)
{ int tempI= this->getIndexFirstNonZeroCoordinate();
  if (tempI==this->size-1)
    return false;
  output.affinePoint.MakeZero(this->size-1);
  output.normal.SetSize(this->size-1);
  output.affinePoint.TheObjects[tempI].Assign(*this->LastObject());
  output.affinePoint.TheObjects[tempI].Minus();
  output.affinePoint.TheObjects[tempI].DivideBy(this->TheObjects[tempI]);
  for (int i=0; i<this->size-1; i++)
    output.normal.TheObjects[i].Assign(this->TheObjects[i]);
  return true;
}

void root::DivByInteger(int a)
{ for (int i =0; i<this->size; i++)
    this->TheObjects[i].DivideByInteger(a);
}

int root::getIndexFirstNonZeroCoordinate()
{ for(int i=0; i<this->size; i++)
    if (!this->TheObjects[i].IsEqualToZero())
      return i;
  return -1;
}

int root::getIndexLastNonZeroCoordinate()
{ for(int i=this->size-1; i>=0; i--)
    if (!this->TheObjects[i].IsEqualToZero())
      return i;
  return -1;
}
void root::DivByLargeInt(LargeInt& a)
{ for (int i =0; i<this->size; i++)
    this->TheObjects[i].DivideByLargeInteger(a);
}

void root::DivByLargeRational(const Rational& a)
{ for (int i =0; i<this->size; i++)
    this->TheObjects[i].DivideBy(a);
}

bool root::HasStronglyPerpendicularDecompositionWRT(int UpperBoundNumBetas, roots& theSet, WeylGroup& theWeylGroup, roots& output, List<Rational>& outputCoeffs, bool IntegralCoefficientsOnly)
{ if (UpperBoundNumBetas>0 && output.size>UpperBoundNumBetas)
    return false;
  if (this->IsEqualToZero())
    return true;
  if (theSet.size==0)
    return false;
  if (output.size==0)
  { if (theSet.ContainsObject(*this))
    { output.SetSize(1);
      output.LastObject()->Assign(*this);
      outputCoeffs.SetSize(1);
      outputCoeffs.LastObject()->MakeOne();
      return true;
    }
    output.MakeActualSizeAtLeastExpandOnTop(theSet.size);
    outputCoeffs.MakeActualSizeAtLeastExpandOnTop(theSet.size);
  }
  roots theNewSet;
  theNewSet.MakeActualSizeAtLeastExpandOnTop(theSet.size);
  root tempRoot;
  Rational tempRat;
  for (int indexFirstNonZeroRoot=0; indexFirstNonZeroRoot<theSet.size; indexFirstNonZeroRoot++)
  { root& currentRoot = theSet.TheObjects[indexFirstNonZeroRoot];
    tempRat= theWeylGroup.RootScalarCartanRoot(*this, currentRoot)/theWeylGroup.RootScalarCartanRoot(currentRoot, currentRoot);
    if (tempRat.IsPositive())
      if (!IntegralCoefficientsOnly || tempRat.DenShort==1)
       { theNewSet.size=0;
        for (int i=indexFirstNonZeroRoot; i<theSet.size; i++)
          if (currentRoot.IsStronglyPerpendicularTo(theSet.TheObjects[i], theWeylGroup))
            theNewSet.AddRoot(theSet.TheObjects[i]);
        outputCoeffs.AddObjectOnTop(tempRat);
        output.AddRoot(currentRoot);
        tempRoot = (*this)-currentRoot*tempRat;
        if (tempRoot.HasStronglyPerpendicularDecompositionWRT(UpperBoundNumBetas, theNewSet, theWeylGroup, output, outputCoeffs, IntegralCoefficientsOnly))
          return true;
        output.size--;
        outputCoeffs.size--;
       }
  }
  return false;
}

int MatrixLargeRational::FindPositiveLCMCoefficientDenominatorsTruncated()
{ int result=1;
  for (int i=0; i<this->NumRows; i++)
    for (int j=0; j<this->NumCols; j++)
      result*=(this->elements[i][j].DenShort/Rational::gcdSigned(result, this->elements[i][j].DenShort));
  return result;
}

int MatrixLargeRational::FindPositiveGCDCoefficientNumeratorsTruncated()
{ int result=1;
  for (int i=0; i<this->NumRows; i++)
    for (int j=0; j<this->NumCols; j++)
      if (this->elements[i][j].NumShort!=0)
        result=Rational::gcdSigned(result, this->elements[i][j].NumShort);
  assert(result!=0);
  if (result<0)
    result=-result;
  return result;
}

void MatrixLargeRational::ScaleToIntegralForMinRationalHeightNoSignChange()
{ Rational tempRat;
  tempRat.AssignNumeratorAndDenominator(this->FindPositiveLCMCoefficientDenominatorsTruncated(), this->FindPositiveGCDCoefficientNumeratorsTruncated());
  this->MultiplyByLargeRational(tempRat);
}

void MatrixLargeRational::ComputeDeterminantOverwriteMatrix(Rational &output)
{ int tempI;
  output.Assign(ROne);
  Rational tempRat;
  assert(this->NumCols==this->NumRows);
  int dim =this->NumCols;
  for (int i=0; i<dim; i++)
  {  //this->ComputeDebugString();
    tempI = this->FindPivot(i, i, dim-1);
    if (tempI==-1)
    { output.MakeZero();
      return;
    }
    this->SwitchTwoRows(i, tempI);
    if(tempI!=i){output.Minus(); }
    tempRat.Assign(this->elements[i][i]);
    output.MultiplyBy(tempRat);
    tempRat.Invert();
    this->RowTimesScalar(i, tempRat);
    for (int j=i+1; j<dim; j++)
      if (!this->elements[j][i].IsEqualToZero())
      { tempRat.Assign(this->elements[j][i]);
        tempRat.Minus();
        this->AddTwoRows (i, j, i, tempRat);
      }
  }
}

void MatrixLargeRational::Transpose(GlobalVariables& theGlobalVariables)
{ MatrixLargeRational& tempMat=theGlobalVariables.matTransposeBuffer;
  tempMat.init(this->NumCols, this->NumRows);
  for (int i=0; i<this->NumRows; i++)
    for (int j=0; j<this->NumCols; j++)
      tempMat.elements[j][i].Assign(this->elements[i][j]);
  this->Assign(tempMat);
}

void MatrixLargeRational::MultiplyByInt(int x)
{ for (int i=0; i<this->NumCols; i++)
    for (int j=0; j<this->NumRows; j++)
      this->elements[j][i].MultiplyByInt(x);
}

void MatrixLargeRational::MultiplyByLargeRational(Rational& x)
{ Rational tempRat; tempRat.Assign(x);
  for (int i=0; i<this->NumCols; i++)
    for (int j=0; j<this->NumRows; j++)
      this->elements[j][i].MultiplyBy(tempRat);
}

void MatrixLargeRational::DivideByRational(Rational& x)
{ this->operator/=(x);
}

void MatrixLargeRational::ActOnAroot(root& input, root& output)
{ assert(this->NumCols==input.size);
  root result;
  result.MakeZero(this->NumRows);
  for (int i=0; i<this->NumRows; i++)
    for(int j=0; j<this->NumCols; j++)
      result.TheObjects[i]=result.TheObjects[i]+ this->elements[i][j]*input.TheObjects[j];
  output = result;
}

void MatrixLargeRational::ActOnRoots(roots& theRoots)
{ for (int i=0; i<theRoots.size; i++)
    this->ActOnAroot(theRoots.TheObjects[i]);
}

void MatrixLargeRational::ActOnRoots(roots& input, roots& output)
{ output.SetSize(input.size);
  for (int i=0; i<input.size; i++)
    this->ActOnAroot(input.TheObjects[i], output.TheObjects[i]);
}

void MatrixLargeRational::AssignMatrixIntWithDen(MatrixIntTightMemoryFit& theMat, int Den)
{ this->init(theMat.NumRows, theMat.NumCols);
  for (int i=0; i<this->NumRows; i++)
    for (int j=0; j<this->NumCols; j++)
      this->elements[i][j].AssignNumeratorAndDenominator(theMat.elements[i][j], Den);
}

void MatrixLargeRational::AssignMatrixIntWithDen(Matrix<LargeInt>& theMat, LargeIntUnsigned& Den)
{ this->init(theMat.NumRows, theMat.NumCols);
  for (int i=0; i<this->NumRows; i++)
    for (int j=0; j<this->NumCols; j++)
    { this->elements[i][j]=theMat.elements[i][j];
      this->elements[i][j]/=Den;
    }
}

void MatrixLargeRational::AssignRootsToRowsOfMatrix(const roots& input)
{ if (input.size<=0)
  { this->init(0, 0);
    return;
  }
  int theDimension= input.TheObjects[0].size;
  this->init(input.size, theDimension);
  for (int i=0; i< this->NumRows; i++)
    for (int j=0; j<theDimension; j++)
      this->elements[i][j].Assign(input.TheObjects[i].TheObjects[j]);
}

void MatrixLargeRational::NonPivotPointsToRoot(Selection& TheNonPivotPoints, root& output)
{ this->NonPivotPointsToEigenVector(TheNonPivotPoints, output, (Rational) 1, (Rational) 0);
}

int MathRoutines::lcm(int a, int b)
{ if (a<0)
    a=-a;
  if (b<0)
    b=-b;
  return ((a*b)/Rational::gcdSigned(a, b));
}

int MathRoutines::TwoToTheNth(int n)
{ int result=1;
  for(int i=0; i<n; i++)
    result*=2;
  return result;
}

int MathRoutines::KToTheNth(int k, int n)
{ int result=1;
  for(int i=0; i<n; i++)
    result*=k;
  return result;
}

int MathRoutines::BinomialCoefficientMultivariate(int N, List<int>& theChoices)
{ int ChoiceIndex=0;
  int denominator=1;
  int result=0;
  for( int i=N; i>0; i--)
  { result*=i;
    result/=denominator;
    denominator++;
    if (denominator>theChoices.TheObjects[ChoiceIndex])
    { denominator=1;
      ChoiceIndex++;
    }
  }
  return result;
}

void ProjectOntoHyperPlane(root& input, root& normal, root& ProjectionDirection, root& output)
{ Rational t;
  Rational tempRat;
  root::RootScalarEuclideanRoot(input, normal, t);
  root::RootScalarEuclideanRoot(ProjectionDirection, normal, tempRat);
  t.DivideBy(tempRat);
  assert(t.IsNonNegative());
  t.Minus();
  root::RootPlusRootTimesScalar(input, ProjectionDirection, t, output);
}

void Selection::init(int maxNumElements)
{ if (maxNumElements<=0)
  { this->MaxSize=0;
    maxNumElements=0;
  }
  if (maxNumElements>0 && maxNumElements!=this->MaxSize)
  { delete [] this->selected;
    delete [] this->elements;
    //delete [] elementsInverseSelection;
    this->selected = new bool[maxNumElements];
    this->elements = new int[maxNumElements];
#ifdef CGIversionLimitRAMuse
  ParallelComputing::GlobalPointerCounter+=(maxNumElements-this->MaxSize)*2;
  ParallelComputing::CheckPointerCounters();
#endif
    this->MaxSize =maxNumElements;
  }
  for (int i=0; i<this->MaxSize; i++)
    this->selected[i]=false;
  this->CardinalitySelection=0;
}

//The below function is required to preserve the order of elements given by theSelection.elements.
void roots::SubSelection(Selection& theSelection, roots& output)
{ assert(&output!=this);
  output.SetSize(theSelection.CardinalitySelection);
  for(int i=0; i<theSelection.CardinalitySelection; i++)
    output.TheObjects[i].Assign(this->TheObjects[theSelection.elements[i]]);
}

void roots::SelectionToMatrix(Selection& theSelection, int OutputDimension, MatrixLargeRational& output)
{ output.init((int)OutputDimension, (int)theSelection.CardinalitySelection);
  this->SelectionToMatrixAppend(theSelection, OutputDimension, output, 0);
}

void roots::SelectionToMatrixAppend(Selection& theSelection, int OutputDimension, MatrixLargeRational& output, int StartRowIndex)
{ for(int i=0; i<theSelection.CardinalitySelection; i++)
  { root& tempRoot=this->TheObjects[theSelection.elements[i]];
    for (int j=0; j<OutputDimension; j++)
      output.elements[StartRowIndex+i][j].Assign(tempRoot.TheObjects[j]);
  }
}

void roots::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

void roots::ElementToString(std::string& output)
{ this->ElementToString(output, false, false, false);
}

void roots::ElementToLinearCombinationString(std::string& output)
{ std::stringstream out;
  std::string tempS;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS);
    out <<tempS;
     if (i!=this->size-1)
      out <<" + ";
  }
  output=out.str();
}

void roots::ElementToStringEpsilonForm(std::string& output, bool useLatex, bool useHtml, bool makeTable)
{ std::string tempS; std::stringstream out;
  if (useHtml && makeTable)
    out << "<table>";
  if (useLatex && makeTable)
    out << "\\begin{tabular}{c}";
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToStringEpsilonForm(tempS, useLatex, useHtml);
    if (useHtml && makeTable)
      out << "<tr><td>";
    if (!useLatex || useHtml)
      out << "(";
    out << tempS;
    if (!useLatex || useHtml)
      out << ")";
    if (useLatex && makeTable)
      out << "\\\\";
    if (useHtml && makeTable)
      out << "</td></tr>";
    if (!makeTable)
    { if (i!=this->size-1)
        out << ", ";
    }
    else
      out << "\n";
  }
  if (useHtml && makeTable)
    out << "</table>";
  if (useLatex && makeTable)
    out << "\\end{tabular}";
  output=out.str();
}

void roots::ElementToString(std::string& output, bool useLaTeX, bool useHtml, bool makeTable)
{ std::stringstream out;
  std::string tempS;
  if (! useLaTeX && ! useHtml)
    out << "Num roots: " << this->size << "\n";
  if (useLaTeX && makeTable)
    out << "\\begin{tabular}{c}";
  if (useHtml && makeTable)
    out << "<table>";
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS, useLaTeX);
    if (useHtml && makeTable)
      out << "<tr><td>";
    out << tempS;
    if (!makeTable && i!=this->size-1)
      out << ", ";
    if (useLaTeX && makeTable)
      out << "\\\\\n";
    if (useHtml && makeTable)
      out << "</td></tr>";
  }
  if (useHtml && makeTable)
    out << "</table>";
  if (useLaTeX && makeTable)
    out << "\\end{tabular}";
  output = out.str();
}

void roots::rootsToMatrix(MatrixLargeRational& output)
{ int tempNumCols= 0;
  if (this->size!=0)
    tempNumCols=(int)this->TheObjects[0].size;
  output.init((int) this->size, tempNumCols);
  for (int i=0; i<this->size; i++)
    for (int j=0; j<tempNumCols; j++)
      output.elements[i][j].Assign(this->TheObjects[i].TheObjects[j]);
}

void Selection::AddSelectionAppendNewIndex(int index)
{ if (index>=this->MaxSize || index<0)
    return;
  if (this->selected[index])
    return;
  this->selected[index]=true;
  this->elements[this->CardinalitySelection]=index;
  this->CardinalitySelection++;
}

Selection::Selection()
{ this->MaxSize=-1;
//  this->elementsInverseSelection=0;
  this->selected=0;
  this->elements=0;
  this->CardinalitySelection=0;
}

Selection::Selection(int m)
{  //this->elementsInverseSelection=0;
  this->selected=0;
  this->elements=0;
  this->CardinalitySelection=0;
  this->init(m);
}

void Selection::RemoveLastSelection()
{ if (this->CardinalitySelection==0)
    return;
  this->selected[this->elements[this->CardinalitySelection-1]]=false;
  this->CardinalitySelection--;
}

Selection::~Selection()
{ delete [] this->selected;
  delete [] this->elements;
#ifdef CGIversionLimitRAMuse
  ParallelComputing::GlobalPointerCounter-=this->MaxSize;
  ParallelComputing::CheckPointerCounters();
#endif
  //  delete [] elementsInverseSelection;
  this->MaxSize=0;
  this->selected=0;
  this->elements=0;
}

int Selection::SelectionToIndex()
{ int result=0;
  for (int i=0; i<MaxSize; i++)
  { result*=2;
    if (this->selected[i])
      result+=1;
  }
  return result;
}

void Selection::ShrinkMaxSize()
{ MaxSize--;
  if (selected[MaxSize])
    CardinalitySelection--;
}

void Selection::ExpandMaxSize()
{ this->elements[this->CardinalitySelection]=this->MaxSize;
  this->selected[this->MaxSize]=true;
  this->MaxSize++;
  this->CardinalitySelection++;
}

void Selection::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

void Selection::WriteToFile(std::fstream& output)
{ output << "Sel_max_size: " << this->MaxSize << " cardinality: " << this->CardinalitySelection << " ";
  for (int i=0; i<this->CardinalitySelection; i++)
    output << this->elements[i] << " ";
}

void Selection::ReadFromFile(std::fstream& input)
{ std::string tempS; int tempI, card;
  input >> tempS >> tempI;
  this->init(tempI);
  input >> tempS >> card;
  assert(tempS=="cardinality:");
  for (int i=0; i<card; i++)
  { input>>tempI;
    this->AddSelectionAppendNewIndex(tempI);
  }
}

void Selection::ElementToString(std::string& output)
{ std::stringstream out;
  out << "Cardinality: " << this->CardinalitySelection << "\n";
  for (int i=0; i<this->CardinalitySelection; i++)
    out << this->elements[i] << ", ";
  output=out.str();
}

void Selection::incrementSelection()
{ for (int i=this->MaxSize-1; i>=0; i--)
  { this->selected[i]=!this->selected[i];
    if (this->selected[i])
    { this->ComputeIndicesFromSelection();
      return;
    }
  }
  this->ComputeIndicesFromSelection();
}

void Selection::incrementSelectionFixedCardinality(int card, int& IndexLastZeroWithOneBefore, int& NumOnesAfterLastZeroWithOneBefore)
{ //example of the order of generation of all combinations when card=2 and MaxSize=5. The second column indicates the
  //state of the array at the point in code marked with *** below
  //11000     (->10000) IndexLastZeroWithOneBefore: 2 NumOnesAfterLastZeroWithOneBefore: 0
  //10100     (->10000) IndexLastZeroWithOneBefore: 3 NumOnesAfterLastZeroWithOneBefore: 0
  //10010     (->10000) IndexLastZeroWithOneBefore: 4 NumOnesAfterLastZeroWithOneBefore: 0
  //10001     (->00000) IndexLastZeroWithOneBefore: 1 NumOnesAfterLastZeroWithOneBefore: 1
  //01100     (->01000) IndexLastZeroWithOneBefore: 3 NumOnesAfterLastZeroWithOneBefore: 0
  //01010     (->01000) IndexLastZeroWithOneBefore: 4 NumOnesAfterLastZeroWithOneBefore: 0
  //01001     (->00000) IndexLastZeroWithOneBefore: 2 NumOnesAfterLastZeroWithOneBefore: 1
  //00110     (->00100) IndexLastZeroWithOneBefore: 4 NumOnesAfterLastZeroWithOneBefore: 0
  //00101     (->00000) IndexLastZeroWithOneBefore: 3 NumOnesAfterLastZeroWithOneBefore: 1
  //00011
  if (card>this->MaxSize)
    return;
  if (this->CardinalitySelection!=card)
  { this->initNoMemoryAllocation();
    for (int i=0; i<card; i++)
    { this->selected[i]=true;
      this->elements[i]=i;
    }
    IndexLastZeroWithOneBefore=0;
    this->CardinalitySelection=card;
    return;
  }
  if(card==this->MaxSize || card==0)
    return;
  IndexLastZeroWithOneBefore=-1;
  NumOnesAfterLastZeroWithOneBefore=0;
  for(int i=this->MaxSize-1; i>=0; i--)
  { if (this->selected[i])
    { if (IndexLastZeroWithOneBefore==-1)
        NumOnesAfterLastZeroWithOneBefore++;
      else
        break;
    }
    else
      IndexLastZeroWithOneBefore=i;
  }
  if (IndexLastZeroWithOneBefore==0)
    return;
  for(int i=0; i<NumOnesAfterLastZeroWithOneBefore+1; i++)
    this->selected[this->elements[this->CardinalitySelection-i-1]]=false;
  //***At this point in time the second column is recorded
  for(int i=0; i<NumOnesAfterLastZeroWithOneBefore+1; i++)
  { this->selected[i+ IndexLastZeroWithOneBefore]=true;
    this->elements[this->CardinalitySelection+i-NumOnesAfterLastZeroWithOneBefore-1] = i+ IndexLastZeroWithOneBefore;
  }
}

void Selection::ComputeIndicesFromSelection()
{ this->CardinalitySelection=0;
  for (int i=0; i<this->MaxSize; i++)
  { if (this->selected[i])
    { this->elements[CardinalitySelection]=i;
      this->CardinalitySelection++;
    }
//    else
//    {  elementsInverseSelection[i-CardinalitySelection]=i;
//    }
  }
}

void Selection::initNoMemoryAllocation()
{ for (int i = 0; i<this->CardinalitySelection; i++)
    this->selected[this->elements[i]]=false;
  this->CardinalitySelection = 0;
}

void Selection::MakeSubSelection(Selection &theSelection, Selection &theSubSelection)
{ this->init(theSelection.MaxSize);
  for(int i=0; i<theSubSelection.CardinalitySelection; i++)
    this->AddSelectionAppendNewIndex(theSelection.elements[theSubSelection.elements[i]]);
}

void Selection::Assign(const Selection& right)
{ if (this==&right)
    return;
  if (this->MaxSize!=right.MaxSize)
    this->init(right.MaxSize);
  else
    this->initNoMemoryAllocation();
  for (int i=0; i<right.CardinalitySelection; i++)
  { this->elements[i]=right.elements[i];
    this->selected[this->elements[i]]=true;
  }
  this->CardinalitySelection=right.CardinalitySelection;
}

int Selection::HashFunction() const
{ int tempMin=MathRoutines::Minimum(SomeRandomPrimesSize, this->MaxSize);
  int result=0;
  for (int i=0; i<tempMin; i++)
    if (this->selected[i])
      result+=i*SomeRandomPrimes[i];
  return result;
}

void root::RootPlusRootTimesScalar(root& r1, root& r2, Rational& rat, root& output)
{ Rational tempRat;
  assert(r1.size==r2.size);
  output.Assign(r1);
  for (int i=0; i<r1.size; i++)
  { tempRat.Assign(r2.TheObjects[i]);
    tempRat.MultiplyBy(rat);
    output.TheObjects[i]+=(tempRat);
    //r1.ComputeDebugString();
  }
}

void root::RootScalarRoot(root& r1, root& r2, MatrixLargeRational& KillingForm, Rational& output)
{ Rational tempRat;
  assert(r1.size==KillingForm.NumRows && r1.size==r2.size && r1.size==KillingForm.NumCols);
  output.MakeZero();
  for (int i=0; i<KillingForm.NumRows; i++)
    for(int j =0; j<KillingForm.NumCols; j++)
    { tempRat.Assign(r1.TheObjects[i]);
      tempRat.MultiplyBy(KillingForm.elements[i][j]);
      tempRat.MultiplyBy(r2.TheObjects[j]);
      output+=(tempRat);
    }
}

void root::RootScalarEuclideanRoot(const root& r1, const  root& r2, Rational& output)
{ Rational tempRat;
  if (r1.size!=r2.size)
  { int* x;
    x=0;
    *x=5;
  }
  assert(r1.size==r2.size);
  output.MakeZero();
  for(int i=0; i<r1.size; i++)
  { tempRat.Assign(r1.TheObjects[i]);
    tempRat.MultiplyBy(r2.TheObjects[i]);
    output+=(tempRat);
  }
}

void root::GetCoordsInBasis(roots& inputBasis, root& outputCoords, GlobalVariables& theGlobalVariables)
{ roots& tempRoots=theGlobalVariables.rootsGetCoordsInBasis;
  MatrixLargeRational& tempMat=theGlobalVariables.matGetCoordsInBasis;
  tempRoots.size=0;
  tempRoots.AddListOnTop(inputBasis);
  tempRoots.AddObjectOnTop(*this);
//  tempRoots.ComputeDebugString();
//  tempMat.ComputeDebugString();
//  this->ComputeDebugString();
  bool tempBool=tempRoots.GetLinearDependence(tempMat);
//  tempRoots.ComputeDebugString();
//  tempMat.ComputeDebugString();
  assert(tempBool);
  tempMat.DivideByRational(tempMat.elements[tempMat.NumRows-1][0]);
  outputCoords.SetSize(tempMat.NumRows-1);
  for (int i=0; i<tempMat.NumRows-1; i++)
  { tempMat.elements[i][0].Minus();
    outputCoords.TheObjects[i].Assign(tempMat.elements[i][0]);
  }
}

inline void roots::Pop(int index)
{ this->PopIndexSwapWithLast(index);
}

inline void roots::AddRoot(root &r)
{ this->AddObjectOnTop(r);
}

void roots::WriteToFile(std::fstream& output, GlobalVariables& theGlobalVariables)
{ int theDimension=0;
  if (this->size>0)
    theDimension= this->TheObjects[0].size;
  output << "Num_roots|Dim: " << this->size << " " << theDimension << " ";
  if (this->size<1)
    return;
  for (int i=0; i<this->size; i++)
    for (int j=0; j<theDimension; j++)
    { this->TheObjects[i].TheObjects[j].WriteToFile(output);
      output << " ";
    }
  output << "\n";
}

void roots::ReadCivilizedHumanReadableFormat(std::stringstream& input)
{ int numRoots, theDimension;
  std::string tempS;
  tempS=input.str();
  std::stringstream tempI;
  bool firstOpenBracketFound=false;
  int numClosedBrackets=0;
  int numCommas=0;
  for (int i=0; i<(signed) tempS.size(); i++)
  { if (tempS.at(i)=='(' && ! firstOpenBracketFound)
      firstOpenBracketFound=true;
    if(tempS.at(i)==')' )
      numClosedBrackets++;
    if(tempS.at(i)==',' && numClosedBrackets==0 && firstOpenBracketFound)
      numCommas++;
    if (tempS.at(i)=='(' || tempS.at(i)==')' || tempS.at(i)==',')
      tempS[i]=' ';
  }
  theDimension=numCommas+1;
  numRoots=numClosedBrackets;
  tempI << tempS;
  tempI.seekg(0);
  this->SetSize(numRoots);
  for (int i=0; i<numRoots; i++)
  { this->TheObjects[i].MakeZero(theDimension);
    for(int j=0; j<theDimension; j++)
    { int x;
      tempI >> x;
      this->TheObjects[i].TheObjects[j]=x;
    }
  }
}

void roots::ReadFromFile (std::fstream &input, GlobalVariables& theGlobalVariables)
{ std::string tempS;
  input >> tempS;
  assert (tempS=="Num_roots|Dim:");
  int theDim, theSize;
  input >> theSize >> theDim;
  if (theSize<0)
    theSize=0;
  this->SetSize(theSize);
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].SetSize(theDim);
    for (int j=0; j<theDim; j++)
      this->TheObjects[i].TheObjects[j].ReadFromFile(input);
  }
}

inline void roots::AddIntRoot(intRoot& r)
{ this->SetSize(this->size+1);
  this->TheObjects[this->size-1].AssignIntRoot(r);
}

bool roots::PerturbVectorToRegular(root& output, GlobalVariables& theGlobalVariables, int theDimension)
{ root normal;
  bool result=false;
  while (!this->IsRegular(output, normal, theGlobalVariables, theDimension))
  { result=true;
    normal.DivByInteger(10);
    output.Add(normal);
  }
  if (result)
    output.ScaleToIntegralMinHeight();
  return result;
}

int roots::GetRankOfSpanOfElements(GlobalVariables& theGlobalVariables)const
{ Selection& NonPivotPoints= theGlobalVariables.selGetRankOfSpanOfElements;
  MatrixLargeRational& tempMatrix=theGlobalVariables.matGetRankOfSpanOfElements;
  if (this->size==0)
    return 0;
  int theDimension= this->TheObjects[0].size;
  this->GaussianEliminationForNormalComputation(tempMatrix, NonPivotPoints, theDimension);
  return (theDimension-NonPivotPoints.CardinalitySelection);
}

bool roots::GetMinLinearDependenceWithNonZeroCoefficientForFixedIndex(MatrixLargeRational& outputTheLinearCombination, int theIndex)
{ return false;
}

void roots::GetLinearDependenceRunTheLinearAlgebra(MatrixLargeRational& outputTheLinearCombination, MatrixLargeRational& outputTheSystem, Selection& outputNonPivotPoints)
{ if (this->size==0)
    return;
  int Dimension=(int) this->TheObjects[0].size;
  outputTheSystem.init(Dimension, (int)this->size);
  MatrixLargeRational matOutputEmpty;
  matOutputEmpty.init(-1, -1);
  for(int i=0; i<this->size; i++)
    for(int j=0; j<Dimension; j++)
      outputTheSystem.elements[j][i].Assign(this->TheObjects[i].TheObjects[j]);
  //tempMat.ComputeDebugString();
  MatrixLargeRational::GaussianEliminationByRows(outputTheSystem, matOutputEmpty, outputNonPivotPoints);
  //tempMat.ComputeDebugString();
}

bool roots::GetLinearDependence(MatrixLargeRational& outputTheLinearCombination)
{ MatrixLargeRational tempMat;
  Selection nonPivotPoints;
  this->GetLinearDependenceRunTheLinearAlgebra(outputTheLinearCombination, tempMat, nonPivotPoints);
  if (nonPivotPoints.CardinalitySelection==0)
    return false;
  tempMat.NonPivotPointsToEigenVectorMatrixForm(nonPivotPoints, outputTheLinearCombination, ROne, RZero);
  //outputTheLinearCombination.ComputeDebugString();
  return true;
}

void roots::GaussianEliminationForNormalComputation(MatrixLargeRational& inputMatrix, Selection& outputNonPivotPoints, int theDimension) const
{ inputMatrix.init((int)this->size, (int)theDimension);
  MatrixLargeRational matOutputEmpty;
  matOutputEmpty.init(-1, -1);
  outputNonPivotPoints.init(theDimension);
  for(int i=0; i<this->size; i++)
    for(int j=0; j<theDimension; j++)
      inputMatrix.elements[i][j].Assign(this->TheObjects[i].TheObjects[j]);
  MatrixLargeRational::GaussianEliminationByRows(inputMatrix, matOutputEmpty, outputNonPivotPoints);
}

void roots::ComputeNormal(root& output)
{ if (this->size==0)
    return;
  int theDimension= this->TheObjects[0].size;
  MatrixLargeRational tempMatrix;
  Selection NonPivotPoints;
  NonPivotPoints.init(theDimension);
  output.SetSize(theDimension);
  this->GaussianEliminationForNormalComputation(tempMatrix, NonPivotPoints, theDimension);
  if (NonPivotPoints.CardinalitySelection!=1)
    return;
  tempMatrix.NonPivotPointsToRoot(NonPivotPoints, output);
}

bool roots::IsRegular(root& r, GlobalVariables& theGlobalVariables, int theDimension)
{ root tempRoot;
  return this->IsRegular(r, tempRoot, theGlobalVariables, theDimension);
}

bool roots::IsRegular(root& r, root& outputFailingNormal, GlobalVariables& theGlobalVariables, int theDimension)
{ Selection& WallSelection=theGlobalVariables.selWallSelection;
  WallSelection.init(this->size);
  int x= MathRoutines::NChooseK(this->size, theDimension-1);
  for (int i=0; i<x; i++)
  { WallSelection.incrementSelectionFixedCardinality(theDimension-1);
    root tempRoot;
    if (this->ComputeNormalFromSelection(tempRoot, WallSelection, theGlobalVariables, theDimension))
    { Rational tempRat;
      root::RootScalarEuclideanRoot(tempRoot, r, tempRat);
      if (tempRat.IsEqualToZero())
      { outputFailingNormal.Assign(tempRoot);
        return false;
      }
    }
  }
  return true;
}

bool roots::ComputeNormalExcludingIndex(root& output, int index, GlobalVariables& theGlobalVariables)
{ MatrixLargeRational& tempMatrix=theGlobalVariables.matComputeNormalExcludingIndex;
  MatrixLargeRational matOutputEmpty;
  Selection& NonPivotPoints=theGlobalVariables.selComputeNormalExcludingIndex;
  if (this->size==0)
    return false;
  int theDimension= this->TheObjects[0].size;
  output.SetSize(theDimension);
  tempMatrix.init((int)this->size-1, (int)theDimension);
  matOutputEmpty.init(-1, -1);
  int k=-1;
  for(int i=0; i<this->size; i++)
    if (i!=index)
    { k++;
      for(int j=0; j<theDimension; j++)
        tempMatrix.elements[k][j].Assign(this->TheObjects[i].TheObjects[j]);
    }
  tempMatrix.ComputeDebugString();
  MatrixLargeRational::GaussianEliminationByRows(tempMatrix, matOutputEmpty, NonPivotPoints);
  if (NonPivotPoints.CardinalitySelection!=1)
    return false;
  tempMatrix.NonPivotPointsToRoot(NonPivotPoints, output);
  return true;
}

bool roots::ComputeNormalFromSelection(root& output, Selection& theSelection, GlobalVariables& theGlobalVariables, int theDimension)
{ MatrixLargeRational& tempMatrix= theGlobalVariables.matComputeNormalFromSelection;
  MatrixLargeRational& matOutputEmpty=theGlobalVariables.matOutputEmpty;
  Selection& NonPivotPoints=theGlobalVariables.selComputeNormalFromSelection;
  matOutputEmpty.init(-1, -1);
  output.SetSize(theDimension);
  tempMatrix.init((int)theSelection.CardinalitySelection, (int)theDimension);
  for(int i=0; i<theSelection.CardinalitySelection; i++)
    for(int j=0; j<theDimension; j++)
      tempMatrix.elements[i][j].Assign(this->TheObjects[theSelection.elements[i]].TheObjects[j]);
  MatrixLargeRational::GaussianEliminationByRows(tempMatrix, matOutputEmpty, NonPivotPoints);
  if (NonPivotPoints.CardinalitySelection!=1)
    return false;
  tempMatrix.NonPivotPointsToRoot(NonPivotPoints, output);
  return true;
}

bool roots::ComputeNormalFromSelectionAndExtraRoot(root& output, root& ExtraRoot, Selection& theSelection, GlobalVariables& theGlobalVariables)
{ if (this->size==0)
    return false;
  int theDimension= this->TheObjects[0].size;
  output.SetSize(theDimension);
  MatrixLargeRational& tempMatrix=theGlobalVariables.matComputeNormalFromSelectionAndExtraRoot;
  MatrixLargeRational  matOutputEmpty;
  Selection& NonPivotPoints=theGlobalVariables.selComputeNormalFromSelectionAndExtraRoot;
  tempMatrix.init((int)theSelection.CardinalitySelection+1, (int)theDimension);
  matOutputEmpty.init(-1, -1);
  for(int j=0; j<theDimension; j++)
  { for(int i=0; i<theSelection.CardinalitySelection; i++)
      tempMatrix.elements[i][j].Assign(this->TheObjects[theSelection.elements[i]].TheObjects[j]);
    tempMatrix.elements[theSelection.CardinalitySelection][j].Assign(ExtraRoot.TheObjects[j]);
  }
  MatrixLargeRational::GaussianEliminationByRows(tempMatrix, matOutputEmpty, NonPivotPoints);
  if (NonPivotPoints.CardinalitySelection!=1)
    return false;
  tempMatrix.NonPivotPointsToRoot(NonPivotPoints, output);
  return true;
}


bool roots::ComputeNormalFromSelectionAndTwoExtraRoots( root& output, root& ExtraRoot1, root& ExtraRoot2, Selection& theSelection, GlobalVariables& theGlobalVariables)
{ MatrixLargeRational& tempMatrix= theGlobalVariables.matComputeNormalFromSelectionAndTwoExtraRoots;
  MatrixLargeRational matOutputEmpty;
  Selection& NonPivotPoints= theGlobalVariables.selComputeNormalFromSelectionAndTwoExtraRoots;
  if (this->size==0)
    return false;
  int theDimension= this->TheObjects[0].size;
  output.SetSize(theDimension);
  matOutputEmpty.init(-1, -1);
  tempMatrix.init((int)theSelection.CardinalitySelection+2, (int)theDimension);
  for(int j=0; j<theDimension; j++)
  { for(int i=0; i<theSelection.CardinalitySelection; i++)
      tempMatrix.elements[i][j].Assign(this->TheObjects[theSelection.elements[i]].TheObjects[j]);
    tempMatrix.elements[theSelection.CardinalitySelection][j].Assign(ExtraRoot1.TheObjects[j]);
    tempMatrix.elements[theSelection.CardinalitySelection+1][j].Assign(ExtraRoot2.TheObjects[j]);
  }
  MatrixLargeRational::GaussianEliminationByRows(tempMatrix, matOutputEmpty, NonPivotPoints);
  if (NonPivotPoints.CardinalitySelection!=1)
    return false;
  tempMatrix.NonPivotPointsToRoot(NonPivotPoints, output);
  return true;
}

void roots::GetGramMatrix(MatrixLargeRational& output, WeylGroup& theWeyl) const
{ output.Resize(this->size, this->size, false);
  for (int i=0; i<this->size; i++)
    for(int j=i; j<this->size; j++)
    { theWeyl.RootScalarCartanRoot(this->TheObjects[i], this->TheObjects[j], output.elements[i][j]);
      if (i!=j)
        output.elements[j][i].Assign(output.elements[i][j]);
    }
}

void roots::AssignMatrixRows(MatrixLargeRational& mat)
{ this->size=0;
  root tempRoot;
  this->SetSize(mat.NumRows);
  tempRoot.SetSize(mat.NumCols);
  for (int i=0; i<mat.NumRows; i++)
  { for (int j=0; j<mat.NumCols; j++)
      tempRoot.TheObjects[j].Assign(mat.elements[i][j]);
    this->TheObjects[i].Assign(tempRoot);
  }
}

void roots::AssignMatrixColumns(MatrixLargeRational& mat)
{ this->size=0;
  root tempRoot;
  this->SetSize(mat.NumCols);
  tempRoot.SetSize(mat.NumRows);
  for (int i=0; i<mat.NumCols; i++)
  { for (int j=0; j<mat.NumRows; j++)
      tempRoot.TheObjects[j].Assign(mat.elements[j][i]);
    this->TheObjects[i].Assign(tempRoot);
  }
}

void roots::average(root& output, int theDimension)
{ this->sum(output, theDimension);
  if (this->size==0)
    return;
  output.DivByInteger(this->size);
}

void roots::average(root& output)
{ this->sum(output);
  if (this->size==0)
    return;
  output.DivByInteger(this->size);
}

void roots::sum(root& output, int theDimension)
{ output.MakeZero(theDimension);
  for (int i=0; i<this->size; i++)
    output.Add(this->TheObjects[i]);
}

void roots::sum(root& output)
{ assert(this->size>0);
  output.MakeZero(this->TheObjects[0].size);
  for (int i=0; i<this->size; i++)
    output.Add(this->TheObjects[i]);
}

bool roots::ContainsOppositeRoots()
{ root tempRoot;
  for(int i=0; i<this->size; i++)
  { tempRoot.Assign(this->TheObjects[i]);
    tempRoot.MinusRoot();
    for (int j=i+1; j<this->size; j++)
      if (this->TheObjects[j].IsEqualTo(tempRoot))
        return true;
  }
  return false;
}

void roots::AddRootSnoRepetition(roots &r)
{ for (int i=0; i<r.size; i++)
    this->AddRootNoRepetition(r.TheObjects[i]);
}

bool roots::operator ==(const roots& right)const
{ if (this->size!= right.size)
    return false;
  for (int i=0; i<right.size; i++)
  { if (!this->TheObjects[i].IsEqualTo(right.TheObjects[i]))
      return false;
  }
  return true;
}

void roots::AssignIntRoots(intRoots& r)
{ this->size=0;
  root tempRoot;
  for (int i=0; i<r.size; i++)
  { tempRoot.AssignIntRoot(r.TheObjects[i]);
    this->AddRoot(tempRoot);
  }
}

void roots::AssignHashedIntRoots(HashedList<intRoot>& r)
{ this->size=0;
  root tempRoot;
  for (int i=0; i<r.size; i++)
  { tempRoot.AssignIntRoot(r.TheObjects[i]);
    this->AddRoot(tempRoot);
  }
}

bool roots::CheckForElementSanity()
{ for(int i=0; i<this->size; i++)
    if (!this->TheObjects[i].CheckForElementSanity())
      return false;
  return true;
}

bool roots::AddRootNoRepetition(root& r)
{ if (this->IndexOfObject(r)==-1)
  { this->AddObjectOnTop(r);
    return true;
  }
  return false;
}

int roots::GetDimensionOfElements()
{ if (this->size==0)
    return -1;
  int result= this->TheObjects[0].size;
  for(int i=1; i<this->size; i++)
    assert(this->TheObjects[i].size==result);
  return result;
}

void roots::intersectWith(roots& right, roots& output)
{//this is slow please use the hashed version when speed is needed!
  output.MakeActualSizeAtLeastExpandOnTop(this->size);
  output.size=0;
  for (int i=0; i<this->size; i++)
    if (right.ContainsObject(this->TheObjects[i]))
      output.AddRoot(this->TheObjects[i]);
}

bool roots::ContainsARootNonPerpendicularTo(root& input, WeylGroup& theWeyl)
{ Rational tempRat;
  for (int i=0; i<this->size; i++)
  { theWeyl.RootScalarCartanRoot(this->TheObjects[i], input, tempRat);
    if(!tempRat.IsEqualToZero())
      return true;
  }
  return false;
}

bool roots::ContainsARootNonStronglyPerpendicularTo(root& input, WeylGroup& theWeyl)
{ Rational tempRat;
  for (int i=0; i<this->size; i++)
    if (theWeyl.IsARoot(this->TheObjects[i]+input))
      return true;
  return false;
}

int roots::NumRootsConnectedTo(root& input, WeylGroup& theWeyl)
{ Rational tempRat;
  int result=0;
  for (int i=0; i<this->size; i++)
  { theWeyl.RootScalarCartanRoot(this->TheObjects[i], input, tempRat);
    if(!tempRat.IsEqualToZero())
      result++;
  }
  return result;
}

void roots::MakeEiBasis(int theDimension)
{ this->SetSize(theDimension);
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].MakeEi(theDimension, i);
}

void roots::MakeBasisChange(root& input, root& output) const
{ int theDimension=input.size;
  assert(theDimension==this->size);
  assert(&input!=&output);
  root tempRoot2;
  output.MakeZero(theDimension);
  for (int j=0; j<theDimension; j++)
  { tempRoot2.Assign(this->TheObjects[j]);
    tempRoot2.MultiplyByLargeRational(input.TheObjects[j]);
    output.Add(tempRoot2);
  }
}

void roots::MakeBasisChange(roots& input, roots& output)const
{ assert(&input!=&output);
  output.SetSize(input.size);
   for (int i=0; i<input.size; i++)
    this->MakeBasisChange(input.TheObjects[i], output.TheObjects[i]);
}

void roots::GetCoordsInBasis(roots& inputBasis, roots& outputCoords, GlobalVariables& theGlobalVariables)
{ assert(this!=&outputCoords);
  outputCoords.SetSize(this->size);
  for(int i=0; i<this->size; i++)
    this->TheObjects[i].GetCoordsInBasis(inputBasis, outputCoords.TheObjects[i], theGlobalVariables);
}

int roots::ArrangeFirstVectorsBeOfMaxPossibleRank(GlobalVariables& theGlobalVariables)
{ if (this->size==0)
    return 0;
  int theDimension= this->GetDimensionOfElements();
  Selection NonPivotPoints;
  MatrixLargeRational tempMatrix;
  roots tempRoots;
  int oldRank=0;
  for (int i=0; i<this->size; i++)
  { tempRoots.AddObjectOnTop(this->TheObjects[i]);
    int newRank= tempRoots.GetRankOfSpanOfElements(theGlobalVariables);
    if (newRank==oldRank)
      tempRoots.PopIndexSwapWithLast(tempRoots.size-1);
    else
    { this->SwapTwoIndices(oldRank, i);
      assert(oldRank+1==newRank);
      oldRank=newRank;
    }
    if (oldRank== theDimension)
      return theDimension;
  }
  return (oldRank);
}

inline bool Rational::IsEqualTo(const Rational& b) const
{ if (this->Extended==0 && b.Extended==0)
    return (this->NumShort*b.DenShort==b.NumShort*this->DenShort);
  Rational tempRat;
  tempRat.Assign(*this);
  tempRat.Subtract(b);
  return tempRat.IsEqualToZero();
}

inline bool Rational::IsGreaterThanOrEqualTo(Rational& right)
{ if (this->Extended==0 && right.Extended==0)
    return (this->NumShort*right.DenShort>=right.NumShort*this->DenShort);
  Rational tempRat;
  tempRat.Assign(*this);
  tempRat.Subtract(right);
  return tempRat.IsNonNegative();
}

inline void Rational::ElementToString(std::string& output)const
{ std::stringstream out;
  if (this->Extended==0)
  { out << this->NumShort;
    if (this->DenShort!=1)
      out << "/" << this->DenShort;
  } else
  { std::string tempS;
    this->Extended->num.ElementToString(tempS);
    out << tempS;
    this->Extended->den.ElementToString(tempS);
    if (tempS!="1")
      out << "/" << tempS;
  }
  output = out.str();
}

void CombinatorialChamber::AddInternalWall(root& TheKillerFacetNormal, root& TheFacetBeingKilledNormal, root& direction, CombinatorialChamberContainer& owner, GlobalVariables& theGlobalVariables)
{ //Warning: the below code is false!
  //if (this->flagExplored)
  //  return;
  //Explanation:
  root tempRoot; tempRoot.Assign(TheKillerFacetNormal);
  tempRoot.ScaleToIntegralMinHeightFirstNonZeroCoordinatePositive();
  if (!owner.flagMakingASingleHyperplaneSlice)
    this->InternalWalls.AddRootNoRepetition(tempRoot);
  if (owner.flagMakingASingleHyperplaneSlice && !this->flagExplored)
    if (!owner.flagSliceWithAWallIgnorePermanentlyZero || !this->flagPermanentlyZero)
      owner.PreferredNextChambers.AddOnTopNoRepetition(this->IndexInOwnerComplex);
}

bool CombinatorialChamber::CheckSplittingPointCandidate(Selection& SelectionTargetSimplex, Selection& SelectionStartSimplex, MatrixLargeRational& outputColumn, int Dimension)
{ for (int i=0; i<SelectionStartSimplex.CardinalitySelection; i++)
    if (outputColumn.elements[i][0].IsNonPositive())
      return false;
  if (outputColumn.elements[Dimension-1 ][0].IsNonPositive())
    return false;
  return true;
}

bool CombinatorialChamber::ComputeDebugString(CombinatorialChamberContainer& owner)
{ PolynomialOutputFormat PolyFormatLocal;
  this->ElementToString(this->DebugString, owner, PolyFormatLocal);
  return true;
}

void CombinatorialChamber::ChamberNumberToString(std::string& output, CombinatorialChamberContainer& owner)
{ std::stringstream out;
  if (this->flagHasZeroPolynomiaL)
    out << "Invisible";
  else
    out << "c";
  if (this->DisplayNumber!=-1)
    out << this->DisplayNumber;
  else
    out << this->CreationNumber;
  if (this->flagPermanentlyZero)
    out << " (Permanently zero)";
  if (this->flagExplored)
    out << "(Explored)";
  output=out.str();
}

bool CombinatorialChamber::ElementToString(std::string& output, CombinatorialChamberContainer& owner, PolynomialOutputFormat& PolyFormatLocal)
{ return this->ElementToString(output, owner, false, false, PolyFormatLocal);
}

bool CombinatorialChamber::HasAsNeighbor(CombinatorialChamber* candidateNeighbor)
{ for (int i=0; i<this->Externalwalls.size; i++)
    for (int j=0; j<this->Externalwalls.TheObjects[i].NeighborsAlongWall.size; j++)
      if (candidateNeighbor==this->Externalwalls.TheObjects[i].NeighborsAlongWall.TheObjects[j])
        return true;
  return false;
}

bool CombinatorialChamber::HasNoNeighborsThatPointToThis()
{ for (int i=0; i<this->Externalwalls.size; i++)
    for (int j=0; j<this->Externalwalls.TheObjects[i].NeighborsAlongWall.size; j++)
      if (this->Externalwalls.TheObjects[i].NeighborsAlongWall.TheObjects[j]!=0)
        if (this->Externalwalls.TheObjects[i].NeighborsAlongWall.TheObjects[j]->HasAsNeighbor(this))
          return false;
  return true;
}

void CombinatorialChamber::GetWallNormals(roots& output)
{ output.SetSize(this->Externalwalls.size);
  for (int i=0; i<this->Externalwalls.size; i++)
    output.TheObjects[i].Assign(this->Externalwalls.TheObjects[i].normal);
}

bool CombinatorialChamber::ConsistencyCheck(int theDimension, bool checkVertices, CombinatorialChamberContainer& ownerComplex, GlobalVariables& theGlobalVariables)
{ for (int i=0; i<this->Externalwalls.size; i++)
   if (!this->Externalwalls.TheObjects[i].ConsistencyCheck(*this, ownerComplex))
      return false;
  if (this->flagPermanentlyZero)
    return true;
  roots tempRoots;
  if (checkVertices)
  { for (int i=0; i<this->Externalwalls.size; i++)
    { Rational tempRat;
      this->ComputeInternalPoint(this->InternalPoint, theDimension);
      root::RootScalarEuclideanRoot(this->InternalPoint, this->Externalwalls.TheObjects[i].normal, tempRat);
      if (tempRat.IsNonPositive())
      { ownerComplex.WriteReportToFile("./ChambersNonConvexError.html", false);
        assert(false);
        return false;
      }
      for (int i=0; i<this->AllVertices.size; i++)
        if(!this->PointIsAVertex(this->AllVertices.TheObjects[i], theGlobalVariables))
        { this->PointIsAVertex(this->AllVertices.TheObjects[i], theGlobalVariables);
          this->ComputeDebugString(ownerComplex);
          assert(false);
          return false;
        }
/*      WallData& currentWall= this->Externalwalls.TheObjects[i];
      for (int l=0; l<currentWall.NeighborsAlongWall.size; l++)
        if (currentWall.NeighborsAlongWall.TheObjects[l])
        { CombinatorialChamber& other =*currentWall.NeighborsAlongWall.TheObjects[l];
          tempRoots.size=0;
          tempRoots.AddListOnTop(this->AllVertices);
          tempRoots.AddRootSnoRepetition(other.AllVertices);
          for (int m=0; m<tempRoots.size; m++)
            if (currentWall.normal.OurScalarProductIsZero(tempRoots.TheObjects[m]))
            { tempRoots.PopIndexSwapWithLast(m);
              m--;
            }
          if (tempRoots.size<ownerComplex.AmbientDimension-1)
          { assert(false);
            return false;
          }
        }*/
    }
   /* for (int i=0; i<ownerComplex.size; i++)
      if (ownerComplex.TheObjects[i]!=0 && ownerComplex.TheObjects[i]!=this)
        if (this->PointIsInChamber(ownerComplex.TheObjects[i]->InternalPoint))
        { ownerComplex.WriteReportToFile("./ChambersNonConvexError.html", false);
          assert(false);
          return false;
        }*/
  }
  return true;
}

CombinatorialChamber::CombinatorialChamber()
{ this->flagNormalsAreSorted=false;
  this->flagHasZeroPolynomiaL = true;
  this->IndexInOwnerComplex=-1;
  this->IndexStartingCrossSectionNormal=-1;
  this->flagExplored=false;
  this->DisplayNumber=-1;
  this->flagPermanentlyZero=false;
  this->NumTrueAffineVertices=-1;
}

bool CombinatorialChamber::ProjectToDefaultAffineSpace(CombinatorialChamberContainer* owner, GlobalVariables& theGlobalVariables)
{ this->affineExternalWalls.MakeActualSizeAtLeastExpandOnTop(this->Externalwalls.size);
  this->affineVertices.MakeActualSizeAtLeastExpandOnTop(this->AllVertices.size);
  this->affineExternalWalls.size=0;
  this->affineVertices.size=0;
  root tempCrossSectionNormal, tempAffinePoint;
  tempCrossSectionNormal.AssignWithoutLastCoordinate(owner->StartingCrossSections.TheObjects[this->IndexStartingCrossSectionNormal].normal);
  tempAffinePoint.AssignWithoutLastCoordinate(owner->StartingCrossSections.TheObjects[this->IndexStartingCrossSectionNormal].affinePoint);
  for (int i=0; i<this->Externalwalls.size; i++)
  { affineHyperplane tempAH;
    if (this->Externalwalls.TheObjects[i].normal.MakeAffineProjectionFromNormal(tempAH))
      this->affineExternalWalls.AddObjectOnTop(tempAH);
  }
  Rational tempScalarProd1, tempRat;
  root::RootScalarEuclideanRoot(tempCrossSectionNormal, tempAffinePoint, tempScalarProd1);
  owner->StartingCrossSections.TheObjects[this->IndexStartingCrossSectionNormal].normal.ComputeDebugString();
  owner->StartingCrossSections.TheObjects[this->IndexStartingCrossSectionNormal].affinePoint.ComputeDebugString();
  //this->ComputeDebugString(owner);
  root tempRoot;
  for (int i=0; i<this->AllVertices.size; i++)
    if (this->AllVertices.TheObjects[i].ProjectToAffineSpace(tempRoot))
    { root::RootScalarEuclideanRoot(tempCrossSectionNormal, tempRoot, tempRat);
      if (tempRat.IsEqualTo(tempScalarProd1))
      {  //for (int i=0; i<owner->StartingCrossSections.size; i++)
        { owner->StartingCrossSections.TheObjects[this->IndexStartingCrossSectionNormal].affinePoint.MultiplyByInteger(2);
//          owner->StartingCrossSections.TheObjects[i].affinePoint.DivByInteger(3);
        }
        return false;
      }
      this->affineVertices.AddObjectOnTop(tempRoot);
    }
  this->NumTrueAffineVertices= this->affineVertices.size;
  for (int i=0; i<this->AllVertices.size; i++)
    if (!this->AllVertices.TheObjects[i].ProjectToAffineSpace(tempRoot))
    { Selection tempSel;
      this->findWallsIncidentWithVertexExcludeWallAtInfinity(this->AllVertices.TheObjects[i], tempSel, owner);
      assert(tempSel.CardinalitySelection>=owner->AmbientDimension-2);
      this->ComputeAffineInfinityPointApproximation(tempSel, owner, theGlobalVariables);
    }
  //this->ComputeDebugString(owner);
  return true;
}

void CombinatorialChamber::PurgeInternalWalls()
{ this->InternalWalls.size=0;
}

void CombinatorialChamber::ComputeAffineInfinityPointApproximation(Selection& selectedExternalWalls, CombinatorialChamberContainer* owner, GlobalVariables& theGlobalVariables)
{ root candidateVertex;
  Selection& subSelection = theGlobalVariables.selComputeAffineInfinityPointApproximation1;
  Selection& tempSel = theGlobalVariables.selComputeAffineInfinityPointApproximation2;
  tempSel.init(selectedExternalWalls.CardinalitySelection);
  int tempI = MathRoutines::NChooseK(selectedExternalWalls.CardinalitySelection, owner->AmbientDimension-2);
  for (int i=0; i<tempI; i++)
  { tempSel.incrementSelectionFixedCardinality(owner->AmbientDimension-2);
    subSelection.MakeSubSelection(selectedExternalWalls, tempSel);
    if (this->LinearAlgebraForVertexComputationOneAffinePlane(subSelection, candidateVertex, theGlobalVariables, owner))
      this->affineVertices.AddObjectOnTop(candidateVertex);
  }
}

void CombinatorialChamber::findWallsIncidentWithVertexExcludeWallAtInfinity(root& theVertex, Selection &output, CombinatorialChamberContainer* owner)
{ output.init(this->Externalwalls.size);
  root tempRoot;
  tempRoot.MakeZero(owner->AmbientDimension);
  tempRoot.LastObject()->MakeOne();
  for (int i=0; i<this->Externalwalls.size; i++)
    if (theVertex.OurScalarProductIsZero(this->Externalwalls.TheObjects[i].normal)&&!this->Externalwalls.TheObjects[i].normal.IsEqualTo(tempRoot))
      output.AddSelectionAppendNewIndex(i);
}

int CombinatorialChamber::getIndexInfiniteHyperplane(CombinatorialChamberContainer& owner)
{ root tempRoot; tempRoot.MakeZero(owner.AmbientDimension);
  tempRoot.LastObject()->MakeOne();
  for(int i=0; i<this->Externalwalls.size; i++)
    if (this->Externalwalls.TheObjects[i].normal.IsEqualTo(tempRoot))
      return i;
  return -1;
}

int CombinatorialChamber::getIndexVertexIncidentWithSelection(Selection& theSel)
{ for (int i=0; i<this->AllVertices.size; i++)
    if (this->VertexIsIncidentWithSelection(this->AllVertices.TheObjects[i], theSel))
      return i;
  return -1;
}

bool CombinatorialChamber::VertexIsIncidentWithSelection(root& VertexCandidate, Selection& theSel)
{ for(int i=0; i<theSel.CardinalitySelection; i++)
    if (!this->Externalwalls.TheObjects[theSel.elements[i]].normal.OurScalarProductIsZero(VertexCandidate))
      return false;
  return true;
}

bool CombinatorialChamber::OwnsAWall(WallData* theWall)
{ for (int i=0; i<this->Externalwalls.size; i++)
    if (&this->Externalwalls.TheObjects[i]==theWall)
      return true;
  return false;
}

void CombinatorialChamber::ComputeInternalPoint(root& InternalPoint, int theDimension)
{ InternalPoint.MakeZero(theDimension);
  for (int i=0; i<this->AllVertices.size; i++)
    InternalPoint.Add(this->AllVertices.TheObjects[i]);
  InternalPoint.DivByInteger(this->AllVertices.size);
}

void CombinatorialChamber::ComputeAffineInternalPoint(root& outputPoint, int theDimension)
{ this->affineVertices.average(outputPoint, theDimension);
}

void CombinatorialChamber::LabelWallIndicesProperly()
{ for (int i=0; i<this->Externalwalls.size; i++)
    this->Externalwalls.TheObjects[i].indexInOwnerChamber=i;
}

void CombinatorialChamber::drawOutputAffine(DrawingVariables& TDV, CombinatorialChamberContainer& owner, std::fstream* LaTeXoutput)
{ TDV.ApplyScale(0.3);
  for (int i=0; i<this->affineVertices.size; i++)
  { for(int j=0; j<this->affineVertices.size; j++)
    { affineHyperplane* AreInAWall=0;
      for (int k=0; k<this->affineExternalWalls.size; k++)
       if (this->affineExternalWalls.TheObjects[k].ContainsPoint(this->affineVertices.TheObjects[i]) && this->affineExternalWalls.TheObjects[k].ContainsPoint(this->affineVertices.TheObjects[j]))
        { AreInAWall=&this->affineExternalWalls.TheObjects[k];
          break;
        }
      if (AreInAWall!=0)
      { int color = TDV.GetColorFromChamberIndex(this->IndexInOwnerComplex, LaTeXoutput);
        int penStyle = TDV.PenStyleNormal;
        if (this->flagHasZeroPolynomiaL || this->flagPermanentlyZero)
          penStyle= TDV.PenStyleInvisible;
        if (owner.AffineWallsOfWeylChambers.IndexOfObjectHash(*AreInAWall)!=-1)
          color = TDV.ColorWeylChamberWalls;
        TDV.drawLineBetweenTwoVectorsBuffer(this->affineVertices.TheObjects[i], this->affineVertices.TheObjects[j], penStyle, color, LaTeXoutput);
        root tempRoot; this->ComputeAffineInternalPoint(tempRoot, owner.AmbientDimension-1);
        std::stringstream out;
        out << this->DisplayNumber;
        std::string tempS;
        tempS=out.str();
        color = (!this->flagHasZeroPolynomiaL) ? TDV.ColorTextDefault : TDV.ColorTextZeroChamber;
        int textStyle = (!this->flagHasZeroPolynomiaL) ? TDV.TextStyleNormal : TDV.TextStyleInvisible;
        TDV.drawTextAtVectorBuffer(tempRoot, tempS, color, textStyle, LaTeXoutput);
      }
    }
  }
}

void CombinatorialChamber::ComputeVerticesFromNormals(CombinatorialChamberContainer& owner, GlobalVariables& theGlobalVariables)
{ this->AllVertices.size=0;
  Selection theSelection;
  theSelection.init(this->Externalwalls.size);
  root VertexCandidate;
  int NumCandidates = MathRoutines::NChooseK(this->Externalwalls.size, owner.AmbientDimension-1);
  for (int i=0; i<NumCandidates; i++)
  { theSelection.incrementSelectionFixedCardinality(owner.AmbientDimension-1);
    if (this->LinearAlgebraForVertexComputation(theSelection, VertexCandidate, theGlobalVariables, owner.AmbientDimension))
      if (this->PlusMinusPointIsInChamberModifyInput(VertexCandidate))
        for (int j=0; j<theSelection.CardinalitySelection; j++ )
        { //this->ScaleVertexToFitCrossSection(VertexCandidate, owner);
          this->AllVertices.AddRootNoRepetition(VertexCandidate);
        }
  }
}

bool CombinatorialChamber::ComputeVertexFromSelection(GlobalVariables& theGlobalVariables, root& output, Selection& theSelection, int theDimension)
{ if (this->LinearAlgebraForVertexComputation(theSelection, output, theGlobalVariables, theDimension))
    if (this->PlusMinusPointIsInChamberModifyInput(output))
      return true;
  return false;
}

bool CombinatorialChamber::PlusMinusPointIsInChamberModifyInput(root& point)
{ if (this->PointIsInChamber(point))
  { point.ScaleToIntegralMinHeight();
    return true;
  }
  point.MinusRoot();
  if (this->PointIsInChamber(point))
  { point.ScaleToIntegralMinHeight();
    return true;
  }
  return false;
}

bool CombinatorialChamber::ScaleVertexToFitCrossSection(root& point, CombinatorialChamberContainer& owner)
{ Rational tempRat;
  if (this->IndexStartingCrossSectionNormal==-1)
    return false;
  root::RootScalarEuclideanRoot(point,  owner.StartingCrossSections.TheObjects[this->IndexStartingCrossSectionNormal].normal, tempRat);
  if (tempRat.IsEqualToZero())
    return false;
  point.DivByLargeRational(tempRat);
  root::RootScalarEuclideanRoot(owner.StartingCrossSections.TheObjects[this->IndexStartingCrossSectionNormal].normal, owner.StartingCrossSections.TheObjects[this->IndexStartingCrossSectionNormal].affinePoint, tempRat);
  point.MultiplyByLargeRational(tempRat);
  return true;
}

bool CombinatorialChamber::PointIsStrictlyInsideChamber(const root& point)
{ for (int i=0; i<this->Externalwalls.size; i++)
  { Rational tempRat;
    root::RootScalarEuclideanRoot(this->Externalwalls.TheObjects[i].normal, point, tempRat);
    if (tempRat.IsNonPositive())
      return false;
  }
  return true;
}

bool CombinatorialChamber::PointIsInChamber(const root& point)
{ for (int i=0; i<this->Externalwalls.size; i++)
  { Rational tempRat;
    root::RootScalarEuclideanRoot(this->Externalwalls.TheObjects[i].normal, point, tempRat);
    if (tempRat.IsNegative())
      return false;
  }
  return true;
}

bool CombinatorialChamber::PointIsOnChamberBorder(const root& point)
{ bool found=false;
  for (int i=0; i<this->Externalwalls.size; i++)
  { Rational tempRat;
    root::RootScalarEuclideanRoot(this->Externalwalls.TheObjects[i].normal, point, tempRat);
    if (tempRat.IsNegative())
      return false;
    if (tempRat.IsEqualToZero())
      found=true;
  }
  return found;
}

bool CombinatorialChamber::PointIsAVertex(const root& point, GlobalVariables& theGlobalVariables)
{ roots WallsContainingPoint; WallsContainingPoint.MakeActualSizeAtLeastExpandOnTop(point.size-1);
  for (int i=0; i<this->Externalwalls.size; i++)
  { if (this->Externalwalls.TheObjects[i].normal.OurScalarProductIsZero(point))
      WallsContainingPoint.AddObjectOnTop(this->Externalwalls.TheObjects[i].normal);
    int rank=WallsContainingPoint.GetRankOfSpanOfElements(theGlobalVariables);
    if (rank<WallsContainingPoint.size)
      WallsContainingPoint.PopLastObject();
    if (rank==point.size-1)
      return true;
  }
  return false;
}

bool ConeGlobal::PointIsAVertex(const roots& coneNormals, root& thePoint, GlobalVariables& theGlobalVariables)
{ roots WallsContainingPoint; WallsContainingPoint.MakeActualSizeAtLeastExpandOnTop(thePoint.size-1);
  for (int i=0; i<coneNormals.size; i++)
  { if (coneNormals.TheObjects[i].OurScalarProductIsZero(thePoint))
      WallsContainingPoint.AddObjectOnTop(coneNormals.TheObjects[i]);
    int rank=WallsContainingPoint.GetRankOfSpanOfElements(theGlobalVariables);
    if (rank<WallsContainingPoint.size)
      WallsContainingPoint.PopLastObject();
    if (rank==thePoint.size-1)
      return true;
  }
  return false;
}

bool CombinatorialChamber::ExtraPointRemovesDoubtForBogusWall(MatrixLargeRational& theMatrix, MatrixLargeRational& emptyMat, Selection& bufferSel, root& theRoot)
{ int oldNumRows = theMatrix.NumRows;
  theMatrix.Resize(oldNumRows+1, theRoot.size, true);
  for (int j=0; j<theRoot.size; j++)
    theMatrix.elements[oldNumRows][j]=theRoot.TheObjects[j];
  theMatrix.GaussianEliminationByRows(theMatrix, emptyMat, bufferSel);
  if (bufferSel.CardinalitySelection==theRoot.size-1)
    return true;
  if (bufferSel.CardinalitySelection<theMatrix.NumRows)
    theMatrix.Resize(oldNumRows, theRoot.size, true);
  return false;
}

bool CombinatorialChamber::BordersViaExternalWRTDirectionNonZeroNeighbor(const root& theDirection)
{ for (int i=0; i<this->Externalwalls.size; i++)
  { WallData& currentWall= this->Externalwalls.TheObjects[i];
    if (currentWall.normal.OurScalarProductIsPositive(theDirection))
      for (int j=0; j<currentWall.NeighborsAlongWall.size; j++)
        if (currentWall.NeighborsAlongWall.TheObjects[j]!=0)
          if (!currentWall.NeighborsAlongWall.TheObjects[j]->flagHasZeroPolynomiaL && !currentWall.NeighborsAlongWall.TheObjects[j]->flagPermanentlyZero)
            return true;
  }
  return false;
}

bool CombinatorialChamber::IsABogusNeighborUseStoredVertices(roots& relevantVerticesCurrentWall, WallData& NeighborWall, CombinatorialChamber* Neighbor, CombinatorialChamberContainer& ownerComplex, GlobalVariables& theGlobalVariables)
{// if (NeighborWall.NeighborsAlongWall.size<=1)
    //return false;
  int theDimension= ownerComplex.AmbientDimension;
  MatrixLargeRational& tempMat= theGlobalVariables.matBogusNeighbors;
  MatrixLargeRational& emptyMat= theGlobalVariables.matBogusNeighborsEmpty;
  Selection& tempSel= theGlobalVariables.selBogusNeighbor;
  emptyMat.init(0, 0);
  tempMat.init(0, theDimension);
  for (int i=0; i<Neighbor->AllVertices.size; i++)
  { root& current = Neighbor->AllVertices.TheObjects[i];
    if (NeighborWall.ContainsPoint(current) && this->PointIsInChamber(current))
      if (this->ExtraPointRemovesDoubtForBogusWall(tempMat, emptyMat, tempSel, current))
        return false;
  }
  for (int i=0; i<relevantVerticesCurrentWall.size; i++)
  { root& current= relevantVerticesCurrentWall.TheObjects[i];
    if (Neighbor->PointIsInChamber(current))
      if (this->ExtraPointRemovesDoubtForBogusWall(tempMat, emptyMat, tempSel, current))
        return false;
  }
  return true;
}

void CombinatorialChamber::CheckForAndRemoveBogusNeighbors(CombinatorialChamberContainer& owner, GlobalVariables& theGlobalVariables)
{ int theDimension = owner.AmbientDimension;
  roots VerticesBelongingToCurrentWall;
  VerticesBelongingToCurrentWall.MakeActualSizeAtLeastExpandOnTop(this->AllVertices.size);
  for (int i=0; i<this->Externalwalls.size; i++)
  { WallData& currentWall= this->Externalwalls.TheObjects[i];
    for (int k=0; k<currentWall.NeighborsAlongWall.size; k++)
      if (currentWall.NeighborsAlongWall.TheObjects[k]!=0)
      { VerticesBelongingToCurrentWall.size=0;
        CombinatorialChamber& other = *currentWall.NeighborsAlongWall.TheObjects[k];
        for (int j=0; j<this->AllVertices.size; j++)
        { root& candidate = this->AllVertices.TheObjects[j];
          if (candidate.OurScalarProductIsZero(currentWall.normal) && other.AllVertices.ContainsObject(candidate))
            VerticesBelongingToCurrentWall.AddObjectOnTop(candidate);
        }
        owner.ConsistencyCheck(false, theGlobalVariables);
        if (VerticesBelongingToCurrentWall.GetRankOfSpanOfElements(theGlobalVariables)<theDimension-1)
          k-=currentWall.RemoveNeighborhoodBothSidesAllowRepetitionsReturnNeighborsDecrease(this, currentWall.NeighborsAlongWall.TheObjects[k]);
        owner.ConsistencyCheck(false, theGlobalVariables);
      }
  }
}

bool CombinatorialChamber::IsABogusNeighbor(WallData& NeighborWall, CombinatorialChamber* Neighbor, CombinatorialChamberContainer& ownerComplex, GlobalVariables& theGlobalVariables)
{ if (NeighborWall.NeighborsAlongWall.size<=1)
    return false;
  if (ownerComplex.flagAnErrorHasOcurredTimeToPanic)
  { NeighborWall.ComputeDebugString();
    Neighbor->ComputeDebugString(ownerComplex);
  }
  roots& ExternalWallsConglomerate= theGlobalVariables.rootsIsABogusNeighbor1;
  roots& FoundVertices = theGlobalVariables.rootsIsABogusNeighbor2;
  ExternalWallsConglomerate.size=0;
  for (int i=0; i<this->Externalwalls.size; i++)
    if (&this->Externalwalls.TheObjects[i]!=&NeighborWall)
      ExternalWallsConglomerate.AddRoot(this->Externalwalls.TheObjects[i].normal);
  root tempRoot; tempRoot.Assign(NeighborWall.normal); tempRoot.MinusRoot();
  for (int i=0; i<Neighbor->Externalwalls.size; i++)
    if (!(Neighbor->Externalwalls.TheObjects[i].normal.IsEqualTo(tempRoot)))
      ExternalWallsConglomerate.AddRootNoRepetition(Neighbor->Externalwalls.TheObjects[i].normal);
  Selection& theSelection=theGlobalVariables.selBogusNeighbor;
  theSelection.init(ExternalWallsConglomerate.size);
  int NumPossibilities;
  NumPossibilities =MathRoutines::NChooseK(ExternalWallsConglomerate.size, ownerComplex.AmbientDimension-2);
  root VertexCandidate; VertexCandidate.SetSize(ownerComplex.AmbientDimension);
  int OldRank; OldRank= 0;
  FoundVertices.size=0;
  if (this->flagAnErrorHasOccurredTimeToPanic || ownerComplex.flagAnErrorHasOcurredTimeToPanic)
  { ExternalWallsConglomerate.ComputeDebugString();
    NeighborWall.ComputeDebugString();
  }
  for (int i=0; i<NumPossibilities; i++)
  { theSelection.incrementSelectionFixedCardinality(ownerComplex.AmbientDimension-2);
    if(ExternalWallsConglomerate.ComputeNormalFromSelectionAndExtraRoot(VertexCandidate, NeighborWall.normal, theSelection, theGlobalVariables))
      if (this->PlusMinusPointIsInChamberModifyInput(VertexCandidate))
        if (Neighbor->PointIsInChamber(VertexCandidate))
          if(FoundVertices.AddRootNoRepetition(VertexCandidate))
          { int NewRank;
            if (this->flagAnErrorHasOccurredTimeToPanic)
              FoundVertices.ComputeDebugString();
            NewRank= FoundVertices.GetRankOfSpanOfElements(theGlobalVariables);
            if (NewRank>OldRank)
              OldRank= NewRank;
            else
              FoundVertices.size--;
            if (OldRank==ownerComplex.AmbientDimension-1)
              return false;
          }
  }
  return true;
}

bool CombinatorialChamber::LinearAlgebraForVertexComputation(Selection& theSelection, root& output, GlobalVariables& theGlobalVariables, int theDimension)
{ output.SetSize(theDimension);
  assert(theDimension -1== theSelection.CardinalitySelection);
  MatrixLargeRational& RMinus1ByR=theGlobalVariables.matLinearAlgebraForVertexComputation;
  MatrixLargeRational  matOutputEmpty;
  RMinus1ByR.init((int)(theDimension-1), (int)theDimension);
  matOutputEmpty.init(-1, -1);
  Selection& NonPivotPoints= theGlobalVariables.selLinearAlgebraForVertexComputation;
  for (int i =0; i<theDimension-1; i++)
    for (int j=0; j<theDimension; j++)
      RMinus1ByR.elements[i][j].Assign(this->Externalwalls.TheObjects[theSelection.elements[i]].normal.TheObjects[j]);
  MatrixLargeRational::GaussianEliminationByRows(RMinus1ByR, matOutputEmpty, NonPivotPoints);
  if (NonPivotPoints.CardinalitySelection==1)
  { RMinus1ByR.NonPivotPointsToRoot(NonPivotPoints, output);
    return true;
  }
  return false;
}

bool CombinatorialChamber::LinearAlgebraForVertexComputationOneAffinePlane(Selection& theSelection, root& output, GlobalVariables& theGlobalVariables, CombinatorialChamberContainer* owner)
{ assert(theSelection.CardinalitySelection==owner->AmbientDimension-2);
  MatrixLargeRational& tempMat=theGlobalVariables.matComputationBufferLinAlgOneAffinePlane;
  MatrixLargeRational& tempColumn=theGlobalVariables.matComputationBufferLinAlgAffinePart;
  tempMat.init(owner->AmbientDimension, owner->AmbientDimension);
  tempColumn.init(owner->AmbientDimension, 1);
  for (int i=0; i<theSelection.CardinalitySelection; i++)
  { for (int j=0; j<owner->AmbientDimension; j++)
      tempMat.elements[i][j].Assign(  this->Externalwalls.TheObjects[theSelection.elements[i]].normal.TheObjects[j]);
    tempColumn.elements[i][0].MakeZero();
  }
  tempColumn.elements[owner->AmbientDimension-2][0].MakeOne();
  Rational tempRat; Rational tempOne; tempOne.MakeOne();
  root::RootScalarEuclideanRoot(owner->StartingCrossSections.TheObjects[this->IndexStartingCrossSectionNormal].normal, owner->StartingCrossSections.TheObjects[this->IndexStartingCrossSectionNormal].affinePoint, tempRat);
  tempRat.Subtract(tempOne);
  tempColumn.elements[owner->AmbientDimension-1][0].Assign(tempRat);
  for (int i=0; i<owner->AmbientDimension-1; i++)
  { tempMat.elements[owner->AmbientDimension-2][i].MakeZero();
    tempMat.elements[owner->AmbientDimension-1][i].Assign(  owner->StartingCrossSections.TheObjects[this->IndexStartingCrossSectionNormal].normal.TheObjects[i]);
  }
  tempMat.elements[owner->AmbientDimension-2][owner->AmbientDimension-1].MakeOne();
  tempMat.elements[owner->AmbientDimension-1][owner->AmbientDimension-1].MakeZero();
  Selection tempSel;
  tempMat.ComputeDebugString();
  tempColumn.ComputeDebugString();
  Matrix<Rational>::GaussianEliminationByRows(tempMat, tempColumn, tempSel);
  if(tempSel.CardinalitySelection!=0)
    return false;
  output.SetSize(owner->AmbientDimension-1);
  tempMat.ComputeDebugString();
  tempColumn.ComputeDebugString();
  for (int i=0; i<owner->AmbientDimension-1; i++)
    output.TheObjects[i].Assign(tempColumn.elements[i][0]);
  assert(tempColumn.elements[owner->AmbientDimension-1][0].IsEqualTo(ROne));
  return true;
}

void CombinatorialChamber::FindAllNeighbors(ListPointers<CombinatorialChamber>& TheNeighbors)
{ for (int i=0; i<this->Externalwalls.size; i++)
    for (int j=0; j<this->Externalwalls.TheObjects[i].NeighborsAlongWall.size; j++)
      TheNeighbors.AddObjectOnTop(this->Externalwalls.TheObjects[i].NeighborsAlongWall.TheObjects[j]);
}

bool CombinatorialChamber::TestPossibilityToSlice(root& direction, CombinatorialChamberContainer& owner)
{ bool tempBool;
  if (this->flagExplored)
    return false;
  if (this->flagPermanentlyZero)
  { this->flagExplored=true;
    return false;
  }
  for (int j=0; j<this->Externalwalls.size; j++)
    if (this->Externalwalls.TheObjects[j].IsExternalWithRespectToDirection(direction) && (!this->Externalwalls.TheObjects[j].EveryNeigborIsExplored(tempBool)))
      return false;
  return true;
}

bool CombinatorialChamber::IsSeparatedByStartingConesFrom(CombinatorialChamberContainer& owner, CombinatorialChamber& Neighbor, GlobalVariables& theGlobalVariables)
{ if (!owner.flagStoringVertices)
    return false;
  return owner.startingCones.SeparatePoints(this->InternalPoint, Neighbor.InternalPoint, 0);
}

int CombinatorialChamber::GetIndexWallWithNormal(root& theNormal)
{ for (int i=0; i<this->Externalwalls.size; i++)
    if (this->Externalwalls.TheObjects[i].normal.IsEqualTo(theNormal))
      return i;
  return -1;
}

bool CombinatorialChamber::GetNonSeparableChamberIndicesOrReturnFalseIfUnionNotConvex(CombinatorialChamberContainer& owner, List<int>& outputIndicesChambersToGlue, roots& outputRedundantNormals, GlobalVariables& theGlobalVariables)
{ if (this->GetHashFromSortedNormals()==58238520)
    Stop();
  outputIndicesChambersToGlue.size=0;
  outputIndicesChambersToGlue.AddObjectOnTop(this->IndexInOwnerComplex);
  outputRedundantNormals.size=0;
  if (!this->GetNonSeparableChamberIndicesAppendList(owner, outputIndicesChambersToGlue, theGlobalVariables))
    return false;
  roots& theNormals= theGlobalVariables.rootsGlueingGetNonSeparableChambers;
  theNormals.size=0;
  roots theVertices;
  for (int i=0; i<outputIndicesChambersToGlue.size; i++)
  { for (int j=0; j<owner.TheObjects[outputIndicesChambersToGlue.TheObjects[i]]->Externalwalls.size; j++)
    { WallData& currentWall=owner.TheObjects[outputIndicesChambersToGlue.TheObjects[i]]->Externalwalls.TheObjects[j];
      root& theNormal=currentWall.normal;
      if (theNormals.ContainsObject(-theNormal))
      { outputRedundantNormals.AddOnTopNoRepetition(theNormal);
        outputRedundantNormals.AddOnTopNoRepetition(-theNormal);
        for (int k=0; k<currentWall.NeighborsAlongWall.size; k++)
          if (!outputIndicesChambersToGlue.ContainsObject(currentWall.NeighborsAlongWall.TheObjects[k]->IndexInOwnerComplex))
            return false;
            //the chamber borders with another that is not in among the set of chambers to be glued,
            //along a wall that is to be deleted. Therefore the union of the chambers to be glued cannot be convex.
      }
      theNormals.AddOnTopNoRepetition(theNormal);
    }
    theVertices.AddRootSnoRepetition(owner.TheObjects[outputIndicesChambersToGlue.TheObjects[i]]->AllVertices);
  }
  for (int i=0; i<theNormals.size; i++)
    if (!outputRedundantNormals.ContainsObject(theNormals.TheObjects[i]))
      for (int j=0; j<theVertices.size; j++)
        if (theNormals.TheObjects[i].OurScalarProductIsNegative(theVertices.TheObjects[j]))
          return false;
  for (int i=0; i<outputIndicesChambersToGlue.size; i++)
    for (int j=i+1; j<outputIndicesChambersToGlue.size; j++)
      assert(!owner.startingCones.SeparatePoints(owner.TheObjects[outputIndicesChambersToGlue.TheObjects[i]]->InternalPoint, owner.TheObjects[outputIndicesChambersToGlue.TheObjects[j]]->InternalPoint,0));
  return true;
}

bool CombinatorialChamber::UnionAlongWallIsConvex(CombinatorialChamber& other, int indexWall, GlobalVariables& theGlobalVariables)
{ for(int i=0; i<this->Externalwalls.size; i++)
    if (i!= indexWall)
      for (int j=0; j<other.AllVertices.size; j++)
        if (root::RootScalarEuclideanRoot(this->Externalwalls.TheObjects[i].normal, other.AllVertices.TheObjects[j]).IsNegative())
          return false;
  WallData& theWall= this->Externalwalls.TheObjects[indexWall];
  int indexOtherWall = theWall.GetIndexWallToNeighbor(&other);
  assert(indexOtherWall!=-1);
  for(int i=0; i<other.Externalwalls.size; i++)
    if (i!= indexOtherWall)
      for (int j=0; j<this->AllVertices.size; j++)
        if (root::RootScalarEuclideanRoot(other.Externalwalls.TheObjects[i].normal, this->AllVertices.TheObjects[j]).IsNegative())
          return false;
  return true;
}

bool CombinatorialChamber::SplitChamber(root& theKillerPlaneNormal, CombinatorialChamberContainer& output, root& direction, GlobalVariables& theGlobalVariables)
{ //   roots PositiveVertices, NegativeVertices
  //static int ProblemCounter=0;
  //ProblemCounter++;
  assert(output.TheObjects[output.indexNextChamberToSlice]==this);
  if (output.flagSliceWithAWallIgnorePermanentlyZero && this->flagPermanentlyZero)
    return false;
  bool PlusChamberIsPermanentZero;
  bool MinusChamberIsPermanentZero;
  rootsCollection& LocalContainerPlusVertices=theGlobalVariables.rootsCollectionSplitChamber1;
  rootsCollection& LocalContainerMinusVertices=theGlobalVariables.rootsCollectionSplitChamber2;
  roots& LocalLinearAlgebra= theGlobalVariables.rootsSplitChamber1;
  List<CombinatorialChamber*>& PossibleBogusNeighbors=theGlobalVariables.listCombinatorialChamberPtSplitChamber;
  List<int>& PossibleBogusWalls=theGlobalVariables.listWallDataPtSplitChamber;
  List<int>& IndicesPossibleBogusWallsThisChamber=theGlobalVariables.listWallDataPtSplitChamber2;
  CombinatorialChamber* NewPlusChamber;
  CombinatorialChamber* NewMinusChamber;
  PossibleBogusNeighbors.size=0;
  PossibleBogusWalls.size=0;
  IndicesPossibleBogusWallsThisChamber.size=0;
  Selection theSelection;
  PlusChamberIsPermanentZero=false;
  MinusChamberIsPermanentZero=false;
  LocalLinearAlgebra.size=0;
//  if (CombinatorialChamberContainer::flagAnErrorHasOcurredTimeToPanic)
//  {  output.ComputeDebugString();
//    this->ConsistencyCheck();
//  }
  for (int i=0; i<this->Externalwalls.size; i++)
  { bool tempBool;
    tempBool=LocalLinearAlgebra.AddRootNoRepetition(Externalwalls.TheObjects[i].normal);
    if(!output.startingCones.theFacets.ContainsObjectHash(*LocalLinearAlgebra.LastObject()))
    { LocalLinearAlgebra.LastObject()->MinusRoot();
 //     assert(output.startingCones.theFacets.ContainsObjectHash(*LocalLinearAlgebra.LastObject()));
    }
    if (!tempBool)
      this->ComputeDebugString(output);
    assert(tempBool);
  }
  if (output.flagAnErrorHasOcurredTimeToPanic)
    theKillerPlaneNormal.ComputeDebugString();
  LocalLinearAlgebra.AddRoot(theKillerPlaneNormal);
  theSelection.init(LocalLinearAlgebra.size);
  int NumCandidates = MathRoutines::NChooseK(LocalLinearAlgebra.size, output.AmbientDimension-1);
  LocalContainerPlusVertices.SetSize(LocalLinearAlgebra.size);
  LocalContainerMinusVertices.SetSize(LocalLinearAlgebra.size);
  LocalContainerMinusVertices.ResetCounters();
  LocalContainerPlusVertices.ResetCounters();
  bool hasPositive, hasNegative;
  hasPositive=false; hasNegative=false;
  root PositiveChamberInternalPoint, NegativeChamberInternalPoint;
  PositiveChamberInternalPoint.MakeZero(output.AmbientDimension);
  NegativeChamberInternalPoint.MakeZero(output.AmbientDimension);
  bool foundBad=false;
  for (int i=0; i<NumCandidates; i++)
  { root VertexCandidate; VertexCandidate.SetSize(output.AmbientDimension);
    theSelection.incrementSelectionFixedCardinality(output.AmbientDimension-1);
    if (LocalLinearAlgebra.ComputeNormalFromSelection(VertexCandidate, theSelection, theGlobalVariables, output.AmbientDimension))
      if (this->PlusMinusPointIsInChamberModifyInput(VertexCandidate))
      { Rational tempRat; bool IsPositive; bool IsNegative;
        root::RootScalarEuclideanRoot(VertexCandidate, theKillerPlaneNormal, tempRat);
        IsPositive = tempRat.IsPositive();
        IsNegative = tempRat.IsNegative();
        hasPositive = (hasPositive || IsPositive);
        hasNegative = (hasNegative || IsNegative);
        for (int j=0; j<output.AmbientDimension-1; j++)
        { if (!IsNegative)
          { LocalContainerPlusVertices.TheObjects[theSelection.elements[j]].AddRootNoRepetition(VertexCandidate);
            PositiveChamberInternalPoint.Add(VertexCandidate);
          }
          if(!IsPositive)
          { LocalContainerMinusVertices.TheObjects[theSelection.elements[j]].AddRootNoRepetition(VertexCandidate);
            NegativeChamberInternalPoint.Add(VertexCandidate);
          }
        }
      }
  }
  if (!output.flagMakingASingleHyperplaneSlice)
  { PlusChamberIsPermanentZero = output.IsSurelyOutsideGlobalCone(LocalContainerPlusVertices);
    MinusChamberIsPermanentZero = output.IsSurelyOutsideGlobalCone(LocalContainerMinusVertices);
  }
  if (!(hasPositive && hasNegative) || foundBad)
  { if (output.flagMakingASingleHyperplaneSlice && output.flagSliceWithAWallInitDone)
    { //Note: this code needs review. Disabled it to simplify the scheme. I need to consider whether the
      //old scheme which is now commented out actually saves time or not.
      //if (hasPositive)
      //  this->PropagateSlicingWallThroughNonExploredNeighbors(theKillerPlaneNormal, LocalContainerMinusVertices, output, theGlobalVariables);
      //else
      //  this->PropagateSlicingWallThroughNonExploredNeighbors(theKillerPlaneNormal, LocalContainerPlusVertices, output, theGlobalVariables);
      //there is something wrong here: the below line seems logical, but contradicts the following comment, which I wrote long ago
      // and I really don't remember why I wrote it and what was the issue...
      this->flagExplored=true;
      //Note: this line here is forbidden! this->flagExplored=true; There is no guarantee that all neighbors have been explored at this phase of the algorithm.
    }
    return false;
  }
/*  if (output.flagAnErrorHasOcurredTimeToPanic)
  {  PositiveChamberInternalPoint.ComputeDebugString();
    NegativeChamberInternalPoint.ComputeDebugString();
  }*/
  if (output.flagUsingStartingConesSeparation)
    if (!output.flagMakingASingleHyperplaneSlice)
      if (!this->flagHasZeroPolynomiaL && !this->flagPermanentlyZero)
        if (!output.startingCones.SeparatePoints(PositiveChamberInternalPoint, NegativeChamberInternalPoint, 0))//&theKillerPlaneNormal))
          return false;
//  if (CombinatorialChamberContainer::flagAnErrorHasOcurredTimeToPanic)
//  { LocalContainerPlusVertices.ComputeDebugString();
//    LocalContainerMinusVertices.ComputeDebugString();
//  }
  NewPlusChamber = new CombinatorialChamber;
  NewMinusChamber = new CombinatorialChamber;
#ifdef CGIversionLimitRAMuse
  ParallelComputing::GlobalPointerCounter+=2;
  ParallelComputing::CheckPointerCounters();
#endif
  NewPlusChamber->flagPermanentlyZero = PlusChamberIsPermanentZero;
  NewMinusChamber->flagPermanentlyZero = MinusChamberIsPermanentZero;
  NewPlusChamber->Externalwalls.MakeActualSizeAtLeastExpandOnTop(this->Externalwalls.size+1);
  NewMinusChamber->Externalwalls.MakeActualSizeAtLeastExpandOnTop(this->Externalwalls.size+1);
  NewPlusChamber->flagHasZeroPolynomiaL = this->flagHasZeroPolynomiaL;
  NewMinusChamber->flagHasZeroPolynomiaL = this->flagHasZeroPolynomiaL;
  NewPlusChamber->IndexStartingCrossSectionNormal = this->IndexStartingCrossSectionNormal;
  NewMinusChamber->IndexStartingCrossSectionNormal = this->IndexStartingCrossSectionNormal;
  if (output.flagMakingASingleHyperplaneSlice)
  { NewPlusChamber->flagExplored=true;
    NewMinusChamber->flagExplored=true;
  }
  output.AddChamberPointerSetUpPreferredIndices(NewPlusChamber, theGlobalVariables);
  output.AddChamberPointerSetUpPreferredIndices(NewMinusChamber, theGlobalVariables);
  if (output.flagStoringVertices)
  { LocalContainerPlusVertices.Average(NewPlusChamber->InternalPoint, LocalLinearAlgebra.size, output.AmbientDimension);
    LocalContainerMinusVertices.Average(NewMinusChamber->InternalPoint, LocalLinearAlgebra.size, output.AmbientDimension);
    for (int i=0; i<LocalLinearAlgebra.size; i++)
    { NewPlusChamber->AllVertices.AddRootSnoRepetition(LocalContainerPlusVertices.TheObjects[i]);
      NewMinusChamber->AllVertices.AddRootSnoRepetition(LocalContainerMinusVertices.TheObjects[i]);
    }
  }
  if (output.flagAnErrorHasOcurredTimeToPanic)
    this->ComputeDebugString(output);
  for (int i=0; i<this->Externalwalls.size; i++)
  { this->Externalwalls.TheObjects[i].SplitWall(i, IndicesPossibleBogusWallsThisChamber, this, NewPlusChamber, NewMinusChamber, output, LocalContainerPlusVertices.TheObjects[i], LocalContainerMinusVertices.TheObjects[i], theKillerPlaneNormal, direction, PossibleBogusNeighbors, PossibleBogusWalls, theGlobalVariables);
    if (output.flagAnErrorHasOcurredTimeToPanic)
    { NewPlusChamber->ComputeDebugString(output);
      NewMinusChamber->ComputeDebugString(output);
      this->ComputeDebugString(output);
      NewPlusChamber->ConsistencyCheck(output.AmbientDimension, false, output, theGlobalVariables);
      NewMinusChamber->ConsistencyCheck(output.AmbientDimension, false, output, theGlobalVariables);
      output.ComputeDebugString();
    }
  }
//  if (CombinatorialChamberContainer::AnErrorHasOcurredTimeToPanic)
//  { this->ComputeDebugString();
//  }
  for (int i=1; i<this->InternalWalls.size; i++)
  { NewPlusChamber->InternalWalls.AddRootNoRepetition(this->InternalWalls.TheObjects[i]);
    NewMinusChamber->InternalWalls.AddRootNoRepetition(this->InternalWalls.TheObjects[i]);
  }
  this->MakeNewMutualNeighbors(NewPlusChamber, NewMinusChamber, theKillerPlaneNormal);
  if (CombinatorialChamberContainer::flagAnErrorHasOcurredTimeToPanic)
  { NewPlusChamber->ComputeDebugString(output);
    NewMinusChamber->ComputeDebugString(output);
    assert(NewPlusChamber->ConsistencyCheck(output.AmbientDimension, true, output, theGlobalVariables));
    assert(NewMinusChamber->ConsistencyCheck(output.AmbientDimension, true, output, theGlobalVariables));
    output.ComputeDebugString();
  }
//  if (output.flagSpanTheEntireSpace || !output.flagStoringVertices || !output.flagUsingVerticesToDetermineBogusNeighborsIfPossible)
  for (int i=0; i<PossibleBogusNeighbors.size; i++)
  { WallData& possibleBadWall = PossibleBogusNeighbors.TheObjects[i]->Externalwalls.TheObjects[PossibleBogusWalls.TheObjects[i]];
    if (NewPlusChamber->IsABogusNeighbor(possibleBadWall, PossibleBogusNeighbors.TheObjects[i], output, theGlobalVariables))
      possibleBadWall.RemoveNeighborhoodBothSidesNoRepetitionNeighbors(PossibleBogusNeighbors.TheObjects[i], NewPlusChamber);
    if (NewMinusChamber->IsABogusNeighbor(possibleBadWall, PossibleBogusNeighbors.TheObjects[i], output, theGlobalVariables))
      possibleBadWall.RemoveNeighborhoodBothSidesNoRepetitionNeighbors(PossibleBogusNeighbors.TheObjects[i], NewMinusChamber);
  }
//  output.ComputeDebugString();
  assert(NewPlusChamber->Externalwalls.size>=output.AmbientDimension);
  assert(NewMinusChamber->Externalwalls.size>=output.AmbientDimension);
  assert(this->HasNoNeighborsThatPointToThis());
  assert(output.TheObjects[output.indexNextChamberToSlice]==this);
  assert(NewPlusChamber->ConsistencyCheck(output.AmbientDimension, true, output, theGlobalVariables));
  assert(NewMinusChamber->ConsistencyCheck(output.AmbientDimension, true, output, theGlobalVariables));
  //if (output.flagAnErrorHasOcurredTimeToPanic)
  //{  output.ComputeDebugString();
    //assert(NewPlusChamber->ConsistencyCheck());
    //assert(NewMinusChamber->ConsistencyCheck());
  //}
  return true;
}

void CombinatorialChamber::PropagateSlicingWallThroughNonExploredNeighbors(root& theKillerNormal, rootsCollection& CuttingPlaneVertices, CombinatorialChamberContainer& owner, GlobalVariables& theGlobalVariables)
{ for (int i=0; i<this->Externalwalls.size; i++)
  { bool mustPropagate=false;
    for (int j=0; j<CuttingPlaneVertices.TheObjects[i].size; j++)
      if (this->Externalwalls.TheObjects[i].ContainsPoint(CuttingPlaneVertices.TheObjects[i].TheObjects[j]))
      { mustPropagate=true;
        break;
      }
    if (mustPropagate)
      for (int j=0; j<this->Externalwalls.TheObjects[i].NeighborsAlongWall.size; j++)
        if (this->Externalwalls.TheObjects[i].NeighborsAlongWall.TheObjects[j]!=0)
          if(!this->Externalwalls.TheObjects[i].NeighborsAlongWall.TheObjects[j]->flagExplored)
          { root tempRoot; tempRoot.MakeZero(owner.AmbientDimension);
            root& otherNormal= this->Externalwalls.TheObjects[i].NeighborsAlongWall.TheObjects[j]->Externalwalls.TheObjects[this->Externalwalls.TheObjects[i].IndicesMirrorWalls.TheObjects[j]].normal;
            this->Externalwalls.TheObjects[i].NeighborsAlongWall.TheObjects[j]->AddInternalWall(theKillerNormal, otherNormal, tempRoot, owner, theGlobalVariables);
          }
  }
}

void CombinatorialChamberContainer::ConvertHasZeroPolyToPermanentlyZero()
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
      if (this->TheObjects[i]->flagHasZeroPolynomiaL)
        this->TheObjects[i]->flagPermanentlyZero=true;
}

void CombinatorialChamberContainer::AddWeylChamberWallsToHyperplanes(GlobalVariables& theGlobalVariables, WeylGroup& theWeylGroup)
{ MatrixLargeRational tempMat;
  tempMat.Assign(theWeylGroup.CartanSymmetric);
  tempMat.Invert(theGlobalVariables);
  tempMat.ComputeDebugString();
  this->NumProjectiveHyperplanesBeforeWeylChamberWalls=this->theHyperplanes.size;
  roots tempRoots;
  this->WeylChamber.ReleaseMemory();
  for (int i=0; i<tempMat.NumCols; i++)
  { root tempRoot; tempRoot.SetSize(tempMat.NumRows);
    for (int j=0; j<tempMat.NumRows; j++)
      tempRoot.TheObjects[j].Assign(tempMat.elements[j][i]);
    tempRoots.AddRoot(tempRoot);
  }
  this->WeylChamber.ComputeFromDirections(tempRoots, theGlobalVariables, tempMat.NumCols);
  this->WeylChamber.ComputeDebugString();
  for (int i=0; i< this->WeylChamber.size; i++)
    this->theHyperplanes.AddObjectOnTopNoRepetitionOfObjectHash(this->WeylChamber.TheObjects[i]);
}


void CombinatorialChamberContainer::AddChamberPointerSetUpPreferredIndices(CombinatorialChamber* theChamber, GlobalVariables& theGlobalVariables)
{ theChamber->IndexInOwnerComplex=this->size;
  this->AddObjectOnTop(theChamber);
  if (!this->flagMakingASingleHyperplaneSlice)
  { if (!theChamber->flagPermanentlyZero)
      this->PreferredNextChambers.AddOnTopNoRepetition(this->size-1);
  //    this->PreferredNextChambers.AddOnBottomNoRepetition(this->size-1);
    else
      theChamber->flagExplored=true;
  }
}

void CombinatorialChamber::MakeNewMutualNeighbors(CombinatorialChamber* NewPlusChamber, CombinatorialChamber* NewMinusChamber, root& normal)
{ WallData tempWall; tempWall.normal.Assign(normal);
  tempWall.NeighborsAlongWall.AddObjectOnTop(NewMinusChamber);
  NewPlusChamber->Externalwalls.AddObjectOnTop(tempWall);
  tempWall.normal.MinusRoot(); tempWall.NeighborsAlongWall.TheObjects[0]=NewPlusChamber;
  NewMinusChamber->Externalwalls.AddObjectOnTop(tempWall);
  NewPlusChamber->Externalwalls.LastObject()->IndicesMirrorWalls.AddObjectOnTop(NewMinusChamber->Externalwalls.size-1);
  NewMinusChamber->Externalwalls.LastObject()->IndicesMirrorWalls.AddObjectOnTop(NewPlusChamber->Externalwalls.size-1);
//  if (CombinatorialChamberContainer::flagAnErrorHasOcurredTimeToPanic)
//  { NewPlusChamber->ComputeDebugString();
//    NewMinusChamber->ComputeDebugString();
//  }
}

void CombinatorialChamberContainer::PurgeInternalWalls()
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
      this->TheObjects[i]->PurgeInternalWalls();
}

bool CombinatorialChamberContainer::IsSurelyOutsideGlobalCone(rootsCollection& TheVertices)
{ return this->TheGlobalConeNormals.IsSurelyOutsideCone(TheVertices);
}

void CombinatorialChamberContainer::ComputeGlobalCone(roots& directions, GlobalVariables& theGlobalVariables)
{ this->TheGlobalConeNormals.ComputeFromDirections(directions, theGlobalVariables, this->AmbientDimension);
}

void CombinatorialChamberContainer::MakeExtraProjectivePlane()
{  /*root extraWallNormal;
  extraWallNormal.MakeZero(root::AmbientDimension+1);
  extraWallNormal.TheObjects[root::AmbientDimension].MakeOne();
  Facet* tempFacet2= this->theHyperplanes.
    NormalizeRootAndGetFacetCreateNewIfNeeded(extraWallNormal);
  for (int i=0; i<this->size; i++)
  { tempFacet2->Owners.AddCouple(this->TheObjects[i], 0);
  }*/
}

void CombinatorialChamberContainer::MakeReportOneSlice(GlobalVariables& theGlobalVariables, int currentIndex, int totalRoots, root& theCurrentDirection)
{ if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()==0)
    return;
  std::stringstream out5;
  std::stringstream out4;
  out4 << "Direction index: " << currentIndex << " out of " << totalRoots << " current direction: " << theCurrentDirection.ElementToString();
  out5 << "Chamber index: " << this->indexNextChamberToSlice << " Explored " << this->NumExplored << " out of " << this->GetNumNonZeroPointers();
  theGlobalVariables.theIndicatorVariables.ProgressReportString4=out4.str();
  theGlobalVariables.theIndicatorVariables.ProgressReportString5=out5.str();
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void CombinatorialChamberContainer::MakeReportGlueing(GlobalVariables& theGlobalVariables, int currentIndex, int TotalNumGlueingsSoFar)
{ if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()==0)
    return;
  std::stringstream out3;
  out3 << "Glueing: checking chamber index: " << currentIndex << " out of " << this->size << " Total glueings: " << TotalNumGlueingsSoFar;
  theGlobalVariables.theIndicatorVariables.ProgressReportString3=out3.str();
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void CombinatorialChamberContainer::ComputeVerticesFromNormals(GlobalVariables& theGlobalVariables)
{ if(this->flagAnErrorHasOcurredTimeToPanic)
    for(int i=0; i<this->size; i++)
      this->TheObjects[i]->ComputeDebugString(*this);
  for(int i=0; i<this->size; i++)
    this->TheObjects[i]->ComputeVerticesFromNormals(*this, theGlobalVariables);
}

bool CombinatorialChamberContainer::ProjectToDefaultAffineSpaceModifyCrossSections(GlobalVariables& theGlobalVariables)
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
      if (!this->TheObjects[i]->ProjectToDefaultAffineSpace(this, theGlobalVariables))
        return false;
  return true;
}

int CombinatorialChamberContainer::RootBelongsToChamberIndex(root& input, std::string* outputString)
{ std::stringstream out;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
      if (this->TheObjects[i]->PointIsInChamber(input))
      { if (outputString!=0)
          this->TheObjects[i]->ChamberNumberToString(*outputString, *this);
        return i;
      }
  return -1;
}

void CombinatorialChamberContainer::ProjectToDefaultAffineSpace(GlobalVariables& theGlobalVariables)
{ while (!this->ProjectToDefaultAffineSpaceModifyCrossSections(theGlobalVariables))
  { //this->ComputeDebugString();
  }
}

void CombinatorialChamberContainer::ComputeNextIndexToSlice(root& direction)
{//  if (this->flagAnErrorHasOcurredTimeToPanic)
//    this->ComputeDebugString();
  while (this->PreferredNextChambers.size>0)
  { this->indexNextChamberToSlice=*this->PreferredNextChambers.LastObject();
    this->PreferredNextChambers.PopLastObject();
    if (this->TheObjects[this->indexNextChamberToSlice]!=0)
      if (this->TheObjects[this->indexNextChamberToSlice]->TestPossibilityToSlice(direction, *this))
        return;
  }
  this->indexNextChamberToSlice=-1;
  bool foundUnexplored=false;
  for (int i=this->FirstNonExploredIndex; i<this->size; i++)
    if (this->TheObjects[i]!=0)
    { if(!foundUnexplored && !this->TheObjects[i]->flagExplored)
      { this->FirstNonExploredIndex=i;
        foundUnexplored=true;
      }
      if (this->TheObjects[i]->TestPossibilityToSlice(direction, *this))
      { this->indexNextChamberToSlice= i;
        return;
      }
    }
  this->indexNextChamberToSlice=-1;
}

bool CombinatorialChamberContainer::isAValidVertexInGeneral(const root& candidate, roots& theNormalsInvolved, Selection& theSelectedNormals)
{ root currentNormal;
  for (int i=0; i<theSelectedNormals.CardinalitySelection; i++)
  { currentNormal = theNormalsInvolved.TheObjects[theSelectedNormals.elements[i]];
    currentNormal.ComputeDebugString();
    bool found=false;
    int indexCurrentNormal=this->startingCones.theFacets.IndexOfObjectHash(currentNormal);
    assert(indexCurrentNormal!=-1);
    for (int j=0; j<this->startingCones.ConesHavingFixedNormal.TheObjects[indexCurrentNormal].size; j++)
    { int theIndexInvolved=this->startingCones.ConesHavingFixedNormal.TheObjects[indexCurrentNormal].TheObjects[j];
      assert(this->startingCones.TheObjects[theIndexInvolved].ContainsObject(currentNormal) || this->startingCones.TheObjects[theIndexInvolved].ContainsObject(-currentNormal));
      if (this->startingCones.TheObjects[theIndexInvolved].IsOnConeBorder(candidate))
      { found=true;
        break;
      }
    }
    if (!found)
      return false;
  }
  return true;
}

void CombinatorialChamberContainer::CheckForAndRemoveBogusNeighbors(GlobalVariables& theGlobalVariables)
{ this->ConsistencyCheck(true, theGlobalVariables);
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
    { this->TheObjects[i]->CheckForAndRemoveBogusNeighbors(*this, theGlobalVariables);
      this->ConsistencyCheck(false, theGlobalVariables);
    }
  this->ConsistencyCheck(true, theGlobalVariables);
}

bool CombinatorialChamberContainer::ConsistencyCheckNextIndicesToSlice()
{ if (this->indexNextChamberToSlice==-1)
    return true;
  if (this->TheObjects[this->indexNextChamberToSlice]==0)
    return false;
  for (int i=0; i<this->PreferredNextChambers.size; i++)
    if (this->TheObjects[this->PreferredNextChambers.TheObjects[i]]==0)
      return false;
  return true;
}

bool CombinatorialChamberContainer::ConsistencyCheck(bool CheckForConvexityChambers, GlobalVariables& theGlobalVariables)
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
      if (!this->TheObjects[i]->ConsistencyCheck(this->AmbientDimension, CheckForConvexityChambers, *this, theGlobalVariables))
        return false;
  return true;
}

void CombinatorialChamberContainer::WriteReportToFile(DrawingVariables& TDV, roots& directions, std::fstream& output)
{ if (!output.is_open())
    return;
  this->drawOutput(TDV, this->IndicatorRoot, &output);
  std::string tempS;
  output << "Nilradical simple coords:\\\\\n ";
  for (int i=0; i<directions.size; i++)
  { directions.TheObjects[i].ElementToString(tempS);
    output << tempS << "\\\\\n";
  }
  this->ElementToString(tempS, true, false);
  output << tempS;
}

void CombinatorialChamberContainer::WriteReportToFile(const std::string& FileNameOutput, bool DoPurgeZeroPointers)
{ std::fstream tempF;
  CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(tempF, FileNameOutput, false, true, false);
  this->WriteReportToFile(tempF, DoPurgeZeroPointers);
}

void CombinatorialChamberContainer::WriteReportToFile(std::fstream& output, bool DoPurgeZeroPointers)
{ std::string tempS;
  if (DoPurgeZeroPointers)
  { this->PurgeZeroPointers();
    this->LabelChamberIndicesProperly();
  }
  this->ElementToString(tempS, false, true);
  output << tempS;
}

void CombinatorialChamberContainer::ElementToString(std::string& output)
{ this->ElementToString(output, false, false);
}

void CombinatorialChamberContainer::ElementToString(std::string& output, bool useLatex, bool useHtml)
{ std::stringstream out;
  std::string tempS;
  std::string endOfLine;
  root tempRoot;
  PolynomialOutputFormat PolyFormatLocal;
  endOfLine="\n";
  if (useLatex)
    endOfLine="\\\\\n";
  if (useHtml)
    endOfLine="\n<br>\n";
  else
    endOfLine="\n";
//  this->PurgeZeroPointers();
  if (useHtml)
    out << "<html><title> Chambers </title><body>";
  out << "Number of visible chambers: " << this->LabelChambersForDisplayAndGetNumVisibleChambers() << endOfLine;
  if (this->AffineWallsOfWeylChambers.size>0)
  { int tempI=this->LabelChambersAndGetNumChambersInWeylChamber(this->WeylChamber);
    out << "Number of chambers with internal point in Weyl chamber: " << tempI << endOfLine;
    out << "Weyl chamber walls and their images: " << endOfLine;
    for (int i=0; i<this->AffineWallsOfWeylChambers.size; i++)
    { this->AffineWallsOfWeylChambers.TheObjects[i].ElementToString(tempS);
      out << tempS << endOfLine;
    }
  }
  if (this->size>this->GraphicsMaxNumChambers)
  { out << "Detailed chamber data too large for display";
    output=out.str();
    return;
  }
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
      //if (!this->TheObjects[i]->flagHasZeroPolynomiaL || !useHtml)
      { this->TheObjects[i]->ElementToString(tempS, *this, useLatex, useHtml, PolyFormatLocal);
        out << tempS;
        if (useHtml)
        { this->TheObjects[i]->ComputeInternalPoint(tempRoot, this->AmbientDimension);
          tempRoot.ElementToString(tempS, true);
          out << "Internal point: " << tempS;
        }
        out << endOfLine << endOfLine;
        if (out.gcount()>this->flagMaxNumCharsAllowedInStringOutput && !useHtml)
          break;
      }
  if (useHtml)
    out << "</body></html>";
  output= out.str();
}

void CombinatorialChamberContainer::WireChamberAdjacencyInfoAsIn(CombinatorialChamberContainer& input)
{ assert(this->size==input.size);
  input.LabelChamberIndicesProperly();
  this->LabelChamberIndicesProperly();
  if (this->flagAnErrorHasOcurredTimeToPanic)
    this->ComputeDebugString();
  for (int i=0; i<input.size; i++)
    this->TheObjects[i]->WireChamberAndWallAdjacencyData(*this, input.TheObjects[i]);
}

void CombinatorialChamberContainer::InduceFromLowerDimensionalAndProjectivize(CombinatorialChamberContainer& input, GlobalVariables& theGlobalVariables)
{ this->init();
  this->flagMakingASingleHyperplaneSlice=true;
  this->AmbientDimension=input.AmbientDimension+1;
//  input.ComputeDebugString();
  this->initAndCreateNewObjects(input.size);
  this->StartingCrossSections.SetSize(input.StartingCrossSections.size);
  for (int i=0; i<input.StartingCrossSections.size; i++)
  { this->StartingCrossSections.TheObjects[i].affinePoint.SetSize(input.AmbientDimension+1);
    this->StartingCrossSections.TheObjects[i].normal.SetSize(input.AmbientDimension+1);
    for (int j=0; j<input.AmbientDimension; j++)
    { this->StartingCrossSections.TheObjects[i].affinePoint.TheObjects[j].Assign(input.StartingCrossSections.TheObjects[i].affinePoint.TheObjects[j]);
      this->StartingCrossSections.TheObjects[i].normal.TheObjects[j].Assign(input.StartingCrossSections.TheObjects[i].normal.TheObjects[j]);
    }
    this->StartingCrossSections.TheObjects[i].normal.TheObjects[input.AmbientDimension].MakeOne();
    this->StartingCrossSections.TheObjects[i].affinePoint.TheObjects[input.AmbientDimension].MakeOne();
  }
  input.LabelChamberIndicesProperly();
  this->LabelChamberIndicesProperly();
  if (this->flagAnErrorHasOcurredTimeToPanic)
  { this->ComputeDebugString();
    input.ComputeDebugString();
  }
  for (int i=0; i<this->size; i++)
    this->TheObjects[i]->InduceFromCombinatorialChamberLowerDimensionNoAdjacencyInfo(*input.TheObjects[i], *this);
  this->theHyperplanes.ClearTheObjects();
  //this->ComputeDebugString();
  for (int i=0; i<input.theHyperplanes.size; i++)
  { root tempRoot, theZeroRoot; theZeroRoot.MakeZero(this->AmbientDimension-1);
    tempRoot.Assign(input.theHyperplanes.TheObjects[i]);
    tempRoot.MakeNormalInProjectivizationFromPointAndNormal(theZeroRoot, input.theHyperplanes.TheObjects[i]);
    tempRoot.ScaleToIntegralMinHeightFirstNonZeroCoordinatePositive();
    this->theHyperplanes.AddObjectOnTopNoRepetitionOfObjectHash(tempRoot);
  }
  //this->ComputeDebugString();
  this->ComputeVerticesFromNormals(theGlobalVariables);
  //this->ComputeDebugString();
  this->WireChamberAdjacencyInfoAsIn(input);
  //this->ComputeDebugString();
  if (!this->ConsistencyCheck(true, theGlobalVariables))
  { this->flagAnErrorHasOcurredTimeToPanic=true;
  }
  assert(this->ConsistencyCheck(true, theGlobalVariables));
}

void CombinatorialChamberContainer::LabelChamberIndicesProperly()
{ for(int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
    { this->TheObjects[i]->IndexInOwnerComplex=i;
      this->TheObjects[i]->LabelWallIndicesProperly();
    }
}

 void CombinatorialChamberContainer::SetupRootsOfBorel(char WeylLetter, int Dimension, bool reverseOrderElementsForTest)
  { WeylGroup tempW;
    tempW.MakeArbitrary(WeylLetter, Dimension);
    tempW.ComputeRootsOfBorel(this->theDirections);
    this->theCurrentIndex=-1;
    if (reverseOrderElementsForTest)
      this->theDirections.ReverseOrderElements();
  }

CombinatorialChamberContainer::CombinatorialChamberContainer()
{ this->init();
}

void CombinatorialChamberContainer::init()
{ //initializations required for multitasking  syncronization
  this->flagReachSafePointASAP=false;
  this->flagMustStop=false;
  this->flagIsRunning=false;
  ///////////////////////////////////////////////////////////////////////////
  //these flags are kept for legacy purposes. The only supported combination under which the program runs is this!
  ////////////////////////////////////////////////////////////////////////////////
  this->flagStoringVertices=true;
  this->flagMakeGrandMasterConsistencyCheck=false;
  ///////////////////////////////////////////////////////////////////////////
  this->KillAllElements();
  this->ReleaseMemory();
  this->FirstNonExploredIndex=0;
  this->indexNextChamberToSlice=-1;
  this->theCurrentIndex=-1;
  this->NewHyperplanesToSliceWith.size=0;
  this->theHyperplanes.ClearTheObjects();
  this->PreferredNextChambers.ReleaseMemory();
  this->startingCones.ReleaseMemory();
  this->theWeylGroupAffineHyperplaneImages.size=0;
  this->flagMakingASingleHyperplaneSlice=false;
  this->flagUsingVerticesToDetermineBogusNeighborsIfPossible=false;
  this->flagSpanTheEntireSpace=true;
  this->flagMakingReports=true;
  this->flagDrawingProjective=true;
  this->flagSliceWithAWallIgnorePermanentlyZero=true;
  this->flagUsingStartingConesSeparation=false;
}

CombinatorialChamberContainer::~CombinatorialChamberContainer()
{ this->Free();
}

void CombinatorialChamberContainer::DumpAll()
{ CombinatorialChamberContainer::TheBigDump.clear();
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i]->ComputeDebugString(*this);
//    CombinatorialChamberContainer::TheBigDump <<this->TheObjects[i]->DebugString;
  }
}

int CombinatorialChamberContainer::LabelChambersForDisplayAndGetNumVisibleChambers()
{ int NumZeroChambers=0;
  int NumChambersNonZero=0;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
    { if (this->TheObjects[i]->flagHasZeroPolynomiaL)
      { NumZeroChambers++;
        this->TheObjects[i]->DisplayNumber=NumZeroChambers;
      } else
      { NumChambersNonZero++;
        this->TheObjects[i]->DisplayNumber=NumChambersNonZero;
      }
    }
  return NumChambersNonZero;
}

int CombinatorialChamberContainer::FindVisibleChamberWithDisplayNumber(int inputDisplayNumber)
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
      if (!this->TheObjects[i]->flagHasZeroPolynomiaL)
        if (this->TheObjects[i]->DisplayNumber==inputDisplayNumber)
      return i;
  return -1;
}

int CombinatorialChamberContainer::GetNumVisibleChambersNoLabeling()
{ int NumChambersNonZero=0;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
      if (!this->TheObjects[i]->flagHasZeroPolynomiaL)
        NumChambersNonZero++;
  return NumChambersNonZero;
}

int CombinatorialChamberContainer::GetNumNonZeroPointers()
{ int result=0;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
     result++;
  return result;
}

int CombinatorialChamberContainer::LabelChambersAndGetNumChambersInWeylChamber(ConeGlobal& theWeylChamber)
{ int NumChambersInWeyl=0;
  int NumZeroChambers=0;
  int NumChambersNonZeroNotInWeyl=0;
//  theWeylChamber.ComputeDebugString();
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
    { if (this->TheObjects[i]->flagHasZeroPolynomiaL)
      { NumZeroChambers++;
        this->TheObjects[i]->DisplayNumber=NumZeroChambers;
      } else
      { if (this->TheObjects[i]->affineVertices.size!=0)
        { root tempRoot;
          this->TheObjects[i]->ComputeAffineInternalPoint(tempRoot, this->AmbientDimension-1);
          if (theWeylChamber.IsInCone(tempRoot))
          { NumChambersInWeyl++;
            this->TheObjects[i]->DisplayNumber=NumChambersInWeyl;
          } else
            NumChambersNonZeroNotInWeyl++;
        }
      }
    }
  NumChambersNonZeroNotInWeyl=0;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
     if (!this->TheObjects[i]->flagHasZeroPolynomiaL)
       if (this->TheObjects[i]->affineVertices.size!=0)
        { root tempRoot;
          this->TheObjects[i]->ComputeAffineInternalPoint(tempRoot, this->AmbientDimension-1);
          if (!theWeylChamber.IsInCone(tempRoot))
          { NumChambersNonZeroNotInWeyl++;
            this->TheObjects[i]->DisplayNumber = NumChambersInWeyl+NumChambersNonZeroNotInWeyl;
          }
        }
  return NumChambersInWeyl;
}

void CombinatorialChamberContainer::Free()
{ this->KillAllElements();
}

void CombinatorialChamberContainer::MakeStartingChambers(roots& directions, root* theIndicatorRoot, GlobalVariables& theGlobalVariables)
{ this->flagMakingASingleHyperplaneSlice=false;
  if (directions.size==0)
    return;
  this->AmbientDimension= directions.TheObjects[0].size;
  if (this->AmbientDimension==1)
    return;
  int tempI= directions.ArrangeFirstVectorsBeOfMaxPossibleRank(theGlobalVariables);
  assert(tempI== this->AmbientDimension);
  this->IndicatorRoot.Assign(IndicatorRoot);
  if (this->IndicatorRoot.size!=this->AmbientDimension)
    this->IndicatorRoot.MakeZero(this->AmbientDimension);
  this->startingCones.initFromDirections(directions, theGlobalVariables, *this);
//  this->startingCones.ComputeDebugString();
  this->ComputeGlobalCone(directions, theGlobalVariables);
  //this->TheGlobalConeNormals.ComputeDebugString();
  this->PreferredNextChambers.ReleaseMemory();
  this->KillAllElements();
  if (this->flagSpanTheEntireSpace)
    this->MakeStartingChambersSpanEntireSpace(directions, theIndicatorRoot, theGlobalVariables);
  else
    this->MakeStartingChambersDontSpanEntireSpace(directions, theIndicatorRoot, theGlobalVariables);
}

/*void CombinatorialChamberContainer::MakeStartingChambersSpanEntireSpace(roots& directions, root* theIndicatorRoot, GlobalVariables& theGlobalVariables)
{ Selection theSelection;
  theSelection.init(this->AmbientDimension);
  this->theHyperplanes.ClearTheObjects();
  this->theHyperplanes.MakeActualSizeAtLeastExpandOnTop(MathRoutines::NChooseK(directions.size, this->AmbientDimension-1));
  for(int i=0; i<this->AmbientDimension; i++)
  { roots TempRoots;
    root TempRoot;
    Rational tempRat;
    theSelection.incrementSelectionFixedCardinality(this->AmbientDimension-1);
    directions.SubSelection(theSelection, TempRoots);
    TempRoots.ComputeNormal(TempRoot);
    TempRoot.ScaleToIntegralMinHeightFirstNonZeroCoordinatePositive();
    this->theHyperplanes.AddObjectOnTopHash(TempRoot);
  }
  theSelection.initNoMemoryAllocation();
  int NumStartingChambers=MathRoutines::TwoToTheNth(this->AmbientDimension);
  this->initAndCreateNewObjects(NumStartingChambers);
  this->StartingCrossSections.SetSize(NumStartingChambers);
  for(int i=0; i<NumStartingChambers; i++)
  { int tempI= theSelection.SelectionToIndex();
    this->TheObjects[tempI]->Externalwalls.MakeActualSizeAtLeastExpandOnTop(this->AmbientDimension);
    for (int j=0; j<this->AmbientDimension; j++)
    { this->TheObjects[tempI]->AllVertices.AddRoot(directions.TheObjects[j]);
      if (theSelection.selected[j])
      { int tempI2;
        theSelection.selected[j]=false;
        tempI2=theSelection.SelectionToIndex();
        theSelection.selected[j]=true;
        CombinatorialChamber* plusOwner; CombinatorialChamber* minusOwner;
        if(this->theHyperplanes.TheObjects[this->AmbientDimension-j-1].OurScalarProductIsPositive(directions.TheObjects[j]))
        { plusOwner= this->TheObjects[tempI];
          minusOwner= this->TheObjects[tempI2];
        } else
        { minusOwner= this->TheObjects[tempI];
          plusOwner= this->TheObjects[tempI2];
        }
        this->TheObjects[tempI]->MakeNewMutualNeighbors(plusOwner, minusOwner, this->theHyperplanes.TheObjects[this->AmbientDimension-j-1]);
      } else
        this->TheObjects[tempI]->AllVertices.LastObject()->MinusRoot();
//      if (this->flagAnErrorHasOcurredTimeToPanic)
  //      this->ComputeDebugString();
    }
    root tempRoot;
    tempRoot.Assign(directions.TheObjects[0]);
    if (!theSelection.selected[0])
      tempRoot.MinusRoot();
    this->StartingCrossSections.TheObjects[tempI].affinePoint.Assign(tempRoot);
    theSelection.incrementSelection();
//    if (this->flagAnErrorHasOcurredTimeToPanic)
//      this->ComputeDebugString();
  }
  for(int i=0; i<NumStartingChambers; i++)
  { this->TheObjects[i]->IndexStartingCrossSectionNormal=i;
    root Accum;  Accum.MakeZero(this->AmbientDimension);
    for (int j=0; j<this->TheObjects[i]->Externalwalls.size; j++)
      Accum.Add(this->TheObjects[i]->Externalwalls.TheObjects[j].normal);
    this->StartingCrossSections.TheObjects[i].normal.Assign(Accum);
//    if (this->flagAnErrorHasOcurredTimeToPanic)
//      Accum.ComputeDebugString();
    assert(this->TheObjects[i]->ConsistencyCheck(this->AmbientDimension, false, *this));
    if (this->TheGlobalConeNormals.IsSurelyOutsideCone(this->TheObjects[i]->AllVertices))
      this->TheObjects[i]->flagPermanentlyZero=true;
    this->TheObjects[i]->AllVertices.Average(this->TheObjects[i]->InternalPoint, this->AmbientDimension);
  }
  this->TheObjects[NumStartingChambers-1]->flagHasZeroPolynomiaL=false;
  this->TheGlobalConeNormals.ElementToString(theGlobalVariables.theIndicatorVariables.StatusString1);
  this->ComputeDebugString(false);
  theGlobalVariables.theIndicatorVariables.StatusString1.append(this->DebugString);
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);

//  if (this->flagAnErrorHasOcurredTimeToPanic)
//    this->ComputeDebugString();
}*/

void CombinatorialChamber::WriteToFile(std::fstream& output, GlobalVariables& theGlobalVariables)
{ output << "Flags_and_indices: ";
  output << this->flagHasZeroPolynomiaL << " " << this->flagExplored << " " << this->flagPermanentlyZero << " ";
  output << this->IndexInOwnerComplex << " " << this->IndexStartingCrossSectionNormal << " " << this->DisplayNumber << "\nVertices:\n";
  this->AllVertices.WriteToFile(output, theGlobalVariables);
  output << "Internal_point: ";
  this->InternalPoint.WriteToFile(output);
  output << "\nInternalWalls:\n";
  this->InternalWalls.WriteToFile(output, theGlobalVariables);
  output << "\n" << this->Externalwalls.size << "\n";
  for (int i=0; i<this->Externalwalls.size; i++)
  { this->Externalwalls.TheObjects[i].WriteToFile(output);
    output << " ";
  }
}

bool CombinatorialChamber::ReadFromFile(std::fstream& input, GlobalVariables& theGlobalVariables, CombinatorialChamberContainer& owner)
{ if (!input.is_open())
    return false;
  std::string tempS;
  int tempI;
  input >> tempS;
  input >> this->flagHasZeroPolynomiaL >> this->flagExplored>>this->flagPermanentlyZero;
  input >> this->IndexInOwnerComplex >> this->IndexStartingCrossSectionNormal;
  input >> this->DisplayNumber;
  input >> tempS;
  this->AllVertices.ReadFromFile(input, theGlobalVariables);
  input >> tempS;
  this->InternalPoint.ReadFromFile(input);
  input >> tempS;
  assert(tempS =="InternalWalls:");
  this->InternalWalls.ReadFromFile(input, theGlobalVariables);
  input >> tempI;
  this->Externalwalls.SetSize(tempI);
  for (int i=0; i<this->Externalwalls.size; i++)
    this->Externalwalls.TheObjects[i].ReadFromFile(input, owner);
  return true;
}

void WallData::WriteToFile(std::fstream& output)
{ //output << this->indexInOwnerChamber <<" ";
  this->normal.WriteToFile(output);
  output << " " << this->NeighborsAlongWall.size << " ";
  assert(this->NeighborsAlongWall.size==this->IndicesMirrorWalls.size);
  for (int i=0; i<this->NeighborsAlongWall.size; i++ )
    if (this->NeighborsAlongWall.TheObjects[i]==0)
      output << -1 << " " << -1 << " ";
    else
    { //assert(this->MirrorWall.TheObjects[i]!=0);
      output << this->NeighborsAlongWall.TheObjects[i]->IndexInOwnerComplex << " " << this->IndicesMirrorWalls.TheObjects[i] << " ";
    }
}

void WallData::ReadFromFile(std::fstream& input, CombinatorialChamberContainer& owner)
{ //input >>this->indexInOwnerChamber;
  this->normal.ReadFromFile(input);
  int tempI, indexN, indexW;
  input >> tempI;
  this->NeighborsAlongWall.SetSize(tempI);
  this->IndicesMirrorWalls.SetSize(tempI);
  for (int i=0; i<this->NeighborsAlongWall.size; i++ )
  { input >> indexN >> indexW;
    if (indexN==-1)
    { this->NeighborsAlongWall.TheObjects[i]=0;
      this->IndicesMirrorWalls.TheObjects[i]=-1;
    }
    else
    { this->NeighborsAlongWall.TheObjects[i]= owner.TheObjects[indexN];
      this->IndicesMirrorWalls.TheObjects[i]=indexW;
      assert(this->NeighborsAlongWall.TheObjects[i]!=0);
    }
  }
}

void CombinatorialChamberContainer::WriteToDefaultFile(GlobalVariables& theGlobalVariables)
{ this->WriteToFile("./theChambers.txt", theGlobalVariables);
}

bool CombinatorialChamberContainer::WriteToFile(const std::string& FileName, GlobalVariables& theGlobalVariables)
{ std::fstream tempF;
  CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(tempF, FileName, false, true, false);
  this->WriteToFile(tempF, theGlobalVariables);
  tempF.close();
  return true;
}

bool CombinatorialChamberContainer::ReadFromFile(const std::string& FileName, GlobalVariables& theGlobalVariables)
{ std::fstream tempF;
  if (!CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(tempF, FileName, false, false, false))
    return false;
  this->ReadFromFile(tempF, theGlobalVariables);
  assert(this->ConsistencyCheck(false, theGlobalVariables));
  tempF.close();
  return true;
}

bool CombinatorialChamberContainer::ReadFromDefaultFile(GlobalVariables& theGlobalVariables)
{ return this->ReadFromFile("./theChambers.txt", theGlobalVariables);
}

void CombinatorialChamberContainer::PauseSlicing()
{ this->thePauseController.SignalPauseToSafePointCallerAndPauseYourselfUntilOtherReachesSafePoint();
}

void CombinatorialChamberContainer::ResumeSlicing()
{ this->thePauseController.UnlockSafePoint();
}

void CombinatorialChamberContainer::SliceTheEuclideanSpace(GlobalVariables& theGlobalVariables, bool SpanTheEntireSpace)
{ this->flagIsRunning=true;
  this->SliceTheEuclideanSpace(0, theGlobalVariables, SpanTheEntireSpace);
  this->flagIsRunning=false;
}

void ConeGlobal::WriteToFile(std::fstream& output, GlobalVariables& theGlobalVariables)
{ this->roots::WriteToFile(output, theGlobalVariables);
  output << "\nChamberTestArray: " << this->ChamberTestArray.size << " ";
  for (int i=0; i<this->ChamberTestArray.size; i++)
    output << this->ChamberTestArray.TheObjects[i] << " ";
}

void ConeGlobal::ReadFromFile(std::fstream& input, GlobalVariables& theGlobalVariables)
{ std::string tempS; int tempI;
  this->roots::ReadFromFile(input, theGlobalVariables);
  input >> tempS >> tempI;
  this->ChamberTestArray.SetSize(tempI);
  for (int i=0; i<this->ChamberTestArray.size; i++)
    input >> this->ChamberTestArray.TheObjects[i];
}

void simplicialCones::WriteToFile(std::fstream& output, GlobalVariables& theGlobalVariables)
{ this->theFacets.WriteToFile(output);
  output << "\nConesHavingFixedNormal: ";
  output << this->ConesHavingFixedNormal.size << " ";
  for (int i=0; i<this->ConesHavingFixedNormal.size; i++)
  { output << this->ConesHavingFixedNormal.TheObjects[i].size << " ";
    for (int j=0; j<this->ConesHavingFixedNormal.TheObjects[i].size; j++)
      output << this->ConesHavingFixedNormal.TheObjects[i].TheObjects[j] << " ";
  }
  output << "\ntheCones: " << this->size << " ";
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].WriteToFile(output, theGlobalVariables);
    output << " ";
  }
}

void simplicialCones::ReadFromFile(std::fstream& input, GlobalVariables& theGlobalVariables)
{ std::string tempS; int tempI;
  this->theFacets.ReadFromFile(input);
  input >> tempS;
  assert(tempS=="ConesHavingFixedNormal:");
  input >> tempI;
  this->ConesHavingFixedNormal.SetSize(tempI);
  for (int i=0; i<this->ConesHavingFixedNormal.size; i++)
  { input >> tempI;
    this->ConesHavingFixedNormal.TheObjects[i].SetSize(tempI);
    for (int j=0; j<this->ConesHavingFixedNormal.TheObjects[i].size; j++)
      input >> this->ConesHavingFixedNormal.TheObjects[i].TheObjects[j];
   }
  input >> tempS >> tempI;
  assert(tempS=="theCones:");
  this->SetSize(tempI);
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].ReadFromFile(input, theGlobalVariables);
}

void hashedRoots::WriteToFile(std::fstream& output)
{ int theDimension=0;
  if (this->size>0)
    theDimension= this->TheObjects[0].size;
  output << "Num|dim: " << this->size << " " << theDimension << " ";
  for (int i=0; i<this->size; i++)
    for (int j=0; j<theDimension; j++)
    { this->TheObjects[i].TheObjects[j].WriteToFile(output);
      output << " ";
    }
}

void hashedRoots::ReadFromFile(std::fstream& input)
{ int theDimension; std::string tempS;
  int theSize;
  this->ClearTheObjects();
  input >> tempS >> theSize >> theDimension;
  this->MakeActualSizeAtLeastExpandOnTop(theSize);
  root tempRoot;
  tempRoot.SetSize(theDimension);
  for (int i=0; i<theSize; i++)
  { for (int j=0; j<theDimension; j++)
      tempRoot.TheObjects[j].ReadFromFile(input);
    this->AddObjectOnTopHash(tempRoot);
   }
}

void ConeGlobal::ComputeFromDirections(roots& directions, GlobalVariables& theGlobalVariables, int theDimension)
{ this->size=0;
  int NumCandidates = MathRoutines::NChooseK(directions.size, theDimension-1);
  Selection theSelection;
  theSelection.init(directions.size);
  root normalCandidate;
  for (int i=0; i<NumCandidates; i++)
  { theSelection.incrementSelectionFixedCardinality(theDimension-1);
    if (directions.ComputeNormalFromSelection(normalCandidate, theSelection, theGlobalVariables, theDimension))
    { bool hasPositive; bool hasNegative;
      hasPositive=false; hasNegative=false;
      for (int j=0; j<directions.size; j++)
      { Rational tempRat;
        root::RootScalarEuclideanRoot(directions.TheObjects[j], normalCandidate, tempRat);
        if (tempRat.IsNegative())
          hasNegative=true;
        if (tempRat.IsPositive())
          hasPositive=true;
      }
      normalCandidate.ScaleToIntegralMinHeight();
      if ((hasNegative && !hasPositive))
        normalCandidate.MinusRoot();
      if (!(hasNegative && hasPositive))
      {  bool IsValid=true;
        for (int j=0; j<this->size; j++)
          if (normalCandidate.IsProportionalTo(this->TheObjects[j]))
            IsValid=false;
        if (IsValid)
          this->AddRootNoRepetition(normalCandidate);
      }
    }
  }
  this->ChamberTestArray.SetSize(this->size);
}

bool ConeGlobal::IsSurelyOutsideCone(roots& TheVertices)
{ if (!this->FillInChamberTestArray(TheVertices, true))
    return false;
  return this->IsSurelyOutsideConeAccordingToChamberTestArray();
}

bool ConeGlobal::FillInChamberTestArray(roots& TheVertices, bool initChamberTestArray)
{ //init first the array we will use for check
  //values in the array: 0 undertermined, -1 - outside with respect to the normal of the particular wall, +1 inside with respect to the normal of the particular wall
  if (initChamberTestArray)
    this->ChamberTestArray.initFillInObject(this->size, 0);
  for (int j=0; j<TheVertices.size; j++)
  { bool TestedVertexIsStrictlyInsideGlobalCone = true;
    for (int k=0; k<this->size; k++)
    { Rational tempRat;
      root::RootScalarEuclideanRoot(TheVertices.TheObjects[j], this->TheObjects[k], tempRat);
      int state;  state=0;
      if (tempRat.IsPositive())
        state =1;
      else
      { TestedVertexIsStrictlyInsideGlobalCone=false;
        if (tempRat.IsNegative())
          state=-1;
      }
      if (state!=0)
      { if (this->ChamberTestArray.TheObjects[k]==0)
          this->ChamberTestArray.TheObjects[k]=state;
        else
          if (this->ChamberTestArray.TheObjects[k]!=state)
            return false;
      }
    }
    if (TestedVertexIsStrictlyInsideGlobalCone)
      return false;
  }
  return true;
}

bool ConeGlobal::IsSurelyOutsideConeAccordingToChamberTestArray()
{ for (int i=0; i<this->size; i++)
    if (this->ChamberTestArray.TheObjects[i]==-1)
      return true;
  return false;
}

bool ConeGlobal::IsSurelyOutsideCone(rootsCollection& TheVertices)
{ bool firstRun=true;
  for (int i=0; i<TheVertices.size; i++)
  { if (!this->FillInChamberTestArray(TheVertices.TheObjects[i], firstRun))
      return false;
    firstRun=false;
  }
  return this->IsSurelyOutsideConeAccordingToChamberTestArray();
}

/*void CombinatorialChamber::InduceFromAffineConeAddExtraDimension(affineCone& input)
{ this->ExternalWallsNormals.SetSize(input.theWalls.size);
  //the extra dimension is going to be the last dimension
  for (int i=0; i<this->ExternalWallsNormals.size; i++)
  { this->ExternalWallsNormals.TheObjects[i].
      MakeNormalInProjectivizationFromAffineHyperplane(input.theWalls.TheObjects[i]);
  }
}*/

void CombinatorialChamber::InduceFromCombinatorialChamberLowerDimensionNoAdjacencyInfo(CombinatorialChamber& input, CombinatorialChamberContainer& owner)
{ root ZeroRoot; ZeroRoot.MakeZero(owner.AmbientDimension-1);
  this->Externalwalls.SetSize(input.Externalwalls.size+1);
  if (owner.flagAnErrorHasOcurredTimeToPanic)
    input.ComputeDebugString(owner);
  assert(input.IndexInOwnerComplex==this->IndexInOwnerComplex);
  //the extra dimension is going to be the last dimension
  for (int i=0; i<input.Externalwalls.size; i++)
  { this->Externalwalls.TheObjects[i].normal.MakeNormalInProjectivizationFromPointAndNormal(ZeroRoot, input.Externalwalls.TheObjects[i].normal);
    this->Externalwalls.TheObjects[i].NeighborsAlongWall.size=0;
    this->Externalwalls.TheObjects[i].IndicesMirrorWalls.size=0;
  }
  //this->ComputeDebugString(&owner);
  this->Externalwalls.LastObject()->normal.MakeZero(owner.AmbientDimension);
  this->Externalwalls.LastObject()->normal.TheObjects[owner.AmbientDimension-1].MakeOne();
  this->Externalwalls.LastObject()->IndicesMirrorWalls.size=0;
  this->Externalwalls.LastObject()->IndicesMirrorWalls.AddObjectOnTop(-1);
  this->Externalwalls.LastObject()->NeighborsAlongWall.size=0;
  this->Externalwalls.LastObject()->NeighborsAlongWall.AddObjectOnTop(0);
  this->flagHasZeroPolynomiaL= input.flagHasZeroPolynomiaL;
  this->flagPermanentlyZero= input.flagPermanentlyZero;
  this->IndexStartingCrossSectionNormal= input.IndexStartingCrossSectionNormal;
}

void CombinatorialChamber::WireChamberAndWallAdjacencyData(CombinatorialChamberContainer& owner, CombinatorialChamber* input)
{ this->LabelWallIndicesProperly();
  input->LabelWallIndicesProperly();
  assert(this->Externalwalls.size==input->Externalwalls.size+1);
  for (int i=0; i<input->Externalwalls.size; i++)
  { WallData& currentWall= this->Externalwalls.TheObjects[i];
    WallData& originalWall= input->Externalwalls.TheObjects[i];
    currentWall.NeighborsAlongWall.SetSize(originalWall.NeighborsAlongWall.size);
    currentWall.IndicesMirrorWalls.SetSize(originalWall.NeighborsAlongWall.size);
    assert(originalWall.IndicesMirrorWalls.size==originalWall.NeighborsAlongWall.size);
    for (int j=0; j<currentWall.NeighborsAlongWall.size; j++)
      if (originalWall.NeighborsAlongWall.TheObjects[j]==0)
      { currentWall.NeighborsAlongWall.TheObjects[j]=0;
        currentWall.IndicesMirrorWalls.TheObjects[j]=-1;
      } else
      { currentWall.NeighborsAlongWall.TheObjects[j]=owner.TheObjects[originalWall.NeighborsAlongWall.TheObjects[j]->IndexInOwnerComplex];
        assert(currentWall.NeighborsAlongWall.TheObjects[j]->Externalwalls.size == originalWall.NeighborsAlongWall.TheObjects[j]->Externalwalls.size+1);
        currentWall.NeighborsAlongWall.TheObjects[j]->LabelWallIndicesProperly();
        currentWall.IndicesMirrorWalls.TheObjects[j]= originalWall.IndicesMirrorWalls.TheObjects[j];
      }
  }
}

bool ConeGlobal::IsInCone(const root& r)
{ for (int i=0; i<this->size; i++)
  { Rational tempRat;
    root::RootScalarEuclideanRoot(r, this->TheObjects[i], tempRat);
    if (tempRat.IsNegative())
      return false;
  }
  return true;
}

bool ConeGlobal::IsInCone(const roots& theRoots)
{ for (int i=0; i<theRoots.size; i++)
    if (!this->IsInCone(theRoots.TheObjects[i]))
      return false;
  return true;
}

int ConeGlobal::GetSignWRTCone(const root& r)
{ Rational tempRat;
  bool allPositive=true;
  for (int i=0; i<this->size; i++)
  { r.RootScalarEuclideanRoot(this->TheObjects[i], r, tempRat);
    if (tempRat.IsNegative())
      return -1;
    if (tempRat.IsEqualToZero())
      allPositive=false;
  }
  if (allPositive)
    return 1;
  return 0;
}

bool ConeGlobal::IsOnConeBorder(const root& r)
{ bool found=false;
  for (int i=0; i<this->size; i++)
  { Rational tempRat;
    root::RootScalarEuclideanRoot(r, this->TheObjects[i], tempRat);
    if (tempRat.IsNegative())
      return false;
    if (tempRat.IsEqualToZero())
      found=true;
  }
  return found;
}

bool ConeGlobal::IsStrictlyInsideCone(const root& r)
{ for (int i=0; i<this->size; i++)
  { Rational tempRat;
    root::RootScalarEuclideanRoot(r, this->TheObjects[i], tempRat);
    if (tempRat.IsNonPositive())
      return false;
  }
  return true;
}

bool ConeGlobal::SeparatesPoints(root& point1, root& point2)
{ bool tempB1= this->IsInCone(point1);
  bool tempB2= this->IsInCone(point2);
  return !(tempB1==tempB2);
}

void ConeGlobal::operator=(const ConeGlobal& right)
{ this->CopyFromBase(right);
  this->ChamberTestArray.CopyFromBase(right.ChamberTestArray);
}

void CombinatorialChamberContainer::LabelAllUnexplored()
{ for (int i =0; i<size; i++)
    if (!this->TheObjects[i]->flagPermanentlyZero || this->flagMakingASingleHyperplaneSlice)
      this->TheObjects[i]->flagExplored =false;
  this->FirstNonExploredIndex=0;
  this->NumExplored=0;
}

bool WallData::IsExternalWithRespectToDirection(root& direction)
{ return this->normal.OurScalarProductIsPositive(direction);
}

bool WallData::EveryNeigborIsExplored(bool& allNeighborsHaveZeroPoly)
{ allNeighborsHaveZeroPoly=true;
  for (int i=0; i<this->NeighborsAlongWall.size; i++)
    if (this->NeighborsAlongWall.TheObjects[i]!=0)
    { if ((!this->NeighborsAlongWall.TheObjects[i]->flagExplored)&&(!this->NeighborsAlongWall.TheObjects[i]->flagPermanentlyZero))
        return false;
      else
        if(!this->NeighborsAlongWall.TheObjects[i]->flagHasZeroPolynomiaL && !this->NeighborsAlongWall.TheObjects[i]->flagPermanentlyZero)
          allNeighborsHaveZeroPoly=false;
    }
  return true;
}

bool WallData::FacetContainsChamberOnlyOnce(CombinatorialChamber* owner)
{ bool FoundOnce= false;
  for (int i=0; i<this->NeighborsAlongWall.size; i++)
    if (this->NeighborsAlongWall.TheObjects[i]==owner)
    { FoundOnce= !FoundOnce;
      if (!FoundOnce)
        return false;
    }
  return FoundOnce;
}

void WallData::ElementToString(std::string& output)
{ std::stringstream out;
  std::string tempS; this->normal.ElementToString(tempS);
  out << "normal: " << tempS << " Neighbors: ";
  if (this->flagDisplayWallDetails)
    for (int i=0; i<this->NeighborsAlongWall.size; i++)
    { if (this->NeighborsAlongWall.TheObjects[i]!=0)
      { if (this->NeighborsAlongWall.TheObjects[i]->flagHasZeroPolynomiaL)
          out << "Invisible";
        else
          out << "c";
        out << this->NeighborsAlongWall.TheObjects[i]->DisplayNumber << ", ";
      }
    }
  output = out.str();
}

void WallData::RemoveNeighborhoodBothSidesNoRepetitionNeighbors(CombinatorialChamber* owner, CombinatorialChamber* NeighborPointer)
{ if (CombinatorialChamberContainer::flagAnErrorHasOcurredTimeToPanic)
  { assert(this->ContainsNeighborAtMostOnce(NeighborPointer));
    assert(owner->OwnsAWall(this));
  }
  for (int i=0; i<this->NeighborsAlongWall.size; i++)
    if (this->NeighborsAlongWall.TheObjects[i]==NeighborPointer)
    { this->NeighborsAlongWall.TheObjects[i]->Externalwalls.TheObjects[this->IndicesMirrorWalls.TheObjects[i]].RemoveNeighborOneSideNoRepetitions(owner);
      this->NeighborsAlongWall.PopIndexSwapWithLast(i);
      this->IndicesMirrorWalls.PopIndexSwapWithLast(i);
      //this->NeighborsAlongWall.TheObjects[i]=0;
      //this->IndicesMirrorWalls.TheObjects[i]=-1;
      return;
    }
  assert(false);
}

int WallData::RemoveNeighborhoodBothSidesAllowRepetitionsReturnNeighborsDecrease(CombinatorialChamber* owner, CombinatorialChamber* NeighborPointer)
{ int NumFoundNeighbors=0;
  for (int i=0; i<this->NeighborsAlongWall.size; i++)
    if (this->NeighborsAlongWall.TheObjects[i]==NeighborPointer)
    { if (this->NeighborsAlongWall.TheObjects[i]!=0)
        this->NeighborsAlongWall.TheObjects[i]->Externalwalls.TheObjects[this->IndicesMirrorWalls.TheObjects[i]].RemoveNeighborOneSideAllowRepetitions(owner);
      this->NeighborsAlongWall.PopIndexSwapWithLast(i);
      this->IndicesMirrorWalls.PopIndexSwapWithLast(i);
      i--;
      NumFoundNeighbors++;
    }
  return NumFoundNeighbors;
}

void WallData::RemoveNeighborOneSideNoRepetitions(CombinatorialChamber* NeighborPointer)
{ assert(this->ContainsNeighborAtMostOnce(NeighborPointer));
  for (int i=0; i<this->NeighborsAlongWall.size; i++)
    if (this->NeighborsAlongWall.TheObjects[i]==NeighborPointer)
    { this->NeighborsAlongWall.PopIndexSwapWithLast(i);
      this->IndicesMirrorWalls.PopIndexSwapWithLast(i);
      return;
    }
  assert(false);
}

void WallData::RemoveNeighborOneSideAllowRepetitions(CombinatorialChamber* NeighborPointer)
{ for (int i=0; i<this->NeighborsAlongWall.size; i++)
    if (this->NeighborsAlongWall.TheObjects[i]==NeighborPointer)
    { this->NeighborsAlongWall.PopIndexSwapWithLast(i);
      this->IndicesMirrorWalls.PopIndexSwapWithLast(i);
      i--;
    }
}

bool WallData::ConsistencyCheck(CombinatorialChamber& owner, CombinatorialChamberContainer& ownerComplex)
{ int trueNeighbors=0;
  for (int i=0; i<this->NeighborsAlongWall.size; i++)
    if (this->NeighborsAlongWall.TheObjects[i]!=0)
    { WallData& otherWall= this->NeighborsAlongWall.TheObjects[i]->Externalwalls.TheObjects[this->IndicesMirrorWalls.TheObjects[i]];
      if (!otherWall.ContainsNeighborExactlyOnce(&owner))
        Stop();
      assert(otherWall.ContainsNeighborExactlyOnce(&owner));
      assert(this->ContainsNeighborExactlyOnce(this->NeighborsAlongWall.TheObjects[i]));
      root tempRoot; tempRoot.Assign(this->normal);
      tempRoot.MinusRoot();
      if(!tempRoot.IsEqualTo(otherWall.normal))
      { assert(false);
        return false;
      }
      if (!this->ContainsNeighborAtMostOnce(this->NeighborsAlongWall.TheObjects[i]))
      { assert(false);
        return false;
      }
      trueNeighbors++;
    }
  return true;
}

bool WallData::ContainsNeighborAtMostOnce(CombinatorialChamber* neighbor)
{ int NumNeighbors=0;
  for (int i=0; i<this->NeighborsAlongWall.size; i++)
  { if (this->NeighborsAlongWall.TheObjects[i]==neighbor)
      NumNeighbors++;
    if (NumNeighbors>1)
    { assert(false);
      return false;
    }
  }
  return true;
}

bool WallData::ContainsNeighborExactlyOnce(CombinatorialChamber* neighbor)
{ int NumNeighbors=0;
  for (int i=0; i<this->NeighborsAlongWall.size; i++)
  { if (this->NeighborsAlongWall.TheObjects[i]==neighbor)
      NumNeighbors++;
    if (NumNeighbors>1)
      return false;
  }
  return NumNeighbors==1;
}

void WallData::operator=(const WallData& right)
{ if (this==&right)
    return;
  this->flagIsClosed=right.flagIsClosed;
  this->normal.Assign(right.normal);
  this->NeighborsAlongWall.CopyFromBase(right.NeighborsAlongWall);
  this->IndicesMirrorWalls.CopyFromBase(right.IndicesMirrorWalls);
}

void WallData::RemoveNeighborExtraOcurrences(CombinatorialChamber* neighbor)
{ bool found=false;
  for (int i=0; i<this->NeighborsAlongWall.size; i++)
    if (this->NeighborsAlongWall.TheObjects[i]==neighbor)
    { if (found)
      { this->NeighborsAlongWall.PopIndexSwapWithLast(i);
        this->IndicesMirrorWalls.PopIndexSwapWithLast(i);
        i--;
      }
      found=true;
    }
}

void WallData::SubstituteNeighborOneOccurenceNeighborOnly(CombinatorialChamber* oldNeighbor, CombinatorialChamber* newNeighbor, int IndexNewNeighborWall)
{ assert(this->ContainsNeighborAtMostOnce(oldNeighbor));
  for (int i=0; i<this->NeighborsAlongWall.size; i++)
    if (this->NeighborsAlongWall.TheObjects[i]==oldNeighbor)
    { this->NeighborsAlongWall.TheObjects[i] = newNeighbor;
      this->IndicesMirrorWalls.TheObjects[i] = IndexNewNeighborWall;
      return;
    }
  assert(false);
}

void WallData::SubstituteNeighborOneAllowNeighborAppearingNotOnce(CombinatorialChamber* oldNeighbor, CombinatorialChamber* newNeighbor, int IndexNewNeighborWall)
{ for (int i=0; i<this->NeighborsAlongWall.size; i++)
    if (this->NeighborsAlongWall.TheObjects[i]==oldNeighbor)
    { this->NeighborsAlongWall.TheObjects[i] = newNeighbor;
      this->IndicesMirrorWalls.TheObjects[i] = IndexNewNeighborWall;
    }
}

int WallData::GetIndexWallToNeighbor(CombinatorialChamber* neighbor)
{ int tempI= this->NeighborsAlongWall.IndexOfObject(neighbor);
  if (tempI==-1)
    return -1;
  return this->IndicesMirrorWalls.TheObjects[tempI];
}

void WallData::AddNeighbor(CombinatorialChamber* newNeighbor, int IndexNewNeighborWall)
{ this->NeighborsAlongWall.AddObjectOnTop(newNeighbor);
  this->IndicesMirrorWalls.AddObjectOnTop(IndexNewNeighborWall);
}

bool WallData::SplitWall(int indexInOwner, List<int>& possibleBogusWallsThisSide, CombinatorialChamber* BossChamber, CombinatorialChamber* NewPlusChamber, CombinatorialChamber* NewMinusChamber, CombinatorialChamberContainer& ownerComplex, roots& ThePlusVertices, roots& TheMinusVertices, root& TheKillerFacet, root& direction, List<CombinatorialChamber*>& PossibleBogusNeighbors, List<int>& PossibleBogusWalls, GlobalVariables& theGlobalVariables)
{ bool IsPositive, IsNegative; IsPositive = false;  IsNegative = false;
  //static int ProblemCounter=0;
  //ProblemCounter++;
  Rational tempRat;
  for (int j=0; j<ThePlusVertices.size; j++)
    if (TheKillerFacet.OurScalarProductIsPositive(ThePlusVertices.TheObjects[j]))
    { IsPositive=true;
      break;
    }
  for (int j=0; j<TheMinusVertices.size; j++)
    if(TheKillerFacet.OurScalarProductIsNegative(TheMinusVertices.TheObjects[j]))
    { IsNegative=true;
      break;
    }
  assert(IsPositive || IsNegative);
  if (ownerComplex.flagAnErrorHasOcurredTimeToPanic)
    this->ComputeDebugString();
  if (IsPositive && IsNegative)
  {//we must split the face
    NewPlusChamber->Externalwalls.AddObjectOnTopCreateNew();
    NewMinusChamber->Externalwalls.AddObjectOnTopCreateNew();
    int IndexNewPlusWall;
    int IndexNewMinusWall;
    IndexNewPlusWall = NewPlusChamber->Externalwalls.size-1;
    IndexNewMinusWall = NewMinusChamber->Externalwalls.size-1;
    NewPlusChamber->Externalwalls.LastObject()->normal.Assign(this->normal);
    NewMinusChamber->Externalwalls.LastObject()->normal.Assign(this->normal);
    for (int i=0; i<this->NeighborsAlongWall.size; i++)
    { if (this->NeighborsAlongWall.TheObjects[i]!=0)
      { WallData& MirrorWall = this->NeighborsAlongWall.TheObjects[i]->Externalwalls.TheObjects[this->IndicesMirrorWalls.TheObjects[i]];
        if (ownerComplex.flagAnErrorHasOcurredTimeToPanic)
          MirrorWall.ComputeDebugString();
        MirrorWall.SubstituteNeighborOneOccurenceNeighborOnly(BossChamber, NewPlusChamber, IndexNewPlusWall);
        MirrorWall.AddNeighbor(NewMinusChamber, IndexNewMinusWall);
        if (ownerComplex.flagAnErrorHasOcurredTimeToPanic)
          MirrorWall.ComputeDebugString();
        if(PossibleBogusNeighbors.AddOnTopNoRepetition(this->NeighborsAlongWall.TheObjects[i]))
        { PossibleBogusWalls.AddObjectOnTop(this->IndicesMirrorWalls.TheObjects[i]);
          possibleBogusWallsThisSide.AddObjectOnTop(indexInOwner);
        }
        NewPlusChamber->Externalwalls.LastObject()->AddNeighbor(this->NeighborsAlongWall.TheObjects[i], this->IndicesMirrorWalls.TheObjects[i]);
        NewMinusChamber->Externalwalls.LastObject()->AddNeighbor(this->NeighborsAlongWall.TheObjects[i], this->IndicesMirrorWalls.TheObjects[i]);
        assert(PossibleBogusNeighbors.size==PossibleBogusWalls.size);
        if (this->NeighborsAlongWall.TheObjects[i]!=0)
          if (!this->NeighborsAlongWall.TheObjects[i]->flagPermanentlyZero)
            this->NeighborsAlongWall.TheObjects[i]->AddInternalWall(TheKillerFacet, MirrorWall.normal, direction, ownerComplex, theGlobalVariables);
        if (ownerComplex.flagAnErrorHasOcurredTimeToPanic)
          this->NeighborsAlongWall.TheObjects[i]->ConsistencyCheck(ownerComplex.AmbientDimension, true, ownerComplex, theGlobalVariables);
      }
    }
    return true;
  }
  else
  { root tempRoot; tempRoot.SetSize(ownerComplex.AmbientDimension);
    CombinatorialChamber* tempC;
    root FacetInternalPoint; FacetInternalPoint.SetSize(ownerComplex.AmbientDimension);
    if (IsPositive)
      tempC= NewPlusChamber;
    else
      tempC= NewMinusChamber;
    tempC->Externalwalls.AddObjectOnTop(*this);
    for (int i=0; i<this->NeighborsAlongWall.size; i++)
      if (this->NeighborsAlongWall.TheObjects[i]!=0)
      { WallData& theMirrorWall= this->NeighborsAlongWall.TheObjects[i]->Externalwalls.TheObjects[this->IndicesMirrorWalls.TheObjects[i]];
        theMirrorWall.SubstituteNeighborOneOccurenceNeighborOnly(BossChamber, tempC, tempC->Externalwalls.size - 1);
      }
    return false;
  }
}

bool CombinatorialChamber::MakeFacetFromEdgeAndDirection(WallData& Wall1, WallData& Wall2, CombinatorialChamberContainer& owner, root& direction, roots & directions, int CurrentIndex, root& outputNormal, GlobalVariables& theGlobalVariables)
{ root NewFacetNormal;
//  tempNormal1.SetSize(root::AmbientDimension);
//  tempNormal2.SetSize(root::AmbientDimension);
  NewFacetNormal.SetSize(owner.AmbientDimension);
  Rational a1, a2, b;
  root::RootScalarEuclideanRoot(direction, Wall1.normal, a1);
  root::RootScalarEuclideanRoot(direction, Wall2.normal, a2);
  assert(!a1.IsEqualToZero());
  assert(!a2.IsEqualToZero());
  b.Assign(a1);
  b.DivideBy(a2);
  b.Minus();
  root::RootPlusRootTimesScalar(Wall1.normal, Wall2.normal, b, NewFacetNormal);
  NewFacetNormal.ScaleToIntegralMinHeightFirstNonZeroCoordinatePositive();
  if (!this->IsAValidCandidateForNormalOfAKillerFacet(NewFacetNormal, directions, CurrentIndex, owner, theGlobalVariables))
    return false;
  outputNormal.Assign(NewFacetNormal);
  return true;
}

bool WallData::IsInFacetNoBoundaries(root &point)
{ Rational tempRat;
  root::RootScalarEuclideanRoot(point, this->normal, tempRat);
  return (tempRat.IsEqualToZero());
}

bool CombinatorialChamber::IsAValidCandidateForNormalOfAKillerFacet(root& normalCandidate, roots& directions, int CurrentIndex, CombinatorialChamberContainer& owner, GlobalVariables& theGlobalVariables)
{ if (owner.theHyperplanes.IndexOfObjectHash(normalCandidate)!=-1)
    return true;
  roots& WallBasis=theGlobalVariables.rootsWallBasis;
  WallBasis.size=0;
  for (int i=0; i<=CurrentIndex; i++)
  { Rational tempRat;
    root::RootScalarEuclideanRoot(directions.TheObjects[i], normalCandidate, tempRat);
    if (tempRat.IsEqualToZero())
      WallBasis.AddRoot(directions.TheObjects[i]);
  }
  if (WallBasis.size<owner.AmbientDimension-1)
    return false;
  int tempI=WallBasis.GetRankOfSpanOfElements(theGlobalVariables);
  if (tempI<owner.AmbientDimension-1)
    return false;
  assert(tempI==owner.AmbientDimension-1);
  owner.theHyperplanes.AddObjectOnTopHash(normalCandidate);
  return true;
}

void ComplexQN::MultiplyByBasicComplex(BasicComplexNumber& b)
{
}

void ComplexQN::CopyFrom(const ComplexQN& q)
{ this->NumVars = q.NumVars;
  for (int i=0; i<this->NumVars; i++)
    this->Exponent.TheObjects[i].Assign(q.Exponent.TheObjects[i]);
  this->Coefficient.Assign(q.Coefficient);
}

void ComplexQN::MakePureQN(Rational* expArg, int NumVars)
{ this->NumVars=NumVars;
  this->MakeConst(ROne, NumVars);
  for(int i=0; i<this->NumVars; i++)
    this->Exponent.TheObjects[i].Assign(expArg[i]);
  this->Simplify();
  this->CheckCoefficient();
}

void ComplexQN::MakePureQN(int NumVars, int NonZeroIndex, Rational& coeff, Rational& ConstExp, Rational& Exp)
{ this->NumVars =NumVars;
  for(int i=0; i<this->NumVars; i++)
    this->Exponent.TheObjects[i].MakeZero();
  this->Coefficient.MakeBasicComplex(coeff, ConstExp) ;
  this->Exponent.TheObjects[NonZeroIndex].Assign(Exp);
  this->Simplify();
}

bool ComplexQN::ExponentIsEqualToZero()
{ this->CheckCoefficient();
  for (int i=0; i<this->NumVars; i++)
    if (!this->Exponent.TheObjects[i].IsEqualTo(RZero))
      return false;
  return true;
}

void ComplexQN::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

bool ComplexQN::HasSameExponent(ComplexQN& q)
{ for (int i=0; i<this->NumVars; i++)
    if (!this->Exponent.TheObjects[i].IsEqualTo(q.Exponent.TheObjects[i]))
      return false;
  return true;
}

void ComplexQN::MultiplyByLargeRational(Rational& r)
{ this->Coefficient.MultiplyByLargeRational(r);
}

void ComplexQN::operator =(const ComplexQN& q)
{ this->CopyFrom(q);
  this->CheckCoefficient();
}

bool ComplexQN::operator ==(ComplexQN& q)
{ this->CheckCoefficient();
  for (int i=0; i<this->NumVars+1; i++)
    if (!(this->Exponent.TheObjects[i].IsEqualTo(q.Exponent.TheObjects[i])))
      return false;
  return true;
}

void ComplexQN::MultiplyBy(ComplexQN& q)
{ for (int i=0; i<this->NumVars; i++)
    this->Exponent.TheObjects[i]+=(q.Exponent.TheObjects[i]);
  this->Coefficient.MultiplyBy(q.Coefficient);
  this->Simplify();
}

void ComplexQN::MakeConst(Rational& Coeff, int NumVars)
{ this->Coefficient.AssignRational(Coeff);
  this->NumVars =NumVars;
  for (int i=0; i<this->NumVars; i++)
    this->Exponent.TheObjects[i].MakeZero();
}

void CompositeComplexQN::MakeConst(Rational& Coeff, int numVars)
{ ComplexQN q(numVars);
  this->size =0;
  this->NumVariables=numVars;
  q.MakeConst(Coeff, numVars);
  this->AddObjectOnTop(q);
}

/*bool CompositeComplexQN::ElementHasPlusInFront()
{  if (this->NumNonZeroElements()>1)
  {return true; }
  else
  {  for (int i=0; i<this->size; i++)
    {  if (!this->TheObjects[i].Coefficient.IsEqualToZero())
      {  return this->TheObjects[i].Coefficient.ElementHasPlusInFront();
      }
    }
  }
  return true;
}
*/
void CompositeComplexQN::ElementToString(std::string& output)const
{ std::stringstream out;
  int NumNonZero = this->NumNonZeroElements();
  std::string tempS;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS);
    if (tempS[0]!='0')
    { if (tempS[0]!='-')
        out << "+";
      out << tempS;
    }
  }
  output=out.str();
  if (output[0]=='+')
    output.erase(0, 1);
  if (NumNonZero >1)
  { output.append(")");
    output.insert(0, "(");
  }
}

void CompositeComplexQN::AddComplexQN(ComplexQN& q)
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].HasSameExponent(q))
    { this->TheObjects[i].Coefficient.Add(q.Coefficient);
      if (this->TheObjects[i].Coefficient.IsEqualToZero())
        this->PopIndexSwapWithLast(i);
      return;
    }
  this->AddObjectOnTop(q);
}

void CompositeComplexQN::operator+=(const CompositeComplexQN &q)
{ for(int i=0; i<q.size; i++)
    this->AddComplexQN(q.TheObjects[i]);
}

bool CompositeComplexQN::ComputeDebugString()
{ this->DebugString.clear();
  this->ElementToString(this->DebugString);
  return true;
}

void CompositeComplexQN::MultiplyByComplexQN(ComplexQN &q)
{ for(int i=0; i<this->size; i++)
    this->TheObjects[i].MultiplyBy(q);
}

void CompositeComplexQN::LinearSubstitution(MatrixLargeRational& TheSub)
{ CompositeComplexQN Accum(TheSub.NumRows-1);
  ComplexQN tempQ(TheSub.NumRows-1);
  Accum.size=0;
  Accum.NumVariables= TheSub.NumRows-1;
  for(int i=0; i<this->size; i++)
  { tempQ.CopyFrom(this->TheObjects[i]);
    tempQ.LinearSubstitution(TheSub);
    Accum.AddComplexQN(tempQ);
  }
  this->Assign(Accum);
}

void CompositeComplexQN::MakePureQN(Rational* expArg, int numVars)
{ this->NumVariables=numVars;
  this->size=0;
  static ComplexQN tempQ(numVars);
  tempQ.MakePureQN(expArg, numVars);
  this->AddObjectOnTop(tempQ);
}

void CompositeComplexQN::MakePureQN(Rational* expArg, int numVars, Rational& coeff)
{ this->NumVariables=numVars;
  this->MakePureQN(expArg, numVars);
  this->TheObjects[0].Coefficient.AssignRational(coeff);
}

void CompositeComplexQN::MakePureQN(int numVars, int NonZeroIndex, Rational&coeff, Rational&Exp)
{ this->MakePureQN(numVars, NonZeroIndex, Exp, RZero, coeff);
}

void CompositeComplexQN::MakePureQN(int numVars, int NonZeroIndex, Rational&coeffExp, Rational&ConstExp, Rational& Coeff)
{ this->size=0;
  this->NumVariables=numVars;
  ComplexQN tempQ(numVars);
  tempQ.MakePureQN(numVars, NonZeroIndex, Coeff, ConstExp, coeffExp);
  this->AddComplexQN(tempQ);
}

void CompositeComplexQN::MakePureQN(Rational& constExp, int numVars, Rational&coeff)
{ this->MakePureQN(numVars, 0, RZero, constExp, coeff);
}

void CompositeComplexQN::MultiplyByLargeRational(Rational &r)
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].MultiplyByLargeRational(r);
}

bool CompositeComplexQN::IsEqualToZero()const
{ for (int i=0; i<this->size; i++)
    if (!this->TheObjects[i].IsEqualToZero())
      return false;
  return true;
}

void CompositeComplexQN::Simplify()
{ for( int i=0; i<this->size; i++)
    this->TheObjects[i].Simplify();
}

int CompositeComplexQN::NumNonZeroElements()const
{ int result=0;
  for (int i=0; i<this->size; i++)
    if (!this->TheObjects[i].IsEqualToZero())
      result++;
  return result;
}

bool CompositeComplexQN::IsEqualTo(const CompositeComplexQN& q) const
{ CompositeComplexQN tempQN(q.NumVariables) ;
  tempQN.Assign(q);
  tempQN.MultiplyByLargeRational(RMOne);
  tempQN.Add(*this);
  return tempQN.IsEqualToZero();
}

void CompositeComplexQN::DivideByRational(Rational& r)
{ Rational tempRat;
  tempRat.Assign(r);
  tempRat.Invert();
  this->MultiplyByLargeRational(tempRat);
}

void CompositeComplexQN::Assign(const CompositeComplexQN &q)
{ this->size=0;
  this->NumVariables= q.NumVariables;
  for (int i=0; i<q.size; i++)
    this->AddObjectOnTop(q.TheObjects[i]);
}

void CompositeComplexQN::MultiplyBy(CompositeComplexQN& q)
{ CompositeComplexQN tempQ(q.NumVariables);
  CompositeComplexQN Accum(q.NumVariables);
  Accum.size=0;
  for (int i=0; i<q.size; i++)
  { tempQ.Assign(*this);
    tempQ.MultiplyByComplexQN(q.TheObjects[i]);
    Accum.Add(tempQ);
  }
  this->Assign(Accum);
}

/*void ComplexQN::DecreaseNumVariables(int increment, ComplexQN& output)
{  output.CopyFrom(*this);
  output.size-=increment;
}

void ComplexQN::DecreaseNumVariables(int increment, CompositeComplexQN& output)
{ ComplexQN tempQ(this->size-2);
  this->DecreaseNumVariables(increment, tempQ);
  output.size=0;
  output.AddComplexQN(tempQ);
}

void ComplexQN::DecreaseNumVariables(int increment)
{ this->size-=increment;
}*/

/*void ComplexQN::AddBasicComplexNumber(BasicComplexNumber& b)
{ for(int i=0; i<this->Coefficients.size; i++)
  { if (this->Coefficients.TheObjects[i].Exp.IsEqualTo(b.Exp))
    { this->Coefficients.TheObjects[i].Coeff.Add(b.Coeff);
      this->Simplify();
      return;
    }
  }
  this->Coefficients.AddObjectOnTop(b);
  this->Simplify();
} */

void ComplexQN::ElementToString(std::string& output)
{ if (this->IsEqualToZero()){output.clear(); output.append("0"); return; }
  std::stringstream out;
  std::string tempS;
  this->Coefficient.ElementToString(tempS);
  if (!this->ExponentIsEqualToZero())
  { if (tempS=="1")
      tempS.clear();
    if (tempS=="-1")
      tempS="-";
    out << tempS << "e^{2i \\pi(";
    tempS.clear();
    this->LinPartToString(tempS);
    out << tempS << ")}";
  }
  else
    out << tempS;
  output= out.str();
}

void ComplexQN::LinPartToString(std::string& output)
{ output.clear();
  std::stringstream out;
  std::string tempS;
  PolynomialOutputFormat PolyFormatLocal;
  for (int i=0; i<this->NumVars; i++)
    if (!this->Exponent.TheObjects[i].IsEqualTo(RZero))
    { if (!this->Exponent.TheObjects[i].IsEqualTo(ROne))
      { tempS.clear();
        if (!this->Exponent.TheObjects[i].IsEqualTo(RMOne))
          this->Exponent.TheObjects[i].ElementToString(tempS);
        else
          tempS.assign("-");
        if (tempS[0]!='-')
          out << "+";
        out << tempS;
      }
      else
        out << "+";
      out << PolyFormatLocal.GetLetterIndex(i);
    }
  output= out.str();
  if (output.size()!=0)
    if (output[0]=='+')
      output.erase(0, 1);
}

void ComplexQN::LinearSubstitution(MatrixLargeRational& TheSub)
{ List<Rational> tempExponent;
  tempExponent.SetSize(TheSub.NumRows);
  Rational tempRat;
  BasicComplexNumber tempBC;
  tempBC.Coeff.MakeOne();
  tempBC.Exp.Assign(RZero);
  assert(TheSub.NumCols==this->NumVars);
  for (int i=0; i<TheSub.NumRows-1; i++)
    tempExponent.TheObjects[i].MakeZero();
  for (int i=0; i<this->NumVars; i++)
  { tempRat.Assign(TheSub.elements[0][i]);
    tempRat.MultiplyBy(this->Exponent.TheObjects[i]);
    tempBC.Exp+=(tempRat);
    for (int j=1; j<TheSub.NumRows; j++)
    { tempRat.Assign(TheSub.elements[j][i]);
      tempRat.MultiplyBy(this->Exponent.TheObjects[i]);
      tempExponent.TheObjects[j-1]+=(tempRat);
    }
  }
  this->NumVars= TheSub.NumRows-1;
  for (int i=0; i<this->NumVars; i++)
    this->Exponent.TheObjects[i].Assign(tempExponent.TheObjects[i]);
  this->Coefficient.MultiplyByBasicComplex(tempBC);
  this->Simplify();
}

void ComplexQN::Simplify()
{ this->Coefficient.Simplify();
  for (int i=0; i<this->NumVars; i++)
    this->Exponent.TheObjects[i].AssignFracValue();
}

bool ComplexQN::IsBasicComplex()
{ if (this->Coefficient.size==0)
    return true;
  return (this->ExponentIsEqualToZero());
}

/*void ComplexQN::MakePureQN(Rational* expArg, int Size)
{  this->Coefficient.Assign(ROne);
  this->size=Size;
  for (int i=0; i<this->size; i++)
  { this->Exponent[i].Assign(expArg[i]);
  }
  this->Simplify();
}*/

bool ComplexQN::IsEqualToZero()
{ return (this->Coefficient.size==0);
}

void PolynomialRationalCoeff::MakeLinPolyFromInt(int theDimension, int x1, int x2, int x3, int x4, int x5)
{ root tempRoot;
  tempRoot.InitFromIntegers(theDimension, x1, x2, x3, x4, x5);
  this->MakeLinPolyFromRoot(tempRoot);
}

void PolynomialRationalCoeff::operator=(const std::string& tempS)
{ Parser theParser;
  GlobalVariables tempGV;
  theParser.ParseEvaluateAndSimplify(tempS, tempGV);
  if (theParser.theValue.ExpressionType==ParserNode::typePoly)
    this->Assign(theParser.theValue.polyValue.GetElement());
  else
    this->Nullify(-1);
}

void PolynomialRationalCoeff::operator=(const PolynomialRationalCoeff& right)
{ this->CopyFromPoly(right);
}

void PolynomialRationalCoeff::MakePolyExponentFromIntRoot(intRoot& r, GlobalVariables& theGlobalVariables)
{ this->ClearTheObjects();
  this->NumVars=(int)r.size;
  Monomial<Rational>& tempM=theGlobalVariables.monMakePolyExponentFromIntRoot;
  tempM.init((int)r.size);
  tempM.Coefficient.Assign(ROne);
  for (int i=0; i<r.size; i++)
    tempM.degrees[i]=(int) r.TheObjects[i];
  this->AddMonomial(tempM);
}

int PolynomialRationalCoeff::SizeWithoutDebugString()
{ int Accum=0;
  Accum+=this->HashedList<Monomial<Rational> >::SizeWithoutObjects();
  Accum+=  sizeof(this->NumVars);
  for (int i=0; i<this->ActualSize; i++)
    Accum+=this->TheActualObjects[i].SizeWithoutCoefficient()+sizeof(Rational);
  return Accum;
}

void PolynomialRationalCoeff::TimesInteger(int x)
{ if (x==0)
  { this->Nullify(this->NumVars);
    return;
  }
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].Coefficient.MultiplyByInt(x);
}

void PolynomialRationalCoeff::DivByInteger(int x)
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].Coefficient.DivideByInteger(x);
}

void PolynomialRationalCoeff::AssignIntegerPoly(IntegerPoly& p)
{ this->Nullify(p.NumVars);
  this->MakeActualSizeAtLeastExpandOnTop(p.size);
  static Monomial<Rational> tempM;
  tempM.initNoDegreesInit(this->NumVars);
  for (int i=0; i<p.size; i++)
  { for (int j=0; j<this->NumVars; j++)
      tempM.degrees[j]=p.TheObjects[i].degrees[j];
    tempM.Coefficient.AssignInteger(p.TheObjects[i].Coefficient.value);
    this->AddObjectOnTopHash(tempM);
  }
}

void PolynomialRationalCoeff::MakePolyFromDirectionAndNormal(root& direction, root& normal, Rational& Correction, GlobalVariables& theGlobalVariables)
{ Rational tempRat2;
  root::RootScalarEuclideanRoot(direction, normal, tempRat2);
  this->ClearTheObjects();
  this->NumVars=(int)direction.size;
  Monomial<Rational>& tempM=theGlobalVariables.monMakePolyFromDirectionAndNormal;
  for (int i=0; i<direction.size; i++)
  { tempM.MakeNVarFirstDegree(i, (int)direction.size, normal.TheObjects[i]);
    tempM.Coefficient.DivideBy(tempRat2);
    this->AddMonomial(tempM);
  }
  this->AddConstant(Correction);
}

/*
void QuasiPolynomialPointers::IntegrateDiscreteInDirectionFromZeroTo
                              (root& direction, PolynomialRationalCoeff& EndPoint,
                              QuasiPolynomialOld& output,
                              QuasiPolynomialOld& input,
                              PrecomputedQuasiPolynomialIntegralPointersKillOnExit&
                                                                  PrecomputedDiscreteIntegrals)
{
  if (input.TheMonomials.size==0) {return; }
  int NumVars= input.TheMonomials.TheObjects[0]->NumVariables;
  PolynomialPointersKillOnExit<CompositeComplexQN> TSubstitution;
  TSubstitution.initAndCreateNewObjects(NumVars+1);
  for (int i=0; i<NumVars; i++)
  {
    Monomial<CompositeComplexQN> TempMonomial;
    TempMonomial.MakeOneLetterMonomialFirstDegree(i, NumVars+1, CQNOne);
    TSubstitution.TheObjects[i]->AddMonomial(TempMonomial);
    direction.coordinates[i].MinusRational();
    CompositeComplexQN tempQN(root::AmbientDimension, direction.coordinates[i]);
    TempMonomial.MakeOneLetterMonomialFirstDegree(NumVars, NumVars+1, tempQN);
    TSubstitution.TheObjects[i]->AddMonomial(TempMonomial);
    TSubstitution.TheObjects[i]->ComputeDebugString();
    direction.coordinates[i].MinusRational();
  }
  TSubstitution.TheObjects[NumVars]->TheMonomials.initAndCreateNewObjects(1);
  TSubstitution.TheObjects[NumVars]->TheMonomials.TheObjects[0]
               ->MakeOneLetterMonomialFirstDegree(NumVars, NumVars+1, CQNOne);
  TSubstitution.TheObjects[NumVars]->ComputeDebugString();
  Polynomial<CompositeComplexQN> Accum;
  Accum.CopyFrom(input);
  Accum.IncreaseNumVariables(1);
  Accum.ComputeDebugString();
  Accum.Substitution(TSubstitution, Accum);
  Accum.ComputeDebugString();
  output.TheMonomials.KillAllElements();
  PolynomialPointersKillOnExit<CompositeComplexQN> UpperBoundSubstitution;
  UpperBoundSubstitution.initAndCreateNewObjects(NumVars);
  UpperBoundSubstitution.TheObjects[0]->CopyFrom(EndPoint);
  for (int i=0; i<Accum.TotalDegree()+1; i++)
  {
    Polynomial<CompositeComplexQN> TempPoly;
    Polynomial<CompositeComplexQN> TempPoly2;
    Polynomial<CompositeComplexQN> TempPoly3;
    Accum.ComponentInFrontOfVariableToPower(NumVars, i, TempPoly);
    TempPoly.ComputeDebugString();
    TempPoly2.CopyFrom(*PrecomputedDiscreteIntegrals.TheObjects[i]);
    TempPoly2.IncreaseNumVariables(NumVars-1);
    TempPoly2.ComputeDebugString();
    TempPoly2.Substitution(UpperBoundSubstitution, TempPoly3);
    TempPoly3.ComputeDebugString();
    TempPoly.MultiplyBy(TempPoly3);
    TempPoly.ComputeDebugString();
    output.ComputeDebugString();
    output.AddPolynomial(TempPoly);
    output.ComputeDebugString();
  }
}*/

void PolynomialsRationalCoeff::ComputeDiscreteIntegrationUpTo(int d)
{ this->SetSize(d);
  this->TheObjects[0].MakeNVarDegOnePoly(1, 0, ROne, ROne);
  PolynomialRationalCoeff Accum, tempPoly;
  for (int i=1; i<d; i++)
  { Accum.ClearTheObjects();
    Accum.NumVars=1;
    for (int j=0; j<i; j++)
    { tempPoly.CopyFromPoly(this->TheObjects[j]);
      int tempI=MathRoutines::NChooseK(i+1, j);
      Rational tempNum(-tempI, 1);
      tempPoly.TimesConstant(tempNum);
      Accum.AddPolynomial(tempPoly);
    }
    tempPoly.MakeNVarDegOnePoly(1, 0, ROne, ROne);
    tempPoly.RaiseToPower(i+1, (Rational) 1);
    Accum.AddPolynomial(tempPoly);
    Rational tempRat(1, i+1);
    Accum.TimesConstant(tempRat);
    this->TheObjects[i].CopyFromPoly(Accum);
  }
}

void PolynomialsRationalCoeff::MakeSubAddExtraVarForIntegration(root& direction)
{ this->SetSize(direction.size);
  for (int i=0; i<direction.size; i++)
  { Rational tempRat; tempRat.Assign(direction.TheObjects[i]); tempRat.Minus();
    this->TheObjects[i].MakeNVarDegOnePoly((int)(direction.size+1), i, direction.size, ROne, tempRat);
  }
}

void PolynomialsRationalCoeff::MakeSubNVarForOtherChamber(root& direction, root& normal, Rational& Correction, GlobalVariables& theGlobalVariables)
{ this->SetSize(direction.size);
  PolynomialRationalCoeff TempPoly;
  TempPoly.MakePolyFromDirectionAndNormal(direction, normal, Correction, theGlobalVariables);
  for (int i=0; i<direction.size; i++)
  { PolynomialRationalCoeff TempPoly2;
    TempPoly2.CopyFromPoly(TempPoly);
    TempPoly2.TimesConstant(direction.TheObjects[i]);
    TempPoly2.TimesConstant(RMOne);
    this->TheObjects[i].MakeNVarDegOnePoly((int)direction.size, i, ROne);
    this->TheObjects[i].AddPolynomial(TempPoly2);
  }
}

void PolynomialsRationalCoeff::MakeLinearSubOnLastVariable(int NumVars, PolynomialRationalCoeff& LastVarSub)
{ this->SetSize(NumVars);
  for (int i=0; i<NumVars-1; i++)
    this->TheObjects[i].MakeNVarDegOnePoly(NumVars, i, ROne);
  this->TheObjects[NumVars-1].CopyFromPoly(LastVarSub);
}

PolynomialOutputFormat::PolynomialOutputFormat()
{ this->MakeAlphabetxi();
  this->ExtraLinesCounterLatex=0;
}

void PolynomialOutputFormat::MakeRegularAlphabet()
{ this->alphabet.SetSize(26);
  this->alphabet.TheObjects[0]='a';
  this->alphabet.TheObjects[1]='b';
  this->alphabet.TheObjects[2]='c';
  this->alphabet.TheObjects[3]='d';
  this->alphabet.TheObjects[4]='e';
  this->alphabet.TheObjects[5]='f';
  this->alphabet.TheObjects[6]='g';
  this->alphabet.TheObjects[7]='h';
  this->alphabet.TheObjects[8]='i';
  this->alphabet.TheObjects[9]='j';
  this->alphabet.TheObjects[10]='k';
  this->alphabet.TheObjects[11]='l';
  this->alphabet.TheObjects[12]='m';
  this->alphabet.TheObjects[13]='n';
  this->alphabet.TheObjects[14]='o';
  this->alphabet.TheObjects[15]='p';
  this->alphabet.TheObjects[16]='q';
  this->alphabet.TheObjects[17]='r';
  this->alphabet.TheObjects[18]='s';
  this->alphabet.TheObjects[19]='t';
  this->alphabet.TheObjects[20]='u';
  this->alphabet.TheObjects[21]='v';
  this->alphabet.TheObjects[22]='w';
  this->alphabet.TheObjects[23]='x';
  this->alphabet.TheObjects[24]='y';
  this->alphabet.TheObjects[25]='z';
  this->cutOffString=false;
  this->cutOffSize=500;
}

std::string PolynomialOutputFormat::GetLetterIndex(int index)const
{ if (index<this->alphabet.size)
    return this->alphabet.TheObjects[index];
  std::stringstream out;
  out << "x_{" << index+1 << "}";
  std::string tempS=out.str();
  return tempS;
}

void PolynomialOutputFormat::SetLetterIndex(const std::string& theLetter, int index)
{ if (index<this->alphabet.size)
    this->alphabet.TheObjects[index]=theLetter;
}

void PolynomialOutputFormat::MakeAlphabetArbitraryWithIndex(const std::string& theLetter)
{ this->alphabet.SetSize(1000);
  for (int i=0; i<this->alphabet.size; i++)
  { std::stringstream out;
    out << theLetter << "_";
     if (i>=9)
      out << "{";
    out << i+1;
     if (i>=9)
      out << "}";
    this->alphabet.TheObjects[i]=out.str();
  }
  this->cutOffString=false;
  this->cutOffSize=500;
}

void PolynomialOutputFormat::MakeAlphabetyi()
{ this->MakeAlphabetArbitraryWithIndex("y");
}

void PolynomialOutputFormat::MakeAlphabetxi()
{ this->MakeAlphabetArbitraryWithIndex("x");
}

/*int PolynomialRationalCoeff::FindGCMCoefficientDenominators()
{  int result=1;
  for (int i=0; i<this->size; i++)
  {  int tempI=Rational::gcdSigned(result, this->TheObjects[i].Coefficient.den);
    result= result*this->TheObjects[i].Coefficient.den/tempI;
  }
  return result;
}*/
/*
void PolynomialRationalCoeff::IntegrateDiscreteFromZeroTo
              (int IntegrationVariableIndex, PolynomialRationalCoeff &EndPoint,
               PolynomialRationalCoeffPointers& PrecomputedDiscreteIntegration)
{
  PolynomialRationalCoeff Accum, tempP1;
  int tempI=this->FindMaxPowerOfVariableIndex( IntegrationVariableIndex);
  for (int i=0; i<tempI; i++)
  {
    this->ComponentInFrontOfVariableToPower(IntegrationVariableIndex, i, tempP1);


  }
}*/

void QuasiMonomial::RationalLinearSubstitution(QPSub& TheSub, QuasiPolynomialOld& output)
{ if (this->Coefficient.IsEqualToZero())
  { output.ClearTheObjects();
    output.NumVars= (int)TheSub.TheQNSub.NumRows;
    return;
  }
  PolynomialRationalCoeff tempP;
  Monomial<Rational> tempM;
  tempM.initNoDegreesInit(this->NumVariables);
  tempM.Coefficient.Assign(ROne);
  for (int i=0; i<this->NumVariables; i++)
    tempM.degrees[i]= this->degrees[i];
  tempM.Substitution(TheSub.RationalPolyForm, tempP, (int)(TheSub.TheQNSub.NumRows-1), (Rational) 1);
  QuasiNumber tempQ((int)TheSub.TheQNSub.NumRows);
  tempQ.Assign(this->Coefficient);
  tempQ.LinearSubstitution(TheSub);
  output.AssignPolynomialRationalCoeff(tempP);
  output.TimesConstant(tempQ);
}

void PrecomputedQuasiPolynomialIntegral::operator=(PrecomputedQuasiPolynomialIntegral& right)
{ this->degree= right.degree;
  this->Den= right.Den;
  this->Num= right.Num;
  this->Value.Assign(right.Value);
}

void QuasiPolynomialOld::operator=(const QuasiPolynomialOld& right)
{ this->CopyFromPoly(right);
}

void QuasiPolynomialOld::AssignPolynomialRationalCoeff(PolynomialRationalCoeff& p)
{ this->Nullify(p.NumVars);
  static QuasiMonomial tempM;
  tempM.initNoDegreesInit(this->NumVars);
  for (int i=0; i<p.size; i++)
  { for (int j=0; j<this->NumVars; j++)
      tempM.degrees[j]=p.TheObjects[i].degrees[j];
    tempM.Coefficient.MakeConst(p.TheObjects[i].Coefficient, this->NumVars);
    this->AddObjectOnTopHash(tempM);
  }
}

void QuasiPolynomialOld::Nullify(int numVars)
{ this->ClearTheObjects();
  this->NumVars=numVars;
}

void QuasiPolynomialOld::WriteComplexFormToDebugString()
{ CompositeComplexQNPoly p;
  p.AssignQP(*this);
  p.ComputeDebugString();
  this->DebugString.assign(p.DebugString);
}

void QuasiPolynomialOld::Simplify()
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].Coefficient.Simplify();
}

void QuasiPolynomialOld::TimesInteger(int x)
{ QuasiNumber tempQN;
  tempQN.AssignInteger(this->NumVars, x);
  this->TimesConstant(tempQN);
}

void QuasiPolynomialOld::operator*=(const Rational& x )
{ QuasiNumber tempQN;
  tempQN.AssignLargeRational(this->NumVars, x);
  this->TimesConstant(tempQN);
}

void QuasiPolynomialOld::Evaluate(intRoot& values, Rational& output)
{ output.MakeZero();
  std::string tempS;
  /*if (Rational::flagAnErrorHasOccurredTimeToPanic)
  {  output.ElementToString(tempS);
  }*/
  Rational tempLRat, tempLRat2;
  for (int i=0; i<this->size; i++)
  { tempLRat.MakeOne();
    /*if (Rational::flagAnErrorHasOccurredTimeToPanic)
    {  this->TheObjects[i].ComputeDebugString();
    }*/
    for (int j=0; j<this->NumVars; j++)
    { for (int k=0; k<this->TheObjects[i].degrees[j]; k++)
      {  /*if (Rational::flagAnErrorHasOccurredTimeToPanic)
        { if (this->TheObjects[i].DebugString=="-1/2ac^{2}")
          { tempLRat.ElementToString(tempS);
          }
        }*/
        tempLRat.MultiplyByInt(values.TheObjects[j]);
      /*  if (Rational::flagAnErrorHasOccurredTimeToPanic)
        { if (this->TheObjects[i].DebugString=="-1/2ac^{2}")
          { tempLRat.ElementToString(tempS);
          }
        }*/
      }
    }
    this->TheObjects[i].Coefficient.Evaluate(values, tempLRat2);
/*    if (Rational::flagAnErrorHasOccurredTimeToPanic)
    {  this->TheObjects[i].ComputeDebugString();
      if (this->TheObjects[i].DebugString=="-1/2ac^{2}")
      { Stop();
        tempLRat2.ElementToString(tempS);
      }
      tempLRat.ElementToString(tempS);
    }*/
    tempLRat.MultiplyBy(tempLRat2);
    /*if (Rational::flagAnErrorHasOccurredTimeToPanic)
    {  this->TheObjects[i].ComputeDebugString();
      if (this->TheObjects[i].DebugString=="-1/2ac^{2}")
      { Stop();
        tempLRat2.ElementToString(tempS);
      }
      tempLRat.ElementToString(tempS);
    }*/
    output+=(tempLRat);
    /*if (Rational::flagAnErrorHasOccurredTimeToPanic)
    {  output.ElementToString(tempS);
    }*/
  }
}

void QuasiPolynomialOld::DivByInteger(int x)
{ Rational tempRat2;
  tempRat2.AssignNumeratorAndDenominator(1, x);
  QuasiNumber tempQN;
  tempQN.AssignLargeRational(this->NumVars, tempRat2);
  this->TimesConstant(tempQN);
}

void QuasiPolynomialOld::RationalLinearSubstitution(QPSub& TheSub, QuasiPolynomialOld& output)
{ QuasiPolynomialOld tempQP;
  QuasiPolynomialOld Accum;
  Accum.ClearTheObjects();
  Accum.NumVars= (int)TheSub.TheQNSub.NumRows;
  for (int i=0; i<this->size; i++)
  { QuasiMonomial tempQM;
    tempQM.Assign(this->TheObjects[i]);
    tempQM.RationalLinearSubstitution(TheSub, tempQP);
    Accum.AddPolynomial(tempQP);
  }
  output.CopyFromPoly(Accum);
}

QuasiPolynomialOld::QuasiPolynomialOld()
{ QuasiPolynomialOld::TotalCreatedPolys++;
  this->CreationNumber=QuasiPolynomialOld::TotalCreatedPolys;
  GlobalCollectorsPolys.AddObjectOnTop(this);
};

void QuasiPolynomialOld::MakeTauknp(int k, int n)
{ QuasiNumber tempQN;
  tempQN.MakePureQN(1, 0, ROne, 1, k, n);
  this->MakeNVarConst(1, tempQN);
}

void PrecomputedTauknPointersKillOnExit::GetTaukn(int k, int n, CompositeComplexQN& output)
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]->k==k && this->TheObjects[i]->n==n)
    { output.Assign(this->TheObjects[i]->Taukn);
      return;
    }
  this->ComputeTaukn(k, n, output);
  PrecomputedTaukn* NewMember = new PrecomputedTaukn;
#ifdef CGIversionLimitRAMuse
  ParallelComputing::GlobalPointerCounter++;
  ParallelComputing::CheckPointerCounters();
#endif
  this->AddObjectOnTop(NewMember);
  NewMember->k=k;
  NewMember->n=n;
  NewMember->Taukn.Assign(output);
}

void PrecomputedTauknPointersKillOnExit::ComputeTaukn(int k, int n, CompositeComplexQN& output)
{  CompositeComplexQN NonConstQN(1), Accum(1);
  Rational tempRat(1, n);
  NonConstQN.MakePureQN(1, 0, ROne, tempRat);
  NonConstQN.ComputeDebugString();
  Rational tempRat2(k*(1-n), n);
  Accum.MakePureQN(1, 0, RZero, tempRat2, tempRat);
  Accum.ComputeDebugString();
  for (int i=0; i<n; i++)
  {  if (i!=k)
    {  tempRat.AssignNumeratorAndDenominator(i, n);
      CompositeComplexQN tempQN(1), tempQN2(1);
      tempQN.MakePureQN(tempRat, 1, RMOne);
      tempQN.ComputeDebugString();
      tempQN2.Assign(NonConstQN);
      tempQN2.Add(tempQN);
      tempQN2.ComputeDebugString();
      assert(tempQN2.ComputeDebugString());
      Accum.MultiplyBy(tempQN2);
      assert(Accum.ComputeDebugString());
    }
  }
  output.Assign(Accum);
  assert(output.ComputeDebugString());
}

void rootsCollection::ResetCounters()
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].size=0;
}

void rootsCollection::CollectionToRoots(roots& output)
{  int counter=0;
  for(int i=0; i<this->size; i++)
    counter+=this->TheObjects[i].size;
  output.MakeActualSizeAtLeastExpandOnTop(counter);
  output.size=0;
  for(int i=0; i<this->size; i++)
    output.AddListOnTop(this->TheObjects[i]);
}

void rootsCollection::ComputeDebugString()
{  std::string tempS;
  this->DebugString.clear();
  for (int i=0; i<this->size; i++)
  {  this->TheObjects[i].ElementToString(tempS);
    this->DebugString.append(tempS);
    this->DebugString.append("\n");
  }
}

void rootsCollection::WriteToFile(std::fstream& output, GlobalVariables& theGlobalVariables)
{ output << "Num_collections: " << this->size << "\n";
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].WriteToFile(output, theGlobalVariables);
}

void rootsCollection::ReadFromFile(std::fstream& input, GlobalVariables& theGlobalVariables)
{ std::string tempS;
  int tempI;
  input >> tempS >> tempI;
  this->SetSize(tempI);
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].ReadFromFile(input, theGlobalVariables);
}

void rootsCollection::Average(root& output, int Number, int theDimension)
{ root tempRoot; output.MakeZero(theDimension);
  if (this->size==0)
    return;
  for(int i=0; i<Number; i++)
  { this->TheObjects[i].average(tempRoot, theDimension);
    output+=tempRoot;
  }
  output.DivByInteger(this->size);
}

void CompositeComplexQNSub::MakeLinearSubIntegrand(root& normal, root& direction, Rational& Correction, GlobalVariables& theGlobalVariables)
{ PolynomialRationalCoeff EndPoint;
  EndPoint.MakePolyFromDirectionAndNormal(direction, normal, Correction, theGlobalVariables);
  this->RationalPolyForm.MakeSubstitutionLastVariableToEndPoint(1, EndPoint);
  this->MatrixForCoeffs.init((int)(direction.size+1), 1);
  Rational tempLargeRat;
  root::RootScalarEuclideanRoot(direction, normal, tempLargeRat);
  MatrixForCoeffs.elements[0][0].Assign(Correction);
  for (int i=1; i<this->MatrixForCoeffs.NumRows; i++)
  { MatrixForCoeffs.elements[i][0].Assign(normal.TheObjects[i-1]);
    MatrixForCoeffs.elements[i][0].DivideBy(tempLargeRat);
  }
}

void CompositeComplexQNSub::MakeSubAddExtraVarForIntegration(root &direction)
{ this->RationalPolyForm.MakeSubAddExtraVarForIntegration(direction);
  this->MatrixForCoeffs.init((int)direction.size+2, (int)direction.size);
  this->MatrixForCoeffs.NullifyAll();
  for (int i=0; i<this->MatrixForCoeffs.NumCols; i++)
  { this->MatrixForCoeffs.elements[i][i].Assign(ROne);
    this->MatrixForCoeffs.elements[direction.size+1][i].Assign(RMOne);
    this->MatrixForCoeffs.elements[direction.size+1][i].MultiplyBy(direction.TheObjects[i]);
  }
}

void CompositeComplexQNSub::MakeSubNVarForOtherChamber(root& direction, root& normal, Rational& Correction, GlobalVariables& theGlobalVariables)
{ this->RationalPolyForm.MakeSubNVarForOtherChamber(direction, normal, Correction, theGlobalVariables);
  this->MatrixForCoeffs.init((int)direction.size+1, (int)direction.size);
  Rational tempLargeRat;
  root::RootScalarEuclideanRoot(direction, normal, tempLargeRat);
  tempLargeRat.Minus();
  for (int i=0; i<direction.size; i++)
  { this->MatrixForCoeffs.elements[0][i].Assign(Correction);
    this->MatrixForCoeffs.elements[0][i].MultiplyBy(direction.TheObjects[i]);
    this->MatrixForCoeffs.elements[0][i].Minus();
    for(int j=0; j<direction.size; j++)
    { this->MatrixForCoeffs.elements[j+1][i].Assign(normal.TheObjects[j]);
      this->MatrixForCoeffs.elements[j+1][i].DivideBy(tempLargeRat);
      this->MatrixForCoeffs.elements[j+1][i].MultiplyBy(direction.TheObjects[i]);
      if (i==j)
        this->MatrixForCoeffs.elements[j+1][i]+=(ROne);
    }
  }
}

void BasicComplexNumber::Assign(const BasicComplexNumber & c)
{ this->Coeff.Assign(c.Coeff);
  this->Exp.Assign(c.Exp);
}

void BasicComplexNumber::init(Rational& coeff, Rational & exp)
{ this->Coeff.Assign(coeff);
  this->Exp.Assign(exp);
}

void BasicComplexNumber::MultiplyBy(BasicComplexNumber &c)
{ this->Coeff.MultiplyBy(c.Coeff);
  this->Exp+=(c.Exp);
}

void BasicComplexNumber::MultiplyByLargeRational(Rational &c)
{ this->Coeff.MultiplyBy(c);
}

void BasicComplexNumber::Simplify()
{ this->Exp.AssignFracValue();
}

bool BasicComplexNumber::operator ==(const BasicComplexNumber& c)
{ return (this->Coeff.IsEqualTo(c.Coeff) && this->Exp.IsEqualTo(c.Exp));
}

void BasicComplexNumber::operator = (const BasicComplexNumber& c)
{ this->Assign(c);
}

void BasicComplexNumber::AssignRational(Rational& r)
{ this->Coeff.Assign(r);
  this->Exp.MakeZero();
}

void BasicComplexNumber::AssignLargeRational(const Rational& r)
{ this->Coeff.Assign(r);
  this->Exp.MakeZero();
}

void BasicComplexNumber::ElementToString(std::string& output)
{ std::stringstream out;
  std::string tempS;
  if (this->Coeff.IsEqualToZero())
  { output.assign("0");
    return;
  }
  if (this->Exp.IsEqualTo(RZero))
  { this->Coeff.ElementToString(output);
    return;
  }
  this->Coeff.ElementToString(tempS);
  if (tempS=="1")
    tempS.clear();
  if (tempS=="-1")
    tempS="-";
  out << tempS;
  this->Exp.ElementToString(tempS);
  out << "e^{2i\\pi(" << tempS << ")}";
  output= out.str();
}

void CompositeComplex::Add(CompositeComplex &c)
{ for (int i=0; i<c.size; i++)
    this->AddBasicComplex(c.TheObjects[i]);
  this->Simplify();
}

void CompositeComplex::MakeBasicComplex(Rational& coeff, Rational & exp)
{ BasicComplexNumber tempB;
  tempB.init(coeff, exp);
  this->size=0;
  this->AddObjectOnTop(tempB);
}

void CompositeComplex::MultiplyBy(CompositeComplex& c)
{ CompositeComplex Accum;
  BasicComplexNumber tempB;
  Accum.size=0;
  for (int i=0; i<c.size; i++)
    for (int j=0; j<this->size; j++)
    { tempB.Assign(this->TheObjects[j]);
      tempB.MultiplyBy(c.TheObjects[i]);
      Accum.AddBasicComplex(tempB);
    }
  Accum.Simplify();
  this->CopyFromBase(Accum);
}

void CompositeComplex::AddLargeRational(Rational& r)
{ for (int i=0; i<this->size; i++)
    if(this->TheObjects[i].Exp.IsEqualTo(RZero))
    { this->TheObjects[i].Coeff+=(r);
      if (this->TheObjects[i].Coeff.IsEqualToZero())
        this->PopIndexSwapWithLast(i);
      return;
    }
  BasicComplexNumber tempB;
  tempB.AssignLargeRational(r);
  this->AddObjectOnTop(tempB);
}

void CompositeComplex::ElementToString(std::string& output)
{ std::stringstream out;
  std::string tempS;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS);
    if (!(tempS[0]=='0'))
    { if(!(tempS[0]=='-'))
        out << "+";
      out << tempS;
    }
  }
  if (this->size>1)
    out << ")";
  output= out.str();
  if (output[0]=='+')
    output.erase(0, 1);
  if (this->size>1)
    output.insert(0, "(");
}

void CompositeComplex::MultiplyByLargeRational(Rational &r)
{ if(r.IsEqualTo(RZero))
  { this->size=0;
    return;
  }
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].MultiplyByLargeRational(r);
}

void CompositeComplex::Simplify()
{ while (this->SimplifyTrue()){}
}

bool CompositeComplex::SimplifyTrue()
{ bool result = false;
  if (this->size==0)
    return result;
/*  static Rational CommonFactor; */
  this->TheObjects[0].Simplify();
/*  CommonFactor.Assign(this->TheObjects[0].Exp);     */
  for (int i=1; i<this->size; i++)
  { this->TheObjects[i].Simplify();
/*    if (CommonFactor.IsGreaterThan(this->TheObjects[i].Exp))
    { CommonFactor.Assign(this->TheObjects[i].Exp);
    }*/
  }
/*  if (CommonFactor.IsGreaterThan(RZero))
  { for (int i=0; i<this->size; i++)
    {this->TheObjects[i].Exp.Subtract(CommonFactor); }
  } */
  for (int i=1; i<=this->FindMaxDenExp(); i++)
    result= result || this->SimplifyWRT(i);
/*  if (CommonFactor.IsGreaterThan(RZero))
  { for (int i=0; i<this->size; i++)
    {this->TheObjects[i].Exp.Add(CommonFactor); }
  }*/
  return result;
}

int CompositeComplex::FindMaxDenExp()
{ int result=0;
  for (int i=0; i<this->size; i++)
    result =MathRoutines::Maximum(result, this->TheObjects[i].Exp.DenShort);
  return result;
}

bool CompositeComplex::SimplifyWRT(int n)
{ if (n==1)
    return false;
  Rational CoeffFirst;
  bool FoundFirst=false;
  CoeffFirst.MakeZero();
  int NumFound=0;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].Exp.DenShort==n)
    { if (!FoundFirst)
      { CoeffFirst.Assign(this->TheObjects[i].Coeff);
        FoundFirst=true;
      }
      if (!this->TheObjects[i].Coeff.IsEqualTo(CoeffFirst))
        return false;
      NumFound++;
    }
  if (NumFound<CompositeComplex::PrecomputedCyclotomic.EulerPhi(n))
    return false;
  if (!CoeffFirst.IsEqualToZero())
  { for (int i=0; i<this->size; i++)
      if (this->TheObjects[i].Exp.DenShort== n)
      { this->PopIndexSwapWithLast(i);
        i--;
      }
    Rational tempRat;
    Rational tempRat2;
    CompositeComplex::PrecomputedCyclotomic.GetSumPrimitiveRoots(n, tempRat);
    tempRat2.Assign(tempRat);
    tempRat2.MultiplyBy(CoeffFirst);
    this->AddLargeRational(tempRat2);
  }
  return true;
}

bool CompositeComplex::IsEqualToZero()
{ return (this->size==0);
}

void CompositeComplex::Assign(const CompositeComplex& c)
{ this->CopyFromBase(c);
}

void CompositeComplex::AddBasicComplex(BasicComplexNumber& b)
{ for(int i=0; i<this->size; i++)
    if (this->TheObjects[i].Exp.IsEqualTo(b.Exp))
    { this->TheObjects[i].Coeff+=(b.Coeff);
      if (this->TheObjects[i].Coeff.IsEqualToZero())
        this->PopIndexSwapWithLast(i);
      return;
    }
  this->AddObjectOnTop(b);
}

void CompositeComplex::AddRational(Rational& r)
{ for (int i=0; i<this->size; i++)
    if(this->TheObjects[i].Exp.IsEqualTo(RZero))
    { this->TheObjects[i].Coeff+=(r);
      if (this->TheObjects[i].Coeff.IsEqualToZero())
        this->PopIndexSwapWithLast(i);
      return;
    }
  BasicComplexNumber tempB;
  tempB.AssignRational(r);
  this->AddObjectOnTop(tempB);
}

void CompositeComplex::AssignRational(Rational &r)
{ this->size=0;
  BasicComplexNumber tempB;
  tempB.AssignRational(r);
  this->AddObjectOnTop(tempB);
}

void CompositeComplex::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

void CompositeComplex::MultiplyByBasicComplex(BasicComplexNumber &b)
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].MultiplyBy(b);
}

void CyclotomicList::DivOneVarByOneVarPoly(PolynomialRationalCoeff& p, PolynomialRationalCoeff& q, PolynomialRationalCoeff& quotient, PolynomialRationalCoeff& remainder)
{ remainder.CopyFromPoly(p);
  Monomial<Rational> HighestM;
  HighestM.Assign(q.TheObjects[0]);
  for (int i=1; i<q.size; i++)
    if (HighestM.degrees[0]<q.TheObjects[i].degrees[0])
      HighestM.Assign(q.TheObjects[i]);
  int index;
  quotient.ClearTheObjects();
  while(remainder.HasGEQMonomial(HighestM, index))
  { Monomial<Rational> tempM;
    tempM.init(1);
    tempM.Coefficient.Assign(remainder.TheObjects[index].Coefficient);
    tempM.Coefficient.DivideBy(HighestM.Coefficient);
    tempM.degrees[0]= remainder.TheObjects[index].degrees[0]-HighestM.degrees[0];
    quotient.AddMonomial(tempM);
    tempM.Coefficient.Minus();
    PolynomialRationalCoeff tempQ2;
    tempQ2.CopyFromPoly(q);
    tempQ2.MultiplyByMonomial(tempM);
    remainder.AddPolynomial(tempQ2);
  }
}

void CyclotomicList::GetSumPrimitiveRoots(int n, Rational& output)
{ this->ComputeCyclotomic(n);
  int phi= this->EulerPhi(n);
  for (int i=0; i<this->TheObjects[n-1].size; i++)
    if(this->TheObjects[n-1].TheObjects[i].degrees[0]==phi-1)
    {  output.Assign(this->TheObjects[n-1].TheObjects[i].Coefficient);
      output.Minus();
      return;
    }
  output.MakeZero();
}

void CyclotomicList::ComputeCyclotomic(int n)
{ if (this->size<n)
    this->SetSize(n);
  if(this->TheObjects[n-1].size==0)
  { PolynomialRationalCoeff tempP;
    tempP.MakeMonomialOneLetter(1, 0, n, ROne);
    tempP.AddConstant(RMOne);
    for (int i=1; i<n; i++)
    { if (((n/i)*i)==n)
      { this->ComputeCyclotomic(i);
        PolynomialRationalCoeff tempD, tempR, tempQ;
        tempD.CopyFromPoly(this->TheObjects[i-1]);
        this->DivOneVarByOneVarPoly(tempP, tempD, tempQ, tempR);
        tempP.CopyFromPoly(tempQ);
      }
    }
    this->TheObjects[n-1].CopyFromPoly(tempP);
  }
}

int CyclotomicList::EulerPhi(int n)
{ this->ComputeCyclotomic(n);
  int result=0;
  for(int i=0; i<this->TheObjects[n-1].size; i++)
    result = MathRoutines::Maximum(result, this->TheObjects[n-1].TheObjects[i].degrees[0]);
  return result;
}

void BasicQN::ScaleBy(int DenIncrease)
{ for (int i=0; i<this->Exp.NumRows; i++)
  { for (int j=0; j<this->NumVars; j++)
      this->Exp.elements[i][j]*= DenIncrease;
    this->Nums.elements[i][0]*=DenIncrease;
  }
  this->Den*=DenIncrease;
}

void BasicQN::MultiplyByLargeRational(Rational& coeff)
{ this->Coefficient.MultiplyBy(coeff);
  if (this->Coefficient.IsEqualToZero())
  { this->Exp.Free();
    this->Nums.Free();
  }
}

void BasicQN::MultiplyBy(BasicQN& q)
{ if (q.Den==this->Den)
    this->MultiplyBySameDen(q);
  else
  { BasicQN tempQ;
    tempQ.Assign(q);
    int thelcm= MathRoutines::lcm(this->Den, q.Den);
    tempQ.ScaleBy((thelcm/q.Den));
    this->ScaleBy((thelcm/this->Den));
    this->MultiplyBySameDen(tempQ);
  }
}

void BasicQN::GetCoeffInFrontOfLast(Rational& output)
{ if (this->Exp.NumRows>0)
    output.AssignInteger(Exp.elements[0][this->NumVars-1]);
  else
    output.MakeZero();
}

int BasicQN::GaussianEliminationByRows()
{ return this->GaussianEliminationByRowsCol(this->NumVars-1, false);
}

int BasicQN::GaussianEliminationByRowsCol(int Col, bool MoveToRight)
{ int Row=0;
  while(Row<this->Exp.NumRows && Col<this->NumVars && Col>=0)
  { if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    { this->ComputeDebugString();
    }
    int PivotRow=-1;
    for (int i=Row; i<this->Exp.NumRows; i++)
      if(this->Exp.elements[i][Col]!=0)
      { PivotRow=i;
        break;
      }
    if (PivotRow!=-1)
    { this->SetPivotRow(PivotRow, Row, Col);
      int ExploringRow= PivotRow+1;
      while (ExploringRow<this->Exp.NumRows)
      {  //this->ComputeDebugString();
        int PivotElt= this->Exp.elements[Row][Col];
        if (PivotElt<= this->Exp.elements[ExploringRow][Col])
        { int coeff = -(this->Exp.elements[ExploringRow][Col]/PivotElt);
          this->RowPlusScalarTimesRow(ExploringRow, coeff, Row, 0);
        }
        if (this->Exp.elements[ExploringRow][Col]==0)
          ExploringRow++;
        else
          SetPivotRow(ExploringRow, Row, Col);
      }
      int PivotElt = this->Exp.elements[Row][Col];
      for (int i=0; i<Row; i++)
        if (PivotElt<=this->Exp.elements[i][Col])
        { int coeff =-( this->Exp.elements[i][Col]/PivotElt);
          coeff%=this->Den;
          if (coeff<0){coeff+=this->Den; }
          this->RowPlusScalarTimesRow(i, coeff, Row, 0);
        }
      Row++;
    }
    if(MoveToRight)
      Col++;
    else
      Col--;
  }
  return Row;
}

void BasicQN::RowPlusScalarTimesRow(int rowInd, int scalar, int otherRowInd, int StartCol)
{ for (int i=StartCol; i<this->NumVars; i++)
  { this->Exp.elements[rowInd][i]= (this->Exp.elements[rowInd][i]+scalar*this->Exp.elements[otherRowInd][i])%(this->Den);
    if (this->Exp.elements[rowInd][i]<0)
      this->Exp.elements[rowInd][i]+=this->Den;
  }
  this->Nums.elements[rowInd][0]=(this->Nums.elements[rowInd][0]+scalar*this->Nums.elements[otherRowInd][0])%(this->Den);
  if (this->Nums.elements[rowInd][0]<0)
    this->Nums.elements[rowInd][0]+=this->Den;
}

void BasicQN::WriteToFile(std::fstream& output)
{ this->Coefficient.WriteToFile(output);
  output << " | ";
  output << this->Den << " " << this->Exp.NumRows << " | ";
  for (int i=0; i<this->Exp.NumRows; i++)
  { for (int j=0; j<this->Exp.NumCols; j++)
      output << this->Exp.elements[i][j] << " ";
    output << "~ " << this->Nums.elements[i][0] << " | ";
  }
}

void BasicQN::ReadFromFile(std::fstream& input, int NumV)
{  std::string tempS;
  this->Coefficient.ReadFromFile(input);
  int tempI;
  input >> tempS >> this->Den >> tempI >> tempS;
  this->Exp.init(tempI, NumV);
  this->Nums.init(tempI, NumV);
  this->NumVars=NumV;
  for (int i=0; i<this->Exp.NumRows; i++)
  { for (int j=0; j<NumV; j++)
      input >> this->Exp.elements[i][j];
    input >> tempS >> this->Nums.elements[i][0] >> tempS;
  }
}

void BasicQN::SetPivotRow(int index, int PivotRowIndex, int Col)
{ if (index!=PivotRowIndex)
    this->SwitchTwoRows(index, PivotRowIndex, 0);
//  int PivotElt = this->Exp.elements[PivotRowIndex][Col];
//  int Scale= PivotElt/(gcd(PivotElt, this->Den));
//  if (Scale!=1)
//  {  Scale = this->InvertModN(Scale, this->Den);
//    this->MultiplyRowBy(PivotRowIndex, Scale, 0);
//  }
}

void BasicQN::MultiplyRowBy(int rowInd, int scalar, int StartColInd)
{ for (int i=StartColInd; i<this->NumVars; i++)
  { this->Exp.elements[rowInd][i]=(this->Exp.elements[rowInd][i]*scalar)%this->Den;
    if (this->Exp.elements[rowInd][i]<0)
      this->Exp.elements[rowInd][i]+=this->Den;
  }
  this->Nums.elements[rowInd][0]= (this->Nums.elements[rowInd][0]*scalar)%this->Den;
  if (this->Nums.elements[rowInd][0]<0)
    this->Nums.elements[rowInd][0]+=this->Den;
}

void BasicQN::MultiplyBySameDen(BasicQN& q)
{ int newRows= q.Exp.NumRows;
  this->Exp.Resize(this->Exp.NumRows+q.Exp.NumRows, this->NumVars, true);
  this->Nums.Resize(this->Exp.NumRows, 1, true);
  for (int i =0; i<newRows; i++ )
  { for (int j=0; j<q.NumVars; j++)
      this->Exp.elements[this->Exp.NumRows-newRows+i][j]= q.Exp.elements[i][j];
    this->Nums.elements[this->Exp.NumRows-newRows+i][0]= q.Nums.elements[i][0];
  }
  this->Coefficient.MultiplyBy(q.Coefficient);
  this->Simplify();
}

int BasicQN::InvertModN( int X, int N)
{ int q, r, p, d; // d - divisor, q - quotient, r - remainder, p is the number to be divided
  int vD[2], vP[2], temp;
  vP[0]=1; vP[1]=0; // at any given moment, p=vP[0]*N+vP[1]*X
  vD[0]=0; vD[1]=1;   // at any given moment, d=vD[0]*N+vD[1]*X
  p=N; d=X; d%=N; if (d<0){d+=N; }
  while (d>0)
  { q=p/d;
    r=p%d;
    p=d;
    d=r;
    for(int i=0; i<2; i++)
    { temp=vP[i];
      vP[i]= vD[i];
      vD[i]= temp-q*vD[i];
    }
  }
  assert(p==1); //if d and p were relatively prime this should be so. Otherwise the function was not called properly.
  p=vP[1]%N;
  if (p<0)
    p+=N;
  return p;
}

inline void BasicQN::Assign(const BasicQN &q)
{ this->Exp.Assign(q.Exp);
  this->Nums.Assign(q.Nums);
  this->NumVars= q.NumVars;
  this->Den= q.Den;
  this->Coefficient.Assign(q.Coefficient);
}

void BasicQN::ComputeDebugString()
{ PolynomialOutputFormat PolyFormatLocal;
  this->ElementToString(this->DebugString, PolyFormatLocal);
}

void BasicQN::ElementToString(std::string &output, const PolynomialOutputFormat& PolyFormat)const
{ std::stringstream out;
  std::string tempS;
  if (this->Exp.NumRows==0)
  { this->Coefficient.ElementToString(output);
    return;
  }
  this->Coefficient.ElementToString(tempS);
  if (tempS=="1") tempS.clear();
  if (tempS=="-1") tempS="-";
  if (!PolyFormat.UsingLatexFormat )
    out << tempS << "t_" << this->Den << "[";
  else
    out << tempS << "{\\tau_{" << this->Den << "}}_{[";
  for (int i=0; i<this->Exp.NumRows; i++)
  {  std::stringstream out2;
    out2 << "(";
    for (int j=0; j<this->NumVars; j++)
    { if (this->Exp.elements[i][j]!=0)
      {  if (this->Exp.elements[i][j]>0)
          out2 << "+";
        if (this->Exp.elements[i][j]!=1)
        { if (this->Exp.elements[i][j]==-1)
            out2 << "-";
          else
            out2 << this->Exp.elements[i][j];
        }
        out2 << PolyFormat.GetLetterIndex(j);
      }
    }
    out2 << "=" << this->Nums.elements[i][0] << ")";
    tempS= out2.str();
    if (tempS[1]=='+')
      tempS.erase(1, 1);
    out << tempS;
  }
  out << "]}";
  output=out.str();
}

inline bool BasicQN::ExponentIsEqualToZero()
{ return (this->Exp.NumRows==0);
}

inline bool BasicQN::HasSameExponent(BasicQN &q)
{ if (this->Exp.NumRows!=q.Exp.NumRows)
    return false;
  if (this->Den!=q.Den)
    return false;
  for (int i=0; i<this->Exp.NumRows; i++)
  { if (this->Nums.elements[i][0]!=q.Nums.elements[i][0])
      return false;
    for (int j=0; j<this->NumVars; j++)
      if (this->Exp.elements[i][j]!=q.Exp.elements[i][j])
        return false;
  }
  return true;
}

inline void BasicQN::Evaluate(List<int>& theVars, Rational& output)
{ output.MakeZero();
  for (int i=0; i<this->Exp.NumRows; i++)
  { int Accum=0;
    for (int j=0; j<this->NumVars; j++)
      Accum += this->Exp.elements[i][j]*theVars.TheObjects[j];
    Accum-=this->Nums.elements[i][0];
    Accum%=this->Den;
    if (Accum<0)
      Accum+=this->Den;
    if (Accum!=0)
      return;
  }
  output.Assign(this->Coefficient);
}
/*
void BasicQN::MakeQNFromMatrixAndColumn(MatrixLargeRational& theMat, root& column)
{ this->Coefficient.AssignRational(ROne);
  this->NumVars=root::AmbientDimension;
  this->Exp.init(theMat.NumRows, root::AmbientDimension);
  this->Nums.init(theMat.NumRows, 1);
  int tempLCM= 1;
  theMat.ComputeDebugString();
  for (int i=0; i<theMat.NumRows; i++)
  {  for (int j=0; j<theMat.NumCols; j++)
    { tempLCM= lcm(tempLCM, theMat.elements[i][j].den);
    }
    tempLCM= lcm(tempLCM, column.TheObjects[i].GetDenValueTruncated());
  }
  this->Den=tempLCM;
  for (int i=0; i<this->Exp.NumRows; i++)
  { for (int j=0; j<root::AmbientDimension; j++)
    { this->Exp.elements[i][j]=(theMat.elements[i][j].num*tempLCM)/theMat.elements[i][j].den;
      this->Exp.elements[i][j]%=tempLCM;
      if (this->Exp.elements[i][j]<0) {this->Exp.elements[i][j]+=tempLCM; }
    }
    this->Nums.elements[i][0]= (column.TheObjects[i].GetNumValueTruncated()*tempLCM)/
                      column.TheObjects[i].GetDenValueTruncated();
    this->Nums.elements[i][0]%=tempLCM;
    if (this->Nums.elements[i][0]<0){this->Nums.elements[i][0]+=tempLCM; }
  }
  //this->ComputeDebugString();
  this->Simplify();
  //this->ComputeDebugString();
}*/

void BasicQN::MakeQNFromMatrixAndColumn(MatrixLargeRational& theMat, root& column)
{ this->Coefficient.MakeOne();
  int theDimension = column.size;
  this->NumVars=(int) theDimension;
  this->Exp.init(theMat.NumRows, (int)theDimension);
  this->Nums.init(theMat.NumRows, 1);
  int tempLCM= 1;
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    theMat.ComputeDebugString();
  for (int i=0; i<theMat.NumRows; i++)
  { for (int j=0; j<theMat.NumCols; j++)
      tempLCM= MathRoutines::lcm(tempLCM, theMat.elements[i][j].DenShort);
    tempLCM= MathRoutines::lcm(tempLCM, column.TheObjects[i].DenShort);
  }
  this->Den=tempLCM;
  for (int i=0; i<this->Exp.NumRows; i++)
  { for (int j=0; j<theDimension; j++)
    { this->Exp.elements[i][j]=(theMat.elements[i][j].NumShort*tempLCM)/theMat.elements[i][j].DenShort;
      this->Exp.elements[i][j]%=tempLCM;
      if (this->Exp.elements[i][j]<0)
        this->Exp.elements[i][j]+=tempLCM;
    }
    this->Nums.elements[i][0]= (column.TheObjects[i].NumShort*tempLCM)/column.TheObjects[i].DenShort;
    this->Nums.elements[i][0]%=tempLCM;
    if (this->Nums.elements[i][0]<0)
      this->Nums.elements[i][0]+=tempLCM;
  }
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
  { this->ComputeDebugString();
    if (this->DebugString=="\\tau_{6}[(3a+5b=1)(4b=2)]")
    { Stop();
    }
  }
  this->Simplify();
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
  { this->ComputeDebugString();
  }
}

void BasicQN::BasicQNToComplexQN(CompositeComplexQN& output)
{ CompositeComplexQN tempC;
  MatrixLargeRational TheSub;
  TheSub.init(this->NumVars+1, 1);
  output.MakeConst(ROne, this->NumVars);
//  tempC.MakeConst(RZero, this->NumVars);
  for (int i=0; i<this->Exp.NumRows; i++)
  { PrecomputedTausLocal.GetTaukn(this->Nums.elements[i][0], this->Den, tempC);
    for (int j=0; j<this->NumVars; j++)
      TheSub.elements[j+1][0].AssignNumeratorAndDenominator(this->Exp.elements[i][j], 1);
    TheSub.elements[0][0].MakeZero();
    tempC.LinearSubstitution(TheSub);
    output.MultiplyBy(tempC);
  }
  output.MultiplyByLargeRational(this->Coefficient);
}

inline void BasicQN::DecreaseNumVars(int decrease)
{ this->Exp.Resize(this->Exp.NumRows, this->Exp.NumCols-decrease, true);
  this->NumVars-=decrease;
}

bool BasicQN::IsEqualToZero()
{ return this->Coefficient.IsEqualToZero();
}

inline void BasicQN::operator =(const BasicQN& q)
{ this->Assign(q);
}

bool BasicQN::operator ==(BasicQN &q)
{ return this->HasSameExponent(q);
}

inline void BasicQN::SwitchTwoRows(int rowI1, int rowI2, int StartCol)
{ int temp;
  for (int i=StartCol; i<this->NumVars; i++)
  {  temp=this->Exp.elements[rowI1][i];
    this->Exp.elements[rowI1][i]= this->Exp.elements[rowI2][i] ;
    this->Exp.elements[rowI2][i]= temp;
  }
  temp= this->Nums.elements[rowI1][0];
  this->Nums.elements[rowI1][0]=this->Nums.elements[rowI2][0];
  this->Nums.elements[rowI2][0]=temp;
}

void BasicQN::Simplify()
{ int FirstZeroRow=this->GaussianEliminationByRows();
  if (partFractions::flagAnErrorHasOccurredTimeToPanic)
    this->ComputeDebugString();
  if (Den==1)
    FirstZeroRow=0;
  for (int i=FirstZeroRow; i<this->Exp.NumRows; i++)
    if (this->Nums.elements[i][0]!=0)
    { this->MakeConst(RZero, this->NumVars);
      return;
    }
  this->Exp.Resize(FirstZeroRow, this->NumVars, true);
  this->Nums.Resize(FirstZeroRow, 1, true);
}

void BasicQN::LinearSubstitution(QPSub& theSub)
{  assert(this->NumVars== theSub.TheQNSub.NumCols);
  BasicQN tempOutput;
  int LastRowIndex=theSub.TheQNSub.NumRows-1;
  tempOutput.Exp.init(this->Exp.NumRows, LastRowIndex);
  tempOutput.Nums.init(LastRowIndex, 1);
  this->ScaleBy(theSub.QNSubDen);
  for(int i=0; i<this->Exp.NumRows; i++)
  { for (int k=0; k<LastRowIndex; k++)
    {  tempOutput.Exp.elements[i][k]=0;
      for (int j=0; j<this->NumVars; j++)
        tempOutput.Exp.elements[i][k]+=(this->Exp.elements[i][j]/theSub.QNSubDen)*theSub.TheQNSub.elements[k][j];
      tempOutput.Exp.elements[i][k]%=this->Den;
      if (tempOutput.Exp.elements[i][k]<0)
        tempOutput.Exp.elements[i][k]+=this->Den;
    }
    for (int j=0; j<this->NumVars; j++)
      tempOutput.Nums.elements[i][0]-=(this->Exp.elements[i][j]/theSub.QNSubDen)*theSub.TheQNSub.elements[LastRowIndex][j];
    tempOutput.Nums.elements[i][0]%= this->Den;
    if (tempOutput.Nums.elements[i][0]<0)
      tempOutput.Nums.elements[i][0]+=this->Den;
  }
  this->Exp.Assign(tempOutput.Exp);
  this->Nums.Assign(tempOutput.Nums);
  this->NumVars=(int)theSub.TheQNSub.NumRows-1;
  this->ComputeDebugString();
  this->Simplify();
}

void BasicQN::MakeConst(const Rational& Coeff, int NumV)
{ this->Exp.Free();
  this->Nums.Free();
  this->Coefficient.Assign(Coeff);
  this->Den=1;
  this->NumVars=NumV;
}

void BasicQN::MakeFromNormalAndDirection(root& normal, root& direction, int theMod, Rational& coeff)
{ root tempRoot;
  Rational tempLargeRat;
  int theDimension = direction.size;
  root::RootScalarEuclideanRoot(normal, direction, tempLargeRat);
  tempRoot.Assign(normal);
  tempRoot.DivByLargeRational(tempLargeRat);
  this->Exp.init(1, (int)theDimension);
  this->Nums.init(1, 1);
  this->Den= tempRoot.FindLCMDenominatorsTruncateToInt();
  tempRoot.MultiplyByInteger(this->Den);
  this->Coefficient.Assign(coeff);
  this->NumVars= (int)theDimension;
  this->Nums.elements[0][0]=theMod;
  for (int i=0; i<theDimension; i++)
    this->Exp.elements[0][i]=tempRoot.TheObjects[i].NumShort;
  this->Simplify();
}

int BasicQN::HashFunction() const
{ int result=0;
  for (int i=0; i<this->Exp.NumRows; i++)
    result+=SomeRandomPrimes[i]*this->Exp.elements[i][this->NumVars-i-1];
  return result;
}

void BasicQN::MakePureQN(int NumVariables, int NonZeroIndex, Rational&coeff, int theExp, int Num, int theDen)
{ this->NumVars= NumVariables;
  this->Exp.init(1, NumVariables);
  this->Nums.init(1, 1);
  this->Nums.elements[0][0]=Num;
  this->Coefficient.Assign(coeff);
  this->Exp.NullifyAll();
  this->Den=theDen;
  this->Exp.elements[0][NonZeroIndex] = theExp% this->Den;
}

void BasicQN::ExpToDebugString()
{ std::stringstream out;
  for (int i=0; i<this->Exp.NumRows; i++)
  {  for (int j=0; j<this->NumVars; j++)
      out << "|" << this->Exp.elements[i][j];
    out << "|";
  }
  this->DebugString=out.str();
  this->ComputeDebugString();
}

void QuasiNumber::ElementToString(std::string& output, const PolynomialOutputFormat& PolyFormat)const
{ std::stringstream out;
  std::string tempS;
  if (this->size>1)
    out << "(";
  int LineLengthCounter=0;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS, PolyFormat);
    if (!(tempS[0]=='0'))
    { if(!(tempS[0]=='-'))
      { out << "+";
        LineLengthCounter++;
      }
      out << tempS;
      LineLengthCounter+=(signed)tempS.length();
      if(LineLengthCounter>PolyFormat.LatexMaxLineLength && i!=this->size-1)
      {  LineLengthCounter=0;
        out << "\\\\&&\n";
      }
    }
  }
  if (this->size>1)
    out << ")";
  output= out.str();
  if (output.size()>1)
    if (output[1]=='+')
      output.erase(1, 1);
  if (output.size()>0)
    if (output[0]=='+')
      output.erase(0, 1);
}

void QuasiNumber::operator+=(const QuasiNumber& q)
{ for (int i=0; i<q.size; i++)
    this->AddBasicQuasiNumber(q.TheObjects[i]);
}

void QuasiNumber::WriteToFile(std::fstream& output)
{ output << this->size << " " << this->NumVariables << " | ";
  for(int i=0; i<this->size; i++)
    this->TheObjects[i].WriteToFile(output);
}

void QuasiNumber::ReadFromFile(std::fstream& input)
{  int NeededSize;
  std::string tempS;
  input>> NeededSize >> this->NumVariables>>tempS;
  BasicQN tempQN;
  this->MakeConst(RZero, this->NumVariables);
  this->MakeActualSizeAtLeastExpandOnTop(NeededSize);
  for(int i=0; i<NeededSize; i++)
  { tempQN.ReadFromFile(input, this->NumVariables);
    this->AddBasicQuasiNumber(tempQN);
  }
}

void QuasiNumber::AddBasicQuasiNumber(BasicQN& q)
{ if (QuasiNumber::flagAnErrorHasOccurredTimeToPanic)
  { this->ComputeDebugString();
    q.ComputeDebugString();
  }
  int tempH= q.HashFunction()%this->HashSize;
  if (tempH<0){tempH+=this->HashSize; }
  if (q.Coefficient.IsEqualToZero())
    return;
  for (int i=0; i<this->TheHashedArrays[tempH].size; i++)
  {  int tempI = this->TheHashedArrays[tempH].TheObjects[i];
    if (this->TheObjects[tempI].HasSameExponent(q))
    {  this->TheObjects[tempI].Coefficient+=(q.Coefficient);
      if (this->TheObjects[tempI].Coefficient.IsEqualToZero())
        this->PopIndexSwapWithLastHash(tempI);
      return;
    }
  }
  this->AddObjectOnTopHash(q);
}

void QuasiNumber::AssignInteger(int NumVars, int x)
{ Rational tempRat;
  tempRat.AssignInteger(x);
  this->AssignLargeRational(NumVars, tempRat);
}


void QuasiNumber::Assign(const QuasiNumber& q)
{ if (this==&q) return;
  this->MakeZero(q.NumVariables);
  this->CopyFromHash(q);
}

bool QuasiNumber::ComputeDebugString()
{ PolynomialOutputFormat PolyFormatLocal;
  this->DebugString.clear();
  this->ElementToString(this->DebugString, PolyFormatLocal);
  return true;
}

void QuasiNumber::Evaluate(List<int>& theVars, Rational& output)
{ output.MakeZero();
  Rational tempRat;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].Evaluate(theVars, tempRat);
    output+=(tempRat);
  }
}

void QuasiNumber::DivideByRational(Rational& r)
{ Rational tempRat;
  tempRat.Assign(r);
  tempRat.Invert();
  this->MultiplyByLargeRational(tempRat);
}

void QuasiNumber::MultiplyBy(const QuasiNumber& q)
{ QuasiNumber Accum;
  BasicQN tempQ;
  Accum.MakeZero(this->NumVariables);
  for (int i=0; i<q.size; i++)
    for (int j=0; j<this->size; j++)
    { tempQ.Assign(this->TheObjects[j]);
      tempQ.MultiplyBy(q.TheObjects[i]);
      Accum.AddBasicQuasiNumber(tempQ);
    }
  this->Assign(Accum);
}

void QuasiNumber::QNtoComplex(CompositeComplexQN& output)
{ output.MakeConst(RZero, this->NumVariables);
  CompositeComplexQN tempC;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].BasicQNToComplexQN(tempC);
    output.Add(tempC);
  }
}

bool QuasiNumber::IsEqualTo(const QuasiNumber& q) const
{  //the below line is just for speed
  if (&q==&QuasiNumber::TheRingZero)
    return this->IsEqualToZero();
  QuasiNumber tempQN(q.NumVariables) ;
  tempQN.Assign(q);
  tempQN.MultiplyByLargeRational(RMOne);
  tempQN.Add(*this);
  return tempQN.IsEqualToZero();
}


bool QuasiNumber::IsEqualToZero()const
{ return (this->size==0);
  /*for (int i=0; i<this->size; i++)
  {  if (!this->TheObjects[i].IsEqualToZero())
    {  return false;
    }
  }*/
//  return true;
}

void QuasiNumber::LinearSubstitution(QPSub& TheSub)
{  QuasiNumber Accum;
  BasicQN tempQ;
  Accum.MakeZero((int)(TheSub.TheQNSub.NumRows-1));
  for(int i=0; i<this->size; i++)
  {  tempQ.Assign(this->TheObjects[i]);
    tempQ.LinearSubstitution(TheSub);
    Accum.AddBasicQuasiNumber(tempQ);
  }
  this->Assign(Accum);
}

void QuasiNumber::MakeZero(int NumVars)
{ this->ClearTheObjects();
  this->NumVariables= NumVars;
}

/*void QuasiNumber::DecreaseNumVars(int decrease)
{ for (int i=0; i<this->size; i++)
  { this->TheObjects[i].DecreaseNumVars(decrease);
  }
  this->NumVariables-=decrease;
  this->Simplify();
}*/

void QuasiNumber::Simplify()
{ this->ComputeDebugString();
  if (this->size==0)
    return;
  int theLCM=1;
  for (int i=0; i<this->size; i++)
    theLCM=MathRoutines::lcm(theLCM, this->TheObjects[i].Den);
  if (theLCM>4)
    return;
  int NumCycles = MathRoutines::KToTheNth(theLCM, this->NumVariables);
  SelectionWithMaxMultiplicity theSubset;
  theSubset.initMaxMultiplicity(this->NumVariables, theLCM-1);
//  bool oneValue=true;
  Rational theValue, tempRat;
  std::string tempS, tempS2;
  for (int i=0; i<NumCycles; i++)
  { theValue.ElementToString(tempS);
    tempRat.ElementToString(tempS2);
    if (i==0)
      this->Evaluate(theSubset.Multiplicities, theValue);
    else
    { this->Evaluate(theSubset.Multiplicities, tempRat);
      if (!tempRat.IsEqualTo(theValue)) {return; }
      theSubset.IncrementSubset();
    }
  }
  this->MakeZero(this->NumVariables);
  this->AssignLargeRational(this->NumVariables, theValue);
}

void QuasiNumber::AssignLargeRational(int NumVars, const Rational& coeff)
{  BasicQN q;
  this->MakeZero(NumVars);
  q.MakeConst(coeff, NumVars);
  this->AddBasicQuasiNumber(q);
}

void QuasiNumber::MakePureQN(int NumVar, int NonZeroIndex, Rational&coeff, int theExp, int Num, int theDen)
{ this->MakeZero(NumVar);
  BasicQN tempQ;
  tempQ.MakePureQN(NumVar, NonZeroIndex, coeff, theExp, Num, theDen);
  this->AddBasicQuasiNumber(tempQ);
}

void QuasiNumber::MakeFromNormalAndDirection(root& normal, root& direction, int theMod, Rational& coeff)
{ this->MakeZero((int)normal.size);
  BasicQN tempQ;
  tempQ.MakeFromNormalAndDirection(normal, direction, theMod, coeff);
  this->AddBasicQuasiNumber(tempQ);
}

void QuasiNumber::MakeConst(Rational& Coeff, int NumV)
{  BasicQN q;
  this->MakeZero(NumV);
  q.MakeConst(Coeff, NumV);
  this->AddBasicQuasiNumber(q);
}

/*void QuasiNumber::MakeQNFromMatrixAndColumn(MatrixLargeRational& theMat, root& column)
{ this->ClearTheObjects();
  this->NumVariables= root::AmbientDimension;
  static BasicQN tempBQN;
  tempBQN.MakeQNFromMatrixAndColumn(theMat, column);
  this->AddBasicQuasiNumber(tempBQN);
}*/

void QuasiNumber::MakeQNFromMatrixAndColumn(MatrixLargeRational& theMat, root& column)
{ this->ClearTheObjects();
  this->NumVariables= (int)column.size;
  BasicQN tempBQN;
  tempBQN.MakeQNFromMatrixAndColumn(theMat, column);
  this->AddBasicQuasiNumber(tempBQN);
}

void QuasiNumber::MultiplyByBasicQuasiNumber(BasicQN& q)
{ QuasiNumber Accum;
  BasicQN tempQ;
  Accum.MakeZero(this->NumVariables);
  for (int i=0; i<this->size; i++)
  {  tempQ.Assign(this->TheObjects[i]);
    tempQ.MultiplyBy(q);
    Accum.AddBasicQuasiNumber(tempQ);
  }
  this->Assign(Accum);
}

void QuasiNumber::MultiplyByLargeRational(Rational& r)
{  if (r.IsEqualTo(RZero))
  { this->MakeZero(this->NumVariables);
    return;
  }
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].MultiplyByLargeRational(r);
}

void QPSub::MakeLinearSubIntegrand(root& normal, root& direction, Rational& Correction, GlobalVariables& theGlobalVariables)
{ PolynomialRationalCoeff EndPoint;
  EndPoint.MakePolyFromDirectionAndNormal(direction, normal, Correction, theGlobalVariables);
  this->RationalPolyForm.MakeSubstitutionLastVariableToEndPoint(1, EndPoint);
  this->TheQNSub.init((int)(normal.size+1), 1);
  Rational tempRat;
  root tempRoot; tempRoot.SetSize(normal.size);
  root::RootScalarEuclideanRoot(direction, normal, tempRat);
  tempRoot.Assign(normal);
  tempRoot.DivByLargeRational(tempRat);
  int tempDen=tempRoot.FindLCMDenominatorsTruncateToInt();
  tempDen= MathRoutines::lcm(Correction.DenShort, tempDen);
  tempRoot.MultiplyByInteger(tempDen);
  this->QNSubDen= tempDen;
  this->TheQNSub.elements [normal.size][0]=-(Correction.NumShort*tempDen)/Correction.DenShort;
  this->TheQNSub.elements [normal.size][0]%=tempDen;
  if (this->TheQNSub.elements [normal.size][0]<0)
    this->TheQNSub.elements[normal.size][0]+=tempDen;
  for (int i=0; i<this->TheQNSub.NumRows; i++)
  { this->TheQNSub.elements[i][0]=(normal.TheObjects[i].NumShort)%this->QNSubDen;
    if (this->TheQNSub.elements[i][0]<0)
      this->TheQNSub.elements[i][0]+=tempDen;
  }
}

void QPSub::MakeSubAddExtraVarForIntegration(root& direction)
{ this->RationalPolyForm.MakeSubAddExtraVarForIntegration(direction);
  this->TheQNSub.init((int)direction.size+2, (int)direction.size);
  this->TheQNSub.NullifyAll();
  this->QNSubDen=1;
  for (int i=0; i<this->TheQNSub.NumCols; i++)
  { this->TheQNSub.elements[i][i]=1;
    this->TheQNSub.elements[direction.size][i]= -direction.TheObjects[i].NumShort;
  }
}

void QPSub::MakeSubFromMatrixIntAndDen(MatrixIntTightMemoryFit& theMat, int Den)
{ this->RationalPolyForm.MakeSubFromMatrixIntAndDen(theMat, Den);
  this->QNSubDen=Den;
  this->TheQNSub.Assign(theMat);
}

void QPSub::MakeSubFromPolynomialsRationalCoeff(PolynomialsRationalCoeff& input)
{ this->RationalPolyForm.SetSize(input.size);
  if (input.size<1)
    return;
  int theDimension= input.TheObjects[0].NumVars;
  for(int i=0; i<input.size; i++)
    this->RationalPolyForm.TheObjects[i].CopyFromPoly(input.TheObjects[i]);
  this->TheQNSub.init((int)theDimension+1, (int)theDimension);
  this->TheQNSub.NullifyAll();
  for (int i=0; i<input.size; i++)
    for (int k=0; k<input.TheObjects[i].size; k++)
      for (int j=0; j<theDimension; j++)
      { bool IsAConstantTerm=true;
        assert(  input.TheObjects[i].TheObjects[k].degrees[j]==1 || input.TheObjects[i].TheObjects[k].degrees[j]==0);
        if (input.TheObjects[i].TheObjects[k].degrees[j]==1)
        { this->TheQNSub.elements[i][j]=input.TheObjects[i].TheObjects[k].Coefficient.NumShort;
          assert(IsAConstantTerm);
          IsAConstantTerm=false;
        }
        if (IsAConstantTerm)
          this->TheQNSub.elements[theDimension][i]=input.TheObjects[i].TheObjects[k].Coefficient.NumShort;
      }
}

void QPSub::MakeSubNVarForOtherChamber(root &direction, root &normal, Rational &Correction, GlobalVariables& theGlobalVariables)
{ this->RationalPolyForm.MakeSubNVarForOtherChamber(direction, normal, Correction, theGlobalVariables);
  int theDimension= direction.size;
  this->TheQNSub.init((int)theDimension+1, (int)theDimension);
  Rational tempRat;
  root::RootScalarEuclideanRoot(direction, normal, tempRat);
  root tempRoot; tempRoot.SetSize(theDimension);
  tempRoot.Assign(normal);
  tempRat.Minus();
  tempRoot.DivByLargeRational(tempRat);
  int tempDen = tempRoot.FindLCMDenominatorsTruncateToInt();
  tempDen= MathRoutines::lcm(tempDen, Correction.DenShort);
  tempRoot.MultiplyByInteger(tempDen);
  int Corr= -(Correction.NumShort*((signed int)Correction.DenShort))/tempDen;
  this->TheQNSub.NullifyAll();
  this->QNSubDen=tempDen;
  for (int i=0; i<theDimension; i++)
  { this->TheQNSub.elements[theDimension][i]=(direction.TheObjects[i].NumShort*Corr)%tempDen;
    if (this->TheQNSub.elements[theDimension][i]<0)
      this->TheQNSub.elements[theDimension][i]+=tempDen;
    for(int j=0; j<theDimension; j++)
    { this->TheQNSub.elements[i][j]=tempRoot.TheObjects[j].NumShort*direction.TheObjects[j].NumShort;
      if (i==j)
        this->TheQNSub.elements[i][j]+=1;
      TheQNSub.elements[i][j]%=tempDen;
      if (TheQNSub.elements[i][j]<0)
        TheQNSub.elements[i][j]+=tempDen;
    }
  }
}

void SortedQPs::AddToEntry(int x, int y, int z, QuasiMonomial &QM)
{ if (x>this->FakeSize-1)
    this->setFakeSize(x+1, QM.NumVariables);
  if (y>this->TheObjects[x]->FakeSize-1)
    this->TheObjects[x]->setFakeSize(y+1, QM.NumVariables);
  if(z>this->TheObjects[x]->TheObjects[y]->FakeSize-1)
    this->TheObjects[x]->TheObjects[y]->setFakeSize(z+1, QM.NumVariables);
  this->TheObjects[x]->TheObjects[y]->TheObjects[z]->AddMonomial(QM);
}

void Rational::WriteToFile(std::fstream& output)
{ std::string tempS;
  this->ElementToString(tempS);
  output << tempS << " ";
}

inline void Rational::RaiseToPower(int x)
{ Rational tempRat;
  tempRat.MakeOne();
  if (x<0)
  { x=-x;
    this->Invert();
  }
  if (!this->IsInteger())
    MathRoutines::RaiseToPower(*this, x, tempRat);
  else
  { LargeIntUnsigned tempNum;
    this->GetNumUnsigned(tempNum);
    LargeIntUnsigned oneLI;
    oneLI.MakeOne();
    MathRoutines::RaiseToPower(tempNum, x, oneLI);
    LargeInt tempNumSigned;
    tempNumSigned.AssignLargeIntUnsigned(tempNum);
    tempNumSigned.sign= (this->IsPositive() || x%2==0) ? 1 :-1;
    this->AssignLargeInteger(tempNumSigned);
  }
}

inline void Rational::Invert()
{ if (this->Extended==0)
  { int tempI= this->DenShort;
    assert(tempI>0);
    if (this->NumShort<0)
    { this->DenShort=-this->NumShort;
      this->NumShort=-tempI;
    }
    else
    { this->DenShort= this->NumShort;
      this->NumShort= tempI;
    }
    return;
  }
  LargeIntUnsigned tempI;
  tempI.Assign(this->Extended->den);
  this->Extended->den.Assign( this->Extended->num.value);
  this->Extended->num.value.Assign(tempI);
}

void Rational::AssignString(const std::string& input)
{ int positionInTempS=0;
  this->MakeZero();
  if (input=="0")
    return;
  if (input[0]=='-')
    positionInTempS++;
  LargeIntUnsigned tempNum, tempDen;
  tempNum.MakeZero();
  tempDen.MakeOne();
  bool readingNumerator=true;
  for (unsigned i=positionInTempS; i<input.length(); i++)
  { char a= input[i];
    if (a=='/')
    { readingNumerator=false;
      tempDen.MakeZero();
    } else
    { if (readingNumerator)
      { tempNum.MultiplyByUInt(10);
        unsigned int x=std::atoi(&a);
        tempNum.AddUInt(x);
      } else
      { tempDen.MultiplyByUInt(10);
        unsigned int x= std::atoi(&a);
        tempDen.AddUInt(x);
      }
    }
  }
  this->MakeOne();
  this->DivideByLargeIntegerUnsigned(tempDen);
  this->MultiplyByLargeIntUnsigned(tempNum);
  if (input[0]=='-')
    this->Minus();
}

void Rational::ReadFromFile(std::fstream& input)
{ std::string tempS;
  input>> tempS;
  this->AssignString(tempS);
}

root Rational::operator *(const root& right)const
{ root result;
  result.Assign(right);
  result.MultiplyByLargeRational(*this);
  return result;
}

inline void Rational::MultiplyByInt(int x)
{ Rational tempRat;
  tempRat.AssignInteger(x);
  this->MultiplyBy(tempRat);
}

inline void Rational::MultiplyBy(const Rational& r)
{ if (r.Extended==0)
    if (this->TryToMultiplyQuickly(r.NumShort, r.DenShort))
      return;
  this->InitExtendedFromShortIfNeeded();
  if (r.Extended!=0)
  { this->Extended->num.MultiplyBy(r.Extended->num);
    this->Extended->den.MultiplyBy(r.Extended->den);
  }
  else
  { this->Extended->num.MultiplyByInt(r.NumShort);
    this->Extended->den.MultiplyByUInt((unsigned int)r.DenShort);
  }
  this->Simplify();
}

Rational operator/(int left, const Rational& right)
{ Rational tempRat=left;
  tempRat/=right;
  return tempRat;
}

Rational operator-(const Rational& argument)
{ Rational tempRat;
  tempRat.Assign(argument);
  tempRat.Minus();
  return tempRat;
}

inline void Rational::MultiplyByLargeInt(LargeInt& x)
{ this->InitExtendedFromShortIfNeeded();
  this->Extended->num.MultiplyBy(x);
  this->Simplify();
}

void Rational::MultiplyByLargeIntUnsigned(LargeIntUnsigned& x)
{ this->InitExtendedFromShortIfNeeded();
  this->Extended->num.value.MultiplyBy(x);
  this->Simplify();
}

inline void Rational::DivideBy(const Rational& r)
{ if (r.Extended==0)
  { int tempNum;
    int tempDen;
    if(r.NumShort<0)
    { tempNum= -(r.DenShort);
      tempDen= -r.NumShort;
    }
    else
    { tempNum=r.DenShort;
      tempDen= r.NumShort;
    }
    if (this->TryToMultiplyQuickly(tempNum, tempDen))
      return;
  }
  if (this==&r)
  { this->MakeOne();
    return;
  }
  this->InitExtendedFromShortIfNeeded();
  if (r.Extended!=0)
  { this->Extended->num.value.MultiplyBy(r.Extended->den);
    this->Extended->den.MultiplyBy(r.Extended->num.value);
    this->Extended->num.sign*=r.Extended->num.sign;
  }
  else
  { int tempNum; int tempDen;
    if(r.NumShort<0)
    { tempNum= -(r.DenShort);
      tempDen= -r.NumShort;
    }
    else
    { tempNum= r.DenShort;
      tempDen= r.NumShort;
    }
    this->Extended->num.MultiplyByInt(tempNum);
    this->Extended->den.MultiplyByUInt(tempDen);
  }
  this->Simplify();
}

Rational Rational::operator/(const Rational& right) const
{ Rational tempRat;
  tempRat.Assign(*this);
  tempRat.DivideBy(right);
  return tempRat;
}

Rational Rational::operator*(const Rational& right) const
{ Rational tempRat;
  tempRat.Assign(*this);
  tempRat.MultiplyBy(right);
  return tempRat;
}

Rational Rational::operator+(const Rational& right) const
{ Rational tempRat;
  tempRat.Assign(*this);
  tempRat+=(right);
  return tempRat;
}

Rational Rational::operator-(const Rational& right) const
{ Rational tempRat;
  tempRat.Assign(*this);
  tempRat.Subtract(right);
  return tempRat;
}

void Rational::Assign(const Rational& r)
{ this->NumShort = r.NumShort;
  this->DenShort = r.DenShort;
  if (r.Extended==0)
  { if (this->Extended==0) return;
    this->FreeExtended();
    return;
  }
  this->InitExtendedFromShortIfNeeded();
  this->Extended->num.Assign(r.Extended->num);
  this->Extended->den.Assign(r.Extended->den);
}

inline void Rational::AssignFracValue()
{ if (this->Extended==0)
  { if (this->NumShort==0)
      return;
    if (this->DenShort==1)
    { this->NumShort=0;
      this->DenShort=1;
      return;
    }
    this->NumShort=this->NumShort% this->DenShort;
    if (this->NumShort<0)
      this->NumShort+=this->DenShort;
    return;
  }
  if (this->IsEqualToZero())
    return;
  if (this->Extended->den.IsEqualToOne())
  { this->MakeZero();
    return;
  }
  LargeIntUnsigned newNum, tempI;
  this->Extended->num.value.DivPositive(this->Extended->den, tempI, newNum);
  this->Extended->num.value.Assign(newNum);
  if (this->Extended->num.IsNegative())
    this->Extended->num.AddLargeIntUnsigned(this->Extended->den);
  assert(this->Extended->num.IsNonNegative());
  this->Simplify();
}

void Rational::AddInteger(int x)
{ Rational tempRat;
  tempRat.AssignNumeratorAndDenominator(x, 1);
  this->operator+=(tempRat);
}

bool Rational::IsGreaterThan(const Rational& r) const
{ Rational tempRat;
  tempRat.Assign(*this);
  tempRat.Subtract(r);
  return tempRat.IsPositive();
}

void Rational::Subtract(const Rational& r)
{ Rational temp;
  temp.Assign(r);
  temp.Minus();
  this->operator+=(temp);
}

void Rational::AssignInteger(int x)
{ this->FreeExtended();
  this->DenShort=1;
  this->NumShort=x;
}

Rational Rational::Factorial(int n)
{ Rational result;
  result.MakeOne();
  for (int i=0; i<n; i++)
    result.MultiplyByInt(i+1);
  return result;
}

Rational Rational::TwoToTheNth(int n)
{ Rational result=1;
  if (n>=0)
    for (int i=0; i<n; i++)
      result.MultiplyByInt(2);
  else
    for (int i=0; i>n; i--)
      result.DivideByInteger(2);
  return result;
}

Rational Rational::NChooseK(int n, int k)
{ Rational result;
  result.MakeOne();
  for (int i=0; i<k; i++)
  { result.MultiplyByInt(n-i);
    result.DivideByInteger(i+1);
  }
  return result;
}

Rational Rational::NtoTheKth(int n, int k)
{ Rational result=n;
  result.RaiseToPower(k);
  return result;
}

bool Rational::IsInteger()const
{ if (this->Extended==0)
    return this->DenShort==1;
  else
    return this->Extended->den.IsEqualToOne();
}

double Rational::DoubleValue()
{ if (this->Extended==0)
    return (double)this->NumShort/(double)this->DenShort;
  else
    return this->Extended->num.GetDoubleValue()/this->Extended->den.GetDoubleValue();
}

void Rational::Simplify()
{ if (this->Extended==0)
  { if (this->NumShort==0)
      this->DenShort=1;
    else
    { if (this->DenShort==1)
        return;
      int tempGCD;
      if (this->NumShort>0)
        tempGCD= this->gcd(this->NumShort, this->DenShort);
      else
        tempGCD= this->gcd(-this->NumShort, this->DenShort);
      this->NumShort/=tempGCD;
      this->DenShort/=tempGCD;
    }
    return;
  }
  if (this->Extended->num.IsEqualToZero())
  { this->MakeZero();
    return;
  }
  if (!this->Extended->den.IsEqualToOne())
  { LargeIntUnsigned tempI;
    LargeIntUnsigned::gcd(this->Extended->den, this->Extended->num.value, tempI);
    /*if (Rational::flagAnErrorHasOccurredTimeToPanic)
    { std::string tempS1, tempS2, tempS3;
      tempI.ElementToString(tempS1);
      this->ElementToString(tempS2);
    }*/
    LargeIntUnsigned tempI2;
    this->Extended->den.DivPositive(tempI, this->Extended->den, tempI2);
    this->Extended->num.value.DivPositive(tempI, this->Extended->num.value, tempI2);
  }
  this->ShrinkExtendedPartIfPossible();
}

inline void LargeIntUnsigned::AddShiftedUIntSmallerThanCarryOverBound(unsigned int x, int shift)
{ assert(x<LargeIntUnsigned::CarryOverBound);
  while (x>0)
  { if (shift>=this->size)
    { int oldsize=this->size;
      this->SetSize(shift+1);
      for (int i=oldsize; i<this->size; i++)
        this->TheObjects[i]=0;
    }
    this->TheObjects[shift]+=x;
    if (this->TheObjects[shift]>=LargeIntUnsigned::CarryOverBound)
    { this->TheObjects[shift]-=LargeIntUnsigned::CarryOverBound;
      x=1;
      shift++;
    } else
      x=0;
  }
//  this->FitSize();
}

inline void LargeIntUnsigned::AssignShiftedUInt(unsigned int x, int shift)
{ if (x==0)
  { this->MakeZero();
    return;
  }
  this->SetSize(shift+1);
  for (int i=0; i<shift; i++)
    this->TheObjects[i]=0;
  unsigned int tempX= x%LargeIntUnsigned::CarryOverBound;
  this->TheObjects[shift]=tempX;
  x= x/LargeIntUnsigned::CarryOverBound;
  while (x!=0)
  { tempX= x%LargeIntUnsigned::CarryOverBound;
    this->AddObjectOnTop(tempX);
    x= x/LargeIntUnsigned::CarryOverBound;
  }
}

inline void LargeIntUnsigned::AddNoFitSize(const LargeIntUnsigned& x)
{ int oldsize= this->size;
  this->SetSize(MathRoutines::Maximum(this->size, x.size)+1);
  for (int i=oldsize; i<this->size; i++)
    this->TheObjects[i]=0;
  unsigned int CarryOver=0;
  for(int i=0; i<x.size; i++)
  { this->TheObjects[i]+=x.TheObjects[i]+CarryOver;
    if (this->TheObjects[i]>=LargeIntUnsigned::CarryOverBound)
    { this->TheObjects[i]-=LargeIntUnsigned::CarryOverBound;
      CarryOver=1;
    }
    else
      CarryOver=0;
  }
  if (CarryOver!=0)
    for(int i=x.size; i<this->size; i++)
    { this->TheObjects[i]+=1;
      if (this->TheObjects[i]>=LargeIntUnsigned::CarryOverBound)
        this->TheObjects[i]-=LargeIntUnsigned::CarryOverBound;
      else
        break;
    }
}

void LargeIntUnsigned::Add(const LargeIntUnsigned& x)
{ this->AddNoFitSize(x);
  this->FitSize();
}

void LargeIntUnsigned::SubtractSmallerPositive(const LargeIntUnsigned& x)
{ unsigned int CarryOver=0;
  assert(this->IsGEQ(x));
  for (int i=0; i<x.size; i++)
    if (this->TheObjects[i]<x.TheObjects[i]+CarryOver)
    { this->TheObjects[i]+=LargeIntUnsigned::CarryOverBound;
      this->TheObjects[i]-=(x.TheObjects[i]+CarryOver);
      CarryOver=1;
    }
    else
    { this->TheObjects[i]-=(x.TheObjects[i]+CarryOver);
      CarryOver=0;
    }
  if (CarryOver!=0)
  { for (int i=x.size; i<this->size; i++)
      if (this->TheObjects[i]>0)
      { this->TheObjects[i]--;
        break;
      }
      else
        this->TheObjects[i]=LargeIntUnsigned::CarryOverBound-1;
  }
  this->FitSize();
//  assert(this->CheckForConsistensy());
}

void LargeIntUnsigned::MultiplyBy(const LargeIntUnsigned& x, LargeIntUnsigned& output)const
{ assert(this!=&output && &x!=&output);
  output.SetSize(x.size+output.size);
  for(int i=0; i<output.size; i++)
    output.TheObjects[i]=0;
  for (int i=0; i<this->size; i++)
    for(int j=0; j<x.size; j++)
    { unsigned long long tempLong= this->TheObjects[i];
      unsigned long long tempLong2= x.TheObjects[j];
      tempLong= tempLong*tempLong2;
      unsigned long long lowPart= tempLong%LargeIntUnsigned::CarryOverBound;
      unsigned long long highPart= tempLong/LargeIntUnsigned::CarryOverBound;
      output.AddShiftedUIntSmallerThanCarryOverBound((unsigned int) lowPart, i+j);
      output.AddShiftedUIntSmallerThanCarryOverBound((unsigned int) highPart, i+j+1);
    }
  output.FitSize();
//  assert(this->CheckForConsistensy());
}

void LargeIntUnsigned::FitSize()
{ int newSize=this->size;
  for (int i=this->size-1; i>=1; i--)
    if (this->TheObjects[i]==0)
      newSize--;
    else
      break;
  this->SetSize(newSize);
//  assert(this->CheckForConsistensy());
}

void LargeIntUnsigned::MultiplyByUInt(unsigned int x)
{ LargeIntUnsigned tempLI;
  tempLI.AssignShiftedUInt(x, 0);
  this->MultiplyBy(tempLI);
}

void LargeIntUnsigned::MultiplyBy(const LargeIntUnsigned& x)
{ LargeIntUnsigned tempInt;
  this->MultiplyBy(x, tempInt);
  this->Assign(tempInt);
//  assert(this->CheckForConsistensy());
}

void LargeInt::MultiplyByInt(int x)
{//  if (this->value.size==0) return;
  LargeInt tempI;
  tempI.AssignInt(x);
  this->MultiplyBy(tempI);
}

void LargeIntUnsigned::ElementToString(std::string& output)const
{ int base=10;
  int tempI;
  if (this->IsEqualToZero())
  { output="0";
    return;
  }
  LargeIntUnsigned tempInt;
  tempInt.Assign(*this);
  std::string tempS;
  std::stringstream out;
  while(!tempInt.IsEqualToZero() )
  { tempI= tempInt%base;
    out << tempI;
    tempInt= tempInt/base;
  }
  tempS= out.str();
  output.resize(tempS.size());
  for (unsigned int i=0; i<tempS.size(); i++)
    output[i]=tempS[tempS.size()-1-i];
//  assert(this->CheckForConsistensy());
}

bool LargeInt::IsEqualTo(const LargeInt& x)const
{ if (x.sign!=this->sign)
  { if (x.IsEqualToZero() && this->IsEqualToZero())
      return true;
    else
      return false;
  }
  return this->value.IsEqualTo(x.value);
}

bool LargeInt::CheckForConsistensy()
{ if (this->sign!=-1 && this->sign!=1)
    return false;
  for (int i=0; i<this->value.size; i++)
    if (this->value.TheObjects[i]>=LargeIntUnsigned::CarryOverBound)
      return false;
  return true;
}

double LargeInt::GetDoubleValue()
{ return this->GetIntValueTruncated();
}

void LargeInt::ElementToString(std::string& output)const
{ std::stringstream out;
  if (this->IsEqualToZero())
  { output.assign("0");
    return;
  }
  if (this->sign==-1)
    out << "-";
  std::string tempS;
  this->value.ElementToString(tempS);
  out << tempS;
  output=out.str();
}

void LargeInt::AssignInt(int x)
{ if (x==0)
  { this->MakeZero();
    return;
  }
  this->sign=1;
  if (x<0)
  { this->sign=-1;
    x=-x;
  }
  this->value.AssignShiftedUInt( (unsigned int)x, 0);
//  assert(this->CheckForConsistensy());
}

void LargeInt::AddLargeIntUnsigned(LargeIntUnsigned& x)
{ if (this->sign==1)
  { this->value.Add(x);
    return;
  }
  if (this->value.IsGEQ(x))
    this->value.SubtractSmallerPositive(x);
  else
  { LargeIntUnsigned tempI;
    tempI.Assign(x);
    tempI.SubtractSmallerPositive(this->value);
    this->value.Assign(tempI);
  }
}

void LargeInt::Add(const LargeInt& x)
{ if (this->sign==x.sign)
    this->value.Add(x.value);
  else
  { if (this->value.IsGEQ(x.value))
      this->value.SubtractSmallerPositive(x.value);
    else
    { LargeIntUnsigned tempI;
      tempI.Assign(this->value);
      this->value.Assign(x.value);
      this->value.SubtractSmallerPositive(tempI);
      this->sign= x.sign;
    }
  }
//  assert(this->CheckForConsistensy());
}

int LargeIntUnsigned::GetUnsignedIntValueTruncated()
{ return  (int) this->TheObjects[0];
}

bool LargeIntUnsigned::IsEqualTo(const LargeIntUnsigned &right)const
{ if (this->size!=right.size)
    return false;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=right.TheObjects[i])
      return false;
  return true;
}

double LargeIntUnsigned::GetDoubleValue()
{ //must be rewritten
  return this->GetUnsignedIntValueTruncated();
}

void LargeIntUnsigned::gcd(const LargeIntUnsigned& a, const LargeIntUnsigned& b, LargeIntUnsigned& output)
{ LargeIntUnsigned p, q, r, temp;
  std::string tempSP, tempSQ, tempSR, tempS;
  p.Assign(a);
  q.Assign(b);
  /*if (Rational::flagAnErrorHasOccurredTimeToPanic)
  { p.ElementToString(tempSP);
    q.ElementToString(tempSQ);
    r.ElementToString(tempSR);
    temp.ElementToString(tempS);
  }*/
  while(!q.IsEqualToZero() )
  { /*if (Rational::flagAnErrorHasOccurredTimeToPanic)
    { p.ElementToString(tempSP);
      q.ElementToString(tempSQ);
      r.ElementToString(tempSR);
      temp.ElementToString(tempS);
    }*/
    p.DivPositive(q, temp, r);
    /*if (Rational::flagAnErrorHasOccurredTimeToPanic)
    { p.ElementToString(tempSP);
      q.ElementToString(tempSQ);
      r.ElementToString(tempSR);
      temp.ElementToString(tempS);
    }*/
    p.Assign(q);
    /*if (Rational::flagAnErrorHasOccurredTimeToPanic)
    { p.ElementToString(tempSP);
      q.ElementToString(tempSQ);
      r.ElementToString(tempSR);
      temp.ElementToString(tempS);
    }*/
    q.Assign(r);
    /*if (Rational::flagAnErrorHasOccurredTimeToPanic)
    { p.ElementToString(tempSP);
      q.ElementToString(tempSQ);
      r.ElementToString(tempSR);
      temp.ElementToString(tempS);
    }*/
  }
  output.Assign(p);
//  assert(output.CheckForConsistensy());
}

void LargeInt::MakeZero()
{ this->value.MakeZero();
  this->sign=1;
}

void LargeInt::Assign(const LargeInt& x)
{ this->sign=x.sign;
  this->value.CopyFromBase(x.value);
//  assert(this->CheckForConsistensy());
}

LargeInt LargeInt::operator/(int x)const
{ LargeInt result;
  LargeIntUnsigned remainder;
  LargeIntUnsigned tempX;
  int absX=x; signed char signX=1; if (x<0){ signX=-1; absX=-absX; }
  tempX.AssignShiftedUInt(absX, 0);
  this->value.DivPositive(tempX, result.value, remainder);
//  assert(result.CheckForConsistensy());
  result.sign=this->sign* signX;
  return result;
}

LargeInt LargeInt::operator/(LargeInt& x)const
{ LargeInt result;
  LargeInt remainder;
  this->value.DivPositive(x.value, result.value, remainder.value);
  result.sign= this->sign* x.sign;
  assert(result.CheckForConsistensy());
  return result;
}

int LargeInt::operator%(int x)
{ assert(x>0);
  LargeIntUnsigned result;
  LargeIntUnsigned remainder;
  LargeIntUnsigned tempX;
  if (x<0)
    x=-x;
  tempX.AssignShiftedUInt(x, 0);
  this->value.DivPositive(tempX, result, remainder);
  if (remainder.size ==0)
    return 0;
  else
    return remainder.TheObjects[0];
}

LargeIntUnsigned LargeIntUnsigned::operator/(unsigned int x)const
{ LargeIntUnsigned result;
  LargeIntUnsigned remainder;
  LargeIntUnsigned tempX;
  tempX.AssignShiftedUInt(x, 0);
  this->DivPositive(tempX, result, remainder);
//  assert(result.CheckForConsistensy());
  return result;
}

LargeIntUnsigned LargeIntUnsigned::operator/(const LargeIntUnsigned& x)const
{ LargeIntUnsigned result;
  LargeIntUnsigned remainder;
  this->DivPositive(x, result, remainder);
  return result;
}

int LargeIntUnsigned::operator%(unsigned int x)
{ LargeIntUnsigned result;
  LargeIntUnsigned remainder;
  LargeIntUnsigned tempX;
  tempX.AssignShiftedUInt(x, 0);
  this->DivPositive(tempX, result, remainder);
  return remainder.TheObjects[0];
}

void LargeIntUnsigned::MakeOne()
{ this->SetSize(1);
  this->TheObjects[0]=1;
}

void LargeIntUnsigned::MakeZero()
{ this->SetSize(1);
  this->TheObjects[0]=0;
}

bool LargeIntUnsigned::IsGEQ(const LargeIntUnsigned& x)const
{ if (this->size>x.size)
    return true;
  if (this->size<x.size)
    return false;
  for (int i=this->size-1; i>=0; i--)
  { if (x.TheObjects[i]>this->TheObjects[i])
      return false;
    if (x.TheObjects[i]<this->TheObjects[i])
      return true;
  }
  return true;
}

void CompositeComplexQNPoly::AssignQP(QuasiPolynomialOld& q)
{ Monomial<CompositeComplexQN> tempM;
  tempM.init(q.NumVars);
  this->ClearTheObjects();
  this->NumVars= q.NumVars;
  for (int i=0; i<q.size; i++)
  { for (int j=0; j<this->NumVars; j++)
      tempM.degrees[j]=q.TheObjects[i].degrees[j];
    q.TheObjects[i].Coefficient.QNtoComplex(tempM.Coefficient);
    this->AddMonomial(tempM);
  }
}

void partFractionPolynomials::ComputeQuasiPolynomial(QuasiPolynomialOld& output, bool RecordNumMonomials, int theDimension, GlobalVariables& theGlobalVariables)
{ output.Nullify((int)theDimension);
  for (int i=0; i<this->size; i++)
  { if (RecordNumMonomials)
    { std::stringstream out;
      out<<i<<" out of "<<this->size<<" accounted for";
      theGlobalVariables.theIndicatorVariables.ProgressReportString4= out.str();
    }
    QuasiPolynomialOld& tempQP = theGlobalVariables.QPComputeQuasiPolynomial;
    QuasiNumber& tempQN = theGlobalVariables.QNComputeQuasiPolynomial;
    tempQP.AssignPolynomialRationalCoeff(this->TheObjects[i]);
    //tempQP.ComputeDebugString();
    tempQN.MakeQNFromMatrixAndColumn(this->theNormals, this->LatticeIndicators.TheObjects[i]);
    if (partFraction::flagAnErrorHasOccurredTimeToPanic)
      tempQN.ComputeDebugString();
    //tempQN.ComputeDebugString();
    tempQP.TimesConstant(tempQN);
    //tempQP.ComputeDebugString();
    if (partFraction::MakingConsistencyCheck)
    { std::string tempS;
      Rational tempLR;
      tempQP.Evaluate(partFraction::theVectorToBePartitioned, tempLR);
      //assert (tempLR.den.IsEqualTo(LIOne));
      partFractions::CheckSum+=(tempLR);
      //partFraction::CheckSum.Add(tempLR);
//      assert(partFractions::CheckSum.den.IsEqualTo(LIOne));
    }
    output.AddPolynomial(tempQP);
    //output.ComputeDebugString();
  }
}

void partFractionPolynomials::initLatticeIndicatorsFromPartFraction(partFractions& ownerExpression, partFraction& owner, GlobalVariables& theGlobalVariables, int theDimension)
{ this->LatticeIndicators.size=0;
  this->theNormals.init((int)theDimension, (int)theDimension);
  for (int i=0; i<theDimension; i++)
  { int tempI=owner.IndicesNonZeroMults.TheObjects[i];
    assert(owner.TheObjects[tempI].Elongations.size==1);
    for(int j=0; j<theDimension; j++)
      this->theNormals.elements[j][i].AssignInteger(ownerExpression.RootsToIndices.TheObjects[tempI].TheObjects[j]*owner.TheObjects[tempI].Elongations.TheObjects[0]);
  }
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    theNormals.ComputeDebugString();
  this->theNormals.Invert(theGlobalVariables);
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    theNormals.ComputeDebugString();
  this->size=0;
}

void partFractionPolynomials::AddPolynomialLargeRational(root& rootLatticeIndicator, PolynomialRationalCoeff& input)
{ root tempRoot, tempRoot2;
  int theDimension= rootLatticeIndicator.size;
  tempRoot.SetSize(theDimension);
  tempRoot2.SetSize(theDimension);
  Rational tempRat, tempRat2;
  //if (partFraction::MakingConsistencyCheck)
  //{ this->CheckConsistency(rootLatticeIndicator, input);
  //}
  //tempRoot.MakeZero();
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    this->theNormals.ComputeDebugString();
  for(int i=0; i<this->theNormals.NumRows; i++)
  { tempRoot.TheObjects[i].MakeZero();
    if (partFraction::MakingConsistencyCheck)
      tempRoot2.TheObjects[i].MakeZero();
    for(int j=0; j<theDimension; j++)
    { tempRat.Assign(this->theNormals.elements[i][j]);
      tempRat.MultiplyBy(rootLatticeIndicator.TheObjects[j]);
      tempRoot.TheObjects[i]+=(tempRat);
      if (partFraction::MakingConsistencyCheck)
      { if (partFraction::flagAnErrorHasOccurredTimeToPanic)
        { Stop();
        }
        tempRat2.AssignInteger(partFraction::theVectorToBePartitioned.TheObjects[j]);
        tempRat2.MultiplyBy(this->theNormals.elements[i][j]);
        tempRoot2.TheObjects[i]+=(tempRat2);
      }
    }
    tempRoot.TheObjects[i].AssignFracValue();
    if (partFraction::MakingConsistencyCheck)
    { tempRoot2.TheObjects[i].AssignFracValue();
    }
  }
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
  { tempRoot.ComputeDebugString();
    tempRoot2.ComputeDebugString();
  }
  if (partFraction::MakingConsistencyCheck)
  {  if (tempRoot2.IsEqualTo(tempRoot))
    { Rational tempLRat;
      std::string tempS1, tempS2;
      if (partFraction::flagAnErrorHasOccurredTimeToPanic)
      { input.ComputeDebugString();
      }
      input.Evaluate(partFraction::theVectorToBePartitioned, tempLRat);
      tempLRat.ElementToString(tempS1);
  //    tempLRat.ElementToString(tempS1);
      partFraction::CheckSum+=(tempLRat);
      if (partFraction::flagAnErrorHasOccurredTimeToPanic)
      { partFraction::CheckSum.ElementToString(tempS1);
      }
    }
  }
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
  { rootLatticeIndicator.ComputeDebugString();
  }
  int x= this->LatticeIndicators.IndexOfObject(tempRoot);
  if (x==-1)
  { this->LatticeIndicators.AddRoot(tempRoot);
    this->AddObjectOnTop(input);
  }
  else
  { this->TheObjects[x].AddPolynomial(input);
    if (partFraction::MakingConsistencyCheck)
    {  if (tempRoot2.IsEqualTo(tempRoot))
      { Rational tempLRat;
        this->TheObjects[x].Evaluate(partFraction::theVectorToBePartitioned, tempLRat);
        assert(tempLRat.IsEqualTo(partFraction::CheckSum));
      }
    }
  }
}

void partFractionPolynomials::CheckConsistency(root& RootLatticeIndicator, PolynomialRationalCoeff& input)
{ root tempRoot2;
  int theDimension= RootLatticeIndicator.size;
  tempRoot2.AssignIntRoot(partFraction::theVectorToBePartitioned);
  tempRoot2.Subtract(RootLatticeIndicator);
  intRoot tempIntRoot;
  tempIntRoot.AssignRoot(tempRoot2);
  root tempRoot; tempRoot.SetSize(theDimension);
  Rational tempRat;
  for(int i=0; i<this->theNormals.NumRows; i++)
  { tempRoot.TheObjects[i].MakeZero();
    for(int j=0; j<theDimension; j++)
    { tempRat.Assign(this->theNormals.elements[i][j]);
      tempRat.MultiplyBy(tempRoot2.TheObjects[j]);
      tempRoot.TheObjects[i]+=(tempRat);
    }
    tempRoot.TheObjects[i].AssignFracValue();
  }
  Rational tempLRat;
  if (tempRoot.IsEqualToZero())
  { input.Evaluate(tempIntRoot, tempLRat);
    std::string tempS;
    tempLRat.ElementToString(tempS);
    assert(tempS=="1");
  }
}

bool partFraction::RemoveRedundantShortRootsClassicalRootSystem(partFractions& owner, root* Indicator, GlobalVariables& theGlobalVariables, int theDimension)
{ bool result=false;
  if (Indicator!=0)
    if (!this->rootIsInFractionCone(owner, Indicator, theGlobalVariables))
      return false;
  IntegerPoly ComputationalBuffer;
  for (int i=0; i<owner.RootsToIndices.IndicesRedundantShortRoots.CardinalitySelection; i++  )
  { int tempI1, tempI2;
    tempI1= owner.RootsToIndices.IndicesRedundantShortRoots.elements[i];
    tempI2= owner.RootsToIndices.IndicesDoublesOfRedundantShortRoots.TheObjects[tempI1];
    if(tempI2!=-1)
    { if (  this->TheObjects[tempI1].Multiplicities.size>0 && this->TheObjects[tempI2].Multiplicities.size>0)
      { IntegerPoly& tempP=theGlobalVariables.IPRemoveRedundantShortRootsClassicalRootSystem;
        assert(this->TheObjects[tempI1].Multiplicities.size==1 && this->TheObjects[tempI2].Multiplicities.size==1);
        tempP.ClearTheObjects();
        tempP.NumVars= (int)theDimension;
        tempP.MakePolyExponentFromIntRoot(owner.RootsToIndices.TheObjects[tempI1]);
        tempP.AddConstant(IOne);
        //tempP.ComputeDebugString();
        ComputationalBuffer.AssignPolynomialLight(this->Coefficient);
        for (int j=0; j<this->TheObjects[tempI1].Multiplicities.TheObjects[0]; j++)
          ComputationalBuffer.MultiplyBy(tempP);
        this->Coefficient.AssignPolynomial(ComputationalBuffer);
        //this->Coefficient.ComputeDebugString();
        this->TheObjects[tempI2].AddMultiplicity(this->TheObjects[tempI1].Multiplicities.TheObjects[0], 1);
        this->TheObjects[tempI1].AddMultiplicity(-this->TheObjects[tempI1].Multiplicities.TheObjects[0], 1);
        assert(this->TheObjects[tempI1].Multiplicities.size==0);
        result=true;
      }
    }
  }
  this->ComputeIndicesNonZeroMults();
  return result;
}

bool partFractions::RemoveRedundantShortRootsIndex(GlobalVariables& theGlobalVariables, root* Indicator, int theIndex)
{ if (!this->TheObjects[theIndex].rootIsInFractionCone(*this, Indicator, theGlobalVariables))
    return false;
  bool found=false;
  for (int k=0; k < this->TheObjects[theIndex].IndicesNonZeroMults.size; k++)
  { int currentIndex=this->TheObjects[theIndex].IndicesNonZeroMults.TheObjects[k];
    oneFracWithMultiplicitiesAndElongations& currentFrac = this->TheObjects[theIndex].TheObjects[currentIndex];
    if (currentFrac.Elongations.size>1)
    { found=true;
      break;
    }
  }
  if (!found)
    return false;
  partFraction& thePF= theGlobalVariables.fracRemoveRedundantRootsBuffer1;
  thePF.Assign(this->TheObjects[theIndex]);
  this->PopIndexSwapLastHashAndAccount(theIndex, theGlobalVariables, Indicator);
  Rational localStartCheckSum, localEndCheckSum;
  std::string tempS, tempS1, tempS2;
  IntegerPoly ComputationalBufferCoefficient, tempIP;
  PolyPartFractionNumerator ComputationalBufferCoefficientNonExpanded, tempPP;
  ComputationalBufferCoefficient.AssignPolynomialLight(thePF.Coefficient);
  thePF.CoefficientNonExpanded.ComputePolyPartFractionNumerator(ComputationalBufferCoefficientNonExpanded, this->AmbientDimension);
  if (this->flagMakingProgressReport || this->flagAnErrorHasOccurredTimeToPanic)
  { thePF.ComputeOneCheckSum(*this, localStartCheckSum, this->AmbientDimension, theGlobalVariables);
    localStartCheckSum.ElementToString(tempS2);
  }
  for (int k=0; k<thePF.IndicesNonZeroMults.size; k++)
  { int currentIndex=thePF.IndicesNonZeroMults.TheObjects[k];
    oneFracWithMultiplicitiesAndElongations& currentFrac = thePF.TheObjects[currentIndex];
    int LCMElongations = currentFrac.GetLCMElongations();
    this->RootsToIndices.TheObjects[currentIndex].ElementToString(tempS);
    while (currentFrac.Elongations.size>1)
    { for (int i=0; i<currentFrac.Elongations.size; i++)
      { int ElongationValue=currentFrac.Elongations.TheObjects[i];
        if (ElongationValue!=LCMElongations)
        { int numSummands=LCMElongations/ElongationValue;
          if (thePF.UncoveringBrackets)
          { thePF.GetNElongationPoly(*this, currentIndex, ElongationValue, numSummands, tempIP, this->AmbientDimension);
            tempIP.ComputeDebugString();
            tempIP.RaiseToPower(currentFrac.Multiplicities.TheObjects[i], IOne);
            tempIP.ComputeDebugString();
            ComputationalBufferCoefficient.MultiplyBy(tempIP);
          }
          else
          { PolyPartFractionNumerator tempP;
            thePF.GetNElongationPoly(*this, currentIndex, ElongationValue, numSummands, tempP, this->AmbientDimension);
            tempP.RaiseToPower(currentFrac.Multiplicities.TheObjects[i], IOne);
//            this->CoefficientNonExpanded.ComputeDebugString();
            ComputationalBufferCoefficientNonExpanded.MultiplyBy(tempP);
//            this->CoefficientNonExpanded.ComputeDebugString();
          }
          ComputationalBufferCoefficientNonExpanded.ComputeDebugString();
          currentFrac.AddMultiplicity(currentFrac.Multiplicities.TheObjects[i], LCMElongations);
          currentFrac.AddMultiplicity(-currentFrac.Multiplicities.TheObjects[i], ElongationValue);
          thePF.Coefficient.AssignPolynomial(ComputationalBufferCoefficient);
          thePF.ComputeOneCheckSum(*this, localEndCheckSum, this->AmbientDimension, theGlobalVariables);
          assert(localEndCheckSum.IsEqualTo(localStartCheckSum));
        }
      }
    }
    if (partFraction::MakingConsistencyCheck || this->flagAnErrorHasOccurredTimeToPanic)
    { thePF.Coefficient.AssignPolynomial(ComputationalBufferCoefficient);
      thePF.ComputeOneCheckSum(*this, localEndCheckSum, this->AmbientDimension, theGlobalVariables);
      localEndCheckSum.ElementToString(tempS1);
      assert(localStartCheckSum.IsEqualTo(localEndCheckSum));
    }
  }
  thePF.CoefficientNonExpanded.AssignPolyPartFractionNumerator(ComputationalBufferCoefficientNonExpanded);
  thePF.Coefficient.AssignPolynomial(ComputationalBufferCoefficient);
  int tempI = this->IndexOfObjectHash(thePF);
  if (tempI==-1)
    this->AddAlreadyReduced(thePF, theGlobalVariables, Indicator);
  else
  { this->AccountPartFractionInternals(-1, tempI, Indicator, theGlobalVariables);
    this->TheObjects[tempI].AddReturnShouldAttemptReduction(thePF, *this, theGlobalVariables);
    this->AccountPartFractionInternals(1, tempI, Indicator, theGlobalVariables);
  }
  return true;
}

bool partFraction::reduceOnceTotalOrderMethod(partFractions& Accum, GlobalVariables& theGlobalVariables, root* Indicator)
{ for (int i=0; i<this->IndicesNonZeroMults.size; i++)
  { for (int j=0; j<this->IndicesNonZeroMults.size; j++)
    { //assert (this->IndicesNonZeroMults[i]<this->IndicesNonZeroMults[j]);
      int AminusBindex = Accum.RootsToIndices.TableAllowedAminusB.elements[this->IndicesNonZeroMults.TheObjects[i]][this->IndicesNonZeroMults.TheObjects[j]];
      int Aminus2Bindex = Accum.RootsToIndices.TableAllowedAminus2B.elements[this->IndicesNonZeroMults.TheObjects[i]][this->IndicesNonZeroMults.TheObjects[j]];
      if (AminusBindex!=-1 &&  AminusBindex>this->IndicesNonZeroMults.TheObjects[j])
      { this->decomposeAMinusNB(this->IndicesNonZeroMults.TheObjects[i], this->IndicesNonZeroMults.TheObjects[j], 1, AminusBindex, Accum, theGlobalVariables, Indicator);
        return true;
      }
      if (Aminus2Bindex!=-1 &&  Aminus2Bindex>this->IndicesNonZeroMults.TheObjects[j])
      { this->decomposeAMinusNB( this->IndicesNonZeroMults.TheObjects[i], this->IndicesNonZeroMults.TheObjects[j], 2, Aminus2Bindex, Accum, theGlobalVariables, Indicator);
        return true;
      }
    }
  }
//  Accum.Add(*this);
  return false;
}

bool partFraction::reduceOnceGeneralMethodNoOSBasis(partFractions& Accum, GlobalVariables& theGlobalVariables, root* Indicator)
{ roots& tempRoots=theGlobalVariables.rootsreduceOnceGeneralMethod;
  MatrixLargeRational& tempMat= theGlobalVariables.matreduceOnceGeneralMethod;
  tempRoots.size=0;
  int IndexInLinRelationOfLastGainingMultiplicityIndex=-1;
  for (int i=0; i<this->IndicesNonZeroMults.size; i++)
  { intRoot tempRoot; tempRoot.SetSize(Accum.AmbientDimension);
    int currentIndex= this->IndicesNonZeroMults.TheObjects[i];
    if (currentIndex== this->LastDistinguishedIndex)
      IndexInLinRelationOfLastGainingMultiplicityIndex=i;
    tempRoot= Accum.RootsToIndices.TheObjects[currentIndex];
    tempRoot.MultiplyByInteger(this->TheObjects[currentIndex].GetLargestElongation());
    tempRoots.AddIntRoot(tempRoot);
    bool ShouldDecompose;
    ShouldDecompose = tempRoots.GetLinearDependence(tempMat);
  //  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
  //  { tempMat.ComputeDebugString();
  //  }
  //  tempMat.ComputeDebugString();
    if (ShouldDecompose && this->LastDistinguishedIndex!=-1)
    { if (IndexInLinRelationOfLastGainingMultiplicityIndex==-1)
        ShouldDecompose=false;
      else
        ShouldDecompose = !tempMat.elements[IndexInLinRelationOfLastGainingMultiplicityIndex][0].IsEqualToZero();
    }
    if (ShouldDecompose)
    { if (this->flagAnErrorHasOccurredTimeToPanic)
        this->ComputeDebugString(Accum, theGlobalVariables);
      this->DecomposeFromLinRelation(tempMat, Accum, theGlobalVariables, Indicator);
      return true;
    }
  }
  this->LastDistinguishedIndex=-1;
  return false;
  //tempRoots.r
}

bool partFraction::reduceOnceGeneralMethod(partFractions& Accum, GlobalVariables& theGlobalVariables, root* Indicator)
{ roots& tempRoots = theGlobalVariables.rootsreduceOnceGeneralMethod;
  MatrixLargeRational& tempMat = theGlobalVariables.matreduceOnceGeneralMethod;
  tempRoots.size=0;
  if (this->flagAnErrorHasOccurredTimeToPanic)
    this->ComputeDebugString(Accum, theGlobalVariables);
  this->LastDistinguishedIndex=this->getSmallestNonZeroIndexGreaterThanOrEqualTo(Accum, this->LastDistinguishedIndex);
  int IndexInLinRelationOfLastGainingMultiplicityIndex=-1;
  for (int i=0; i<this->IndicesNonZeroMults.size; i++)
  { intRoot tempRoot; tempRoot.SetSize(Accum.AmbientDimension);
    int currentIndex= this->IndicesNonZeroMults.TheObjects[i];
    if (currentIndex== this->LastDistinguishedIndex)
      IndexInLinRelationOfLastGainingMultiplicityIndex=i;
    tempRoot= Accum.RootsToIndices.TheObjects[currentIndex];
    tempRoot.MultiplyByInteger(this->TheObjects[currentIndex].GetLargestElongation());
    tempRoots.AddIntRoot(tempRoot);
    bool ShouldDecompose;
    ShouldDecompose = tempRoots.GetLinearDependence(tempMat);
  //  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
  //  { tempMat.ComputeDebugString();
  //  }
  //  tempMat.ComputeDebugString();
    if ( ShouldDecompose && (this->LastDistinguishedIndex!=-1 || this->LastDistinguishedIndex==Accum.RootsToIndices.size))
    { if (IndexInLinRelationOfLastGainingMultiplicityIndex==-1)
        ShouldDecompose=false;
      else
        ShouldDecompose = !tempMat.elements[IndexInLinRelationOfLastGainingMultiplicityIndex][0].IsEqualToZero();
    }
    if (ShouldDecompose)
    { if (this->flagAnErrorHasOccurredTimeToPanic)
      { this->ComputeDebugString(Accum, theGlobalVariables);
        tempMat.ComputeDebugString();
      }
      this->DecomposeFromLinRelation(tempMat, Accum, theGlobalVariables, Indicator);
      if (this->flagAnErrorHasOccurredTimeToPanic)
      { this->ComputeDebugString(Accum, theGlobalVariables);
        Accum.ComputeDebugString(theGlobalVariables);
      }
      //this->ComputeDebugString();
      return true;
    }
  }
  return false;
  //tempRoots.r
}

int partFraction::SizeWithoutDebugString()
{  int Accum =0;
  Accum+=this->Coefficient.SizeWithoutObjects();
  Accum+=this->::ListLight<oneFracWithMultiplicitiesAndElongations>::SizeWithoutObjects();
  Accum+=this->size*sizeof(oneFracWithMultiplicitiesAndElongations);
  Accum+=  this->IndicesNonZeroMults.SizeWithoutObjects();
  return Accum;
}

void partFraction::AssignDenominatorOnly(const partFraction& p)
{ this->CopyFromLight(p);
  this->Coefficient.NumVars=p.Coefficient.NumVars;
  this->ComputeIndicesNonZeroMults();
}

bool partFraction::AddReturnShouldAttemptReduction(const partFraction& other, const partFractions& owner, GlobalVariables& theGlobalVariables)
{ assert(*this==other);
  bool shouldAttemptReduction=false;
  IntegerPoly& ComputationalBufferCoefficient1 = theGlobalVariables.IPComputationalBufferAddPartFraction1;
  IntegerPoly& ComputationalBufferCoefficient2 = theGlobalVariables.IPComputationalBufferAddPartFraction2;
  PolyPartFractionNumerator& ComputationalBufferCoefficientNonExpanded1=theGlobalVariables.PPFNAddPartFraction1;
  PolyPartFractionNumerator& ComputationalBufferCoefficientNonExpanded2=theGlobalVariables.PPFNAddPartFraction2;
  ComputationalBufferCoefficient1.AssignPolynomialLight(this->Coefficient);
  ComputationalBufferCoefficient2.AssignPolynomialLight(other.Coefficient);
  this->CoefficientNonExpanded.ComputePolyPartFractionNumerator(ComputationalBufferCoefficientNonExpanded1, owner.AmbientDimension);
  other.CoefficientNonExpanded.ComputePolyPartFractionNumerator(ComputationalBufferCoefficientNonExpanded2, owner.AmbientDimension);
  ComputationalBufferCoefficient1.AddPolynomial(ComputationalBufferCoefficient2);
  if (ComputationalBufferCoefficient1.EvaluateAtOne()==0)
  { if (this->flagAnErrorHasOccurredTimeToPanic)
      ComputationalBufferCoefficient1.ComputeDebugString();
    shouldAttemptReduction=true;
  }
  ComputationalBufferCoefficientNonExpanded1.AddPolynomial (ComputationalBufferCoefficientNonExpanded2);
  this->Coefficient.AssignPolynomial (ComputationalBufferCoefficient1);
  this->CoefficientNonExpanded.AssignPolyPartFractionNumerator (ComputationalBufferCoefficientNonExpanded1);
  return shouldAttemptReduction;
}

void partFraction::Assign(const partFraction& p)
{ this->CopyFromLight(p);
  this->Coefficient.AssignPolynomialLight(p.Coefficient);
  this->CoefficientNonExpanded.AssignPolyPartFractionNumeratorLight(p.CoefficientNonExpanded);
  this->IndicesNonZeroMults.CopyFromBase(p.IndicesNonZeroMults);
  this->IsIrrelevant= p.IsIrrelevant;
  this->RelevanceIsComputed= p.RelevanceIsComputed;
  this->LastDistinguishedIndex=p.LastDistinguishedIndex;
}

void partFraction::AssignNoIndicesNonZeroMults(partFraction& p)
{ this->CopyFromLight(p);
  this->Coefficient.AssignPolynomialLight(p.Coefficient);
  this->CoefficientNonExpanded.AssignPolyPartFractionNumeratorLight(p.CoefficientNonExpanded);
}

int partFraction::ElementToString(partFractions& owner, std::string& output, bool LatexFormat, bool includeVPsummand, bool includeNumerator, GlobalVariables& theGlobalVariables)
{ MatrixIntTightMemoryFit tempMat;
  PolynomialOutputFormat PolyFormatLocal;
  return this->ElementToStringBasisChange(owner, tempMat, false, output, LatexFormat, includeVPsummand, includeNumerator, PolyFormatLocal, theGlobalVariables);
}

int partFraction::GetNumMonomialsInNumerator()
{ if (this->UncoveringBrackets)
    return this->Coefficient.size;
  else
    return this->CoefficientNonExpanded.size;
}

void partFraction::WriteToFile(std::fstream& output, GlobalVariables& theGlobalVariables)
{ output << "Fraction_start: " << this->size << "\n";
  for (int j=0; j<this->size; j++)
  { output <<this->TheObjects[j].Multiplicities.size <<" ";
    for (int i=0; i<this->TheObjects[j].Multiplicities.size; i++)
      output << this->TheObjects[j].Multiplicities.TheObjects[i] <<" "<< this->TheObjects[j].Elongations.TheObjects[i] <<" ";
  }
  output<<"\nCoefficient:\n";
  this->Coefficient.WriteToFile(output);
  output<<"Fraction_end\n";
}

void partFraction::ReadFromFile(partFractions& owner, std::fstream& input, GlobalVariables& theGlobalVariables, int theDimension)
{ std::string tempS;
  int tempI;
  input >> tempS >> tempI;
  assert(tempI==owner.RootsToIndices.size);
  this->init(tempI);
  for (int j=0; j<this->size; j++)
  { input >>tempI;
    this->TheObjects[j].Multiplicities.SetSize(tempI);
    this->TheObjects[j].Elongations.SetSize(tempI);
    for (int i=0; i<this->TheObjects[j].Multiplicities.size; i++)
      input >> this->TheObjects[j].Multiplicities.TheObjects[i] >> this->TheObjects[j].Elongations.TheObjects[i];
  }
  input >>tempS;
  this->Coefficient.ReadFromFile(input, (int)theDimension);
  input>>tempS;
  this->ComputeIndicesNonZeroMults();
}

void partFraction::UncoverBracketsNumerator(GlobalVariables& theGlobalVariables, int theDimension)
{ if (this->UncoveringBrackets)
    return;
//  this->CoefficientNonExpanded.ComputeDebugString();
  IntegerPoly ComputationalBufferCoefficient;
  PolyPartFractionNumerator ComputationalBufferCoefficientNonExpanded;
  this->CoefficientNonExpanded.ComputePolyPartFractionNumerator(ComputationalBufferCoefficientNonExpanded, theDimension);
  //ComputationalBufferCoefficientNonExpanded.ComputeDebugString();
  ComputationalBufferCoefficientNonExpanded.ConvertToIntegerPoly(ComputationalBufferCoefficient, theDimension);
  //ComputationalBufferCoefficient.ComputeDebugString();
  this->Coefficient.AssignPolynomial(ComputationalBufferCoefficient);
  //ComputationalBufferCoefficient.AssignPolynomialLight(this->Coefficient);
  //ComputationalBufferCoefficient.ComputeDebugString();
//  this->Coefficient.ComputeDebugString();
}

void partFraction::ComputeOneCheckSum(partFractions& owner, Rational& output, int theDimension, GlobalVariables& theGlobalVariables)
{ if (this->flagAnErrorHasOccurredTimeToPanic)
  { this->Coefficient.ComputeDebugString();
    this->ComputeDebugString(owner, theGlobalVariables);
  }
  IntegerPoly ComputationalBufferCoefficient;
  ComputationalBufferCoefficient.AssignPolynomialLight(this->Coefficient);
  ComputationalBufferCoefficient.Evaluate(oneFracWithMultiplicitiesAndElongations::CheckSumRoot, output);
  std::string tempS;
  if (this->flagAnErrorHasOccurredTimeToPanic && Rational::flagAnErrorHasOccurredTimeToPanic)
  { output.ElementToString(tempS);
  }
  //output.ElementToString(tempS);
  Rational tempRat;
  for (int i=0; i<this->IndicesNonZeroMults.size; i++)
  { this->TheObjects[this->IndicesNonZeroMults.TheObjects[i]].ComputeOneCheckSum(tempRat, owner.RootsToIndices.TheObjects[this->IndicesNonZeroMults.TheObjects[i]], theDimension);
    //tempRat.ElementToString(tempS);
    output.MultiplyBy(tempRat);
    //output.ElementToString(tempS);
  }
}

#ifdef WIN32
#pragma warning(disable:4018)//grrrrr
#endif
int partFraction::ElementToStringBasisChange(partFractions& owner, MatrixIntTightMemoryFit& VarChange, bool UsingVarChange, std::string& output, bool LatexFormat, bool includeVPsummand, bool includeNumerator, PolynomialOutputFormat& PolyFormatLocal, GlobalVariables& theGlobalVariables)
{ std::stringstream out, out2;
  std::string tempS, stringPoly;
  if (this->Coefficient.size==0)
  {output.clear(); return 0; }
  int NumLinesUsed=0;
//  int OldCutOff=0;
  int theDimension= owner.RootsToIndices.TheObjects[0].size;
  IntegerPoly& ComputationalBufferCoefficient=theGlobalVariables.IPElementToStringBasisChange;
  PolyPartFractionNumerator& ComputationalBufferCoefficientNonExpanded= theGlobalVariables.PPFNElementToStringBasisChange;
  ComputationalBufferCoefficient.AssignPolynomialLight(this->Coefficient);
  this->CoefficientNonExpanded.ComputePolyPartFractionNumerator(ComputationalBufferCoefficientNonExpanded, theDimension);
  if (!UsingVarChange)
  { if (includeNumerator)
      { if (this->UncoveringBrackets)
          NumLinesUsed+=ComputationalBufferCoefficient.StringPrintOutAppend(stringPoly, PolyFormatLocal, true);
        else
          NumLinesUsed+=ComputationalBufferCoefficientNonExpanded.StringPrintOutAppend(stringPoly, PolyFormatLocal, true);
      }
    else
      stringPoly="(...)";
  }
  else
  { PolynomialRationalCoeff tempP, tempP2;
    Polynomials<Rational> tempSub;
    tempP.Nullify((int)VarChange.NumRows);
    tempSub.MakeExponentSubstitution(VarChange);
    tempP2.AssignIntegerPoly(ComputationalBufferCoefficient);
    tempP2.Substitution(tempSub, tempP, (int)VarChange.NumRows, (Rational) 1);
    NumLinesUsed+=tempP.StringPrintOutAppend(stringPoly, PolyFormatLocal, true);
  }
  if (stringPoly=="1")
    stringPoly="";
  if (stringPoly=="-1")
    stringPoly="-";
  if ((this->Coefficient.size>1 && this->UncoveringBrackets) || (this->CoefficientNonExpanded.size>1 && !this->UncoveringBrackets))
    out2 << "(";
  out2 << stringPoly;
  if ((this->Coefficient.size>1 && this->UncoveringBrackets) || (this->CoefficientNonExpanded.size>1 && !this->UncoveringBrackets))
    out2 << ")";
  stringPoly= out2.str();
//  this->intRootToString(out, this->RootShift, false);
  out << " ";
  for (int i =0; i<this->size; i++)
  { this->TheObjects[i].ElementToStringBasisChange(owner, VarChange, UsingVarChange, tempS, LatexFormat, i, theDimension, PolyFormatLocal);
    out << tempS;
  }
  if (includeVPsummand && LatexFormat)
  { std::string tempS2;
    QuasiPolynomialOld tempQP;
    tempQP.Nullify((int)theDimension);
    this->partFractionToPartitionFunctionSplit(owner, tempQP, false, false, theGlobalVariables, theDimension);
    PolyFormatLocal.MakeAlphabetyi();
    PolyFormatLocal.cutOffString=false;
    tempQP.StringPrintOutAppend(tempS2, PolyFormatLocal, true);
    PolyFormatLocal.MakeAlphabetxi();
    PolyFormatLocal.cutOffString=false;
    out << "\\\\\n&&[";
    NumLinesUsed++;
    out << tempS2;
    out << "]";
  }
  tempS= out.str();
  if (LatexFormat)
  { //NumLinesUsed+=this->ControlLineSizeStringPolys(stringPoly);
    //NumLinesUsed+=this->ControlLineSizeFracs(tempS);
    output.clear();
    output.append(stringPoly);
    if (stringPoly.size()>(unsigned) PolyFormatLocal.LatexMaxLineLength)
    { output.append("\\\\\n&&");
      NumLinesUsed++;
    }
    output.append(tempS);
  }
  else
  { output.clear();
    output.append(stringPoly);
    output.append(tempS);
  }
  return NumLinesUsed;
}
#ifdef WIN32
#pragma warning(default:4018)//grrrrr
#endif

bool partFraction::rootIsInFractionCone(partFractions& owner, root* theRoot, GlobalVariables& theGlobalVariables)
{ if (theRoot==0)
    return true;
  if (this->RelevanceIsComputed)
    return !this->IsIrrelevant;
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
  { this->ComputeDebugString(owner, theGlobalVariables);
    //if (this->DebugString=="a^{3}b^{2} \\frac{1}{(1-a^{2}b^{3})^5} \\frac{1}{(1-ab)}")
    //{ Stop();
    //}
  }
  MatrixLargeRational tempMat, MatOneCol;
  Selection NonPivotPoints;
  ConeGlobal tempCone; roots tempRoots;
  for (int i=0; i<this->IndicesNonZeroMults.size; i++)
  { int tempI= this->IndicesNonZeroMults.TheObjects[i];
    tempRoots.AddIntRoot(owner.RootsToIndices.TheObjects[tempI]);
  }
  tempCone.ComputeFromDirections(tempRoots, theGlobalVariables, theRoot->size);
  tempCone.ComputeDebugString();
  this->IsIrrelevant=! tempCone.IsInCone(*theRoot);
  this->RelevanceIsComputed=true;
  return !this->IsIrrelevant;
}

void partFraction::PrepareFraction(int indexA, int indexB, int AminusNBindex, bool indexAisNullified, partFraction& output, IntegerPoly& AminusNbetaPoly)
{ output.AssignNoIndicesNonZeroMults(*this);
  static IntegerPoly ComputationalBufferCoefficient;
  ComputationalBufferCoefficient.AssignPolynomialLight(output.Coefficient);
  int powerDropA = this->TheObjects[indexA].Multiplicities.TheObjects[0];
  int powerDropB = this->TheObjects[indexB].Multiplicities.TheObjects[0];
  if (indexAisNullified)
    powerDropB=0;
  else
    powerDropA=0;
  for (int i=0; i<powerDropB; i++)
    ComputationalBufferCoefficient.MultiplyBy(AminusNbetaPoly);
  output.DecreasePowerOneFrac(indexA, powerDropA);
  output.DecreasePowerOneFrac(indexB, powerDropB);
  output.DecreasePowerOneFrac(AminusNBindex, -powerDropA-powerDropB);
  output.Coefficient.AssignPolynomial(ComputationalBufferCoefficient);
}

int partFraction::GetNumProportionalVectorsClassicalRootSystems(partFractions& owner)
{ int result=0;
  for (int i=0; i<owner.RootsToIndices.IndicesRedundantShortRoots.CardinalitySelection; i++)
  { int tempI = owner.RootsToIndices.IndicesRedundantShortRoots.elements[i];
    int tempI2= owner.RootsToIndices.getIndexDoubleOfARoot
      (owner.RootsToIndices.TheObjects[tempI]);
    if (tempI2!=-1)
      if (this->TheObjects[tempI2].Multiplicities.size>0)
        result++;
  }
  return result;
}

int partFraction::getSmallestNonZeroIndexGreaterThanOrEqualTo(partFractions& owner, int minIndex)
{ int result=owner.RootsToIndices.size;
  for (int i=0; i<this->IndicesNonZeroMults.size; i++)
  { int tempI=this->IndicesNonZeroMults.TheObjects[i];
    if (this->TheObjects[tempI].Multiplicities.size>0)
      if (tempI>=minIndex && tempI<result)
        result=tempI;
  }
  return result;
}

int partFraction::ComputeGainingMultiplicityIndexInLinearRelation(partFractions& owner,  MatrixLargeRational& theLinearRelation)
{ int DesireToSelectAsGainingMultiplicity=-1;
  int result=-1;
  for( int i=0; i<theLinearRelation.NumRows; i++)
  { if(! theLinearRelation.elements[i][0].IsEqualToZero())
    { int currentIndex= this->IndicesNonZeroMults.TheObjects[i];
      int candidateDesire;
      if (!owner.flagUsingOrlikSolomonBasis)
        candidateDesire=this->TheObjects[currentIndex].GetTotalMultiplicity();
      else
        candidateDesire= currentIndex;
      if (candidateDesire<0)
        candidateDesire=-candidateDesire;
      if (result==-1 || DesireToSelectAsGainingMultiplicity<candidateDesire)
      {  result=i;
        DesireToSelectAsGainingMultiplicity = candidateDesire;
      }
    }
  }
  return result;
}

bool partFraction::CheckForOrlikSolomonAdmissibility(List<int>& theSelectedIndices)
{ return true;
  /*if (!this->flagUsingPrecomputedOrlikSolomonBases)
    return true;
  else
    return true; */
}

bool partFraction::DecomposeFromLinRelation(MatrixLargeRational& theLinearRelation, partFractions& Accum, GlobalVariables& theGlobalVariables, root* Indicator)
{//  theLinearRelation.ComputeDebugString();
  //theLinearRelation.ComputeDebugString();
  int GainingMultiplicityIndexInLinRelation=-1;
  int GainingMultiplicityIndex=-1;
  int ElongationGainingMultiplicityIndex=-1;
  List<int> ParticipatingIndices;
  List<int> theGreatestElongations;
  List<int> theCoefficients;
  Rational oldCheckSum;
  ParticipatingIndices.size=0;
  theCoefficients.size=0;
  theGreatestElongations.size=0;
  GainingMultiplicityIndexInLinRelation =this->ComputeGainingMultiplicityIndexInLinearRelation(Accum, theLinearRelation);
  GainingMultiplicityIndex= this->IndicesNonZeroMults.TheObjects[GainingMultiplicityIndexInLinRelation];
  int tempI=this->TheObjects[GainingMultiplicityIndex].GetLargestElongation();
  theLinearRelation.elements[GainingMultiplicityIndexInLinRelation][0].MultiplyByInt(tempI);
  //theLinearRelation.ComputeDebugString();
  theLinearRelation.ScaleToIntegralForMinRationalHeightNoSignChange();
  if (this->flagAnErrorHasOccurredTimeToPanic)
    theLinearRelation.ComputeDebugString();
  ElongationGainingMultiplicityIndex =theLinearRelation.elements[GainingMultiplicityIndexInLinRelation][0].NumShort;
  if (ElongationGainingMultiplicityIndex<0)
    ElongationGainingMultiplicityIndex=-ElongationGainingMultiplicityIndex;
  else
    theLinearRelation.MultiplyByInt(-1);
  //theLinearRelation.ComputeDebugString();
  for (int i=0; i<theLinearRelation.NumRows; i++)
    if (i!=GainingMultiplicityIndexInLinRelation && !theLinearRelation.elements[i][0].IsEqualToZero())
    { int tempI=this->IndicesNonZeroMults.TheObjects[i];
      ParticipatingIndices.AddObjectOnTop(tempI);
      theGreatestElongations.AddObjectOnTop(this->TheObjects[tempI].GetLargestElongation());
      theCoefficients.AddObjectOnTop(theLinearRelation.elements[i][0].NumShort);
    }
  if (!Accum.flagUsingOrlikSolomonBasis)
    this->LastDistinguishedIndex=GainingMultiplicityIndex;
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    this->ComputeDebugString(Accum, theGlobalVariables);
  //if (this->MakingConsistencyCheck)
  //{ this->ComputeOneCheckSum(this->CheckSum2);
  //}
  //if (!this->CheckForOrlikSolomonAdmissibility(ParticipatingIndices))
  //  return false;
  this->ApplyGeneralizedSzenesVergneFormula(ParticipatingIndices, theGreatestElongations, theCoefficients, GainingMultiplicityIndex, ElongationGainingMultiplicityIndex, Accum, theGlobalVariables, Indicator);
  //if (this->MakingConsistencyCheck)
  //{ assert(this->CheckSum2.IsEqualTo(this->CheckSum));
  //}
  /*if (partFraction::flagAnErrorHasOccurredTimeToPanic)
  { Rational tempRat2, tempRat;
    std::string tempS1, tempS2;
    Accum.ComputeOneCheckSum(tempRat2);
    this->ComputeOneCheckSum(tempRat);
    tempRat.ElementToString(tempS1);
    this->CheckSum2.ElementToString(tempS2);
    tempRat2.Subtract(tempRat);
    assert(oldCheckSum.IsEqualTo(tempRat2));
  }*/
  //Accum.ComputeDebugString();
  return true;
}

void partFraction::AttemptReduction(partFractions& owner, int myIndex, GlobalVariables& theGlobalVariables, root* Indicator)
{ bool hasImprovement=true;
  bool improvedAtLeastOnce=false;
  if (this->flagAnErrorHasOccurredTimeToPanic)
    this->ComputeDebugString(owner, theGlobalVariables);
  partFraction tempFrac;
  IntegerPoly numerator;
  IntegerPoly tempP1, tempP2, tempP3;
  numerator.AssignPolynomialLight(this->Coefficient);
  tempFrac.Assign(*this);
  while (hasImprovement)
  { hasImprovement=false;
    numerator.ComputeDebugString();
    for (int i=0; i<tempFrac.IndicesNonZeroMults.size; i++)
      for (int j=0; j<tempFrac.TheObjects[IndicesNonZeroMults.TheObjects[i]].Multiplicities.size; j++)
      { tempFrac.TheObjects[IndicesNonZeroMults.TheObjects[i]].GetPolyDenominator(tempP1, j, owner.RootsToIndices.TheObjects[IndicesNonZeroMults.TheObjects[i]]);
        tempP1.ComputeDebugString();
        numerator.DivideBy(tempP1, tempP2, tempP3);
        tempP2.ComputeDebugString();
        tempP3.ComputeDebugString();
        if (tempP3.IsEqualToZero())
        {  tempFrac.DecreasePowerOneFrac(IndicesNonZeroMults.TheObjects[i], 1);
          numerator.Assign(tempP2);
          hasImprovement=true;
          improvedAtLeastOnce=true;
        }
      }
  }
  if (improvedAtLeastOnce)
  { if (this->flagAnErrorHasOccurredTimeToPanic)
    {//  owner.CompareCheckSums();
      owner.ComputeDebugString(theGlobalVariables);
    }
    owner.PopIndexHashChooseSwapByLowestNonProcessedAndAccount(myIndex, theGlobalVariables, Indicator);
    tempFrac.Coefficient.AssignPolynomial(numerator);
    owner.AddAndReduce(tempFrac, theGlobalVariables, Indicator);
    if (this->flagAnErrorHasOccurredTimeToPanic)
    {  //owner.CompareCheckSums();
      owner.ComputeDebugString(theGlobalVariables);
    }
  }
}

void partFraction::GetNElongationPolyWithMonomialContribution(partFractions& owner, List<int>& theSelectedIndices, List<int>& theCoefficients, List<int>& theGreatestElongations, int theIndex, IntegerPoly& output, int theDimension)
{ static Monomial<Integer> tempM;
  static IntegerPoly tempP;
  tempM.init((int)theDimension);
  tempM.Coefficient.value=1;
  for (int i=0; i<theIndex; i++)
  { int tempI= theSelectedIndices.TheObjects[i];
    for (int j=0; j<theDimension; j++)
      tempM.degrees[j]+=(int)(theCoefficients.TheObjects[i] *theGreatestElongations.TheObjects[i]*owner.RootsToIndices.TheObjects[tempI].TheObjects[j]);
  }
  this->GetNElongationPoly(owner, theSelectedIndices.TheObjects[theIndex], theGreatestElongations.TheObjects[theIndex], theCoefficients.TheObjects[theIndex], output, theDimension);
  output.MultiplyByMonomial(tempM);
}

void partFraction::ApplyGeneralizedSzenesVergneFormula(List<int>& theSelectedIndices, List<int>& theGreatestElongations, List<int>& theCoefficients, int GainingMultiplicityIndex, int ElongationGainingMultiplicityIndex, partFractions& Accum, GlobalVariables& theGlobalVariables, root* Indicator)
{ partFraction tempFrac; tempFrac.RelevanceIsComputed=false;
  IntegerPoly tempP;
  PolyPartFractionNumerator tempNum;
  IntegerPoly ComputationalBufferCoefficient;
  PolyPartFractionNumerator ComputationalBufferCoefficientNonExpanded;
  //this->lastApplicationOfSVformulaNumNewGenerators=0;
  //this->lastApplicationOfSVformulaNumNewMonomials=0;
  if (this->flagAnErrorHasOccurredTimeToPanic)
    this->ComputeDebugString(Accum, theGlobalVariables);
  Rational StartCheckSum, theDiff;
  if (this->flagAnErrorHasOccurredTimeToPanic)
  { Accum.ComputeOneCheckSum(StartCheckSum, theGlobalVariables);
    this->ComputeOneCheckSum(Accum, theDiff, Accum.AmbientDimension, theGlobalVariables);
  }
  SelectionWithDifferentMaxMultiplicities TheBigBadIndexingSet;
  TheBigBadIndexingSet.initIncomplete(theSelectedIndices.size);
  int TotalMultiplicity;
  TotalMultiplicity=0;
  for (int i=0; i<theSelectedIndices.size; i++)
  { int tempI= this->TheObjects[theSelectedIndices.TheObjects[i]].GetMultiplicityLargestElongation()-1;
    TheBigBadIndexingSet.MaxMultiplicities.TheObjects[i]=tempI;
    TotalMultiplicity+=tempI;
  }
  for (int i=0; i<theSelectedIndices.size; i++)
  { TheBigBadIndexingSet.clearNoMaxMultiplicitiesChange();
    int oldMaxMultiplicity= TheBigBadIndexingSet.MaxMultiplicities.TheObjects[i];
    TheBigBadIndexingSet.MaxMultiplicities.TheObjects[i]=0;
    int NumSubsets=TheBigBadIndexingSet.getTotalNumSubsets();
    for (int j=0; j<NumSubsets; j++)
    { tempFrac.Assign(*this);
      tempFrac.RelevanceIsComputed=false;
      if (this->UncoveringBrackets)
        ComputationalBufferCoefficient.AssignPolynomialLight(tempFrac.Coefficient);
      else
        tempFrac.CoefficientNonExpanded.ComputePolyPartFractionNumerator(ComputationalBufferCoefficientNonExpanded, Accum.AmbientDimension);
      int tempN= TheBigBadIndexingSet.TotalMultiplicity()+oldMaxMultiplicity;
      if (this->flagAnErrorHasOccurredTimeToPanic)
        TheBigBadIndexingSet.ComputeDebugString();
      for (int k=0; k<theSelectedIndices.size; k++)
      { int multiplicityChange;
        if (k!=i)
          multiplicityChange= TheBigBadIndexingSet.Multiplicities.TheObjects[k];
        else
          multiplicityChange= oldMaxMultiplicity+1;
        tempFrac.TheObjects[theSelectedIndices.TheObjects[k]].AddMultiplicity(-multiplicityChange , theGreatestElongations.TheObjects[k]);
        if (this->UncoveringBrackets)
        { this->GetNElongationPolyWithMonomialContribution(Accum, theSelectedIndices, theCoefficients, theGreatestElongations, k, tempP, Accum.AmbientDimension);
          if (this->flagAnErrorHasOccurredTimeToPanic)
            tempP.ComputeDebugString();
          tempP.RaiseToPower(multiplicityChange, IOne);
          if (this->flagAnErrorHasOccurredTimeToPanic)
            tempP.ComputeDebugString();
          ComputationalBufferCoefficient.MultiplyBy(tempP);
          Integer tempInt;
          int tempI;
          if (k==i) tempI = oldMaxMultiplicity; else tempI=multiplicityChange;
          tempInt.value=MathRoutines::NChooseK(tempN, tempI);
          ComputationalBufferCoefficient.TimesConstant(tempInt);
          tempN-=tempI;
          if (this->flagAnErrorHasOccurredTimeToPanic)
            tempFrac.ComputeDebugString(Accum, theGlobalVariables);
        }else
        {}
      }
      if (this->UncoveringBrackets)
        tempFrac.Coefficient.AssignPolynomial(ComputationalBufferCoefficient);
      else
        {}
      if (this->flagAnErrorHasOccurredTimeToPanic)
        tempFrac.ComputeDebugString(Accum, theGlobalVariables);
      tempFrac.TheObjects[GainingMultiplicityIndex].AddMultiplicity(TheBigBadIndexingSet.TotalMultiplicity()+oldMaxMultiplicity+1, ElongationGainingMultiplicityIndex);
      if (this->flagAnErrorHasOccurredTimeToPanic)
        tempFrac.ComputeDebugString(Accum, theGlobalVariables);
      tempFrac.ComputeIndicesNonZeroMults();
      Accum.AddAndReduce(tempFrac, theGlobalVariables, Indicator);
      if (this->flagAnErrorHasOccurredTimeToPanic)
        Accum.ComputeDebugString(theGlobalVariables);
      TheBigBadIndexingSet.IncrementSubset();
    }
    TheBigBadIndexingSet.MaxMultiplicities.TheObjects[i]= oldMaxMultiplicity;
  }
  if (this->flagAnErrorHasOccurredTimeToPanic)
  { Rational tempRat;
    Accum.ComputeOneCheckSum(tempRat, theGlobalVariables);
    tempRat.Subtract(theDiff);
    assert(tempRat.IsEqualTo(StartCheckSum));
  }
}

void partFraction::ApplySzenesVergneFormula(List<int>& theSelectedIndices, List<int>& theElongations, int GainingMultiplicityIndex, int ElongationGainingMultiplicityIndex, partFractions& Accum, GlobalVariables& theGlobalVariables, root* Indicator)
{ static partFraction tempFrac; tempFrac.RelevanceIsComputed=false;
  static IntegerPoly tempP;
  static PolyPartFractionNumerator tempNum;
  static IntegerPoly ComputationalBufferCoefficient;
  static PolyPartFractionNumerator ComputationalBufferCoefficientNonExpanded;
  //this->lastApplicationOfSVformulaNumNewGenerators=0;
  //this->lastApplicationOfSVformulaNumNewMonomials=0;
  Rational StartCheckSum, theDiff;
  if (this->flagAnErrorHasOccurredTimeToPanic)
  { Accum.ComputeOneCheckSum(StartCheckSum, theGlobalVariables);
    this->ComputeOneCheckSum(Accum, theDiff, Accum.AmbientDimension, theGlobalVariables);
  }
  for(int i=0; i<theSelectedIndices.size; i++)
  { tempFrac.Assign(*this);
    tempFrac.RelevanceIsComputed=false;
    ComputationalBufferCoefficient.AssignPolynomialLight(tempFrac.Coefficient);
    tempFrac.CoefficientNonExpanded.ComputePolyPartFractionNumerator(ComputationalBufferCoefficientNonExpanded, Accum.AmbientDimension);
    tempFrac.TheObjects[GainingMultiplicityIndex].AddMultiplicity(1, ElongationGainingMultiplicityIndex);
    oneFracWithMultiplicitiesAndElongations& currentFrac=tempFrac.TheObjects[theSelectedIndices.TheObjects[i]];
    int LargestElongation= currentFrac.GetLargestElongation();
    currentFrac.AddMultiplicity(-1, LargestElongation);
    static Monomial<Integer> tempM;
    if (this->UncoveringBrackets)
    { tempM.init((int)Accum.AmbientDimension);
      tempM.Coefficient.Assign(IOne);
      for (int j=0; j<i; j++)
      { int tempElongation=(int) this->TheObjects[theSelectedIndices.TheObjects[j]].GetLargestElongation();
        for (int k=0; k<Accum.AmbientDimension; k++)
          tempM.degrees[k]+=(int)theElongations.TheObjects[j]*tempElongation*(int)Accum.RootsToIndices.TheObjects[theSelectedIndices.TheObjects[j]].TheObjects[k];
      }
      ParallelComputing::SafePoint();
      ComputationalBufferCoefficient.MultiplyByMonomial(tempM);
      this->GetNElongationPoly(Accum, theSelectedIndices.TheObjects[i], LargestElongation, theElongations.TheObjects[i], tempP, Accum.AmbientDimension);
      ComputationalBufferCoefficient.MultiplyBy(tempP);
      tempFrac.Coefficient.AssignPolynomial(ComputationalBufferCoefficient);
    }
    else
    { static ::MonomialInCommutativeAlgebra<Integer, GeneratorsPartialFractionAlgebra, GeneratorPFAlgebraRecord> tempM;
//      if (this->flagAnErrorHasOccurredTimeToPanic)
//      {  this->ComputeDebugString();
//      }
      tempM.Coefficient.Assign(IOne);
      tempM.ClearTheObjects();
      for (int j=0; j<i; j++)
      { int tempElongation=(int) this->TheObjects[theSelectedIndices.TheObjects[j]].GetLargestElongation();
        intRoot tempRoot;
        tempRoot= Accum.RootsToIndices.TheObjects[theSelectedIndices.TheObjects[j]];
        tempRoot.MultiplyByInteger(theElongations.TheObjects[j]*tempElongation);
        static ::MonomialInCommutativeAlgebra<Integer, GeneratorsPartialFractionAlgebra, GeneratorPFAlgebraRecord> tempM2;
        GeneratorsPartialFractionAlgebra::GetMonomialFromExponentAndElongation(tempRoot, 0, tempM2);
        tempM.MultiplyBy(tempM2);
      }
      ParallelComputing::SafePoint();
      if (theElongations.TheObjects[i]!=1)
      { static intRoot tempRoot;
        tempRoot=Accum.RootsToIndices.TheObjects[theSelectedIndices.TheObjects[i]];
        tempRoot.MultiplyByInteger( LargestElongation);
        static ::MonomialInCommutativeAlgebra<Integer, GeneratorsPartialFractionAlgebra, GeneratorPFAlgebraRecord> tempM2;
        GeneratorsPartialFractionAlgebra::GetMonomialFromExponentAndElongation(tempRoot, theElongations.TheObjects[i], tempM2);
        //tempM2.ComputeDebugString(PolyFormatLocal);
        //tempM.ComputeDebugString(PolyFormatLocal);
        tempM.MultiplyBy(tempM2);
        //tempM.ComputeDebugString(PolyFormatLocal);
      }
      //tempFrac.CoefficientNonExpanded.ComputeDebugString();
      ComputationalBufferCoefficientNonExpanded.MultiplyByMonomial(tempM);
      tempFrac.CoefficientNonExpanded.AssignPolyPartFractionNumerator(ComputationalBufferCoefficientNonExpanded);
      //tempFrac.CoefficientNonExpanded.ComputeDebugString();
    }
    tempFrac.ComputeIndicesNonZeroMults();
    Accum.AddAndReduce(tempFrac, theGlobalVariables, Indicator);
//    this->lastApplicationOfSVformulaNumNewMonomials+=tempFrac.GetNumMonomialsInNumerator();
//    this->lastApplicationOfSVformulaNumNewGenerators+=tempFrac.CoefficientNonExpanded.NumGeneratorsUsed();
  }
  //if (this->flagAnErrorHasOccurredTimeToPanic)
  //{ assert(this->CheckSum.IsEqualTo(this->CheckSum2));
  //}
  if (this->flagAnErrorHasOccurredTimeToPanic)
  { Rational tempRat;
    Accum.ComputeOneCheckSum(tempRat, theGlobalVariables);
    tempRat.Subtract(theDiff);
    assert(tempRat.IsEqualTo(StartCheckSum));
  }
  //this->Coefficient.AssignPolynomial(ComputationalBufferCoefficient);
}

//void partFraction::GetNElongationPoly

void partFraction::decomposeAMinusNB(int indexA, int indexB, int n, int indexAminusNB, partFractions& Accum, GlobalVariables& theGlobalVariables, root* Indicator)
{ static partFraction tempFrac; tempFrac.RelevanceIsComputed=false;
  static IntegerPoly AminusNbetaPoly;
  static IntegerPoly ComputationalBufferCoefficient;
  this->GetAlphaMinusNBetaPoly(Accum, indexA, indexB, n, AminusNbetaPoly, Accum.AmbientDimension);
  int powerA= this->TheObjects[indexA].Multiplicities.TheObjects[0];
  int powerB= this->TheObjects[indexB].Multiplicities.TheObjects[0];
  this->PrepareFraction(indexA, indexB, indexAminusNB, true, tempFrac, AminusNbetaPoly);
  ComputationalBufferCoefficient.AssignPolynomialLight(tempFrac.Coefficient);
  for (int i=powerB; i>=1; i--)
  { Integer tempInt(MathRoutines::NChooseK(powerA+powerB-i-1, powerA-1));
    ComputationalBufferCoefficient.TimesConstant(tempInt);
    tempFrac.Coefficient.AssignPolynomial(ComputationalBufferCoefficient);
    Accum.AddAlreadyReduced(tempFrac, theGlobalVariables, Indicator);
    ComputationalBufferCoefficient.DivideByConstant(tempInt);
//    Accum.ComputeDebugString();
    if (i>1)
    { tempFrac.TheObjects[indexAminusNB].AddMultiplicity(1, 1);
      tempFrac.TheObjects[indexB].AddMultiplicity(-1, 1);
      ComputationalBufferCoefficient.MultiplyBy(AminusNbetaPoly);
  //    tempFrac.ComputeDebugString();
    }
  }
  this->PrepareFraction(indexA, indexB, indexAminusNB, false, tempFrac, AminusNbetaPoly);
//  tempFrac.ComputeDebugString();
  ComputationalBufferCoefficient.AssignPolynomialLight(tempFrac.Coefficient);
  for (int i=powerA; i>=1; i--)
  {  Integer tempInt(MathRoutines::NChooseK(powerA+powerB-i-1, powerB-1));
    ComputationalBufferCoefficient.TimesConstant(tempInt);
    tempFrac.Coefficient.AssignPolynomial(ComputationalBufferCoefficient);
    Accum.AddAlreadyReduced(tempFrac, theGlobalVariables, Indicator);
    ComputationalBufferCoefficient.DivideByConstant(tempInt);
//    Accum.ComputeDebugString();
    if (i>1)
    {  tempFrac.TheObjects[indexAminusNB].AddMultiplicity(1, 1); ;
      tempFrac.TheObjects[indexA].AddMultiplicity(-1, 1); ;
//      tempFrac.ComputeDebugString();
    }
  }
//  Accum.ComputeDebugString();
}

bool partFraction::DecreasePowerOneFrac(int index, int increment)
{ this->TheObjects[index].AddMultiplicity(-increment, 1);
  this->ComputeIndicesNonZeroMults();
  return true;
}

void partFraction::ComputeIndicesNonZeroMults()
{ this->IndicesNonZeroMults.size=0;
  for (int i=0; i<this->size; i++)
    if(this->TheObjects[i].Multiplicities.size>0)
      this->IndicesNonZeroMults.AddObjectOnTop(i);
}

void partFraction::GetAlphaMinusNBetaPoly(partFractions& owner, int indexA, int indexB, int n, IntegerPoly& output, int theDimension)
{ output.Nullify((int)theDimension);
  Monomial<Integer> tempM;
  tempM.init((int)theDimension);
  tempM.Coefficient.Assign(IMOne);
  for (int i=0; i<n; i++)
  { for (int j=0; j<theDimension; j++)
      tempM.degrees[j]= (int)(owner.RootsToIndices.TheObjects[indexA].TheObjects[j]- (i+1)*owner.RootsToIndices.TheObjects[indexB].TheObjects[j]);
    output.AddMonomial(tempM);
  }
}

void partFraction::GetNElongationPoly(partFractions& owner, int index, int baseElongation, int LengthOfGeometricSeries, IntegerPoly& output, int theDimension)
{ output.Nullify((int)theDimension);
  Monomial<Integer> tempM;
  tempM.init((int)theDimension);
  if (LengthOfGeometricSeries>0)
  { tempM.Coefficient.Assign(IOne);
    for (int i=0; i<LengthOfGeometricSeries; i++)
    { for (int j=0; j<theDimension; j++)
        tempM.degrees[j]=(int)(baseElongation*i*owner.RootsToIndices.TheObjects[index].TheObjects[j]);
      output.AddMonomial(tempM);
    }
  }
  else
  { assert(LengthOfGeometricSeries<0);
    tempM.Coefficient.Assign(IMOne);
    for (int i=-1; i>=LengthOfGeometricSeries; i--)
    { for (int j=0; j<theDimension; j++)
        tempM.degrees[j]=int(baseElongation*i*owner.RootsToIndices.TheObjects[index].TheObjects[j]);
      output.AddMonomial(tempM);
    }
  }
  //output.ComputeDebugString();
}

void partFraction::GetNElongationPoly(partFractions& owner, int index, int baseElongation, int LengthOfGeometricSeries, PolyPartFractionNumerator& output, int theDimension)
{ MonomialInCommutativeAlgebra<Integer, ::GeneratorsPartialFractionAlgebra, GeneratorPFAlgebraRecord> tempM;
  assert(LengthOfGeometricSeries!=0);
  intRoot tempRoot;
  tempRoot= owner.RootsToIndices.TheObjects[index];
  tempRoot.MultiplyByInteger(baseElongation);
  ::GeneratorsPartialFractionAlgebra::GetMonomialFromExponentAndElongation(tempRoot, LengthOfGeometricSeries, tempM);
  output.Nullify((int)theDimension);
  output.AddMonomial(tempM);
}

void partFraction::partFractionToPartitionFunctionSplit(partFractions& owner, QuasiPolynomialOld& output, bool RecordNumMonomials, bool StoreToFile, GlobalVariables& theGlobalVariables, int theDimension)
{ static PolynomialRationalCoeff shiftedPoly, tempP;
  static roots normals;
  static partFractionPolynomials tempSplitPowerSeriesCoefficient;
  static partFractionPolynomials* SplitPowerSeriesCoefficient;
  if (partFraction::MakingConsistencyCheck)
  { partFraction::CheckSum.MakeZero();
  }
  if (this->FileStoragePosition!=-1)
  { partFraction::TheBigDump.seekg(this->FileStoragePosition);
    output.ReadFromFile(partFraction::TheBigDump, (int)theDimension);
    if (RecordNumMonomials && ! this->AlreadyAccountedForInGUIDisplay)
    { this->AlreadyAccountedForInGUIDisplay=true;
      partFractions::NumProcessedForVPFMonomialsTotal+=this->Coefficient.size;
      //theGlobalVariables.theIndicatorVariables.NumProcessedMonomials+=this->Coefficient.size;
    }
//    output.ComputeDebugString();
    return;
  }
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    this->ComputeDebugString(owner, theGlobalVariables);
  /*if(RecordSplitPowerSeriesCoefficient)
  { SplitPowerSeriesCoefficient= &this->SplitPowerSeriesCoefficients;
  }
  else*/
  { SplitPowerSeriesCoefficient= &tempSplitPowerSeriesCoefficient;
  }
  SplitPowerSeriesCoefficient->initLatticeIndicatorsFromPartFraction(owner, *this, theGlobalVariables, theDimension);
//  SplitPowerSeriesCoefficient->InvertedMatrixRoots.ComputeDebugString();
  normals.AssignMatrixRows(SplitPowerSeriesCoefficient->theNormals);
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
  { this->ComputeDebugString(owner, theGlobalVariables);
    normals.ComputeDebugString();
    Stop();
  }
  for (int i=0; i<this->Coefficient.size; i++)
  { this->ComputePolyCorrespondingToOneMonomial(shiftedPoly, i, normals, SplitPowerSeriesCoefficient, theDimension);
    if (RecordNumMonomials)
    { std::stringstream out4, out3;
      out4 <<"Current fraction: "<<i+1<<" out of "<<this->Coefficient.size <<" processed";
      partFractions::NumProcessedForVPFMonomialsTotal++;
      out3  <<" Processed " << partFractions::NumProcessedForVPFMonomialsTotal <<" out of " <<partFractions::NumMonomialsInNumeratorsRelevantFractions << " relevant monomials";
      theGlobalVariables.theIndicatorVariables.ProgressReportString4= out4.str();
      theGlobalVariables.theIndicatorVariables.ProgressReportString3= out3.str();
      theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
    }
  }
  SplitPowerSeriesCoefficient->ComputeQuasiPolynomial(output, RecordNumMonomials, theDimension, theGlobalVariables);
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
  { Stop();
  }
  if (partFraction::MakingConsistencyCheck)
  { Rational tempLRat;
    output.Evaluate(partFraction::theVectorToBePartitioned, tempLRat);
    assert(tempLRat.DenShort==1);
    assert(tempLRat.IsEqualTo(partFraction::CheckSum));
  }
  if (StoreToFile)
  { this->FileStoragePosition= partFraction::TheBigDump.tellp();
    output.WriteToFile(partFraction::TheBigDump);
    partFractions::ComputedContributionsList.flush();
  }

//  Accum.ComputeDebugString();
}

void partFraction::ComputePolyCorrespondingToOneMonomial(PolynomialRationalCoeff& output, int index, roots& normals, partFractionPolynomials* SplitPowerSeriesCoefficient, int theDimension)
{ root shiftRational; shiftRational.SetSize(theDimension);
  static PolynomialRationalCoeff tempP;
  for (int j=0; j<theDimension; j++)
    shiftRational.TheObjects[j].AssignInteger(this->Coefficient.TheObjects[index].degrees[j]);
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
  { shiftRational.ComputeDebugString();
    this->Coefficient.ComputeDebugString();
    normals.ComputeDebugString();
  }
  Rational tempRat;
  tempRat.AssignInteger(this->Coefficient.TheObjects[index].Coefficient.value);
  output.MakeNVarConst((int)theDimension, tempRat);
  for (int i=0; i<theDimension; i++)
  { static root beta; beta.SetSize(theDimension);
    static Rational tempRat, tempRat2;
    if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    { normals.ComputeDebugString();
    }
    this->MakePolynomialFromOneNormal(normals.TheObjects[i], shiftRational, this->TheObjects[this->IndicesNonZeroMults.TheObjects[i]].Multiplicities.TheObjects[0], tempP);
    if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    { normals.ComputeDebugString();
    }
    output.MultiplyBy(tempP);
    if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    { tempP.ComputeDebugString();
      output.ComputeDebugString();
    }
  }
  //  output.ComputeDebugString();
  SplitPowerSeriesCoefficient->AddPolynomialLargeRational(shiftRational, output);
  this->AlreadyAccountedForInGUIDisplay=true;
}

void partFraction::MakePolynomialFromOneNormal(root& normal, root& shiftRational, int theMult, PolynomialRationalCoeff& output)
{ Rational tempRat, tempRat2;
  static PolynomialRationalCoeff tempP;
  int theDimension= normal.size;
  output.MakeNVarConst((int)theDimension, LROne);
  if (theMult==1)
    return;
  root::RootScalarEuclideanRoot(normal, shiftRational, tempRat);
  for (int j=0; j<theMult-1; j++)
  { tempP.MakeLinPolyFromRoot(normal);
    if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    { tempP.ComputeDebugString();
    }
    tempRat2.AssignNumeratorAndDenominator(-1, j+1);
    tempRat2.MultiplyBy(tempRat);
    tempRat2+=(LROne);
    Rational tempRat3;
    tempRat3.AssignNumeratorAndDenominator(1, j+1);
    tempP.TimesConstant(tempRat3);
    if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    { tempP.ComputeDebugString(); }
    tempP.AddConstant(tempRat2);
    if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    { tempP.ComputeDebugString(); }
    output.MultiplyBy(tempP);
    if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    { output.ComputeDebugString(); }
  }
}

void partFraction::ComputeNormals(partFractions& owner, roots& output, int theDimension, GlobalVariables& theGlobalVariables)
{ static roots dens;
  root tempRoot; tempRoot.SetSize(theDimension);
  dens.size=0;
  output.size=0;
  for (int i=0; i<theDimension; i++)
  { tempRoot.AssignIntRoot(owner.RootsToIndices.TheObjects[this->IndicesNonZeroMults.TheObjects[i]]);
    dens.AddRoot(tempRoot);
  }
  for (int i=0; i<theDimension; i++)
  { static Rational tempRat, tempRat2;
    dens.ComputeNormalExcludingIndex(tempRoot, i, theGlobalVariables);
    root::RootScalarEuclideanRoot(tempRoot, dens.TheObjects[i], tempRat);
    assert(!tempRat.IsEqualToZero());
    tempRoot.DivByLargeRational(tempRat);
    output.AddRoot(tempRoot);
//    tempRoot.ComputeDebugString();
  }
}

partFraction::partFraction()
{//  this->init(partFraction::RootsToIndices.size);
  this->PowerSeriesCoefficientIsComputed=false;
  this->AlreadyAccountedForInGUIDisplay=false;
  this->FileStoragePosition=-1;
  this->LastDistinguishedIndex=-1;
  this->RelevanceIsComputed=false;
/*  if (partFraction::UseGlobalCollector)
  { partFraction::GlobalCollectorPartFraction.AddObject(this);
    this->indexInGlobalCollectorPartFraction=
      partFraction::GlobalCollectorPartFraction.size-1;
    if (this->indexInGlobalCollectorPartFraction==102)
    { Stop();
    }
  }*/
}

void partFraction::init(int numRoots)
{ this->IndicesNonZeroMults.MakeActualSizeAtLeastExpandOnTop(numRoots);
  this->IndicesNonZeroMults.size=0;
  this->SetSize(numRoots);
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].Elongations.SetSize(0);
    this->TheObjects[i].Multiplicities.SetSize(0);
  }
}

partFraction::~partFraction()
{ /*if (this->indexInGlobalCollectorPartFraction==102)
  { Stop();
  }*/
/*partFraction::GlobalCollectorPartFraction.
    TheObjects[this->indexInGlobalCollectorPartFraction]=0; */
}

bool partFraction::IsEqualToZero()
{ if (this->UncoveringBrackets)
    return this->Coefficient.IsEqualToZero();
  else
    return this->CoefficientNonExpanded.size==0;
}

int partFraction::HashFunction() const
{ int result=0;
  for (int i=0; i<this->size; i++)
    result+=SomeRandomPrimes[i]*this->TheObjects[i].HashFunction();
  return result;
}

bool partFraction::operator==(const partFraction& right)
{ if (this->size!= right.size)
    return false;
  for (int i=0; i<this->size; i++)
    if (! (this->TheObjects[i]==right.TheObjects[i]))
      return false;
/*  for(int i=0; i<root::AmbientDimension; i++)
  { if (this->RootShift[i]!=right.RootShift[i])
      return false;
  }*/
  return true;
}

void partFraction::operator =(const partFraction &right)
{ this->Assign(right);
}

int partFractions::SizeWithoutDebugString()
{ int Accum=0;
  Accum+=  this->HashedList<partFraction>::SizeWithoutObjects();
  for (int i=0; i<this->ActualSize; i++)
    Accum+=this->TheActualObjects[i].SizeWithoutDebugString();
  Accum+=  sizeof(this->HighestIndex)+sizeof(this->IndexLowestNonProcessed);
  return Accum;
}

bool partFractions::AssureIndicatorRegularity(GlobalVariables& theGlobalVariables, root& theIndicator)
{ roots tempRoots;
  tempRoots.AssignHashedIntRoots(this->RootsToIndices);
  if (theIndicator.IsEqualToZero())
  { tempRoots.average(theIndicator, this->AmbientDimension);
    theIndicator.MultiplyByInteger(tempRoots.size);
  }
  return  tempRoots.PerturbVectorToRegular(  theIndicator, theGlobalVariables, theIndicator.size);
}

void partFractions::UncoverBracketsNumerators(GlobalVariables& theGlobalVariables, root* Indicator)
{ if (partFraction::UncoveringBrackets)
    return;
  int changeOfNumMonomials=0;
  for (int i=0; i<this->size; i++)
  { if (this->flagMakingProgressReport)
    { std::stringstream out;
      out <<"Uncovering brackets"<< i+1 <<" out of " << this->size;
      theGlobalVariables.theIndicatorVariables.ProgressReportString4=out.str();
      changeOfNumMonomials-=this->TheObjects[i].Coefficient.size;
      theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
    }
    this->AccountPartFractionInternals(-1, i, Indicator, theGlobalVariables);
    this->TheObjects[i].UncoverBracketsNumerator(theGlobalVariables, this->AmbientDimension);
    this->AccountPartFractionInternals(1, i, Indicator, theGlobalVariables);
    if (this->flagMakingProgressReport)
    { changeOfNumMonomials+=this->TheObjects[i].Coefficient.size;
      std::stringstream out;
      out <<"Number actual monomials"<< changeOfNumMonomials;
      theGlobalVariables.theIndicatorVariables.ProgressReportString5=out.str();
      theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
    }
  }
}

bool partFractions::ShouldIgnore(GlobalVariables& theGlobalVariables, root* Indicator)
{ bool shouldIgnore=!this->TheObjects[this->IndexLowestNonProcessed].rootIsInFractionCone(*this, Indicator, theGlobalVariables);
  if (shouldIgnore)
  { if (this->flagDiscardingFractions)
      this->PopIndexSwapWithLastHash(this->IndexLowestNonProcessed);
    else
      this->IndexLowestNonProcessed++;
  }
  return shouldIgnore;
}

void partFractions::PrepareCheckSums(GlobalVariables& theGlobalVariables)
{//  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.InitFromIntegers(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
//  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.DivByInteger(4);
//  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.MultiplyByInteger(3);
  if (!this->flagUsingCheckSum)
    return;
  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.SetSize(12);
  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.TheObjects[0].AssignNumeratorAndDenominator(1, 2);
  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.TheObjects[1].AssignNumeratorAndDenominator(2, 3);
  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.TheObjects[2].AssignNumeratorAndDenominator(3, 4);
  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.TheObjects[3].AssignNumeratorAndDenominator(4, 5);
  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.TheObjects[4].AssignNumeratorAndDenominator(11, 13);
  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.TheObjects[5].AssignNumeratorAndDenominator(13, 17);
  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.TheObjects[6].AssignNumeratorAndDenominator(17, 19);
  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.TheObjects[7].AssignNumeratorAndDenominator(19, 23);
  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.TheObjects[8].AssignNumeratorAndDenominator(23, 29);
  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.TheObjects[9].AssignNumeratorAndDenominator(31, 37);
  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.TheObjects[10].AssignNumeratorAndDenominator(37, 41);
  ::oneFracWithMultiplicitiesAndElongations::CheckSumRoot.TheObjects[11].AssignNumeratorAndDenominator(41, 43);
  this->ComputeOneCheckSum(this->StartCheckSum, theGlobalVariables);
}

void partFractions::initFromOtherPartFractions(partFractions& input, GlobalVariables& theGlobalVariables)
{ this->RootsToIndices.CopyFromHash(input.RootsToIndices);
  this->IndexLowestNonProcessed=0;
  this->IndexCurrentlyProcessed=0;
  this->ClearHashes();
  this->AmbientDimension= input.AmbientDimension;
}

void partFractions::CompareCheckSums(GlobalVariables& theGlobalVariables)
{ if (!this->flagUsingCheckSum)
    return;
  if (!this->flagDiscardingFractions)
  { this->ComputeOneCheckSum(this->EndCheckSum, theGlobalVariables);
  //partFraction::MakingConsistencyCheck=true;
  /*if (partFraction::MakingConsistencyCheck)
  {  this->ComputeDebugString();
    tempRat2.ElementToString(tempS2);
    tempRat.ElementToString(tempS1);
  }*/
    if (!this->StartCheckSum.IsEqualTo(this->EndCheckSum) || this->flagAnErrorHasOccurredTimeToPanic)
    { std::string tempS1, tempS2;
      this->StartCheckSum.ElementToString(tempS1);
      this->EndCheckSum.ElementToString(tempS2);
      std::stringstream out1, out2;
      out1 << "Starting checksum: " << tempS1;
      out2 << "  Ending checksum: " << tempS2;
      theGlobalVariables.theIndicatorVariables.ProgressReportString1= out1.str();
      theGlobalVariables.theIndicatorVariables.ProgressReportString2=out2.str();
      theGlobalVariables.MakeReport();
    }
    assert(this->StartCheckSum.IsEqualTo(this->EndCheckSum));
#ifdef CGIversionLimitRAMuse
    if (!this->StartCheckSum.IsEqualTo(this->EndCheckSum))
    { std::cout<< "<b>Checksum partial fractions failed!!! </b> </BODY></HTML>";
      std::exit(0);
    }
    else
    { std::cout<< "Checksum successful";
      std::cout.flush();
    }
#endif
  }
}

void partFractions::PrepareIndicatorVariables()
{ this->NumberIrrelevantFractions=0;
  this->NumberRelevantReducedFractions=0;
  this->NumGeneratorsInTheNumerators=0;
  this->NumGeneratorsIrrelevantFractions=0;
  this->NumGeneratorsRelevenatFractions=0;
  this->NumMonomialsInNumeratorsIrrelevantFractions=0;
  this->NumMonomialsInNumeratorsRelevantFractions=0;
  this->NumMonomialsInTheNumerators=1;
  this->NumTotalReduced=0;
  this->NumRelevantNonReducedFractions=0;
  this->NumProcessedForVPFMonomialsTotal=0;
  this->NumProcessedForVPFfractions=0;
  this->NumRunsReduceMonomialByMonomial=0;
}

bool partFractions::splitPartial(GlobalVariables& theGlobalVariables, root* Indicator)
{ partFraction& tempFrac= theGlobalVariables.fracSplit1;
  partFraction tempF;
  std::string OldDebugString;
  int ProblemCounter=0;
  //Checksum code follows:
  std::string tempS1, tempS2;
//  this->ComputeDebugString();
//  partFraction::MakingConsistencyCheck=true;
  //if (Indicator!=0)
  //  this->AssureIndicatorRegularity(theGlobalVariables, *Indicator);
  //this->IndicatorRoot.MakeZero();
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
  { this->CheckSum.ElementToString(tempS1);
    this->ComputeDebugString(theGlobalVariables);
  }
  std::stringstream out; std::string tempS;
  while (this->IndexLowestNonProcessed<this->size )
  { if (this->SplitStepsCounter>= this->LimitSplittingSteps && this->LimitSplittingSteps>0)
    { this->SplitStepsCounter=0;
      return false;
    }
    //this->ComputeDebugString();
//    bool ShouldIgnore=false;
    this->IndexCurrentlyProcessed= this->IndexLowestNonProcessed;
    if (!this->ShouldIgnore(theGlobalVariables, Indicator))
    { if (partFraction::flagAnErrorHasOccurredTimeToPanic)
      { this->ElementToString(OldDebugString, theGlobalVariables);
      //  ProblemCounter++;
      //  if (ProblemCounter==14)
      //    Stop();
      }
      //tempF.Assign(this->TheObjects[this->IndexLowestNonProcessed]);
        tempFrac.Assign(this->TheObjects[this->IndexLowestNonProcessed]);
//      this->ComputeDebugString();
//      tempF.ComputeDebugString();
//      if (this->IndexLowestNonReduced==5 && this->size==9)
//      { partFraction::flagAnErrorHasOccurredTimeToPanic=true;
//        this->ComputeDebugString();
//      }
      bool tempBool;
      if (this->flagUsingOrlikSolomonBasis)
        tempBool=tempFrac.reduceOnceGeneralMethod(*this, theGlobalVariables, Indicator);
      else
        tempBool = tempFrac.reduceOnceGeneralMethodNoOSBasis(*this, theGlobalVariables, Indicator);
      if (! tempBool)
      { if (tempFrac.IndicesNonZeroMults.size<=this->AmbientDimension)
          this->IndexLowestNonProcessed++;
        else
          this->TheObjects[this->IndexLowestNonProcessed].LastDistinguishedIndex=tempFrac.LastDistinguishedIndex;
      }
      else
      {//  if (ProblemCounter==17)
        //  this->ComputeDebugString(theGlobalVariables); //        if (partFraction::flagAnErrorHasOccurredTimeToPanic)
        this->PopIndexHashChooseSwapByLowestNonProcessedAndAccount( this->IndexCurrentlyProcessed, theGlobalVariables, Indicator);
//        { this->ComputeDebugString();
//        }
      }
//      if (partFraction::MakingConsistencyCheck)
//      {  Rational tempRat2;
//        this->UncoverBracketsNumerators();
//        this->ComputeOneCheckSum(tempRat2);
//        if (!tempRat2.IsEqualTo(this->StartCheckSum))
//        {  this->ComputeDebugString();
//          tempRat2.ElementToString(tempS2);
//          assert(false);
//        }
//      }
    }
    if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    { ProblemCounter++;
      this->ComputeDebugString(theGlobalVariables);
      out << this->DebugString<< "\\\\ = \\\\";
      tempS= out.str();
      this->CompareCheckSums(theGlobalVariables);
    }
    this->MakeProgressReportSplittingMainPart(theGlobalVariables);
  //  this->ComputeDebugString();
//    x= this->SizeWithoutDebugString();
    this->SplitStepsCounter++;
  }
  this->SplitStepsCounter=0;
//  this->RemoveRedundantShortRootsClassicalRootSystem();
//  PolyFormatLocal.MakeAlphabetxi();
//  this->ComputeDebugString();
  //this->flagAnErrorHasOccurredTimeToPanic=true;
  if (this->flagAnErrorHasOccurredTimeToPanic)
  { this->ComputeDebugString(theGlobalVariables);
    this->CompareCheckSums(theGlobalVariables);
  }
  Rational tempRat2;
  /*if (partFraction::MakingConsistencyCheck)
  {  this->ComputeDebugString();
    this->ComputeOneCheckSum(tempRat2);
    tempRat2.ElementToString(tempS2);
    tempRat.ElementToString(tempS1);
    assert(tempRat2.IsEqualTo(tempRat));
  }  */
  return true;
}

bool partFractions::split(GlobalVariables& theGlobalVariables, root* Indicator)
{ //partFraction::flagAnErrorHasOccurredTimeToPanic=true;
  //this->flagAnErrorHasOccurredTimeToPanic=true;
  if (!this->flagInitialized)
  { this->IndexLowestNonProcessed=0;
    this->PrepareIndicatorVariables();
    this->PrepareCheckSums(theGlobalVariables);
    this->flagInitialized=true;
  }
  if (this->splitPartial(theGlobalVariables, Indicator))
  { //this->ComputeDebugString();
    this->RemoveRedundantShortRoots(theGlobalVariables, Indicator);
    //this->ComputeDebugString();
    this->UncoverBracketsNumerators(theGlobalVariables, Indicator);
    //partFraction::UncoveringBrackets=true;
    //this->ComputeDebugString();
    this->CompareCheckSums(theGlobalVariables);
    this->IndexLowestNonProcessed= this->size;
    this->MakeProgressReportSplittingMainPart(theGlobalVariables);
  }
  return false;
}

bool partFractions::splitClassicalRootSystem(bool ShouldElongate, GlobalVariables& theGlobalVariables, root* Indicator)
{ this->IndexLowestNonProcessed=0;
  this->PrepareIndicatorVariables();
  //partFraction::flagAnErrorHasOccurredTimeToPanic= true;
  //partFractions::flagAnErrorHasOccurredTimeToPanic= true;
  Rational::flagAnErrorHasOccurredTimeToPanic=true;
  this->PrepareCheckSums(theGlobalVariables);
  std::string tempS;
  this->CheckSum.ElementToString(tempS);
  // if IndicatorRoot is zero then the caller has forgotten
  // to set the flagUsingIndicatorRoot to false
  partFraction tempF;
  while (this->IndexLowestNonProcessed<this->size)
  { //this->ComputeDebugString();
    if (!this->ShouldIgnore(theGlobalVariables, Indicator))
    { tempF.Assign(this->TheObjects[this->IndexLowestNonProcessed]);
      //this->ComputeDebugString();
      //tempF.ComputeDebugString();
      if (! (tempF.reduceOnceTotalOrderMethod(*this, theGlobalVariables, Indicator)))
      { if (this->TheObjects[this->IndexLowestNonProcessed].IndicesNonZeroMults.size-this->TheObjects[this->IndexLowestNonProcessed].GetNumProportionalVectorsClassicalRootSystems(*this)>this->AmbientDimension)
        { this->TheObjects[this->IndexLowestNonProcessed].ComputeDebugString(*this, theGlobalVariables);
          this->NumRelevantNonReducedFractions++;
        }
        this->IndexLowestNonProcessed++;
      }
      else
        this->PopIndexHashChooseSwapByLowestNonProcessedAndAccount( this->IndexLowestNonProcessed, theGlobalVariables, Indicator);
      this->MakeProgressReportSplittingMainPart(theGlobalVariables);
    }
//    this->ComputeDebugString();
//    x= this->SizeWithoutDebugString();
  }
  //this->ComputeDebugString();
//  this->CompareCheckSums();
  if (ShouldElongate)
  {  this->RemoveRedundantShortRootsClassicalRootSystem(theGlobalVariables, Indicator);
//  this->ComputeDebugString();
  }
  this->CompareCheckSums(theGlobalVariables);
  this->IndexLowestNonProcessed= this->size;
  this->MakeProgressReportSplittingMainPart(theGlobalVariables);
  return this->CheckForMinimalityDecompositionWithRespectToRoot(Indicator, theGlobalVariables);
}

bool partFractions::CheckForMinimalityDecompositionWithRespectToRoot(root* theRoot, GlobalVariables& theGlobalVariables)
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].IndicesNonZeroMults.size>this->AmbientDimension)
      if (this->TheObjects[i].rootIsInFractionCone(*this, theRoot, theGlobalVariables))
      { this->TheObjects[i].ComputeDebugString(*this, theGlobalVariables);
        return false;
      }
  return true;
}

void partFraction::initFromRootSystem(partFractions& owner, intRoots& theFraction, intRoots& theAlgorithmBasis, intRoot* weights)
{ IntegerPoly ComputationalBufferCoefficient;
  PolyPartFractionNumerator ComputationalBufferCoefficientNonExpanded;
  if (theFraction.size==0)
    return;
  int theDimension = theFraction.TheObjects[0].size;
  ComputationalBufferCoefficient.MakeNVarConst((int)theDimension, IOne);
  this->Coefficient.AssignPolynomial(ComputationalBufferCoefficient);
  ComputationalBufferCoefficientNonExpanded.MakeNVarConst((int)theDimension, IOne);
  this->CoefficientNonExpanded.AssignPolyPartFractionNumerator(ComputationalBufferCoefficientNonExpanded);
  owner.RootsToIndices.initFromRoots(theAlgorithmBasis, weights);
  this->init(owner.RootsToIndices.size);
  for(int i=0; i<owner.RootsToIndices.size; i++)
    this->TheObjects[i].init();
  for (int i=0; i<theFraction.size; i++)
  { int index = owner.RootsToIndices.getIndex(theFraction.TheObjects[i]);
    this->TheObjects[index].AddMultiplicity(1, 1);
  }
  this->ComputeIndicesNonZeroMults();
}

void partFraction::initFromRoots(partFractions& owner, roots& input)
{ IntegerPoly ComputationalBufferCoefficient;
  PolyPartFractionNumerator ComputationalBufferCoefficientNonExpanded;
  if (input.size==0)
    return;
  int theDimension = input.TheObjects[0].size;
  ComputationalBufferCoefficient.MakeNVarConst((int)theDimension, IOne);
  this->Coefficient.AssignPolynomial(ComputationalBufferCoefficient);
  ComputationalBufferCoefficientNonExpanded.MakeNVarConst((int)theDimension, IOne);
  this->CoefficientNonExpanded.AssignPolyPartFractionNumerator(ComputationalBufferCoefficientNonExpanded);
  intRoots tempRoots;
  tempRoots.AssignRoots(input);
  owner.RootsToIndices.initFromRoots(tempRoots, 0);
  this->init(owner.RootsToIndices.size);
  for(int i=0; i<owner.RootsToIndices.size; i++)
    this->TheObjects[i].init();
  for (int i=0; i<input.size; i++)
  { int index = owner.RootsToIndices.getIndex(tempRoots.TheObjects[i]);
    this->TheObjects[index].AddMultiplicity(1, 1);
  }
  this->ComputeIndicesNonZeroMults();
}

int partFractions::ReadFromFileComputedContributions(std::fstream& input, GlobalVariables& theGlobalVariables)
{ std::string tempS;
  input.seekg(0);
  input >> tempS;
  int lastNonZero=-1;
  for (int i=0; i<this->size; i++)
  { int x;
    input >> x >> this->TheObjects[i].FileStoragePosition;
    if (this->TheObjects[i].FileStoragePosition>lastNonZero)
      lastNonZero=this->TheObjects[i].FileStoragePosition;
    assert(x==i);
  }
  this->LimitSplittingSteps=0;
  return lastNonZero;
}

void partFractions::WriteToFileComputedContributions(std::fstream& output, GlobalVariables&  theGlobalVariables)
{ output.seekp(0);
  output << "Partial_fraction_index/file_storage_position\n";
  for (int i=0; i<this->size; i++)
    output <<  i<< " " << this->TheObjects[i].FileStoragePosition << "\n";
}


partFractions::partFractions()
{ this->HighestIndex=-1;
  this->IndexLowestNonProcessed=-2;
  this->flagSplitTestModeNoNumerators=false;
  this->flagDiscardingFractions=false;
  this->flagUsingCheckSum=false;
  this->flagUsingOrlikSolomonBasis=false;
  this->flagInitialized=false;
  this->SplitStepsCounter=0;
  this->LimitSplittingSteps=0;
}

void partFraction::ComputeDebugString(partFractions& owner, GlobalVariables& theGlobalVariables)
{ this->ElementToString(owner, this->DebugString, PolynomialOutputFormat::UsingLatexFormat, false, true, theGlobalVariables);
}

void partFractions::PopIndexSwapLastHashAndAccount(int index, GlobalVariables& theGlobalVariables, root* Indicator)
{ this->AccountPartFractionInternals(-1, index, Indicator, theGlobalVariables);
  this->PopIndexSwapWithLastHash(index);
}

void partFractions::PopIndexHashChooseSwapByLowestNonProcessedAndAccount(int index, GlobalVariables& theGlobalVariables, root* Indicator)
{ this->AccountPartFractionInternals(-1, index, Indicator, theGlobalVariables);
  if (index>=this->IndexLowestNonProcessed)
    this->PopIndexSwapWithLastHash(index);
  else
  { assert(this->IndexLowestNonProcessed!=0);
    if (this->IndexLowestNonProcessed-1== this->IndexCurrentlyProcessed)
      this->IndexCurrentlyProcessed=index;
    this->SwapTwoIndicesHash(index, this->IndexLowestNonProcessed-1);
    this->PopIndexSwapWithLastHash(this->IndexLowestNonProcessed-1);
    this->IndexLowestNonProcessed--;
  }
}

void partFractions::AccountPartFractionInternals(int sign, int index, root* Indicator, GlobalVariables& theGlobalVariables)
{ partFraction& tempFrac= this->TheObjects[index];
  if (tempFrac.rootIsInFractionCone(*this, Indicator, theGlobalVariables ))
  { if (tempFrac.IndicesNonZeroMults.size<=this->AmbientDimension)
    { this->NumGeneratorsRelevenatFractions+=sign*(tempFrac.CoefficientNonExpanded.NumGeneratorsUsed());
      if (partFraction::UncoveringBrackets)
        this->NumMonomialsInNumeratorsRelevantFractions+=sign*(tempFrac.Coefficient.size);
      else
        this->NumMonomialsInNumeratorsRelevantFractions+=sign*tempFrac.CoefficientNonExpanded.size;
      this->NumTotalReduced+=sign;
      this->NumberRelevantReducedFractions+=sign;
    }
  }
  else
  { this->NumGeneratorsIrrelevantFractions+=sign*tempFrac.CoefficientNonExpanded.NumGeneratorsUsed();
    if (partFraction::UncoveringBrackets)
      this->NumMonomialsInNumeratorsIrrelevantFractions+=sign*tempFrac.Coefficient.size;
    else
      this->NumMonomialsInNumeratorsIrrelevantFractions+=sign*tempFrac.CoefficientNonExpanded.size;
    this->NumTotalReduced+=sign;
    this->NumberIrrelevantFractions+=sign;
  }
  this->NumGeneratorsInTheNumerators+=sign*tempFrac.CoefficientNonExpanded.NumGeneratorsUsed();
  if (partFraction::UncoveringBrackets)
    this->NumMonomialsInTheNumerators+=sign*tempFrac.Coefficient.size;
  else
    this->NumMonomialsInTheNumerators+=sign*tempFrac.CoefficientNonExpanded.size;
}

void partFraction::ReduceMonomialByMonomial(partFractions& owner, int myIndex, GlobalVariables& theGlobalVariables, root* Indicator)
{ partFraction tempFrac;
  //tempFrac.Assign(*this);
  Rational StartCheckSum, theDiff;
  int ProblemCounter=-1;
  if (this->flagAnErrorHasOccurredTimeToPanic)
  { owner.ComputeOneCheckSum(StartCheckSum, theGlobalVariables);
    this->ComputeOneCheckSum(owner, theDiff, owner.AmbientDimension, theGlobalVariables);
    this->ComputeDebugString(owner, theGlobalVariables);
    owner.NumRunsReduceMonomialByMonomial++;
    ProblemCounter=owner.NumRunsReduceMonomialByMonomial;
    if (ProblemCounter==8)
    { Stop();
      owner.ComputeDebugString(theGlobalVariables);
    }
  }
  MatrixLargeRational& tempMat= theGlobalVariables.matReduceMonomialByMonomial;
  MatrixLargeRational& startAsIdMat = theGlobalVariables.matIdMatrix;
  MatrixLargeRational& matColumn = theGlobalVariables.matOneColumn;
  MatrixLargeRational& matLinComb = theGlobalVariables.matReduceMonomialByMonomial2;
  Selection& tempSel= theGlobalVariables.selReduceMonomialByMonomial;
  Monomial<Integer> tempMon; intRoot tempRoot;
  tempMat.init(owner.AmbientDimension, (int) this->IndicesNonZeroMults.size);
  for (int i=0; i<this->IndicesNonZeroMults.size; i++)
    for (int j=0; j<owner.AmbientDimension; j++)
      tempMat.elements[j][i].AssignInteger(owner.RootsToIndices.TheObjects[this->IndicesNonZeroMults.TheObjects[i]].TheObjects[j]*this->TheObjects[this->IndicesNonZeroMults.TheObjects[i]].GetLargestElongation());
  if (this->flagAnErrorHasOccurredTimeToPanic)
  {  this->ComputeDebugString(owner, theGlobalVariables);
    tempMat.ComputeDebugString();
  }
  startAsIdMat.MakeIdMatrix(owner.AmbientDimension);
  MatrixLargeRational::GaussianEliminationByRows(tempMat, startAsIdMat, tempSel, false);
  if (this->flagAnErrorHasOccurredTimeToPanic)
  { startAsIdMat.ComputeDebugString();
    tempMat.ComputeDebugString();
  }
  SelectionWithDifferentMaxMultiplicities thePowers;
  List<int> thePowersSigned;
  thePowersSigned.SetSize(this->IndicesNonZeroMults.size);
  thePowers.initIncomplete(this->IndicesNonZeroMults.size);
  for (int k=0; k<this->Coefficient.size; k++)
  { this->Coefficient.TheObjects[k].MonomialExponentToColumnMatrix(matColumn);
    if (this->flagAnErrorHasOccurredTimeToPanic)
      matColumn.ComputeDebugString();
    matColumn.MultiplyOnTheLeft(startAsIdMat);
    if (this->flagAnErrorHasOccurredTimeToPanic)
      matColumn.ComputeDebugString();
    tempFrac.AssignDenominatorOnly(*this);
    tempFrac.Coefficient.SetSize(1);
    tempFrac.Coefficient.TheObjects[0].Assign(this->Coefficient.TheObjects[k]);
    if (tempMat.RowEchelonFormToLinearSystemSolution(tempSel, matColumn, matLinComb))
    { tempMon.Assign(this->Coefficient.TheObjects[k]);
      if (this->flagAnErrorHasOccurredTimeToPanic)
        matLinComb.ComputeDebugString();
      for (int i=0; i<matLinComb.NumRows; i++)
      { thePowers.MaxMultiplicities.TheObjects[i]=0;
        if (matLinComb.elements[i][0].IsGreaterThanOrEqualTo(ROne) || matLinComb.elements[i][0].IsNegative())
        { int tempI=matLinComb.elements[i][0].floor();
          thePowersSigned.TheObjects[i]=tempI;
          if (tempI<0)
            thePowers.MaxMultiplicities.TheObjects[i]=this->TheObjects[this->IndicesNonZeroMults.TheObjects[i]].GetMultiplicityLargestElongation();
          else
            thePowers.MaxMultiplicities.TheObjects[i]=MathRoutines::Minimum(tempI, this->TheObjects[this->IndicesNonZeroMults.TheObjects[i]].GetMultiplicityLargestElongation());
          tempRoot=owner.RootsToIndices.TheObjects[this->IndicesNonZeroMults.TheObjects[i]];
          tempRoot.MultiplyByInteger(thePowersSigned.TheObjects[i]*this->TheObjects[this->IndicesNonZeroMults.TheObjects[i]].GetLargestElongation());
          tempMon.DivideByExponentOnly(tempRoot);
          if (this->flagAnErrorHasOccurredTimeToPanic)
            tempMon.ComputeDebugString();
        } else
        { thePowers.Multiplicities.TheObjects[i]=0;
          thePowersSigned.TheObjects[i]=0;
        }
      }
      thePowers.ComputeElements();
      int numSummands=thePowers.getTotalNumSubsets();
      if (numSummands==1)
        owner.AddAlreadyReduced(tempFrac, theGlobalVariables, Indicator);
      else
      { partFractions tempFracs;
        Rational tempDiff;
        if (this->flagAnErrorHasOccurredTimeToPanic)
        { tempFracs.initFromOtherPartFractions(owner, theGlobalVariables);
          tempFrac.AssignDenominatorOnly(*this);
          tempFrac.Coefficient.Nullify((int)owner.AmbientDimension);
          tempFrac.Coefficient.AddObjectOnTopLight(this->Coefficient.TheObjects[k]);
          tempFrac.ComputeOneCheckSum(owner, tempDiff, owner.AmbientDimension, theGlobalVariables);
        }
        for (int l=0; l<numSummands; l++)
        { if (ProblemCounter==8 )
            Stop();
          tempFrac.AssignDenominatorOnly(*this);
          if (this->flagAnErrorHasOccurredTimeToPanic)
            thePowers.ComputeDebugString();
          tempFrac.ReduceMonomialByMonomialModifyOneMonomial(owner, theGlobalVariables, thePowers, thePowersSigned, tempMon);
          if (this->flagAnErrorHasOccurredTimeToPanic)
            tempFrac.ComputeDebugString(owner, theGlobalVariables);
          tempFrac.ReduceMonomialByMonomial(owner, -1, theGlobalVariables, Indicator);
          if (this->flagAnErrorHasOccurredTimeToPanic)
            tempFrac.ReduceMonomialByMonomial(tempFracs, -1, theGlobalVariables, Indicator);
          thePowers.IncrementSubset();
        }
        if (this->flagAnErrorHasOccurredTimeToPanic)
        { Rational tempFracsCheckSum;
          tempFracs.ComputeOneCheckSum(tempFracsCheckSum, theGlobalVariables);
          tempFracs.ComputeDebugString(theGlobalVariables);
          assert(tempFracsCheckSum.IsEqualTo(tempDiff));
        }
      }
    }
    else
      owner.AddAlreadyReduced(tempFrac, theGlobalVariables, Indicator);
  }
  if (this->flagAnErrorHasOccurredTimeToPanic)
  { Rational tempRat;
    owner.ComputeOneCheckSum(tempRat, theGlobalVariables);
    tempRat.Subtract(theDiff);
    assert(tempRat.IsEqualTo(StartCheckSum));
  }
}

void partFraction::ReduceMonomialByMonomialModifyOneMonomial(partFractions& Accum, GlobalVariables& theGlobalVariables, SelectionWithDifferentMaxMultiplicities& thePowers, List<int>& thePowersSigned, Monomial<Integer>& input)
{ IntegerPoly& theNumerator=theGlobalVariables.IPReduceMonomialByMonomialModifyOneMonomial1;
  IntegerPoly& tempP=theGlobalVariables.IPReduceMonomialByMonomialModifyOneMonomial2;
  theNumerator.Nullify((int)Accum.AmbientDimension);
  theNumerator.AddMonomial(input);
  assert(thePowersSigned.size== thePowers.Multiplicities.size);
  if (this->flagAnErrorHasOccurredTimeToPanic)
    theNumerator.ComputeDebugString();
  for (int j=0; j<thePowers.Multiplicities.size; j++)
  { int currentIndexInFraction = this->IndicesNonZeroMults.TheObjects[j];
    int currentElongation= this->TheObjects[currentIndexInFraction].GetLargestElongation();
    int MultChange= thePowers.Multiplicities.TheObjects[j];
    int MaxMultchange= this->TheObjects[currentIndexInFraction].GetMultiplicityLargestElongation();
    intRoot tempRoot;
    tempRoot= Accum.RootsToIndices.TheObjects[currentIndexInFraction];
    tempRoot.MultiplyByInteger(currentElongation);
    this->GetPolyReduceMonomialByMonomial(  Accum, theGlobalVariables, tempRoot, thePowersSigned.TheObjects[j], MultChange, MaxMultchange, tempP);
    if (this->flagAnErrorHasOccurredTimeToPanic)
      tempP.ComputeDebugString();
    theNumerator.MultiplyBy(tempP);
    if (this->flagAnErrorHasOccurredTimeToPanic)
      theNumerator.ComputeDebugString();
    this->TheObjects[currentIndexInFraction].AddMultiplicity(-MultChange, currentElongation);
  }
  this->Coefficient.AssignPolynomial(theNumerator);
  this->ComputeIndicesNonZeroMults();
  if (this->flagAnErrorHasOccurredTimeToPanic)
    this->ComputeDebugString(Accum, theGlobalVariables);
}

void partFraction::GetPolyReduceMonomialByMonomial(partFractions& owner, GlobalVariables& theGlobalVariables, intRoot& theExponent, int StartMonomialPower, int DenPowerReduction, int startDenominatorPower, IntegerPoly& output)
{ if (StartMonomialPower==0)
  { output.MakeNVarConst((int)owner.AmbientDimension, IOne);
    return;
  }
  Monomial<Integer> tempMon;  tempMon.init((int)owner.AmbientDimension);
  output.Nullify((int)owner.AmbientDimension);
  if (StartMonomialPower>0)
  { if (DenPowerReduction!=startDenominatorPower)
    { tempMon.Coefficient.value= MathRoutines::NChooseK(StartMonomialPower, DenPowerReduction);
      tempMon.Coefficient.value*=MathRoutines::parity(DenPowerReduction);
      output.AddMonomial(tempMon);
    } else
    { intRoot tempRoot;
      assert(StartMonomialPower>=startDenominatorPower);
      for (int k=0; k<=StartMonomialPower-startDenominatorPower; k++)
      { tempRoot= theExponent; tempRoot.MultiplyByInteger(k);
        tempMon.MakeFromRoot(IOne, tempRoot);
        tempMon.Coefficient.value= MathRoutines::parity(startDenominatorPower)*MathRoutines::NChooseK(StartMonomialPower-1-k, startDenominatorPower-1);
        output.AddMonomial(tempMon);
      }
    }
  }
  if (StartMonomialPower<0 )
  { if (DenPowerReduction!=startDenominatorPower)
    { tempMon.Coefficient.value= MathRoutines::NChooseK(-StartMonomialPower-1+DenPowerReduction, DenPowerReduction);
      output.AddMonomial(tempMon);
    } else
    { intRoot tempRoot;
      for (int k=1; k<=-StartMonomialPower; k++)
      { tempRoot= theExponent; tempRoot.MultiplyByInteger(-k);
        tempMon.MakeFromRoot(IOne, tempRoot);
        tempMon.Coefficient.value= MathRoutines::NChooseK(startDenominatorPower-StartMonomialPower-1-k, startDenominatorPower-1);
        output.AddMonomial(tempMon);
      }
    }
  }
  output.ComputeDebugString();
}

void partFractions::AddAndReduce(partFraction& f, GlobalVariables& theGlobalVariables, root* Indicator)
{ if (this->flagUsingOrlikSolomonBasis)
    f.ReduceMonomialByMonomial(*this, -1, theGlobalVariables, Indicator);
  else
    this->AddAlreadyReduced(f, theGlobalVariables, Indicator);
}

void partFractions::AddAlreadyReduced(partFraction& f, GlobalVariables& theGlobalVariables, root* Indicator)
{ bool shouldAttemptReduction=false;
  int tempI=this->IndexOfObjectHash(f);
  if (tempI==-1)
  { this->AddObjectOnTopHash(f);
    tempI= this->size-1;
    this->TheObjects[tempI].RelevanceIsComputed=false;
    this->AccountPartFractionInternals(1, tempI, Indicator, theGlobalVariables);
  }
  else
  { //Accounting
    this->AccountPartFractionInternals(-1, tempI, Indicator, theGlobalVariables);
    //end of accounting
    shouldAttemptReduction=this->TheObjects[tempI].AddReturnShouldAttemptReduction(f, *this, theGlobalVariables);
    //Accounting
    this->AccountPartFractionInternals(1, tempI, Indicator, theGlobalVariables);
    //end of accounting
  }
  if (this->flagSplitTestModeNoNumerators)
    this->TheObjects[tempI].Coefficient.MakeConst(IOne, (int)this->AmbientDimension);
  if (this->TheObjects[tempI].IsEqualToZero())
  { this->PopIndexHashChooseSwapByLowestNonProcessedAndAccount(tempI, theGlobalVariables, Indicator);
    shouldAttemptReduction=false;
  }
  if (shouldAttemptReduction&& this->flagUsingOrlikSolomonBasis)
  { if (this->flagAnErrorHasOccurredTimeToPanic)
      this->TheObjects[tempI].ComputeDebugString(*this, theGlobalVariables);
    this->TheObjects[tempI].AttemptReduction(*this, tempI, theGlobalVariables, Indicator);
    if (this->flagAnErrorHasOccurredTimeToPanic)
      this->TheObjects[tempI].ComputeDebugString(*this, theGlobalVariables);
  }
}

int partFractions::ElementToString(std::string& output, bool LatexFormat, bool includeVPsummand, bool includeNumerator, GlobalVariables& theGlobalVariables)
{ MatrixIntTightMemoryFit tempMat;
  return this->ElementToStringBasisChange (tempMat, false, output, LatexFormat, includeVPsummand, includeNumerator, theGlobalVariables);
}

int partFractions::ElementToStringOutputToFile(std::fstream& output, bool LatexFormat, bool includeVPsummand, bool includeNumerator, GlobalVariables& theGlobalVariables)
{ MatrixIntTightMemoryFit tempMat;
  return this->ElementToStringBasisChangeOutputToFile(tempMat, false, output, LatexFormat, includeVPsummand, includeNumerator, theGlobalVariables);
}

int partFractions::ElementToStringBasisChange(MatrixIntTightMemoryFit& VarChange, bool UsingVarChange, std::string& output, bool LatexFormat, bool includeVPsummand, bool includeNumerator, GlobalVariables& theGlobalVariables )
{ std::stringstream out;
  std::string tempS;
  int TotalLines=0;
  PolynomialOutputFormat PolyFormatLocal;
  PolyFormatLocal.ExtraLinesCounterLatex=0;
  if (LatexFormat)
  { out << "\\begin{eqnarray*}\n"; }
  int LastCutOff=0;
  for (int i=0; i<this->size; i++)
  { if (this->TheObjects[i].Coefficient.size>0 )
    { TotalLines+=this->TheObjects[i].ElementToStringBasisChange(*this, VarChange, UsingVarChange, tempS, LatexFormat, includeVPsummand, includeNumerator, PolyFormatLocal, theGlobalVariables);
      if (LatexFormat)
        out << "&&";
      if (tempS[0]!='-')
        out << "+";
      out << tempS;
      if (LatexFormat)
      { out << "\\\\ \n";
        TotalLines++;
      }
      else
        out << "\n";
      if (LatexFormat && (TotalLines-LastCutOff)> PolynomialOutputFormat::LatexCutOffLine)
      { out << "\\end{eqnarray*}\\begin{eqnarray*}\n";
        LastCutOff=TotalLines;
      }
    }
    if (TotalLines>this->flagMaxNumStringOutputLines)
    { out << "\n Number of lines exceeded " << this->flagMaxNumStringOutputLines << "; The rest of the output was suppressed.";
      break;
    }
  }
  if (!LatexFormat)
  { output= out.str();
    if (output.size()>0)
      if (output[0]=='+')  output.erase(0, 1);
  }
  else
  { out << "\\end{eqnarray*}";
    output= out.str();
  }
  return TotalLines;
}

int partFractions::ElementToStringBasisChangeOutputToFile(MatrixIntTightMemoryFit& VarChange, bool UsingVarChange, std::fstream& output, bool LatexFormat, bool includeVPsummand, bool includeNumerator, GlobalVariables& theGlobalVariables)
{ std::string tempS;
  int TotalLines=0;
  PolynomialOutputFormat PolyFormatLocal;
  PolyFormatLocal.ExtraLinesCounterLatex=0;
  if (LatexFormat)
    output << "\\begin{eqnarray*}\n";
  int LastCutOff=0;
  for (int i=0; i<this->size; i++)
  { if (this->TheObjects[i].Coefficient.size>0 )
    { TotalLines+=this->TheObjects[i].ElementToStringBasisChange(*this, VarChange, UsingVarChange, tempS, LatexFormat, includeVPsummand, includeNumerator, PolyFormatLocal, theGlobalVariables);
      if (LatexFormat)
        output << "&&";
      if (tempS[0]!='-')
        output << "+";
      output << tempS;
      if (LatexFormat)
      { output << "\\\\ \n";
        TotalLines++;
      }
      else
        output << "\n";
      if (LatexFormat && (TotalLines-LastCutOff)> PolynomialOutputFormat::LatexCutOffLine)
      { output << "\\end{eqnarray*}\\begin{eqnarray*}\n";
        LastCutOff=TotalLines;
      }
    }
  }
  if (LatexFormat)
    output << "\\end{eqnarray*}";
  return TotalLines;
}

#ifdef WIN32
#pragma warning(disable:4018)//grrrrr
#endif
int partFraction::ControlLineSizeFracs(std::string& output, PolynomialOutputFormat& PolyFormatLocal)
{ int numCutOffs= output.size()% PolyFormatLocal.LatexMaxLineLength;
  int LastCutOffIndex=0;
  int NumLinesAdded=0;
  for (int i=0; i<numCutOffs; i++)
    for ( int j=LastCutOffIndex+PolyFormatLocal.LatexMaxLineLength; j<((int) output.size())-1; j++)
      if (output[j]=='\\' && output[j+1]=='f')
      { output.insert(j, "\\\\\n&&");
        NumLinesAdded++;
        LastCutOffIndex=j+5;
        break;
      }
  return NumLinesAdded;
}

int partFraction::ControlLineSizeStringPolys(std::string& output, PolynomialOutputFormat& PolyFormatLocal)
{ int numCutOffs= output.size()% PolyFormatLocal.LatexMaxLineLength;
  int LastCutOffIndex=0;
  int NumLinesAdded=0;
  for(int i=0; i<numCutOffs; i++)
    for(int j=LastCutOffIndex+PolyFormatLocal.LatexMaxLineLength; j<(int)(output.size())-1; j++)
      if ((output[j]=='+'||output[j]=='-')&&output[j-1]!='{')
      { output.insert(j, "\\\\\n&&");
        NumLinesAdded++;
        LastCutOffIndex=j+5;
        break;
      }
  return NumLinesAdded;
}
#ifdef WIN32
#pragma warning(default:4018)//grrrrr
#endif
void partFractions::MakeProgressReportSplittingMainPart(GlobalVariables& theGlobalVariables)
{ if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()==0)
    return;
  std::stringstream out1, out2, out3;
  out1 << this->NumberRelevantReducedFractions << " relevant reduced + " << this->NumberIrrelevantFractions << " disjoint = " << this->NumTotalReduced;
  if (this->NumRelevantNonReducedFractions!=0)
    out1 << " + " << this->NumRelevantNonReducedFractions << " relevant unreduced ";
  out1 << " out of "<< this->size << " total fractions";
  theGlobalVariables.theIndicatorVariables.ProgressReportString1= out1.str();
  out2 << this->NumMonomialsInNumeratorsRelevantFractions << " relevant reduced + " << this->NumMonomialsInNumeratorsIrrelevantFractions << " disjoint = "
          << this->NumMonomialsInNumeratorsRelevantFractions +this->NumMonomialsInNumeratorsIrrelevantFractions << " out of " << this->NumMonomialsInTheNumerators << " total monomials in the numerators";
  theGlobalVariables.theIndicatorVariables.ProgressReportString2= out2.str();
  if (this->NumGeneratorsInTheNumerators!=0)
  { out3 << this->NumGeneratorsRelevenatFractions << " relevant reduced + " << this->NumGeneratorsIrrelevantFractions << " disjoint = " << this->NumGeneratorsIrrelevantFractions +this->NumGeneratorsRelevenatFractions << " out of " << this->NumGeneratorsInTheNumerators << " total generators in the numerators";
    theGlobalVariables.theIndicatorVariables.ProgressReportString3= out3.str();
  } else
    theGlobalVariables.theIndicatorVariables.ProgressReportString3.clear();
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void partFractions::MakeProgressVPFcomputation(GlobalVariables& theGlobalVariables)
{ this->NumProcessedForVPFfractions++;
  if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()==0)
    return;
  std::stringstream out2, out3;
  out2  << "Processed " << this->NumProcessedForVPFfractions << " out of " << this->NumberRelevantReducedFractions << " relevant fractions";
//  out3  << "Processed " <<" out of " <<this->NumMonomialsInNumeratorsRelevantFractions
//        << " relevant fractions";
  theGlobalVariables.theIndicatorVariables.ProgressReportString2= out2.str();
  //::theGlobalVariables.theIndicatorVariables.ProgressReportString3= out3.str();
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void partFractions::ComputeOneCheckSum(Rational& output, GlobalVariables& theGlobalVariables)
{ output.MakeZero();
  for(int i=0; i<this->size; i++)
  { Rational tempRat;
    this->TheObjects[i].ComputeOneCheckSum(*this, tempRat, this->AmbientDimension, theGlobalVariables);
    if (this->flagAnErrorHasOccurredTimeToPanic)
    { std::string tempS;
      tempRat.ElementToString(tempS);
    }
    output+=(tempRat);
    if (this->flagMakingProgressReport)
    { std::stringstream out;
      out << "Checksum " << i+1 << " out of " << this->size;
      theGlobalVariables.theIndicatorVariables.ProgressReportString4= out.str();
      theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
    }
  }
  if (this->flagMakingProgressReport)
  { std::stringstream out;
    out << "Checksum: " << output.ElementToString();
    theGlobalVariables.theIndicatorVariables.ProgressReportString5= out.str();
    theGlobalVariables.MakeReport();
  }
}

void partFractions::initFromRootSystem(intRoots& theFraction, intRoots& theAlgorithmBasis, intRoot* weights, GlobalVariables& theGlobalVariables)
{ this->initCommon();
  if (theFraction.size<1)
    return;
  partFraction f;
  this->AmbientDimension= theFraction.TheObjects[0].size;
  f.initFromRootSystem(*this, theFraction, theAlgorithmBasis, weights);
  this->AddAlreadyReduced(f, theGlobalVariables, 0);
}

void partFractions::initCommon()
{ this->ClearTheObjects();
  this->RootsToIndices.ClearTheObjects();
  this->flagInitialized=false;
  this->SplitStepsCounter=1;
}

void partFractions::initFromRoots(roots& input, GlobalVariables& theGlobalVariables)
{ this->initCommon();
  if (input.size<1)
    return;
  partFraction f;
  this->AmbientDimension= input.TheObjects[0].size;
  f.initFromRoots(*this, input);
  this->AddAlreadyReduced(f, theGlobalVariables, 0);
}

void partFractions::initAndSplit(roots& input, GlobalVariables& theGlobalVariables)
{ this->initFromRoots(input, theGlobalVariables);
  this->split(theGlobalVariables, 0);
}

void partFractions::Run(roots& input, GlobalVariables& theGlobalVariables)
{ if (!this->flagInitialized)
    this->initFromRoots(input, theGlobalVariables);
  this->split(theGlobalVariables, 0);
}

void partFractions::RemoveRedundantShortRoots(GlobalVariables& theGlobalVariables, root* Indicator)
{ partFraction tempFrac;
  Rational startCheckSum, tempCheckSum, tempCheckSum2, tempCheckSum3;
  if (partFraction::MakingConsistencyCheck)
    this->ComputeOneCheckSum(startCheckSum, theGlobalVariables);
  for (int i=0; i<this->size; i++)
    if(this->RemoveRedundantShortRootsIndex(theGlobalVariables, Indicator, i))
    { i--;
      if (this->flagMakingProgressReport)
      { std::stringstream out;
        out << "Elongating denominator " << i+1 << " out of " << this->size;
        theGlobalVariables.theIndicatorVariables.ProgressReportString3=out.str();
        theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
      }
     }
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].Coefficient.IsEqualToZero())
    { this->PopIndexSwapWithLastHash(i);
      i--;
    }
}

void partFractions::RemoveRedundantShortRootsClassicalRootSystem(GlobalVariables& theGlobalVariables, root* Indicator)
{ partFraction tempFrac;
  for (int i=0; i<this->size; i++)
  { tempFrac.Assign(this->TheObjects[i]);
    if(tempFrac.RemoveRedundantShortRootsClassicalRootSystem(*this, Indicator, theGlobalVariables, this->AmbientDimension))
    { this->TheObjects[i].Coefficient.Nullify((int)this->AmbientDimension);
      this->AddAlreadyReduced(tempFrac, theGlobalVariables, Indicator);
    }
    if (this->flagMakingProgressReport)
    { std::stringstream out;
      out << "Elongating denominator " << i+1 << " out of " << this->size;
      theGlobalVariables.theIndicatorVariables.ProgressReportString4=out.str();
      theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
    }
  }
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].Coefficient.IsEqualToZero())
    { this->PopIndexHashChooseSwapByLowestNonProcessedAndAccount(i, theGlobalVariables, Indicator);
      i--;
    }
}

void FileSetPutPointerToEnd(std::fstream& theFile, bool StoreToFile)
{ //theFile.close();
  //theFile.open(path);
  assert(theFile.is_open()||!StoreToFile);
  std::filebuf* pbuf = theFile.rdbuf();
  int tempSize = pbuf->pubseekoff(0, std::fstream::end);
  theFile.seekp(tempSize);
}

bool partFractions::VerifyFileComputedContributions(GlobalVariables&  theGlobalVariables)
{ int tempI= this->ReadFromFileComputedContributions(partFractions::ComputedContributionsList, theGlobalVariables);
  std::filebuf* pbuf = partFraction::TheBigDump.rdbuf();
  int tempSize = pbuf->pubseekoff(0, std::fstream::end);
  partFraction::TheBigDump.seekp(tempSize);
  return(tempSize>=tempI);
}

bool partFractions::partFractionsToPartitionFunctionAdaptedToRoot(  QuasiPolynomialOld& output, root& newIndicator, bool StoreToFile, bool UseOldData, GlobalVariables& theGlobalVariables, bool ResetRelevance)
{ if(this->AssureIndicatorRegularity(theGlobalVariables, newIndicator))
  { theGlobalVariables.theIndicatorVariables.flagRootIsModified=true;
    theGlobalVariables.theIndicatorVariables.modifiedRoot.AssignRoot(newIndicator);
    theGlobalVariables.theIndicatorVariables.ProgressReportString5="Indicator modified to regular";
    theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
  } else
    theGlobalVariables.theIndicatorVariables.flagRootIsModified=false;
  if(ResetRelevance)
    this->ResetRelevanceIsComputed();
  if (!this->CheckForMinimalityDecompositionWithRespectToRoot(&newIndicator, theGlobalVariables))
    return false;
  this->NumProcessedForVPFfractions=0;
  Rational oldCheckSum;
  QuasiPolynomialOld oldOutput;
  if (partFraction::MakingConsistencyCheck)
    partFractions::CheckSum.MakeZero();
  if (StoreToFile && UseOldData)
  { bool tempBool = this->VerifyFileComputedContributions(theGlobalVariables);
    assert(tempBool);
  }
  theGlobalVariables.theIndicatorVariables.NumProcessedMonomialsCurrentFraction=0;
  output.Nullify((int)this->AmbientDimension);
  ///////////////////////////////////////////////
  //this->flagAnErrorHasOccurredTimeToPanic=true;
  //partFraction::flagAnErrorHasOccurredTimeToPanic=true;
  //this->ComputeDebugString();
  ///////////////////////////////////////////////
  static QuasiPolynomialOld tempQP;
  for (int i=0; i<this->size; i++)
  { assert(partFraction::TheBigDump.is_open()||!StoreToFile);
    assert(partFractions::ComputedContributionsList.is_open()||!StoreToFile);
    //if (this->flagAnErrorHasOccurredTimeToPanic)
    //{ this->TheObjects[i].ComputeDebugString();
    //}
    if (this->TheObjects[i].rootIsInFractionCone(*this, &newIndicator, theGlobalVariables))
    { this->TheObjects[i].partFractionToPartitionFunctionSplit(*this, tempQP, true, StoreToFile, theGlobalVariables, this->AmbientDimension);
      if (StoreToFile)
      { this->WriteToFileComputedContributions(partFractions::ComputedContributionsList, theGlobalVariables);
        FileSetPutPointerToEnd(partFractions::ComputedContributionsList, StoreToFile);
        FileSetPutPointerToEnd(partFraction::TheBigDump, StoreToFile);
      }
/*      if(partFraction::MakingConsistencyCheck)
      {  Rational tempLRat2, tempLRat3, tempLRat4;
        std::string tempS1, tempS2, tempS3, tempS4;
        tempQP.Evaluate(partFraction::theVectorToBePartitioned, tempLRat2);
        output.Evaluate(partFraction::theVectorToBePartitioned, tempLRat3);
        tempLRat2.ElementToString(tempS1);
        tempLRat3.ElementToString(tempS2);
        tempLRat4.Assign(tempLRat2);
        tempLRat4.Add(tempLRat3);
        partFraction::CheckSum.ElementToString(tempS3);
        partFractions::CheckSum.ElementToString(tempS4);
        assert(tempLRat2.den.IsEqualTo(LIOne));
        assert(tempLRat3.den.IsEqualTo(LIOne));
        assert(tempLRat2.IsEqualTo(partFraction::CheckSum));
        assert(tempLRat4.IsEqualTo(partFractions::CheckSum));
        if (i==4)
        { Stop();
          QuasiPolynomialOld::flagAnErrorHasOccurredTimeToPanic=true;
          ::RandomCodeIDontWantToDelete theEvilBug;
          theEvilBug.EvilPoly1.Assign(output);
          theEvilBug.EvilPoly2.Assign(tempQP);
          theEvilBug.RevealTheEvilConspiracy();
          RandomCodeIDontWantToDelete::UsingEvilList1=false;
        }
      }*/
      output.AddPolynomial(tempQP);
  /*    if (partFraction::MakingConsistencyCheck)
      {  Rational tempLRat;
        output.Evaluate(partFraction::theVectorToBePartitioned, tempLRat);
        if ((! tempLRat.IsEqualTo(partFractions::CheckSum)) || (! tempLRat.den.IsEqualTo(LIOne)))
        { std::string tempS, tempS2, tempS3, tempS4;
          Rational tempLRat2;
          tempQP.Evaluate(partFraction::theVectorToBePartitioned, tempLRat2);
          partFractions::CheckSum.ElementToString(tempS);
          tempLRat.ElementToString(tempS2);
          oldCheckSum.ElementToString(tempS3);
          tempLRat2.ElementToString(tempS4);
          partFraction::flagAnErrorHasOccurredTimeToPanic=true;
  //        assert(false);
        }
        oldCheckSum.Assign(partFractions::CheckSum);
        oldOutput.Assign(output);
      }*/
      this->MakeProgressVPFcomputation(theGlobalVariables);
    }
  }
/*  if (partFraction::MakingConsistencyCheck)
  { std::string tempS;
    partFractions::CheckSum.ElementToString(tempS);
    Stop();
  }*/
  if (StoreToFile)
  { partFraction::TheBigDump.flush();
  }
  return true;
}

void partFractions::ComputeDebugString(GlobalVariables& theGlobalVariables)
{ this->ElementToString(this->DebugString, PolynomialOutputFormat::UsingLatexFormat, false, true, theGlobalVariables);
}

void partFractions::ElementToString(std::string& output, GlobalVariables& theGlobalVariables)
{ this->ElementToString(output, PolynomialOutputFormat::UsingLatexFormat, false, true, theGlobalVariables);
}

void partFractions::ComputeDebugStringNoNumerator(GlobalVariables& theGlobalVariables)
{ this->ElementToString(this->DebugString, PolynomialOutputFormat::UsingLatexFormat, false, false, theGlobalVariables);
}

void partFractions::ComputeDebugStringWithVPfunction(GlobalVariables& theGlobalVariables)
{ this->ElementToString(this->DebugString, PolynomialOutputFormat::UsingLatexFormat, true, true, theGlobalVariables);
}

void partFractions::WriteToFile(std::fstream& output, GlobalVariables& theGlobalVariables)
{ std::string tempS;
  output << "Dimension: ";
  output << this->AmbientDimension << "\n";
  output << "Indices_of_roots:\n";
  PolynomialOutputFormat PolyFormatLocal;
  for (int i=0; i<this->RootsToIndices.size; i++)
  { this->RootsToIndices.TheObjects[i].ElementToString(tempS);
    output << "| " << i << "    " << tempS << "\n";
  }
  output << "Alphabet_used:\n";
  for (int i=0; i<this->AmbientDimension; i++)
    output << PolyFormatLocal.GetLetterIndex(i) << " ";
  output << "\n" << "Number_of_fractions: " << this->size << "\n";
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].WriteToFile(output, theGlobalVariables);
}

void partFractions::ReadFromFile(std::fstream& input, GlobalVariables& theGlobalVariables)
{ intRoots tempRoots;
  this->PrepareIndicatorVariables();
  PolynomialOutputFormat PolyFormatLocal;
  //input.seekg(0, std::ios::end);
  //int bufferSize= input.tellg();
  //bufferSize = ::Minimum(bufferSize, this->MaxReadFileBufferSize)+1;
  //char* TempBuffer= new char[bufferSize];
  //input.rdbuf()->pubsetbuf(TempBuffer, bufferSize);
  //input.rdbuf()->sgetn(TempBuffer, bufferSize);
//  input.read(TempBuffer, bufferSize+1);
//  std::filebuf* oldInputBuffer;
//  oldInputBuffer=input.rdbuf();
//  input.rdbuf(TempBuffer);
  assert(input.is_open());
  input.seekg(0);
  std::string tempS;
  input >> tempS;
  input >> this->AmbientDimension;
  input >> tempS;
  intRoot tempRoot;
  for (input >> tempS; tempS!="Alphabet_used:"; input >> tempS)
  { int tempI;
    input >> tempI;
    input >> tempS;
    for (int i=0; i<this->AmbientDimension; i++)
    { input >> tempRoot.TheObjects[i];
      input >> tempS;
    }
    tempRoots.AddObjectOnTop(tempRoot);
  }
  tempRoots.ComputeDebugString();
  this->RootsToIndices.initFromRoots(tempRoots, 0);
  for (int i=0; i<this->AmbientDimension; i++)
  { input >> tempS;
    PolyFormatLocal.SetLetterIndex(tempS, i);
  }
  int tempI;
  input >> tempS;
  assert(tempS=="Number_of_fractions:");
  input >> tempI;
  partFraction tempFrac;
  this->MakeActualSizeAtLeastExpandOnTop(tempI);
  for(int i=0; i<tempI; i++)
  { tempFrac.ReadFromFile(*this, input, theGlobalVariables, this->AmbientDimension);
    this->AddAlreadyReduced(tempFrac, theGlobalVariables, 0);
    this->MakeProgressVPFcomputation(theGlobalVariables);
  }
}

void partFractions::ComputeSupport(List<roots>& output, std::stringstream& outputString)
{ output.size=0;
  output.MakeActualSizeAtLeastExpandOnTop(this->size);
  for (int i=0; i<this->size; i++)
  { roots tempRoots;
    tempRoots.ComputeDebugString();
    for (int j=0; j<this->TheObjects[i].IndicesNonZeroMults.size; j++)
    { root tempRoot, tempRoot3;
      tempRoot.AssignIntRoot(this->RootsToIndices.TheObjects[this->TheObjects[i].IndicesNonZeroMults.TheObjects[j]]);
      intRoot tempRoot2;
      tempRoot.DivByInteger(2);
      tempRoot2.AssignRoot(tempRoot);
      tempRoot3.AssignIntRoot(tempRoot2);
      if (!tempRoot3.IsEqualTo(tempRoot))
        tempRoot.MultiplyByInteger(2);
      tempRoots.AddOnTopNoRepetition(tempRoot);
      tempRoots.ComputeDebugString();
    }
    if (output.AddOnTopNoRepetition(tempRoots))
    { tempRoots.ComputeDebugString();
      outputString<< tempRoots.DebugString << "\n\n\n";
    }
  }
}

void partFractions::ComputeDebugStringBasisChange(MatrixIntTightMemoryFit& VarChange, GlobalVariables& theGlobalVariables)
{ this->ElementToStringBasisChange( VarChange, true, this->DebugString, PolynomialOutputFormat::UsingLatexFormat, false, true, theGlobalVariables);
}

void partFractions::ComputeKostantFunctionFromWeylGroup(char WeylGroupLetter, int WeylGroupNumber, QuasiPolynomialOld& output, root* ChamberIndicator, bool UseOldData, bool StoreToFile, GlobalVariables&  theGlobalVariables)
{ intRoots theBorel, theVPbasis;
  intRoot tempWeight; tempWeight.SetSize(WeylGroupNumber);
  roots tempRoots;
  WeylGroup tempW;
  this->ClearTheObjects();
  this->AmbientDimension=(int) WeylGroupNumber;
  if (WeylGroupLetter=='A')
  { tempW.MakeAn(WeylGroupNumber);
  }
  if (WeylGroupLetter=='B')
  { tempW.MakeBn(WeylGroupNumber);
  }
  if (WeylGroupLetter=='C')
  { tempW.MakeCn(WeylGroupNumber);
  }
  if (WeylGroupLetter=='D')
  { tempW.MakeDn(WeylGroupNumber);
  }
  if (WeylGroupLetter=='G')
  { tempW.MakeG2();
  }
  if (WeylGroupLetter=='F')
  { tempW.MakeF4();
    partFractions::ListActualSizeIncrement=35000;
  }
  if (WeylGroupLetter=='A'|| WeylGroupLetter=='B'|| WeylGroupLetter=='C'|| WeylGroupLetter=='D'|| WeylGroupLetter=='F')
  { for (int i=0; i<this->AmbientDimension; i++)
      tempWeight.TheObjects[i]=MathRoutines::KToTheNth(8, this->AmbientDimension-i-1);
  }
  else
    for (int i=0; i<this->AmbientDimension; i++)
      tempWeight.TheObjects[i]=1; //KToTheNth(8, root::AmbientDimension-i-1);
  //tempW.ComputeWeylGroup();
  tempW.ComputeRootsOfBorel(tempRoots);
  theBorel.AssignRoots(tempRoots);
  theVPbasis.CopyFromBase(theBorel);
  if (WeylGroupLetter=='B')
  { for (int i=0; i<theVPbasis.size; i++)
    { Rational tempRat;
      root tempRoot; tempRoot.AssignIntRoot(theVPbasis.TheObjects[i]);
      tempW.RootScalarCartanRoot(tempRoot, tempRoot, tempRat);
      if (tempRat.IsEqualTo(LROne))
      { intRoot tempIntRoot;
        tempIntRoot=theBorel.TheObjects[i];
        tempIntRoot.MultiplyByInteger(2);
        theVPbasis.AddObjectOnTop(tempIntRoot);
      }
    }
  }
  if (WeylGroupLetter=='D')
  { intRoot tempRoot;
    tempRoot.MakeZero(this->AmbientDimension);
    tempRoot.TheObjects[this->AmbientDimension-1]=1;
    tempRoot.TheObjects[this->AmbientDimension-2]=-1;
    theVPbasis.AddObjectOnTop(tempRoot);
    tempRoot.TheObjects[this->AmbientDimension-1]=1;
    tempRoot.TheObjects[this->AmbientDimension-2]=1;
    theVPbasis.AddObjectOnTop(tempRoot);
    for(int i=this->AmbientDimension-3; i>=0; i--)
    { tempRoot.TheObjects[i]=2;
      theVPbasis.AddObjectOnBottom(tempRoot);
    }
    tempWeight.TheObjects[this->AmbientDimension-2]=7;
    tempWeight.TheObjects[this->AmbientDimension-1]=8;
  }
  theVPbasis.BubbleSort(&tempWeight);
  theVPbasis.ComputeDebugString();
  tempW.ComputeDebugString();
  theBorel.ComputeDebugString();
  this->initFromRootSystem(theBorel, theVPbasis, 0, theGlobalVariables);
  //this->flagSplitTestModeNoNumerators=true;
  this->split(theGlobalVariables, ChamberIndicator);
  /*if (WeylGroupLetter=='A'||
      WeylGroupLetter=='B'||
      WeylGroupLetter=='C'||
      WeylGroupLetter=='D')
  {  this->splitClassicalRootSystem(true);
  }
  else
  { if (WeylGroupLetter=='F')
    { this->splitClassicalRootSystem(false);
      this->split();
    }
    else
      this->split();
  }*/
//  this->ComputeDebugString();
  assert(this->CheckForMinimalityDecompositionWithRespectToRoot(ChamberIndicator, theGlobalVariables));
  //return;
  root tempRoot;
  if (ChamberIndicator!=0)
    tempRoot.Assign(*ChamberIndicator);
  else
    tempRoot.MakeZero(this->AmbientDimension);
  if(!this->partFractionsToPartitionFunctionAdaptedToRoot(output, tempRoot, StoreToFile, UseOldData, theGlobalVariables, false))
  { this->ComputeDebugStringNoNumerator(theGlobalVariables);
    assert(false);
  }
  //output.ComputeDebugString();
}

void oneFracWithMultiplicitiesAndElongations::operator =(oneFracWithMultiplicitiesAndElongations& right)
{ this->Multiplicities.CopyFromLight(right.Multiplicities);
  this->Elongations.CopyFromLight(right.Elongations);
}

int oneFracWithMultiplicitiesAndElongations::HashFunction() const
{ return this->GetTotalMultiplicity();
}

void oneFracWithMultiplicitiesAndElongations::GetPolyDenominator(IntegerPoly& output, int MultiplicityIndex, intRoot& theExponent)
{ assert(MultiplicityIndex<this->Multiplicities.size);
  Monomial<Integer> tempM;
  output.MakeNVarConst((int)theExponent.size, IOne);
  tempM.init((int)theExponent.size);
  tempM.Coefficient.Assign(IMOne);
  for (int i=0; i<theExponent.size; i++)
    tempM.degrees[i]=(int)(theExponent.TheObjects[i]*this->Elongations.TheObjects[MultiplicityIndex]);
  output.AddMonomial(tempM);
}

int oneFracWithMultiplicitiesAndElongations::GetLargestElongation()
{ int result=this->Elongations.TheObjects[0];
  for (int i=1; i<this->Elongations.size; i++)
  { assert(this->Elongations.TheObjects[i]!=result);
    if (this->Elongations.TheObjects[i]>result)
      result= this->Elongations.TheObjects[i];
  }
  return result;
}

int oneFracWithMultiplicitiesAndElongations::GetLCMElongations()
{ int result =1;
  for (int i=0; i<this->Elongations.size; i++)
  { assert(this->Elongations.TheObjects[i]!=0);
    result=MathRoutines::lcm(this->Elongations.TheObjects[i], result);
  }
  return result;
}

int oneFracWithMultiplicitiesAndElongations::GetTotalMultiplicity() const
{ int result=0;
  for (int i=0; i<this->Elongations.size; i++)
    result+= this->Multiplicities.TheObjects[i];
  return result;
}

int oneFracWithMultiplicitiesAndElongations::IndexLargestElongation()
{ int result=0;
  for (int i=1; i<this->Elongations.size; i++)
    if (this->Elongations.TheObjects[i]>this->Elongations.TheObjects[result])
      result=i;
  return result;
}

void oneFracWithMultiplicitiesAndElongations::init()
{ this->Elongations.SetSize(0);
  this->Multiplicities.SetSize(0);
}

void oneFracWithMultiplicitiesAndElongations::ComputeOneCheckSum(Rational& output, intRoot& theExp, int theDimension)
{ output.Assign(LROne);
  std::string tempS;
  for (int i=0; i<this->Elongations.size; i++)
  { Rational tempRat, tempRat2, tempRat3;
    tempRat.Assign(LROne);
    tempRat2.Assign(LROne);
    for (int j=0; j<theDimension; j++)
    { if (partFraction::flagAnErrorHasOccurredTimeToPanic)
      { theExp.ElementToString(tempS);
      }
      tempRat3.Assign(oneFracWithMultiplicitiesAndElongations::CheckSumRoot.TheObjects[j]);
      if (!tempRat3.IsEqualToZero())
        tempRat3.RaiseToPower(theExp.TheObjects[j]*this->Elongations.TheObjects[i]);
      tempRat2.MultiplyBy(tempRat3);
      if (partFraction::flagAnErrorHasOccurredTimeToPanic)
      { tempRat2.ElementToString(tempS);
      }
    }
    if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    { tempRat.ElementToString(tempS);
    }
    tempRat.Subtract(tempRat2);
    tempRat.RaiseToPower(this->Multiplicities.TheObjects[i]);
    if (partFraction::flagAnErrorHasOccurredTimeToPanic)
      tempRat.ElementToString(tempS);
    output.MultiplyBy(tempRat);
    if (partFraction::flagAnErrorHasOccurredTimeToPanic)
      output.ElementToString(tempS);
  }
  if (output.IsEqualToZero())
  { std::string tempS;
    Stop();
  }
  output.Invert();
  if (partFraction::flagAnErrorHasOccurredTimeToPanic)
    output.ElementToString(tempS);
}

int oneFracWithMultiplicitiesAndElongations::GetMultiplicityLargestElongation()
{ int result=0;
  int LargestElongationFound=0;
  for (int i=0; i<this->Elongations.size; i++)
    if (LargestElongationFound<this->Elongations.TheObjects[i])
    { LargestElongationFound= this->Elongations.TheObjects[i];
      result= this->Multiplicities.TheObjects[i];
    }
  return result;
}

void oneFracWithMultiplicitiesAndElongations::AddMultiplicity(int MultiplicityIncrement, int Elongation)
{ if (MultiplicityIncrement==0) return;
  int ElongationIndex=this->Elongations.IndexInList(Elongation);
  if (ElongationIndex==-1)
  { this->Elongations.AddObjectOnTopLight(Elongation);
    int tempI=0;
    this->Multiplicities.AddObjectOnTopLight(tempI);
    ElongationIndex= this->Multiplicities.size-1;
  }
  this->Multiplicities.TheObjects[ElongationIndex]+=MultiplicityIncrement;
  assert(this->Multiplicities.TheObjects[ElongationIndex]>=0);
  if (this->Multiplicities.TheObjects[ElongationIndex]==0)
  { this->Multiplicities.PopIndexSwapWithLastLight(ElongationIndex);
    this->Elongations.PopIndexSwapWithLastLight(ElongationIndex);
  }
}

void oneFracWithMultiplicitiesAndElongations::OneFracToStringBasisChange(partFractions& owner, int indexElongation, MatrixIntTightMemoryFit& VarChange, bool UsingVarChange, std::string& output, bool LatexFormat, int indexInFraction, int theDimension, PolynomialOutputFormat& PolyFormatLocal)
{ std::stringstream  out;
  std::string tempS;
  intRoot tempRoot2, tempRoot;
  tempRoot.SetSize(theDimension);
  tempRoot2.SetSize(theDimension);
  int NumCoords;
  if (UsingVarChange)
  { NumCoords= VarChange.NumRows;
    tempRoot2=owner.RootsToIndices.TheObjects[indexInFraction];
    for (int i=0; i<NumCoords; i++)
    { tempRoot.TheObjects[i]=0;
      for (int j=0; j<theDimension; j++)
        tempRoot.TheObjects[i]+=VarChange.elements[i][j]*tempRoot2.TheObjects[j];
    }
  }
  else
  { NumCoords=theDimension;
    tempRoot = owner.RootsToIndices.TheObjects[indexInFraction];
  }
  tempRoot.MultiplyByInteger(this->Elongations.TheObjects[indexElongation]);
  if (!LatexFormat)
    out << "1/(1-";
  else
    out << "\\frac{1}{(1-";
  for(int i=0; i<NumCoords; i++)
    if (tempRoot.TheObjects[i]!=0)
    { out << PolyFormatLocal.GetLetterIndex(i);
      if (tempRoot.TheObjects[i]!=1)
        out << "^{" << tempRoot.TheObjects[i] << "}";
    }
  out << ")";
  if (this->Multiplicities.TheObjects[indexElongation]>1)
    out << "^" << this->Multiplicities.TheObjects[indexElongation];
  if (LatexFormat){ out << "}"; }
  output= out.str();
}

void oneFracWithMultiplicitiesAndElongations::ElementToStringBasisChange(partFractions& owner, MatrixIntTightMemoryFit& VarChange, bool UsingVarChange, std::string& output, bool LatexFormat, int index, int theDimension, PolynomialOutputFormat& PolyFormatLocal)
{ if (this->Multiplicities.size==0)
  { output.clear();
    return;
  }
  std::string tempS;
  std::stringstream out;
  for (int k=0; k<this->Multiplicities.size; k++)
  { this->OneFracToStringBasisChange(owner, k, VarChange, UsingVarChange, tempS, LatexFormat, index, theDimension, PolyFormatLocal);
    out << tempS;
  }
  out << " ";
  output= out.str();
}

bool oneFracWithMultiplicitiesAndElongations::operator ==(oneFracWithMultiplicitiesAndElongations& right)
{ if (this->Elongations.size!=right.Elongations.size)
    return false;
  for (int i=0; i<this->Elongations.size; i++)
  { bool Found=false;
    for (int j=0; j<right.Elongations.size; j++)
      if (this->Elongations.TheObjects[i]==right.Elongations.TheObjects[j])
      { if(this->Multiplicities.TheObjects[i]!=right.Multiplicities.TheObjects[j])
          return false;
        else
        { Found=true;
          break;
        }
      }
    if (!Found)
      return false;
  }
  return true;
}

void intRoot::MakeZero(int theDimension)
{ this->SetSize(theDimension);
  for (int i=0; i<theDimension; i++)
    this->TheObjects[i]=0;
}

void intRoot::AddRoot(intRoot& theRoot)
{ assert(this->size==theRoot.size);
  for (int i=0; i<this->size; i++)
    this->TheObjects[i]+=theRoot.TheObjects[i];
}

int intRoot::HashFunction() const
{ int result=0;
  for (int i=0; i<this->size; i++)
    result+=SomeRandomPrimes[i]*this->TheObjects[i];
  return result;
}

void intRoot::ElementToString(std::string& output)
{ std::stringstream out;
  out << "( ";
  for (int i=0; i<this->size; i++)
  { out << this->TheObjects[i];
    if (i!=this->size-1)
      out << " , ";
  }
  out << " )";
  output= out.str();
}

void intRoot::AssignRoot(root& r)
{ this->SetSize(r.size);
  for (int i=0; i<this->size; i++)
    this->TheObjects[i]= r.TheObjects[i].NumShort;
}

bool intRoot::IsPositive()
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]<0)
      return false;
  return true;
}

void intRoot::initFromInt(int theDimension, int x1, int x2, int x3, int x4, int x5)
{ this->SetSize(theDimension);
  this->TheObjects[0]=x1;
  this->TheObjects[1]=x2;
  this->TheObjects[2]=x3;
  this->TheObjects[3]=x4;
  this->TheObjects[4]=x5;
}

void intRoot::initFromInt(int theDimension, int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8, int x9, int x10, int x11, int x12)
{ this->SetSize(theDimension);
  this->TheObjects[0]=x1;
  this->TheObjects[1]=x2;
  this->TheObjects[2]=x3;
  this->TheObjects[3]=x4;
  this->TheObjects[4]=x5;
  this->TheObjects[5]=x6;
  this->TheObjects[6]=x7;
  this->TheObjects[7]=x8;
  this->TheObjects[8]=x9;
  this->TheObjects[9]=x10;
  this->TheObjects[10]=x11;
  this->TheObjects[11]=x12;
}

inline bool intRoot::IsGEQNoWeight(intRoot& r)
{ assert(this->size==r.size);
  for (int i=0; i<this->size; i++)
    if (r.TheObjects[i]>this->TheObjects[i])
      return false;
  return true;
}

inline bool intRoot::IsHigherThanWRTWeight(intRoot& r, intRoot& theWeights)
{ assert(this->size == r.size);
  int accum=0;
  for (int i=0; i<this->size; i++)
    accum+=(this->TheObjects[i]-r.TheObjects[i])*theWeights.TheObjects[i];
  return (accum>0);
}

void RootToIndexTable::initFromRoots(intRoots& theAlgorithmBasis, intRoot* theWeights)
{ if (theAlgorithmBasis.size==0)
    return;
  int theDimension= theAlgorithmBasis.TheObjects[0].size;
  if (theWeights!=0)
    this->weights=*theWeights;
  for (int i=0; i<theAlgorithmBasis.size; i++)
  { int x= this->IndexOfObjectHash(theAlgorithmBasis.TheObjects[i]);
    if (x==-1)
    { if (theWeights!=0)
        this->AddRootAndSort(theAlgorithmBasis.TheObjects[i]);
      else
        this->AddRootPreserveOrder(theAlgorithmBasis.TheObjects[i]);
    }
  }
  this->NumNonRedundantShortRoots= this->size;
  this->ComputeTable(theDimension);
}

void RootToIndexTable::ComputeTable(int theDimension)
{ intRoot tempR, tempR2, tempR3;
  tempR.SetSize(theDimension);  tempR2.SetSize(theDimension); tempR3.SetSize(theDimension);
  this->IndicesRedundantShortRoots.init(this->size);
  this->IndicesDoublesOfRedundantShortRoots.SetSize(this->size);
  this->TableAllowedAminus2B.init(this->size, this->size);
  this->TableAllowedAminusB.init(this->size, this->size);
  for (int i=0; i<this->size; i++)
  { for (int j=0; j<this->size; j++)
    { for (int k=0; k<theDimension; k++)
      { tempR.TheObjects[k] = this->TheObjects[i].TheObjects[k]-this->TheObjects[j].TheObjects[k];
        tempR2.TheObjects[k] = this->TheObjects[i].TheObjects[k]-2*this->TheObjects[j].TheObjects[k];
      }
      this->TableAllowedAminusB.elements[i][j]=this->getIndex(tempR);
      this->TableAllowedAminus2B.elements[i][j]=this->getIndex(tempR2);
    }
    tempR3=this->TheObjects[i];
    tempR3.MultiplyByInteger(2);
    this->IndicesDoublesOfRedundantShortRoots.TheObjects[i] = this->getIndex(tempR3);
    if (IndicesDoublesOfRedundantShortRoots.TheObjects[i]!=-1)
      this->IndicesRedundantShortRoots.AddSelectionAppendNewIndex(i);
  }
}

int RootToIndexTable::AddRootPreserveOrder(intRoot& theRoot)
{ this->AddObjectOnTopHash(theRoot);
  return this->size-1;
}

int RootToIndexTable::AddRootAndSort(intRoot& theRoot)
{ List<intRoot> tempList;
  tempList.CopyFromBase(*this);
  int index=0;
  for (index=0; index<tempList.size; index++)
    if (theRoot.IsHigherThanWRTWeight(tempList.TheObjects[index], this->weights))
      break;
  tempList.ShiftUpExpandOnTop(index);
  tempList.TheObjects[index]= theRoot;
  this->ClearTheObjects();
  for (int i=0; i<tempList.size; i++)
    this->AddObjectOnTopHash(tempList.TheObjects[i]);
  return index;
}

int RootToIndexTable::getIndex(intRoot& TheRoot)
{ return this->IndexOfObjectHash(TheRoot);
/*  int index= TheRoot.HashFunction();
  index%=this->HashSize;
  if (index<0){index+=this->HashSize; }
  for (int i=0; i<this->TheHashedArrays[index].size; i++)
  { int tempI= this->TheHashedArrays[index].TheObjects[i];
    if (this->TheObjects[tempI]==TheRoot)
    {return tempI; }
  }
  return -1; */
}

int RootToIndexTable::getIndexDoubleOfARoot(intRoot& TheRoot)
{ intRoot tempRoot;
  tempRoot=TheRoot;
  tempRoot.MultiplyByInteger(2);
  return this->getIndex(tempRoot);
}

void SelectionWithMultiplicities::initWithMultiplicities(int NumElements)
{ this->Multiplicities.SetSize(NumElements);
  for (int i=0; i<this->Multiplicities.size; i++)
    this->Multiplicities.TheObjects[i]=0;
  this->elements.MakeActualSizeAtLeastExpandOnTop(NumElements);
  this->elements.size=0;
}

void SelectionWithMultiplicities::ElementToString(std::string& output)
{ std::stringstream out;
  for (int i=0; i<this->elements.size; i++)
    out << "Index: " << this->elements.TheObjects[i] << "\nMultiplicity: " <<this->Multiplicities.TheObjects[this->elements.TheObjects[i]];
  output= out.str();
}

void SelectionWithMaxMultiplicity::initMaxMultiplicity(int NumElements, int MaxMult)
{ this->::SelectionWithMultiplicities::initWithMultiplicities(NumElements);
  this->MaxMultiplicity=MaxMult;
}

int ::SelectionWithMaxMultiplicity::CardinalitySelectionWithMultiplicities()
{ int result=0;
  for (int i=0; i<this->Multiplicities.size; i++)
    result+=this->Multiplicities.TheObjects[i];
  return result;
}

bool SelectionWithMaxMultiplicity::HasMultiplicitiesZeroAndOneOnly()
{ for(int i=0; i<this->elements.size; i++)
    if (this->Multiplicities.TheObjects[elements.TheObjects[i]]>1)
      return false;
  return true;
}

void SelectionWithMaxMultiplicity::IncrementSubsetFixedCardinality(int Cardinality)
{ if (Cardinality<1 || Cardinality>this->MaxMultiplicity*this->Multiplicities.size)
    return;
  if (this->CardinalitySelectionWithMultiplicities()!=Cardinality)
    this->Multiplicities.initFillInObject(this->Multiplicities.size, 0);
  if (this->CardinalitySelectionWithMultiplicities()==0)
  { for (int i=this->Multiplicities.size-1; Cardinality>0; i--)
    { if (Cardinality>=this->MaxMultiplicity)
        this->Multiplicities.TheObjects[i]=this->MaxMultiplicity;
      else
        this->Multiplicities.TheObjects[i]=Cardinality;
      Cardinality-=this->Multiplicities.TheObjects[i];
    }
    this->ComputeElements();
    return;
  }
  int firstNonZeroMult;
  int currentCardinality=Cardinality;
  for(firstNonZeroMult=this->Multiplicities.size-1; firstNonZeroMult>=0; firstNonZeroMult--)
    if (this->Multiplicities.TheObjects[firstNonZeroMult]>0)
      break;
  if (firstNonZeroMult==0)
    return;
  currentCardinality-=this->Multiplicities.TheObjects[firstNonZeroMult];
  this->Multiplicities.TheObjects[firstNonZeroMult]=0;
  for(int i=firstNonZeroMult-1; i>=0; i--)
  { if (this->Multiplicities.TheObjects[i]<this->MaxMultiplicity)
    { this->Multiplicities.TheObjects[i]++;
      currentCardinality++;
      break;
    } else
    { this->Multiplicities.TheObjects[i]=0;
      currentCardinality-=this->MaxMultiplicity;
    }
  }
  for (int i=this->Multiplicities.size-1; currentCardinality<Cardinality; i--)
  { assert(this->Multiplicities.TheObjects[i]==0);
    if (Cardinality-currentCardinality>=this->MaxMultiplicity)
      this->Multiplicities.TheObjects[i]=this->MaxMultiplicity;
    else
      this->Multiplicities.TheObjects[i]=Cardinality-currentCardinality;
    currentCardinality+=this->Multiplicities.TheObjects[i];
  }
  this->ComputeElements();
}

int ::SelectionWithMaxMultiplicity::NumCombinationsOfCardinality(int cardinality)
{ int fixThisShit;
  return ::MathRoutines::NChooseK(this->Multiplicities.size+cardinality-1, cardinality);
  int fixThisShit2;
  return fixThisShit2;
}

void SelectionWithMaxMultiplicity::IncrementSubset()
{ for (int i=this->Multiplicities.size-1; i>=0; i--)
    if (this->Multiplicities.TheObjects[i]<this->MaxMultiplicity)
    { if (this->Multiplicities.TheObjects[i]==0)
        this->elements.AddObjectOnTop(i);
      this->Multiplicities.TheObjects[i]++;
      return;
    }
    else
    { this->Multiplicities.TheObjects[i]=0;
      this->elements.RemoveFirstOccurenceSwapWithLast(i);
    }
}

void SelectionWithMultiplicities::ComputeElements()
{ this->elements.size=0;
  for (int i=0; i<this->Multiplicities.size; i++)
    if (this->Multiplicities.TheObjects[i]>0)
      this->elements.AddObjectOnTop(i);
}

int SelectionWithMultiplicities::CardinalitySelectionWithoutMultiplicities()
{ return this->elements.size;
}

int ::SelectionWithDifferentMaxMultiplicities::getTotalNumSubsets()
{ int result=1;
  for (int i=0; i<this->MaxMultiplicities.size; i++)
    result*=(this->MaxMultiplicities.TheObjects[i]+1);
  assert(result>=0);
  return result;
}

void SelectionWithDifferentMaxMultiplicities::initFromInts(int* theMaxMults, int NumberMaxMults)
{ this->Multiplicities.initFillInObject(NumberMaxMults, 0);
  this->MaxMultiplicities.SetSize(NumberMaxMults);
  for (int i=0; i<this->MaxMultiplicities.size; i++)
    this->MaxMultiplicities.TheObjects[i]=theMaxMults[i];
  this->elements.initFillInObject(NumberMaxMults, 0);
}

void SelectionWithDifferentMaxMultiplicities::initFromInts(const List<int>& theMaxMults)
{ this->Multiplicities.initFillInObject(theMaxMults.size, 0);
  this->elements.initFillInObject(theMaxMults.size, 0);
  this->MaxMultiplicities=theMaxMults;
}

int ::SelectionWithDifferentMaxMultiplicities::TotalMultiplicity()
{ int result=0;
  for (int i=0; i<this->Multiplicities.size; i++)
    result+=this->Multiplicities.TheObjects[i];
  return result;
}

int ::SelectionWithDifferentMaxMultiplicities::MaxTotalMultiplicity()
{ int result=0;
  for (int i=0; i<this->Multiplicities.size; i++)
    result+=this->MaxMultiplicities.TheObjects[i];
  return result;
}

void ::SelectionWithDifferentMaxMultiplicities::clearNoMaxMultiplicitiesChange()
{ for (int i=0; i<this->Multiplicities.size; i++)
    this->Multiplicities.TheObjects[i]=0;
}

void SelectionWithDifferentMaxMultiplicities::IncrementSubset()
{  for (int i=this->Multiplicities.size-1; i>=0; i--)
    if (this->Multiplicities.TheObjects[i]<this->MaxMultiplicities.TheObjects[i])
    { if (this->Multiplicities.TheObjects[i]==0)
        this->elements.AddObjectOnTop(i);
      this->Multiplicities.TheObjects[i]++;
      return;
    }
    else
    { this->Multiplicities.TheObjects[i]=0;
      this->elements.RemoveFirstOccurenceSwapWithLast(i);
    }
}

void WeylGroup::ReflectBetaWRTAlpha(root& alpha, root &Beta, bool RhoAction, root& Output)
{ Rational alphaShift, tempRat, lengthA;
  root result; result.Assign(Beta);
  alphaShift.MakeZero(); lengthA.MakeZero();
  if (RhoAction)
    result.Add(this->rho);
  for (int i=0; i<this->CartanSymmetric.NumRows; i++)
    for (int j=0; j<this->CartanSymmetric.NumCols; j++)
    { tempRat.Assign(result.TheObjects[j]);
      tempRat.MultiplyBy(alpha.TheObjects[i]);
      tempRat.MultiplyBy(this->CartanSymmetric.elements[i][j]*(-2));
      alphaShift+=(tempRat);
      tempRat.Assign(alpha.TheObjects[i]);
      tempRat.MultiplyBy(alpha.TheObjects[j]);
      tempRat.MultiplyBy(this->CartanSymmetric.elements[i][j]);
      lengthA+=(tempRat);
    }
  alphaShift.DivideBy(lengthA);
  Output.SetSize(this->CartanSymmetric.NumRows);
  for (int i=0; i<this->CartanSymmetric.NumCols; i++)
  { tempRat.Assign(alphaShift);
    tempRat.MultiplyBy(alpha.TheObjects[i]);
    tempRat+=(result.TheObjects[i]);
    Output.TheObjects[i].Assign(tempRat);
  }
  if (RhoAction)
    Output.Subtract(this->rho);
}

void WeylGroup::SimpleReflectionDualSpace(int index, root& DualSpaceElement)
{  Rational coefficient, tempRat;
  coefficient.Assign(DualSpaceElement.TheObjects[index]);
  coefficient.DivideBy(this->CartanSymmetric.elements[index][index]);
  for (int i=0; i<this->CartanSymmetric.NumCols; i++)
  { tempRat.Assign(coefficient);
    tempRat.MultiplyBy(this->CartanSymmetric.elements[index][i]*(-2));
    DualSpaceElement.TheObjects[i]+=(tempRat);
  }
}

void WeylGroup::SimpleReflectionRoot(int index, root& theRoot, bool RhoAction, bool UseMinusRho)
{ Rational alphaShift, tempRat;
  alphaShift.MakeZero();
  for (int i=0; i<this->CartanSymmetric.NumCols; i++)
  { tempRat.Assign(theRoot.TheObjects[i]);
    tempRat.MultiplyBy(this->CartanSymmetric.elements[index][i]*(-2));
    alphaShift+=(tempRat);
  }
  if (this->flagAnErrorHasOcurredTimeToPanic)
  { std::string tempS;
    alphaShift.ElementToString(tempS);
  }
  alphaShift.DivideBy(this->CartanSymmetric.elements[index][index]);
  if (RhoAction)
  { if(UseMinusRho)
      alphaShift.AddInteger(1);
    else
      alphaShift.AddInteger(-1);
  }
  theRoot.TheObjects[index]+=(alphaShift);
}

void WeylGroup::SimpleReflectionRootAlg( int index, PolynomialsRationalCoeff& theRoot, bool RhoAction)
{ int lengthA=this->CartanSymmetric.elements[index][index].NumShort;
  PolynomialRationalCoeff AscalarB, tempP;
  AscalarB.Nullify((int)this->CartanSymmetric.NumRows);
  for (int i=0; i<this->CartanSymmetric.NumCols; i++)
  { tempP.Nullify((int)this->CartanSymmetric.NumRows);
    tempP.CopyFromPoly(theRoot.TheObjects[i]);
    tempP.TimesConstant(CartanSymmetric.elements[index][i]);
    AscalarB.AddPolynomial(tempP);
  }
  AscalarB.TimesInteger(-2);
  AscalarB.DivByInteger(lengthA);
  theRoot.TheObjects[index].AddPolynomial(AscalarB);
  if (RhoAction){theRoot.TheObjects[index].AddConstant(RMOne); }
}

void WeylGroup::ActOnAffineHyperplaneByGroupElement(int index, affineHyperplane& output, bool RhoAction, bool UseMinusRho)
{ int tempI= this->TheObjects[index].size;
  for (int i=0; i<tempI; i++)
  { this->SimpleReflectionRoot(this->TheObjects[index].TheObjects[i], output.affinePoint, RhoAction, UseMinusRho);
//    output.affinePoint.ComputeDebugString();
    this->SimpleReflectionDualSpace(this->TheObjects[index].TheObjects[tempI-i-1], output.normal);
  }
}

void WeylGroup::GenerateAdditivelyClosedSubset(roots& input, roots& output)
{ output.CopyFromBase(input);
  root tempRoot;
  for (int i=0; i<output.size; i++)
    for (int j=i+1; j<output.size; j++)
    { tempRoot=output.TheObjects[i]+output.TheObjects[j];
      if (this->IsARoot(tempRoot))
        output.AddOnTopNoRepetition(tempRoot);
    }
}

void WeylGroup::Assign(const WeylGroup& right)
{ this->WeylLetter=right.WeylLetter;
  this->LongRootLength.Assign(right.LongRootLength);
//  this->ShortRootLength.Assign(right.ShortRootLength);
//  this->ShortLongScalarProdPositive.Assign(right.ShortLongScalarProdPositive);
//  this->LongLongScalarProdPositive.Assign(right.LongLongScalarProdPositive);
//  this->ShortShortScalarProdPositive.Assign(right.ShortShortScalarProdPositive);
  this->CartanSymmetricIntBuffer.Assign(right.CartanSymmetricIntBuffer);
  this->CartanSymmetric.Assign(right.CartanSymmetric);
  this->CopyFromHash(right);
  this->RootSystem.CopyFromHash(right.RootSystem);
  this->RootsOfBorel.CopyFromBase(right.RootsOfBorel);
  this->rho.Assign(right.rho);
}

void WeylGroup::ActOnRootByGroupElement(int index, root& theRoot, bool RhoAction, bool UseMinusRho)
{ for (int i=0; i<this->TheObjects[index].size; i++)
    this->SimpleReflectionRoot(this->TheObjects[index].TheObjects[i], theRoot, RhoAction, UseMinusRho);
}

void WeylGroup::GenerateRootSystemFromKillingFormMatrix()
{ root tempRoot;
  roots startRoots;
  hashedRoots tempHashedRootS;
  int theDimension=this->CartanSymmetric.NumCols;
  for (int i=0; i<theDimension; i++)
  { tempRoot.MakeEi(theDimension, i);
    startRoots.AddObjectOnTop(tempRoot);
  }
  this->GenerateOrbit(startRoots, false, tempHashedRootS, false);
  this->RootSystem.ClearTheObjects();
  this->RootsOfBorel.size=0;
  this->RootsOfBorel.MakeActualSizeAtLeastExpandOnTop(tempHashedRootS.size/2);
  this->RootSystem.MakeActualSizeAtLeastExpandOnTop(tempHashedRootS.size);
  for (int i=0; i<tempHashedRootS.size; i++)
    if (tempHashedRootS.TheObjects[i].IsPositiveOrZero())
      this->RootsOfBorel.AddObjectOnTop(tempHashedRootS.TheObjects[i]);
  this->RootsOfBorel.QuickSortAscending();
  for (int i=0; i<this->RootsOfBorel.size; i++)
    this->RootSystem.AddObjectOnTopHash(this->RootsOfBorel.TheObjects[i]);
  for (int i=0; i<this->RootsOfBorel.size; i++)
    this->RootSystem.AddObjectOnTopHash(-this->RootsOfBorel.TheObjects[i]);
}

void WeylGroup::GenerateOrbit(roots& theRoots, bool RhoAction, hashedRoots& output, bool UseMinusRho)
{ WeylGroup tempW;
  this->GenerateOrbit(theRoots, RhoAction, output, false, tempW, UseMinusRho, 0);
}

void WeylGroup::GenerateOrbit(roots& theRoots, bool RhoAction, hashedRoots& output, bool ComputingAnOrbitGeneratingSubsetOfTheGroup, WeylGroup& outputSubset, bool UseMinusRho, int UpperLimitNumElements)
{ for (int i=0; i<theRoots.size; i++)
    output.AddObjectOnTopHash(theRoots.TheObjects[i]);
  root currentRoot;
  ElementWeylGroup tempEW;
  if (ComputingAnOrbitGeneratingSubsetOfTheGroup)
  { int expectedNumElements=(this->GetSizeWeylByFormula(this->WeylLetter, this->GetDim())).NumShort;
    if (UpperLimitNumElements!=-1)
      expectedNumElements=MathRoutines::Minimum(UpperLimitNumElements, expectedNumElements);
    tempEW.size=0;
    outputSubset.MakeActualSizeAtLeastExpandOnTop(expectedNumElements);
    output.MakeActualSizeAtLeastExpandOnTop(expectedNumElements);
    outputSubset.CartanSymmetric.Assign(this->CartanSymmetric);
    outputSubset.size=0;
    outputSubset.AddObjectOnTopHash(tempEW);
  }
  for (int i=0; i<output.size; i++)
  { if (ComputingAnOrbitGeneratingSubsetOfTheGroup)
      tempEW=outputSubset.TheObjects[i];
    for (int j=0; j<this->CartanSymmetric.NumRows; j++)
    { currentRoot=output.TheObjects[i];
      //if (this->flagAnErrorHasOcurredTimeToPanic)
      //{ currentRoot.ComputeDebugString();
      //}
      this->SimpleReflectionRoot(j, currentRoot, RhoAction, UseMinusRho);
      //if (this->flagAnErrorHasOcurredTimeToPanic)
      //{ currentRoot.ComputeDebugString();
      //}
      if (output.IndexOfObjectHash(currentRoot)==-1)
      { output.AddObjectOnTopHash(currentRoot);
        if (ComputingAnOrbitGeneratingSubsetOfTheGroup)
        { tempEW.AddObjectOnTop(j);
          outputSubset.AddObjectOnTopHash(tempEW);
          tempEW.PopIndexSwapWithLast(tempEW.size-1);
        }
      }
      if (UpperLimitNumElements>0)
        if (outputSubset.size>=UpperLimitNumElements)
          return;
    }
  }
}

void WeylGroup::RootScalarCartanRoot(const root& r1, const root& r2, Rational& output)const
{ output.MakeZero();
  for (int i=0; i<this->CartanSymmetric.NumRows; i++)
    for (int j=0; j<this->CartanSymmetric.NumCols; j++)
    { Rational tempRat;
      tempRat.Assign(r1.TheObjects[i]);
      tempRat.MultiplyBy(r2.TheObjects[j]);
      tempRat.MultiplyBy(this->CartanSymmetric.elements[i][j]);
      output+=(tempRat);
    }
}

void WeylGroup::GenerateOrbitAlg(root& ChamberIndicator, PolynomialsRationalCoeff& input, PolynomialsRationalCoeffCollection& output, bool RhoAction, bool PositiveWeightsOnly, ConeGlobal* LimitingCone, bool onlyLowerWeights)
{ hashedRoots TheIndicatorsOrbit;
  WeylGroup OrbitGeneratingSubset;
  PolynomialOutputFormat PolyFormatLocal;
  roots tempRoots;
  tempRoots.size=0;
  tempRoots.AddRoot(ChamberIndicator);
  this->GenerateOrbit(tempRoots, RhoAction, TheIndicatorsOrbit, true, OrbitGeneratingSubset, false, 0);
  TheIndicatorsOrbit.ComputeDebugString();
  roots TempTest;
  root tempRoot;
  for (int i=0; i<OrbitGeneratingSubset.size; i++)
  { tempRoot = ChamberIndicator;
    OrbitGeneratingSubset.ActOnRootByGroupElement(i, tempRoot, RhoAction, false);
    TempTest.AddRoot(tempRoot);
  }
  TempTest.ComputeDebugString();
  PolynomialsRationalCoeff theRoot;
  PolyFormatLocal.MakeAlphabetxi();
  output.size=0;
  output.ChamberIndicators.size=0;
  output.MakeActualSizeAtLeastExpandOnTop(OrbitGeneratingSubset.size);
  input.ComputeDebugString();
  for (int i=0; i<OrbitGeneratingSubset.size; i++)
  { bool tempBool= TheIndicatorsOrbit.TheObjects[i].IsPositiveOrZero()||(!PositiveWeightsOnly);
    if (LimitingCone!=0)
      tempBool = tempBool && LimitingCone->IsInCone(TheIndicatorsOrbit.TheObjects[i]);
    if (onlyLowerWeights)
    { root tempRoot2;
      tempRoot2.Assign(ChamberIndicator);
      tempRoot2.Subtract(TheIndicatorsOrbit.TheObjects[i]);
      tempBool = tempBool && tempRoot2.IsPositiveOrZero();
    }
    if (tempBool)
    { theRoot= input;
      OrbitGeneratingSubset.ActOnRootAlgByGroupElement(i, theRoot, RhoAction);
      output.AddObjectOnTop(theRoot);
      output.ChamberIndicators.AddRoot(TheIndicatorsOrbit.TheObjects[i]);
    }
  }
  output.ComputeDebugString(this->CartanSymmetric.NumRows);
}

void WeylGroup::ActOnRootAlgByGroupElement(int index, PolynomialsRationalCoeff& theRoot, bool RhoAction)
{ for (int i=0; i<this->TheObjects[index].size; i++)
    this->SimpleReflectionRootAlg(this->TheObjects[index].TheObjects[i], theRoot, RhoAction);
}

void WeylGroup::ComputeWeylGroupAndRootsOfBorel(roots& output)
{ this->ComputeWeylGroup();
  output.size=0;
  for (int i=0; i<this->RootSystem.size; i++)
    if (this->RootSystem.TheObjects[i].IsPositiveOrZero())
      output.AddRoot(this->RootSystem.TheObjects[i]);
}

void WeylGroup::ComputeRootsOfBorel(roots& output)
{ output.size=0;
  this->RootSystem.ClearTheObjects();
  this->GenerateRootSystemFromKillingFormMatrix();
  output.CopyFromBase(this->RootsOfBorel);
}

void WeylGroup::ElementToString(std::string& output)
{ std::string tempS;
  std::stringstream out;
  out << "Size: " << this->size << "\n";
//  out <<"Number of roots: "<<this->RootSystem.size<<"\n";
  this->rho.ElementToString(tempS);
  out << "rho:" << tempS << "\n";
  this->RootSystem.ElementToString(tempS);
  out<< "Root system:\n" << tempS << "\n";
  out << "Elements of the group:\n";
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS);
    out << i << ". " << tempS << "\n";
  }
  output= out.str();
}

bool WeylGroup::IsAddmisibleDynkinType(char candidateLetter, int n)
{ if (candidateLetter=='A' && n>0)
    return true;
  if (candidateLetter=='B' && n>1)
    return true;
  if (candidateLetter=='C' && n>1)
    return true;
  if (candidateLetter=='D' && n>3)
    return true;
  if (candidateLetter=='E' && n>5 && n<9)
    return true;
  if (candidateLetter=='F' && n==4)
    return true;
  if (candidateLetter=='G' && n==2)
    return true;
  return false;
}

void WeylGroup::TransformToAdmissibleDynkinType(char inputLetter, int& outputRank)
{ if (inputLetter=='G')
    outputRank=2;
  if (inputLetter=='F')
    outputRank=4;
  if (inputLetter=='E')
  { if (outputRank>8)
      outputRank=8;
    if(outputRank<6)
      outputRank=6;
  }
  if (inputLetter=='C' || inputLetter=='B')
    if (outputRank<2)
      outputRank=2;
  if (inputLetter=='D')
    if (outputRank<4)
      outputRank=4;
}

void WeylGroup::MakeArbitrary(char WeylGroupLetter, int n)
{ switch(WeylGroupLetter)
  { case 'A': this->MakeAn(n);
    break;
    case 'B': this->MakeBn(n);
    break;
    case 'C': this->MakeCn(n);
    break;
    case 'D': this->MakeDn(n);
    break;
    case 'E': this->MakeEn(n);
    break;
    case 'F': this->MakeF4();
    break;
    case 'G': this->MakeG2();
    break;
  }
}

void WeylGroup::MakeDn(int n)
{ this->MakeAn(n);
  if (n<3)
    return;
  this->WeylLetter='D';
  this->CartanSymmetric.elements[n-1][n-2]=0;
  this->CartanSymmetric.elements[n-2][n-1]=0;
  this->CartanSymmetric.elements[n-3][n-1]=-1;
  this->CartanSymmetric.elements[n-1][n-3]=-1;
  this->UpdateIntBuffer();
}

void WeylGroup::MakeAn(int n)
{ if (n<0)
    return;
  this->WeylLetter='A';
  this->LongRootLength=2;
//  this->ShortRootLength=0;
//  this->ShortLongScalarProdPositive=0;
//  this->ShortShortScalarProdPositive=0;
//  this->LongLongScalarProdPositive=1;

  this->rho.SetSize(n);
  this->CartanSymmetric.init(n, n);
  this->CartanSymmetric.NullifyAll();
  for (int i=0; i<n-1; i++)
  { this->CartanSymmetric.elements[i][i]=2;
    this->CartanSymmetric.elements[i+1][i]=-1;
    this->CartanSymmetric.elements[i][i+1]=-1;
  }
  this->CartanSymmetric.elements[n-1][n-1]=2;
  this->UpdateIntBuffer();
}

void WeylGroup::MakeEn(int n)
{ this->MakeAn(n);
  if (n<4)
    return;
  this->WeylLetter='E';
  this->CartanSymmetric.elements[0][1]=0;
  this->CartanSymmetric.elements[1][0]=0;
  this->CartanSymmetric.elements[1][2]=0;
  this->CartanSymmetric.elements[2][1]=0;
  this->CartanSymmetric.elements[0][2]=-1;
  this->CartanSymmetric.elements[1][3]=-1;
  this->CartanSymmetric.elements[2][0]=-1;
  this->CartanSymmetric.elements[3][1]=-1;
  this->UpdateIntBuffer();
}

void WeylGroup::MakeF4()
{ this->WeylLetter='F';
  this->LongRootLength=4;
//  this->ShortRootLength=2;
//  this->LongLongScalarProdPositive=2;
//  this->ShortLongScalarProdPositive=2;
//  this->ShortShortScalarProdPositive=1;

  this->rho.SetSize(4);
  this->CartanSymmetric.init(4, 4);
  this->CartanSymmetric.elements[0][0]=2 ; this->CartanSymmetric.elements[0][1]=-1; this->CartanSymmetric.elements[0][2]=0 ; this->CartanSymmetric.elements[0][3]=0 ;
  this->CartanSymmetric.elements[1][0]=-1; this->CartanSymmetric.elements[1][1]=2 ; this->CartanSymmetric.elements[1][2]=-2; this->CartanSymmetric.elements[1][3]=0 ;
  this->CartanSymmetric.elements[2][0]=0 ; this->CartanSymmetric.elements[2][1]=-2; this->CartanSymmetric.elements[2][2]=4 ; this->CartanSymmetric.elements[2][3]=-2;
  this->CartanSymmetric.elements[3][0]=0 ; this->CartanSymmetric.elements[3][1]=0 ; this->CartanSymmetric.elements[3][2]=-2; this->CartanSymmetric.elements[3][3]=4 ;
  this->UpdateIntBuffer();
}

void WeylGroup::MakeG2()
{  this->WeylLetter='G';
  this->LongRootLength=6;
//  this->ShortRootLength=2;
//  this->LongLongScalarProdPositive=3;
//  this->ShortLongScalarProdPositive=3;
//  this->ShortShortScalarProdPositive=1;
  this->rho.SetSize(2);
  this->CartanSymmetric.init(2, 2);
  this->CartanSymmetric.elements[0][0]=6;
  this->CartanSymmetric.elements[1][1]=2;
  this->CartanSymmetric.elements[1][0]=-3;
  this->CartanSymmetric.elements[0][1]=-3;
  this->UpdateIntBuffer();
}

void WeylGroup::GetEpsilonCoordsWRTsubalgebra(roots& generators, List<root>& input, roots& output, GlobalVariables& theGlobalVariables)
{ MatrixLargeRational& basisChange = theGlobalVariables.matGetEpsilonCoords2;
  MatrixLargeRational& tempMat = theGlobalVariables.matGetEpsilonCoords3;
  DynkinDiagramRootSubalgebra& tempDyn = theGlobalVariables.dynGetEpsCoords;
  roots& simpleBasis = theGlobalVariables.rootsGetEpsCoords2;
  roots& coordsInNewBasis = theGlobalVariables.rootsGetEpsCoords3;
  simpleBasis.CopyFromBase(generators);
  tempDyn.ComputeDiagramTypeModifyInput(simpleBasis, *this);
  bool tempBool = true;
  if (generators.size==0)
    tempBool = false;
  if (!tempBool)
  { output.SetSize(input.size);
    for(int i=0; i<input.size; i++)
      output.TheObjects[i].MakeZero(0);
    return;
  }
  basisChange.Resize(0, 0, true);
  for (int i=0; i<tempDyn.SimpleBasesConnectedComponents.size; i++)
  { this->GetEpsilonMatrix(tempDyn.DynkinTypeStrings.TheObjects[i].at(1), tempDyn.SimpleBasesConnectedComponents.TheObjects[i].size, theGlobalVariables, tempMat);
    basisChange.DirectSumWith(tempMat, (Rational) 0);
    //basisChange.ComputeDebugString();
  }
  tempDyn.SimpleBasesConnectedComponents.CollectionToRoots(simpleBasis);
  coordsInNewBasis.SetSize(input.size);
  for (int i=0; i<input.size; i++)
    input.TheObjects[i].GetCoordsInBasis(simpleBasis, coordsInNewBasis.TheObjects[i], theGlobalVariables);
  //basisChange.ComputeDebugString();
  //coordsInNewBasis.ComputeDebugString();
  basisChange.ActOnRoots(coordsInNewBasis, output);
//  output.ComputeDebugString();
}

void WeylGroup::GetEpsilonCoords(char WeylLetter, int WeylRank, roots& simpleBasis, root& input, root& output, GlobalVariables& theGlobalVariables)
{ MatrixLargeRational& tempMat=theGlobalVariables.matGetEpsilonCoords;
  this->GetEpsilonMatrix(WeylLetter, WeylRank, theGlobalVariables, tempMat);
//  tempMat.ComputeDebugString();
  root result; result.MakeZero(tempMat.NumRows);
  Rational tempRat;
  for (int i=0; i<tempMat.NumRows; i++)
    for (int j=0; j<input.size; j++)
    { tempRat.Assign(tempMat.elements[i][j]);
      tempRat.MultiplyBy(input.TheObjects[j]);
      result.TheObjects[i]+=(tempRat);
    }
//  result.ComputeDebugString();
  output.Assign(result);
}

void WeylGroup::GetEpsilonMatrix(char WeylLetter, int WeylRank, GlobalVariables& theGlobalVariables, MatrixLargeRational& output)
{ //longer root has always smaller index
  if (WeylLetter=='A')
  { output.init(WeylRank+1, WeylRank);
    output.NullifyAll();
    for (int i=0; i<WeylRank; i++)
    { output.elements[i][i]=1;
      output.elements[i+1][i]=-1;
    }
    output.elements[WeylRank][WeylRank-1]=-1;
  }
  if (WeylLetter=='B')
  { output.init(WeylRank, WeylRank);
    output.NullifyAll();
    for (int i=0; i<WeylRank-1; i++)
    { output.elements[i][i]=1;
      output.elements[i+1][i]=-1;
    }
    output.elements[WeylRank-1][WeylRank-1]=1;
  }
  if (WeylLetter=='C')
  { output.init(WeylRank, WeylRank);
    output.NullifyAll();
    for (int i=0; i<WeylRank-1; i++)
    { output.elements[i][i]=1;
      output.elements[i][i+1]=-1;
    }
    output.elements[0][0]=2;
    output.elements[WeylRank-1][WeylRank-1]=1;
  }
  if (WeylLetter=='D')
  { //the triple node comes first, then the long string, then the two int strings.
    // the long string is oriented with the end that is connected to the triple node having
    //smaller index
    output.init(WeylRank, WeylRank);
    output.NullifyAll();
    for (int i=0; i<WeylRank-2; i++)
    { output.elements[i][WeylRank-3-i]=1;
      if (i!=0)
        output.elements[i][WeylRank-2-i]=-1;
    //  output.ComputeDebugString();
    }
    output.elements[WeylRank-2][0]=-1;
    output.elements[WeylRank-2][WeylRank-2]=1;
    output.elements[WeylRank-2][WeylRank-1]=1;
    output.elements[WeylRank-1][WeylRank-2]=1;
    output.elements[WeylRank-1][WeylRank-1]=-1;
  }
  if (WeylLetter=='E' && WeylRank==8)
  { //taken from Humpreys, Introduction to Lie algebras and representation theory, page 65
    //first comes the triple node, then the strip of length 4, then the strip of length 2 and finally the strip of lenght 1
    //as in D, all strips are oriented with the node linked to the triple node first
    output.init(WeylRank, WeylRank);
    output.NullifyAll();
    //\eps_1 coefficient:
    output.elements[0][5]=-1;
    output.elements[0][6]=RHalf;
    output.elements[0][7]=1;
    //\eps_2 coefficient:
    output.elements[1][0]=-1;
    output.elements[1][5]=1;
    output.elements[1][6]=RMHalf;
    output.elements[1][7]=1;
    //\eps_3 coefficient:
    output.elements[2][0]=1;
    output.elements[2][1]=-1;
    output.elements[2][6]=RMHalf;
    //\eps_4 coefficient:
    output.elements[3][1]=1;
    output.elements[3][2]=-1;
    output.elements[3][6]=RMHalf;
    //\eps_5 coefficient:
    output.elements[4][2]=1;
    output.elements[4][3]=-1;
    output.elements[4][6]=RMHalf;
    //\eps_6 coefficient:
    output.elements[5][3]=1;
    output.elements[5][4]=-1;
    output.elements[5][6]=RMHalf;
    //\eps_7 coefficient:
    output.elements[6][4]=1;
    output.elements[6][6]=RMHalf;
    //\eps_8 coefficient:
    output.elements[7][6]=RHalf;
  }
  if (WeylLetter=='E' && WeylRank==7)
  { output.init(8, 7);
    output.NullifyAll();
    //\eps_1 coefficient:
    output.elements[0][4]=-1;
    output.elements[0][5]=RHalf;
    output.elements[0][6]=1;
    //\eps_2 coefficient:
    output.elements[1][0]=-1;
    output.elements[1][4]=1;
    output.elements[1][5]=RMHalf;
    output.elements[1][6]=1;
    //\eps_3 coefficient:
    output.elements[2][0]=1;
    output.elements[2][1]=-1;
    output.elements[2][5]=RMHalf;
    //\eps_4 coefficient:
    output.elements[3][1]=1;
    output.elements[3][2]=-1;
    output.elements[3][5]=RMHalf;
    //\eps_5 coefficient:
    output.elements[4][2]=1;
    output.elements[4][3]=-1;
    output.elements[4][5]=RMHalf;
    //\eps_6 coefficient:
    output.elements[5][3]=1;
    output.elements[5][5]=RMHalf;
    //\eps_7 coefficient:
    output.elements[6][5]=RMHalf;
    //\eps_8 coefficient:
    output.elements[7][5]=RHalf;
  }
  if (WeylLetter=='E' && WeylRank==6)
  { output.init(8, 6);
    output.NullifyAll();
    //\eps_1 coefficient:
    output.elements[0][3]=-1;
    output.elements[0][4]=RHalf;
    output.elements[0][5]=1;
    //\eps_2 coefficient:
    output.elements[1][0]=-1;
    output.elements[1][3]=1;
    output.elements[1][4]=RMHalf;
    output.elements[1][5]=1;
    //\eps_3 coefficient:
    output.elements[2][0]=1;
    output.elements[2][1]=-1;
    output.elements[2][4]=RMHalf;
    //\eps_4 coefficient:
    output.elements[3][1]=1;
    output.elements[3][2]=-1;
    output.elements[3][4]=RMHalf;
    //\eps_5 coefficient:
    output.elements[4][2]=1;
    output.elements[4][4]=RMHalf;
    //\eps_6 coefficient:
    output.elements[5][4]=RMHalf;
    //\eps_7 coefficient:
    output.elements[6][4]=RMHalf;
    //\eps_8 coefficient:
    output.elements[7][4]=RHalf;
  }
  if (WeylLetter=='F')
  { //taken from Humpreys, Introduction to Lie algebras and representation theory, page 65
    // longer roots have smaller indices
    output.init(4, 4);
    output.NullifyAll();
    //eps_1:
    output.elements[0][3]=RHalf;
    //eps_2:
    output.elements[1][0]=1;
    output.elements[1][3]=RMHalf;
    //eps_3:
    output.elements[2][0]=-1;
    output.elements[2][1]=1;
    output.elements[2][3]=RMHalf;
    //eps_4:
    output.elements[3][1]=-1;
    output.elements[3][2]=1;
    output.elements[3][3]=RMHalf;
  }
  if (WeylLetter=='G')
  { // longer roots have smaller indices
    output.init(3, 2);
    output.NullifyAll();
    output.elements[0][0]=1;
    output.elements[1][0]=-1;

    output.elements[0][1]=-1; output.elements[0][1].DivideByInteger(3);
    output.elements[1][1]=2; output.elements[1][1].DivideByInteger(3);
    output.elements[2][1]=-1; output.elements[2][1].DivideByInteger(3);
  }
}

void WeylGroup::MakeBn(int n)
{ this->MakeAn(n);
  if (n<1)
    return;
//  this->ShortRootLength=1;
//  this->LongLongScalarProdPositive=1;
//  this->ShortLongScalarProdPositive=1;
//  this->ShortShortScalarProdPositive=0;
  this->WeylLetter='B';
  this->CartanSymmetric.elements[n-1][n-1]=1;
  this->UpdateIntBuffer();
}

void WeylGroup::MakeCn(int n)
{ this->MakeAn(n);
  if(n<2)
    return;
  this->LongRootLength=4;
//  this->ShortRootLength=2;
//  this->LongLongScalarProdPositive=2;
//  this->ShortLongScalarProdPositive=2;
//  this->ShortShortScalarProdPositive=1;
  this->WeylLetter='C';
  this->CartanSymmetric.elements[n-1][n-1]=4;
  this->CartanSymmetric.elements[n-2][n-1]=-2;
  this->CartanSymmetric.elements[n-1][n-2]=-2;
  this->UpdateIntBuffer();
}

void WeylGroup::ComputeWeylGroup()
{ this->ComputeWeylGroup(0);
}

void WeylGroup::ComputeWeylGroup(int UpperLimitNumElements)
{ this->ComputeRho(true);
//  this->ComputeDebugString();
  roots tempRoots;
  tempRoots.AddRoot(this->rho);
  this->ClearTheObjects();
  hashedRoots tempRoots2;
  tempRoots2.ClearTheObjects();
  this->GenerateOrbit(tempRoots, false, tempRoots2, true, *this, false, UpperLimitNumElements);
}

void WeylGroup::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

int WeylGroup::length(int index)
{ return this->TheObjects[this->size-1].size-this->TheObjects[index].size;
}

void WeylGroup::ComputeRho(bool Recompute)
{ if (this->RootSystem.size==0 || Recompute)
    this->GenerateRootSystemFromKillingFormMatrix();
  //this->ComputeDebugString();
  this->rho.MakeZero(this->CartanSymmetric.NumRows);
  for (int i=0; i<this->RootSystem.size; i++)
    if (RootSystem.TheObjects[i].IsPositiveOrZero() )
      this->rho.Add(RootSystem.TheObjects[i]);
  for (int i=0; i<this->CartanSymmetric.NumCols; i++)
    this->rho.TheObjects[i].DivideByInteger(2);
}

void ReflectionSubgroupWeylGroup::Assign(const ReflectionSubgroupWeylGroup& other)
{ this->CopyFromHash(other);
  this->simpleGenerators.CopyFromBase(other.simpleGenerators);
  this->ExternalAutomorphisms.CopyFromBase(other.ExternalAutomorphisms);
  this->AmbientWeyl.Assign(other.AmbientWeyl);
}

void ReflectionSubgroupWeylGroup::ElementToString(std::string& output)
{ std::stringstream out; std::string tempS;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS);
    out << tempS<<"\n";
  }
  this->ExternalAutomorphisms.ElementToStringGeneric(tempS);
  out << tempS;
  output=out.str();
}

void ReflectionSubgroupWeylGroup::ComputeRootSubsystem()
{ this->RootSubsystem.ClearTheObjects();
  this->RootSubsystem.AddRootsOnTopHash(this->simpleGenerators);
  root currentRoot;
  for (int i=0; i<this->RootSubsystem.size; i++)
    for (int j=0; j<this->simpleGenerators.size; j++)
    { currentRoot.Assign(this->RootSubsystem.TheObjects[i]);
      this->AmbientWeyl.ReflectBetaWRTAlpha(this->simpleGenerators.TheObjects[j], currentRoot, false, currentRoot);
      this->RootSubsystem.AddObjectOnTopNoRepetitionOfObjectHash(currentRoot);
    }
}

void ElementWeylGroup::operator =(const ElementWeylGroup& right)
{ this->CopyFromBase(right);
}

bool ElementWeylGroup::operator ==(const ElementWeylGroup& right)
{ if (this->size!=right.size)
    return false;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=right.TheObjects[i])
      return false;
  return true;
}

void ElementWeylGroup::ElementToString(std::string& output)
{ std::stringstream out;
  for (int i=0; i<this->size; i++)
    out <<this->TheObjects[i]<<", ";
  output= out.str();
}

int ElementWeylGroup::HashFunction() const
{ int top = MathRoutines::Minimum(this->size, ::SomeRandomPrimesSize);
  int result =0;
  for (int i=0; i<top; i++)
    result+=this->TheObjects[i]*::SomeRandomPrimes[i];
  return result;
}

void PolynomialsRationalCoeff::operator=(const PolynomialsRationalCoeff& right)
{ this->CopyFromBase(right);
}

void PolynomialsRationalCoeff::Substitution(PolynomialsRationalCoeff& theSub, int NumVarsTarget)
{ PolynomialRationalCoeff tempP;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].Substitution(theSub, tempP, NumVarsTarget, (Rational) 1);
    this->TheObjects[i].CopyFromPoly(tempP);
  }
}

void PolynomialsRationalCoeff::MakeOneParameterSubFromDirection(root& direction)
{ Monomial<Rational> tempM;
  tempM.init(1);
  tempM.degrees[0]=1;
  this->SetSize(direction.size);
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].Nullify(1);
    tempM.Coefficient.Assign(direction.TheObjects[i]);
    this->TheObjects[i].AddMonomial(tempM);
  }
}

void PolynomialsRationalCoeff::MakeOneParameterSubFromDirectionInts(int x1, int x2, int x3, int x4, int x5)
{ root tempRoot;
  tempRoot.InitFromIntegers(5, x1, x2, x3, x4, x5);
  this->MakeOneParameterSubFromDirection(tempRoot);
}


void PolynomialsRationalCoeff::MakeOneParameterSubFromDirectionIntsAndConstants(int x1, int x2, int x3, int x4, int x5, int c1, int c2, int c3, int c4, int c5)
{ this->MakeOneParameterSubFromDirectionInts(x1, x2, x3, x4, x5);
  Rational rc1, rc2, rc3, rc4, rc5;
  rc1.AssignInteger(c1); rc2.AssignInteger(c2);  rc3.AssignInteger(c3);
  rc4.AssignInteger(c4); rc5.AssignInteger(c5);
  this->TheObjects[0].AddConstant(rc1);
  this->TheObjects[1].AddConstant(rc2);
  this->TheObjects[2].AddConstant(rc3);
  this->TheObjects[3].AddConstant(rc4);
  this->TheObjects[4].AddConstant(rc5);
}

void PolynomialsRationalCoeff::MakeSubFromMatrixIntAndDen(MatrixIntTightMemoryFit &theMat, int Den)
{ MatrixLargeRational tempMat;
  tempMat.AssignMatrixIntWithDen(theMat, Den);
  this->MakeLinearSubWithConstTermFromMatrixRational(tempMat);
}

void PolynomialsRationalCoeff::MakeLinearSubWithConstTermFromMatrixRational(MatrixLargeRational &theMat)
{ this->SetSize(theMat.NumCols);
  for (int i=0; i<this->size; i++)
  { static Monomial<Rational> tempM;
    this->TheObjects[i].Nullify((int)theMat.NumRows-1);
    for (int j=0; j<theMat.NumRows-1; j++)
    { tempM.init((int)theMat.NumRows-1);
      tempM.degrees[j]=1;
      tempM.Coefficient.Assign(theMat.elements[j][i]);
      this->TheObjects[i].AddMonomial(tempM);
    }
    this->TheObjects[i].AddConstant(theMat.elements[theMat.NumRows-1][i]);
  }
}

bool PolynomialsRationalCoeff::operator==(const PolynomialsRationalCoeff& right)
{ assert(false);
  return false;
}

void intRoots::ElementToString(std::string& output)
{ std::string tempS;
  output.clear();
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS);
    output.append(tempS);
    output.append("\n");
  }
}

void intRoots::AssignRoots(roots& r)
{ this->SetSize(r.size);
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].AssignRoot(r.TheObjects[i]);
}

void intRoots::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

void intRoots::BubbleSort(intRoot* weights)
{ intRoot tempRoot;
  for (int i=0; i<this->size; i++)
    for (int j=i+1; j<this->size; j++)
    { bool tempBool;
      if (weights==0)
        tempBool = this->TheObjects[j].IsGEQNoWeight(this->TheObjects[i]);
      else
        tempBool = this->TheObjects[j].IsHigherThanWRTWeight(this->TheObjects[i], *weights);
      if (tempBool)
      { tempRoot= this->TheObjects[i];
        this->TheObjects[i]=this->TheObjects[j];
        this->TheObjects[j]=tempRoot;
      }
    }
}

void hashedRoots::ElementToString(std::string& output)
{ this->ElementToString(output, false);
}

void hashedRoots::ElementToString(std::string& output, bool useHtml)
{ std::stringstream  out;
  std::string tempS;
  out << "Number of vectors: " << this->size << "\n";
  if (useHtml)
    out << "\n<br>\n";
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS);
    out << tempS << "\n";
    if (useHtml)
      out << "\n<br>\n";
  }
  output= out.str();
}

void hashedRoots::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

void PolynomialsRationalCoeff::ElementToString(std::string& output)
{ output.clear();
  PolynomialOutputFormat PolyFormatLocal;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].StringPrintOutAppend(output, PolyFormatLocal, true);
    output.append("\n");
  }
}

void PolynomialsRationalCoeff::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

void PolynomialsRationalCoeff::ComputeB(PolynomialRationalCoeff& output, int cutOffIndex, int theDimension)
{ PolynomialsRationalCoeff EpsForm;
  PolynomialRationalCoeff tempP;
  EpsForm.SetSize(theDimension);
  EpsForm.TheObjects[0].CopyFromPoly(this->TheObjects[0]);
  for (int i=1; i<theDimension; i++)
  { EpsForm.TheObjects[i].CopyFromPoly(this->TheObjects[i]);
    tempP.CopyFromPoly(this->TheObjects[i-1]);
    tempP.TimesConstant(RMOne);
    EpsForm.TheObjects[i].AddPolynomial(tempP);
  }
  EpsForm.TheObjects[3].AddPolynomial(this->TheObjects[4]);
  for (int j=cutOffIndex+1; j<theDimension; j++)
    if (!EpsForm.TheObjects[j].IsGreaterThanZeroLexicographicOrder())
      EpsForm.TheObjects[j].TimesConstant(RMOne);
  output.Nullify(2);
  for (int i=0; i<theDimension; i++)
    output.AddPolynomial(EpsForm.TheObjects[i]);
}

void PolynomialsRationalCoeffCollection::ElementToString(std::string& output, int theDimension)
{ this->ElementToStringComputeFunctionB(output, false, theDimension);
}

void PolynomialsRationalCoeffCollection::ElementToStringComputeFunctionB(std::string& output, bool computingB, int theDimension)
{ std::string tempS;
  std::stringstream  out;
  out << "Number of elements: " << this->size << "\n";
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS);
    out << tempS;
    if (computingB)
    { static PolynomialRationalCoeff tempP;
      this->TheObjects[i].ComputeB(tempP, 2, theDimension);
      tempP.ComputeDebugString();
      out << "  function B: " << tempP.DebugString;
    }
    out << "\n";
  }
  output=out.str();
}

void PolynomialsRationalCoeffCollection::Substitution(PolynomialsRationalCoeff& theSub, int NumVarsTarget)
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].Substitution(theSub, NumVarsTarget);
}

void PolynomialsRationalCoeffCollection::ComputeDebugString(int theDimension)
{ this->ElementToString(this->DebugString, theDimension);
}

void VermaModulesWithMultiplicities::WriteKLCoeffsToFile(std::fstream& output, List<int>& KLcoeff, int TopIndex)
{ output.clear();
  output << "Top_index: " << TopIndex << "\n";
  std::string tempS;
  this->KLcoeffsToString(KLcoeff,  tempS);
  output << tempS;
}

int VermaModulesWithMultiplicities::ReadKLCoeffsFromFile(std::fstream& input, List<int>& output)
{ std::string tempS;
  int TopIndex;
  input >> tempS >>TopIndex;
  output.SetSize(this->size);
  for (int i=0; i<this->size; i++)
    input>>tempS >> output.TheObjects[i];
  return TopIndex;
}

void VermaModulesWithMultiplicities::KLcoeffsToString(List<int>& theKLCoeffs, std::string& output)
{ std::stringstream out;
  for (int i=0; i<theKLCoeffs.size; i++)
    out << i << ".  " << theKLCoeffs.TheObjects[i] << "\n";
  output=out.str();
}

void VermaModulesWithMultiplicities::initTheMults()
{ this->TheMultiplicities.SetSize(this->size);
  this->Explored.SetSize(this->size);
  for (int i=0; i<this->size; i++)
  { this->TheMultiplicities.TheObjects[i]=0;
    this->Explored.TheObjects[i]=false;
  }
  this->NextToExplore=0;
  this->LowestNonExplored=0;
}

void VermaModulesWithMultiplicities::Check()
{ for (int i=0; i<this->size; i++)
  { this->Compute(i);
//    bool found=false;
    for (int j=0; j<this->size; j++)
    { if (this->TheMultiplicities.TheObjects[i]!=0 && this->TheMultiplicities.TheObjects[i]!=1 && this->TheMultiplicities.TheObjects[i]!=-1)
      { this->ComputeDebugString();
        Stop();
      }
    }
  }
}

void VermaModulesWithMultiplicities::Compute(int x)
{ this->initTheMults();
  this->TheMultiplicities.TheObjects[x]=1;
  this->ComputeDebugString();
  while (this->NextToExplore!=-1)
  { for (int i=0; i<this->BruhatOrder.TheObjects[this->NextToExplore].size; i++)
    { int a=this->BruhatOrder.TheObjects[this->NextToExplore].TheObjects[i];
      this->TheMultiplicities.TheObjects[a]-=this->TheMultiplicities.TheObjects[this->NextToExplore];
    }
    this->Explored.TheObjects[this->NextToExplore]=true;
    this->FindNextToExplore();
  //  this->ComputeDebugString();
  }
}

void VermaModulesWithMultiplicities::FindNextToExplore()
{ bool foundNonExplored=false;
  for (int i=this->LowestNonExplored; i<this->size; i++)
  { if (!this->Explored.TheObjects[i])
    { if (!foundNonExplored)
      { this->LowestNonExplored=i;
        foundNonExplored=true;
      }
      if (this->IsMaxNonEplored(i))
      { this->NextToExplore=i;
        return;
      }
    }
  }
  this->NextToExplore=-1;
}

bool VermaModulesWithMultiplicities::IsMaxNonEplored(int index)
{ for (int i=this->LowestNonExplored; i<this->size; i++)
  { if (!this->Explored.TheObjects[i]&& i!=index)
    { root tempRoot;
      tempRoot.Assign(this->TheObjects[i]);
      tempRoot.Subtract(this->TheObjects[index]);
      if (tempRoot.IsPositiveOrZero())
        return false;
    }
  }
  return true;
}

void VermaModulesWithMultiplicities::ElementToString(std::string& output)
{ std::string tempS;
  std::stringstream out;
  out<<"Next to explore: "<<this->NextToExplore<<"\n Orbit of rho:\n";
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS);
    out << tempS<<"   :  "<<this->TheMultiplicities.TheObjects[i];
    if (this->Explored.TheObjects[i])
      out<<" Explored\n";
    else
      out<<" not Explored\n";
  }
  out<<"Bruhat order:\n";
  for (int i=0; i<this->size; i++)
  { out <<i<<".   ";
    for(int j=0; j<this->BruhatOrder.TheObjects[i].size; j++)
      out <<this->BruhatOrder.TheObjects[i].TheObjects[j]<<", ";
    out<<"\n";
  }
  this->RPolysToString(tempS);
  out<<"R Polynomials:\n"<<tempS;
  this->KLPolysToString(tempS);
  out<<"Kazhdan-Lusztig Polynomials:\n"<<tempS;
  output= out.str();
}

void VermaModulesWithMultiplicities::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

void VermaModulesWithMultiplicities::GeneratePartialBruhatOrder()
{ int theDimension= this->TheWeylGroup->CartanSymmetric.NumRows;
  root ZeroRoot; ZeroRoot.MakeZero(theDimension);
  this->BruhatOrder.SetSize(this->size);
  this->InverseBruhatOrder.SetSize(this->size);
  this->SimpleReflectionsActionList.SetSize(this->size);
  this->ComputeDebugString();
  for (int i=0; i<this->size; i++)
  { this->SimpleReflectionsActionList.TheObjects[i].MakeActualSizeAtLeastExpandOnTop(theDimension);
    for (int j=0; j<theDimension; j++)
    { root tempRoot, tempRoot2;
      tempRoot.Assign(this->TheObjects[i]);
      tempRoot2.Assign(this->TheObjects[i]);
      this->TheWeylGroup->SimpleReflectionRoot(j, tempRoot, true, false);
      int x= this->IndexOfObjectHash(tempRoot);
      this->SimpleReflectionsActionList.TheObjects[i].AddObjectOnTop(x);
      tempRoot2.Subtract(tempRoot);
      if (tempRoot2.IsPositiveOrZero() && !tempRoot2.IsEqualTo(ZeroRoot) )
      { this->BruhatOrder.TheObjects[i].AddObjectOnTop(x);
        this->InverseBruhatOrder.TheObjects[x].AddObjectOnTop(i);
      }
    }
  }
  this->ComputeDebugString();
}

void VermaModulesWithMultiplicities::ExtendOrder()
{ this->initTheMults();
  int x=this->FindLowestBruhatNonExplored();
  while (x!=-1)
  {  for (int j=0; j<this->BruhatOrder.TheObjects[x].size; j++)
    { int a= this->BruhatOrder.TheObjects[x].TheObjects[j];
      this->MergeBruhatLists(a, x);
    }
    this->Explored.TheObjects[x]=true;
    x=this->FindLowestBruhatNonExplored();
    this->ComputeDebugString();
  }
}

int VermaModulesWithMultiplicities::FindLowestBruhatNonExplored()
{ for (int i=this->size-1; i>=0; i--)
    if (!this->Explored.TheObjects[i])
    { bool isGood=true;
      for (int j=0; j<this->BruhatOrder.TheObjects[i].size; j++)
      { int a= this->BruhatOrder.TheObjects[i].TheObjects[j];
        if (!this->Explored.TheObjects[a])
        { isGood=false;
          break;
        }
      }
      if (isGood )
        return i;
    }
  return -1;
}

int VermaModulesWithMultiplicities::FindHighestBruhatNonExplored(List<bool>& theExplored)
{ for (int i=0; i<this->size; i++)
    if (!theExplored.TheObjects[i])
    { bool isGood=true;
      for (int j=0; j<this->InverseBruhatOrder.TheObjects[i].size-1; j++)
      { int a= this->InverseBruhatOrder.TheObjects[i].TheObjects[j];
        if (!theExplored.TheObjects[a])
        { isGood=false;
          break;
        }
      }
      if (isGood)
        return i;
    }
  return -1;
}

void VermaModulesWithMultiplicities::MergeBruhatLists(int fromList, int toList)
{ for (int i=0; i<this->BruhatOrder.TheObjects[fromList].size; i++)
  { bool found=false;
    for (int j=0; j<this->BruhatOrder.TheObjects[toList].size; j++)
      if (this->BruhatOrder.TheObjects[toList].TheObjects[j]==this->BruhatOrder.TheObjects[fromList].TheObjects[i])
      { found = true;
        break;
      }
    if (!found)
      this->BruhatOrder.TheObjects[toList].AddObjectOnTop(this->BruhatOrder.TheObjects[fromList].TheObjects[i]);
  }
}

void VermaModulesWithMultiplicities::ComputeFullBruhatOrder()
{ this->initTheMults();
  this->GeneratePartialBruhatOrder();
  this->ExtendOrder();
}

void VermaModulesWithMultiplicities::ComputeKLcoefficientsFromChamberIndicator(root& ChamberIndicator, List<int>& output)
{ this->ComputeKLcoefficientsFromIndex(this->ChamberIndicatorToIndex(ChamberIndicator), output);
}


int VermaModulesWithMultiplicities::ChamberIndicatorToIndex(root &ChamberIndicator)
{ int theDimension= this->TheWeylGroup->CartanSymmetric.NumRows;
  root ChamberIndicatorPlusRho;
  ChamberIndicatorPlusRho.Assign(ChamberIndicator);
  ChamberIndicatorPlusRho.Add(this->TheWeylGroup->rho);
  for (int i=0; i<this->size; i++)
  { Rational tempRat1, tempRat2;
    bool tempBool1, tempBool2;
    bool haveSameSigns=true;
    for (int j=0; j<this->TheWeylGroup->RootSystem.size; j++)
    { this->TheWeylGroup->RootScalarCartanRoot(ChamberIndicatorPlusRho, this->TheWeylGroup->RootSystem.TheObjects[j], tempRat1);
      static root tempRoot; tempRoot.SetSize(theDimension);
      tempRoot.Assign(this->TheObjects[i]);
      tempRoot.Add(this->TheWeylGroup->rho);
      this->TheWeylGroup->RootScalarCartanRoot(tempRoot, this->TheWeylGroup->RootSystem.TheObjects[j], tempRat2);
      tempBool1=tempRat1.IsPositive();
      tempBool2=tempRat2.IsPositive();
      assert(!tempRat1.IsEqualToZero());
      assert(!tempRat2.IsEqualToZero());
      if (tempBool1!=tempBool2)
      { haveSameSigns=false;
        break;
      }
    }
    if (haveSameSigns)
      return i;
  }
  return -1;
}

void VermaModulesWithMultiplicities::ComputeKLcoefficientsFromIndex(int ChamberIndex, List<int>& output)
{ output.SetSize(this->size);
  this->ComputeKLPolys(this->TheWeylGroup, ChamberIndex);
  for (int i=0; i<this->KLPolys.TheObjects[ChamberIndex].size; i++ )
  { output.TheObjects[i]=this->KLPolys.TheObjects[ChamberIndex].TheObjects[i].Substitution(1);
    if((this->TheWeylGroup->length(i)+this->TheWeylGroup->length(ChamberIndex))%2!=0)
      output.TheObjects[i]*=-1;
  }
}

void VermaModulesWithMultiplicities::initFromWeyl(WeylGroup* theWeylGroup)
{ this->TheWeylGroup= theWeylGroup;
  roots tempRoots;
  tempRoots.AddRoot(this->TheWeylGroup->rho);
  this->TheWeylGroup->GenerateOrbit(tempRoots, true, *this, false);
  this->initTheMults();
}

void VermaModulesWithMultiplicities::ComputeKLPolys(WeylGroup* theWeylGroup, int TopChamberIndex)
{  this->GeneratePartialBruhatOrder();
  PolynomialOutputFormat PolyFormatLocal;
  PolyFormatLocal.SetLetterIndex("q", 0);
  this->ComputeRPolys();
//  this->ComputeDebugString();
  this->KLPolys.SetSize(this->size);
  for (int i=0; i<this->size; i++)
    this->Explored.TheObjects[i]=false;
  this->KLPolys.TheObjects[TopChamberIndex].SetSize(this->size);
  int highestNonExplored = this->FindHighestBruhatNonExplored(this->Explored);
  while(highestNonExplored!=-1)
  { this->ComputeKLxy(TopChamberIndex, highestNonExplored);
    this->Explored.TheObjects[highestNonExplored]=true;
    highestNonExplored= this->FindHighestBruhatNonExplored(this->Explored);
  }
}

void VermaModulesWithMultiplicities::ComputeRPolys()
{ int theDimension= this->TheWeylGroup->CartanSymmetric.NumRows;
  this->RPolys.SetSize(this->size);
  for (int i=0; i<this->size; i++)
  { this->Explored.TheObjects[i]=false;
    this->RPolys.TheObjects[i].SetSize(this->size);
  }
  this->LowestNonExplored=this->FindLowestBruhatNonExplored();
  List<bool> ExploredFromTop;
  ExploredFromTop.SetSize(this->size);
  while(this->LowestNonExplored!=-1)
  { for (int i=0; i<this->size; i++)
      ExploredFromTop.TheObjects[i]=false;
    int a= this->FindHighestBruhatNonExplored(ExploredFromTop);
    while (a!=-1)
    { bool tempBool = false;
      for (int j=0; j<theDimension; j++)
        if (this->ComputeRxy(this->LowestNonExplored, a, j))
        { tempBool =true;
          break;
        }
      assert (tempBool);
      ExploredFromTop.TheObjects[a]=true;
      a= this->FindHighestBruhatNonExplored(ExploredFromTop);
    }
    this->Explored.TheObjects[this->LowestNonExplored]=true;
    this->LowestNonExplored= this->FindLowestBruhatNonExplored();
//    std::string tempS;
//    this->RPolysToString(tempS);
  }
  //this->ComputeDebugString();
}

bool VermaModulesWithMultiplicities::IndexGEQIndex(int a, int b)
{ root tempRoot;
  tempRoot.Assign(this->TheObjects[a]);
  tempRoot.Subtract(this->TheObjects[b]);
  return tempRoot.IsPositiveOrZero();
}

bool VermaModulesWithMultiplicities::IndexGreaterThanIndex(int a, int b)
{ if (a==b)
    return false;
  return this->IndexGEQIndex(a, b);
}

int VermaModulesWithMultiplicities::ComputeProductfromSimpleReflectionsActionList(int x, int y)
{ int start = y;
  for (int i=0; i<this->TheWeylGroup->TheObjects[x].size; i++)
    start=this->SimpleReflectionsActionList.TheObjects[start].TheObjects[this->TheWeylGroup->TheObjects[x].TheObjects[i]];
  return start;
}

void VermaModulesWithMultiplicities::ComputeKLxy(int w, int x)
{ OneVarIntPolynomial Accum, tempP1, tempP2;
  if (x==w)
  { this->KLPolys.TheObjects[w].TheObjects[x].MakeConst(1);
    return;
  }
  if (!this->IndexGEQIndex(w, x))
  { this->KLPolys.TheObjects[w].TheObjects[x].Nullify();
    return;
  }
  Accum.Nullify();
  this->KLPolys.TheObjects[w].TheObjects[x].Nullify();
  for (int i=0; i<this->size; i++)
  { if (this->IndexGreaterThanIndex(i, x) && this->IndexGEQIndex(w, i))
    { int tempI;
      if ((this->TheWeylGroup->length(x)+this->TheWeylGroup->length(i))%2==0)
        tempI=1;
      else
        tempI=-1;
      int powerQ= -this->TheWeylGroup->length(x)+2*this->TheWeylGroup->length(i) -this->TheWeylGroup->length(w);
//      this->RPolys.TheObjects[i].TheObjects[x].ComputeDebugString();
      tempP1.Assign(this->RPolys.TheObjects[i].TheObjects[x]);
//      tempP1.ComputeDebugString();
      tempP1.SubstitutionOneOverX();
//      tempP1.ComputeDebugString();
      tempP2.MakeMonomial(tempI, powerQ);
      tempP1.MultiplyBy(tempP2);
      tempP1.MultiplyBy(this->KLPolys.TheObjects[w].TheObjects[i]);
//      tempP1.ComputeDebugString();
      Accum.AddPolynomial(tempP1);
//      Accum.ComputeDebugString();
    }
  }
//  Accum.ComputeDebugString();
  int lengthDiff= this->TheWeylGroup->length(w)-this->TheWeylGroup->length(x);
  for (int i=0; i<Accum.RationalPart.size; i++)
    this->KLPolys.TheObjects[w].TheObjects[x].AddMonomial(-Accum.RationalPart.TheObjects[i], -i-1+lengthDiff);
//  this->KLPolys.TheObjects[x].TheObjects[w].ComputeDebugString();
}

bool VermaModulesWithMultiplicities::ComputeRxy(int x, int y, int SimpleReflectionIndex)
{ if (this->IndexGreaterThanIndex(y, x))
  { this->RPolys.TheObjects[x].TheObjects[y].Nullify();
    return true;
  }
  if (x==y)
  { this->RPolys.TheObjects[x].TheObjects[y].MakeMonomial(1, 0);
    return true;
  }
  int sx= this->SimpleReflectionsActionList.TheObjects[x].TheObjects[SimpleReflectionIndex];
  int sy= this->SimpleReflectionsActionList.TheObjects[y].TheObjects[SimpleReflectionIndex];
  bool boolX, boolY;
  boolX=this->IndexGreaterThanIndex(x, sx);
  boolY=this->IndexGreaterThanIndex(y, sy);
  if (boolX && boolY)
  { this->RPolys.TheObjects[x].TheObjects[y].Assign(this->RPolys.TheObjects[sx].TheObjects[sy]);
    return true;
  }
  if (boolX && !boolY)
  { OneVarIntPolynomial q2Minus1, Accum;
    q2Minus1.MakeQuadratic(1, 0, -1);
    Accum.MakeQuadratic(1, 0, 0);
//    this->RPolys.TheObjects[sx].TheObjects[y].ComputeDebugString();
    q2Minus1.MultiplyBy(this->RPolys.TheObjects[x].TheObjects[sy]);
//    this->RPolys.TheObjects[sx].TheObjects[sy].ComputeDebugString();
    Accum.MultiplyBy(this->RPolys.TheObjects[sx].TheObjects[sy]);
    Accum.AddPolynomial(q2Minus1);
    this->RPolys.TheObjects[x].TheObjects[y].Assign(Accum);
    return true;
  }
  return false;
}

void VermaModulesWithMultiplicities::KLPolysToString(std::string &output)
{ std::stringstream out;
  std::string tempS;
  for (int i=0; i<this->KLPolys.size; i++)
  { this->KLPolys.TheObjects[i].ElementToString(tempS, i);
    out << tempS << "\n";
  }
  output = out.str();
}

void VermaModulesWithMultiplicities::RPolysToString(std::string &output)
{ std::stringstream out;
  std::string tempS;
  for (int i=0; i<this->RPolys.size; i++)
  { this->RPolys.TheObjects[i].ElementToString(tempS, i);
    out << tempS << "\n";
  }
  output = out.str();
}

void OneVarPolynomials::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

void OneVarPolynomials::ElementToString(std::string& output)
{ std::string tempS;
  std::stringstream out;
  PolynomialOutputFormat PolyFormatLocal;
  for (int i=0; i<this->size; i++)
  { tempS.clear();
    this->TheObjects[i].StringPrintOutAppend(tempS, PolyFormatLocal, true);
    if (tempS!="")
      out << i << ". " << tempS << "; ";
  }
  output= out.str();
}

void OneVarPolynomials::ElementToString(std::string& output, int KLindex)
{ std::string tempS;
  std::stringstream out;
  PolynomialOutputFormat PolyFormatLocal;
  for (int i=0; i<this->size; i++)
  { tempS.clear();
    this->TheObjects[i].StringPrintOutAppend(tempS, PolyFormatLocal, true);
    if (tempS!="")
      out << KLindex << "||" << i << " " << tempS << "; ";
  }
  output= out.str();
}

void rootFKFTcomputation::initA2A1A1inD5()
{  //  int j=0;
  intRoot tempRoot;
  tempRoot.initFromInt(5, 0, 0, 1, 0, 0); //eps_3-\eps_4
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 0, 1, 1, 0, 0); //\eps_2-\eps_4
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 0, 0, 1, 1, 0); //eps_3-\eps_5
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 0, 0, 1, 0, 1); //eps_3+\eps_5
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 1, 1, 1, 0, 0); //eps_1-\eps_4
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 0, 1, 1, 1, 0); //eps_2-\eps_5
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 0, 1, 1, 0, 1); //eps_2+\eps_5
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 0, 0, 1, 1, 1); //eps_3+\eps_4
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 1, 1, 1, 1, 0); //eps_1-\eps_5
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 1, 1, 1, 0, 1); //eps_1+\eps_5
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 0, 1, 1, 1, 1); //eps_2+\eps_4
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 1, 1, 1, 1, 1); //eps_1+\eps_4
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 0, 1, 2, 1, 1); //eps_2+\eps_3
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 1, 1, 2, 1, 1); //eps_1+\eps_3
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 1, 2, 2, 1, 1); //eps_1+\eps_2
  this->nilradicalA2A1A1inD5.AddObjectOnTop(tempRoot);
  this->AlgorithmBasisA2A1A1inD5.CopyFromBase(this->nilradicalA2A1A1inD5);
  tempRoot.initFromInt(5, 0, 1, 0, 0, 0); //\eps_2-\eps_3
  this->AlgorithmBasisA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 0, 0, 0, 1, 0); //\eps_4-\eps_5
  this->AlgorithmBasisA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 0, 0, 0, 0, 1); //\eps_4+\eps_5
  this->AlgorithmBasisA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 0, 2, 2, 1, 1); //2\eps_2
  this->AlgorithmBasisA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 0, 0, 2, 1, 1); //2\eps_3
  this->AlgorithmBasisA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 0, 0, 0, 1, 1); //2\eps_4
  this->AlgorithmBasisA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 0, 0, 0, -1, 1); //2\eps_5
  this->AlgorithmBasisA2A1A1inD5.AddObjectOnTop(tempRoot);
  tempRoot.initFromInt(5, 10000, 1000, 100, 8, 10);
  this->AlgorithmBasisA2A1A1inD5.BubbleSort(&tempRoot);
  this->AlgorithmBasisA2A1A1inD5.ComputeDebugString();
}

rootFKFTcomputation::rootFKFTcomputation()
{ this->OutputFile = "C:/math/output.txt";
  this->TheGlobalVariables= new GlobalVariables;
#ifdef CGIversionLimitRAMuse
  ParallelComputing::GlobalPointerCounter++;
  ParallelComputing::CheckPointerCounters();
#endif
}

rootFKFTcomputation::~rootFKFTcomputation()
{ delete this->TheGlobalVariables;
#ifdef CGIversionLimitRAMuse
  ParallelComputing::GlobalPointerCounter--;
  ParallelComputing::CheckPointerCounters();
#endif
}

void rootFKFTcomputation::RunA2A1A1inD5beta12221()
{  this->initA2A1A1inD5();
//  RandomCodeIDontWantToDelete::SomeRandomTests2();
  if (this->useOutputFileForFinalAnswer)
  { std::fstream tempFile;
    tempFile.open(this->OutputFile.c_str(), std::fstream::in | std::fstream::out | std::fstream::app);
    QuasiPolynomialOld tempQP;
    tempQP.ReadFromFile(tempFile, 5);
    tempFile.close();
    this->processA2A1A1inD5beta12221Answer(tempQP);
    return;
  }
  std::fstream KLDump;
  std::fstream PartialFractionsFile;
  bool KLDumpIsPresent =this->OpenDataFileOrCreateIfNotPresent2(KLDump, this->KLCoeffFileString, false, false);
  bool PFfileIsPresent=this->OpenDataFileOrCreateIfNotPresent2(PartialFractionsFile, this->PartialFractionsFileString, false, false);
  bool VPIndexIsPresent= this->OpenDataFileOrCreateIfNotPresent2(partFractions::ComputedContributionsList, this->VPIndexFileString, false, false);
  this->OpenDataFileOrCreateIfNotPresent2(partFraction::TheBigDump, this->VPEntriesFileString, true, false);
  assert(partFraction::TheBigDump.is_open());
  assert(KLDump.is_open());
  assert(PartialFractionsFile.is_open());
  assert(partFractions::ComputedContributionsList.is_open());
  List<partFraction>::ListActualSizeIncrement=13000;
  partFractions theVPfunction;
  //theVPfunction.SetSize(8723);
  //assert(theVPfunction.VerifyFileComputedContributions());

  WeylGroup D5;
  D5.MakeDn(5);
//  D5.MakeAn(3);
  intRoots tempRoots1; roots tempRootsRat;
  D5.ComputeWeylGroup();
  D5.ComputeDebugString();
  VermaModulesWithMultiplicities tempV;
  tempV.initFromWeyl(&D5);
  root beta;
  beta.InitFromIntegers(5, 10, 20, 20, 20, 10);
  List<int> KLcoeff;
//  int TopIndex=
  tempV.ChamberIndicatorToIndex(beta);
  if (KLDumpIsPresent)
  { tempV.ReadKLCoeffsFromFile(KLDump, KLcoeff);
  }
  else
  { tempV.ComputeKLcoefficientsFromChamberIndicator(beta, KLcoeff);
    tempV.KLPolys.ReleaseMemory();
    tempV.RPolys.ReleaseMemory();
    tempV.WriteKLCoeffsToFile(KLDump, KLcoeff, tempV.ChamberIndicatorToIndex(beta));
  }
  KLDump.flush();
  KLDump.close();
//  tempV.ComputeDebugString();
  std::string tempS;
  //tempV.KLcoeffsToString(KLcoeff, tempS);
//  tempV.ComputeDebugString();

//  theVPfunction.initFromRootSystem(tempRoots1, tempRoots1, 0);
 /* partFractions tempTest;
  QuasiPolynomialOld tempQPtest;
  //tempTest.ComputeKostantFunctionFromWeylGroup('A', 3, tempQPtest, 0, false, false);
  this->OpenDataFileOrCreateIfNotPresent(PartialFractionsFile, this->PartialFractionsFileString, false);
  //tempTest.WriteToFile(PartialFractionsFile);
  tempTest.ReadFromFile(PartialFractionsFile);
  PartialFractionsFile.flush();
  PartialFractionsFile.close();
  tempTest.ComputeDebugString();
*/
  if(!PFfileIsPresent )
  { theVPfunction.ComputeDebugString(*this->TheGlobalVariables);
    theVPfunction.initFromRootSystem(  this->nilradicalA2A1A1inD5, this->AlgorithmBasisA2A1A1inD5, 0, *this->TheGlobalVariables);
    theVPfunction.splitClassicalRootSystem(true, *this->TheGlobalVariables, 0);
    theVPfunction.WriteToFile(PartialFractionsFile, *this->TheGlobalVariables);
  }
  else
    theVPfunction.ReadFromFile(PartialFractionsFile, *this->TheGlobalVariables);
  PartialFractionsFile.flush();
  PartialFractionsFile.close();
//  theVPfunction.ComputeDebugString();
  for (int i=0; i<theVPfunction.size; i++)
    assert(theVPfunction.TheObjects[i].IndicesNonZeroMults.size==5);
  QuasiPolynomialOld tempQP;
  beta.MultiplyByInteger(100);
  beta.Add(D5.rho);
  roots tempRoots;
  tempRoots.AssignIntRoots(this->nilradicalA2A1A1inD5);
  if (!VPIndexIsPresent)
    theVPfunction.WriteToFileComputedContributions(theVPfunction.ComputedContributionsList, *this->TheGlobalVariables);
  this->MakeTheRootFKFTSum(beta, theVPfunction, KLcoeff,  tempQP, tempV, tempRoots);
  std::fstream tempFile;
  tempFile.open(this->OutputFile.c_str(), std::fstream::out | std::fstream::trunc);
  tempQP.WriteToFile(tempFile);
  tempFile.close();
  this->processA2A1A1inD5beta12221Answer(tempQP);
  PartialFractionsFile.close();
}

void rootFKFTcomputation::processA2A1A1inD5beta12221Answer(QuasiPolynomialOld& theAnswer)
{ theAnswer.ComputeDebugString();
  root beta;
  beta.InitFromIntegers(5, 1, 2, 2, 2, 1);
  QPSub theSub;
  this->MakeRootFKFTsub(beta, theSub);
  QuasiPolynomialOld tempQP2;
  theAnswer.RationalLinearSubstitution(theSub, tempQP2);
  std::fstream tempFile;
  tempFile.open("C:/math/outSub.txt", std::fstream::out | std::fstream::trunc);
  tempQP2.WriteToFile(tempFile);
  tempFile.close();
  tempQP2.ComputeDebugString();
}

bool rootFKFTcomputation::OpenDataFile(std::fstream& theFile, std::string& theFileName)
{ theFile.open(theFileName.c_str(), std::fstream::in|std::fstream::out);
  if(theFile.is_open())
  { theFile.clear();
    theFile.seekp(0, std::ios_base::end);
    int tempI=theFile.tellp();
    if (tempI>=1)
    { theFile.seekg(0);
      return true;
    }
  }
  return false;
}

bool rootFKFTcomputation::OpenDataFileOrCreateIfNotPresent2
  (std::fstream& theFile, std::string& theFileName, bool OpenInAppendMode, bool openAsBinary)
{ if (OpenInAppendMode)
  { if (openAsBinary)
      theFile.open(theFileName.c_str(), std::fstream::in|std::fstream::out|std::fstream::app| std::fstream::binary);
    else
      theFile.open(theFileName.c_str(), std::fstream::in|std::fstream::out|std::fstream::app);
  } else
  { if (openAsBinary)
      theFile.open(theFileName.c_str(), std::fstream::in|std::fstream::out| std::fstream::binary);
    else
      theFile.open(theFileName.c_str(), std::fstream::in|std::fstream::out);
  }
  if(theFile.is_open())
  { theFile.clear(std::ios::goodbit); // false);
    theFile.seekp(0, std::ios_base::end);
    int tempI=theFile.tellp();
    if (tempI>=1)
      return true;
  }
  theFile.close();
  theFile.open(theFileName.c_str(), std::fstream::out |std::fstream::in| std::fstream::trunc);
  theFile.clear();
  return false;
}

void rootFKFTcomputation::MakeRootFKFTsub(root& direction, QPSub& theSub)
{ MatrixIntTightMemoryFit tempMat;
  tempMat.init(5+2, 5);
  tempMat.NullifyAll();
  int tempLCM=direction.FindLCMDenominatorsTruncateToInt();
  for (int i=0; i<5; i++)
  { tempMat.elements[i][i]=1;
    Rational tempRat;
    tempRat.Assign(direction.TheObjects[i]);
    tempRat.MultiplyByInt(tempLCM);
    tempMat.elements[5][i]=tempRat.NumShort;
    tempMat.elements[5+1][i]=0;
  }
  theSub.MakeSubFromMatrixIntAndDen(tempMat, tempLCM);
}

void rootFKFTcomputation::MakeTheRootFKFTSum(root& ChamberIndicator, partFractions& theBVdecomposition, List<int>& theKLCoeffs,  QuasiPolynomialOld& output, VermaModulesWithMultiplicities& theHighestWeights, roots& theNilradical)
{ PolynomialsRationalCoeffCollection TheChambersInTheGame;
  PolynomialsRationalCoeff StartingRoot;
  //::theGlobalVariables.theIndicatorVariables.TotalNumMonomials = theBVdecomposition.NumMonomialsInTheNumerators();
  ConeGlobal TheNilradicalCone;
  TheNilradicalCone.ComputeFromDirections(theNilradical, *this->TheGlobalVariables, 5);
  TheNilradicalCone.ComputeDebugString();
  StartingRoot.MakeIdSubstitution(5, (Rational) 1);
  theHighestWeights.TheWeylGroup->GenerateOrbitAlg(ChamberIndicator, StartingRoot, TheChambersInTheGame, true, false, &TheNilradicalCone, true);
  QuasiPolynomialOld tempQP1, Accum;
  Accum.Nullify(5);
  for (int i=0; i<TheChambersInTheGame.size; i++)
    if (theKLCoeffs.TheObjects[i]!=0)
    { tempQP1.Nullify(5);
      theBVdecomposition.partFractionsToPartitionFunctionAdaptedToRoot(tempQP1, TheChambersInTheGame.ChamberIndicators.TheObjects[i], true, true, *this->TheGlobalVariables, false);
//      tempQP1.ComputeDebugString();
      tempQP1.TimesInteger(theKLCoeffs.TheObjects[i]);
      Accum.AddPolynomial(tempQP1);
//      Accum.ComputeDebugString();
    }
  output.CopyFromPoly(Accum);
  output.Simplify();
}

void OneVarIntPolynomial::AddMonomial(int coeff, int power)
{ if (power<0)
  { power=-power;
    this->SetSizeAtLeastInitProperly(this->RationalPart, power);
    this->RationalPart.TheObjects[power-1]+=coeff;
  }
  else
  { this->SetSizeAtLeastInitProperly(this->PolynomialPart, power+1);
    this->PolynomialPart.TheObjects[power]+=coeff;
  }
  this->FitSize();
}

void OneVarIntPolynomial::SetSizeAtLeastInitProperly(List<int> &theArray, int desiredSize)
{ if (theArray.size<desiredSize)
  { int oldSize=theArray.size;
    theArray.SetSize(desiredSize);
    for (int i= oldSize; i<theArray.size; i++)
      theArray.TheObjects[i]=0;
  }
}

void OneVarIntPolynomial::AddPolynomial(OneVarIntPolynomial &p)
{ OneVarIntPolynomial::SetSizeAtLeastInitProperly(this->RationalPart, p.RationalPart.size);
  OneVarIntPolynomial::SetSizeAtLeastInitProperly(this->PolynomialPart, p.PolynomialPart.size);
  for (int i=0; i<p.PolynomialPart.size; i++)
    this->PolynomialPart.TheObjects[i]+=p.PolynomialPart.TheObjects[i];
  for (int i=0; i<p.RationalPart.size; i++)
    this->RationalPart.TheObjects[i]+=p.RationalPart.TheObjects[i];
  this->FitSize();
}

void OneVarIntPolynomial::MultiplyBy(OneVarIntPolynomial &p)
{ static OneVarIntPolynomial Accum;
  Accum.RationalPart.size=0;
  Accum.PolynomialPart.size=0;
  OneVarIntPolynomial::SetSizeAtLeastInitProperly(  Accum.PolynomialPart, this->PolynomialPart.size+p.PolynomialPart.size -1);
  OneVarIntPolynomial::SetSizeAtLeastInitProperly(  Accum.RationalPart, this->RationalPart.size+p.RationalPart.size);
  for (int i=0; i<this->PolynomialPart.size; i++)
  { for(int j=0; j<p.PolynomialPart.size; j++)
      Accum.PolynomialPart.TheObjects[i+j]+=this->PolynomialPart.TheObjects[i]*p.PolynomialPart.TheObjects[j];
    for(int j=0; j<p.RationalPart.size; j++)
      if (i-j-1<0)
        Accum.RationalPart.TheObjects[j-i]+=this->PolynomialPart.TheObjects[i]*p.RationalPart.TheObjects[j];
      else
        Accum.PolynomialPart.TheObjects[i-j-1]+=this->PolynomialPart.TheObjects[i]*p.RationalPart.TheObjects[j];
  }
  for (int i=0; i<this->RationalPart.size; i++)
  { for(int j=0; j<p.RationalPart.size; j++)
      Accum.RationalPart.TheObjects[i+j+1]+=this->RationalPart.TheObjects[i]*p.RationalPart.TheObjects[j];
    for(int j=0; j<p.PolynomialPart.size; j++)
      if (j-i-1<0)
        Accum.RationalPart.TheObjects[i-j]+=this->RationalPart.TheObjects[i]*p.PolynomialPart.TheObjects[j];
      else
        Accum.PolynomialPart.TheObjects[j-i-1]+=this->RationalPart.TheObjects[i]*p.PolynomialPart.TheObjects[j];
  }
  Accum.FitSize();
  this->Assign(Accum);
}

void OneVarIntPolynomial::SubstitutionOneOverX()
{ if (this->PolynomialPart.size-1>this->RationalPart.size)
  { int tempI;
    for(int i=0; i<this->RationalPart.size; i++)
    { tempI=this->RationalPart.TheObjects[i];
      this->RationalPart.TheObjects[i]=this->PolynomialPart.TheObjects[i+1];
      this->PolynomialPart.TheObjects[i+1]=tempI;
    }
    int oldSize= this->RationalPart.size;
    this->RationalPart.SetSize(this->PolynomialPart.size-1);
    for(int i=oldSize; i<this->PolynomialPart.size-1; i++)
      this->RationalPart.TheObjects[i]=this->PolynomialPart.TheObjects[i+1];
    this->PolynomialPart.size=oldSize+1;
  }
  else
  { int tempI;
    for(int i=1; i<this->PolynomialPart.size; i++)
    { tempI=this->RationalPart.TheObjects[i-1];
      this->RationalPart.TheObjects[i-1]=this->PolynomialPart.TheObjects[i];
      this->PolynomialPart.TheObjects[i]=tempI;
    }
    int oldSize= this->PolynomialPart.size;
    int start= oldSize;
    this->SetSizeAtLeastInitProperly(this->PolynomialPart, this->RationalPart.size+1);
    if (start==0)
    { start=1;
      if (this->RationalPart.size!=0)
        this->PolynomialPart.TheObjects[0]=0;
    }
    for(int i=start; i<this->RationalPart.size+1; i++)
      this->PolynomialPart.TheObjects[i]=this->RationalPart.TheObjects[i-1];
    this->RationalPart.size=oldSize-1;
    if (this->RationalPart.size<0){this->RationalPart.size=0; }
  }
}

void OneVarIntPolynomial::MakeMonomial(int coeff, int power)
{ this->PolynomialPart.size=0;
  this->RationalPart.size=0;
  if (power<0)
  { OneVarIntPolynomial::SetSizeAtLeastInitProperly(this->RationalPart, -power);
    this->RationalPart.TheObjects[-power-1]=coeff;
  }
  else
  { OneVarIntPolynomial::SetSizeAtLeastInitProperly(this->PolynomialPart, power+1);
    this->PolynomialPart.TheObjects[power]=coeff;
  }
}

void OneVarIntPolynomial::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

void OneVarIntPolynomial::ElementToString(std::string& output)
{ std::stringstream out;
  std::string tempS;
  for (int i=this->RationalPart.size-1; i>=0; i--)
    if (this->RationalPart.TheObjects[i]!=0)
    { std::stringstream out2;
      if (this->RationalPart.TheObjects[i]==-1)
        out2 << "-";
      else
        if (this->RationalPart.TheObjects[i]!=1)
          out2 << this->RationalPart.TheObjects[i];
      out2 << "q^{" << -i-1 << "}";
      tempS=out2.str();
      if (tempS[0]!='-')
        tempS.insert(0, "+");
      out << tempS;
    }
  if (this->PolynomialPart.size>0)
  { if (this->PolynomialPart.TheObjects[0]>0)
      out << "+" << this->PolynomialPart.TheObjects[0];
    if (this->PolynomialPart.TheObjects[0]<0)
      out << this->PolynomialPart.TheObjects[0];
  }
  for (int i=1; i<this->PolynomialPart.size; i++)
  { if (this->PolynomialPart.TheObjects[i]!=0)
    { std::stringstream out2;
      if (this->PolynomialPart.TheObjects[i]==-1)
        out2 << "-";
      else
        if (this->PolynomialPart.TheObjects[i]!=1)
          out2 << this->PolynomialPart.TheObjects[i];
      if (i!=1)
        out2 << "q^{" << i << "}";
      else
        out2 << "q";
      tempS=out2.str();
      if (tempS[0]!='-')
        tempS.insert(0, "+");
      out << tempS;
    }
  }
  output= out.str();
  if (output.size()>0)
    if (output[0]=='+')
      output.erase(0, 1);
}

int OneVarIntPolynomial::Substitution(int x)
{ assert(this->RationalPart.size==0);
  int result=0;
  for (int i=0; i<this->PolynomialPart.size; i++)
  { int accum=1;
    for (int j=0; j<i; j++)
      accum*=x;
    result+=accum*PolynomialPart.TheObjects[i];
  }
  return result;
}

void OneVarIntPolynomial::Nullify()
{ this->RationalPart.size=0;
  this->PolynomialPart.size=0;
}

void OneVarIntPolynomial::MakeConst(int c)
{ this->RationalPart.size=0;
  this->PolynomialPart.SetSize(1);
  this->PolynomialPart.TheObjects[0]=c;
}

void OneVarIntPolynomial::MakeQuadratic(int x2Term, int x1Term, int constTerm)
{ this->RationalPart.size=0;
  this->PolynomialPart.SetSize(3);
  this->PolynomialPart.TheObjects[0]= constTerm;
  this->PolynomialPart.TheObjects[1]= x1Term;
  this->PolynomialPart.TheObjects[2]= x2Term;
}

void OneVarIntPolynomial::ReleaseMemory()
{ this->RationalPart.ReleaseMemory();
  this->PolynomialPart.ReleaseMemory();
}

void OneVarIntPolynomial::FitSize()
{ int sizeDecrease=0;
  for (int i=this->PolynomialPart.size-1; i>=0; i--)
  { if (this->PolynomialPart.TheObjects[i]==0)
      sizeDecrease++;
    else
      break;
  }
  this->PolynomialPart.size-=sizeDecrease;
  sizeDecrease=0;
  for (int i=this->RationalPart.size-1; i>=0; i--)
  { if (this->RationalPart.TheObjects[i]==0)
      sizeDecrease++;
    else
      break;
  }
  this->RationalPart.size-=sizeDecrease;
}

void OneVarIntPolynomials::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

void OneVarIntPolynomials::ElementToString(std::string& output)
{ std::string tempS;
  std::stringstream out;
  for (int i=0; i<this->size; i++)
  { tempS.clear();
    this->TheObjects[i].ElementToString(tempS);
    if (tempS!="")
      out << i << ". " << tempS << "; ";
  }
  output= out.str();
}

void OneVarIntPolynomials::ElementToString(std::string& output, int KLindex)
{ std::string tempS;
  std::stringstream out;
  for (int i=0; i<this->size; i++)
  { tempS.clear();
    this->TheObjects[i].ElementToString(tempS);
    if (tempS!="")
      out << KLindex << "||" << i << " " << tempS << "; ";
  }
  output= out.str();
}

int IntegerPoly::EvaluateAtOne()
{ int result=0;
  for(int i=0; i<this->size; i++)
    result+=this->TheObjects[i].Coefficient.value;
  return result;
}

void IntegerPoly::Evaluate(root& values, Rational& output)
{ std::string tempS1, tempS2;
  output.MakeZero();
  //if(this->flagAnErrorHasOccurredTimeToPanic)
  //{ output.ElementToString(tempS1);
  //}
  for (int i=0; i<this->size; i++)
  { Rational tempRat1, tempRat2;
    tempRat1.AssignInteger(this->TheObjects[i].Coefficient.value);
    for (int j=0; j<this->NumVars; j++)
    { tempRat2.Assign(values.TheObjects[j]);
      if (tempRat2.IsEqualToZero())
      { tempRat1.MakeZero();
        break;
      }
      tempRat2.RaiseToPower(this->TheObjects[i].degrees[j]);
      tempRat1.MultiplyBy(tempRat2);
      ParallelComputing::SafePoint();
    }
//    if(this->flagAnErrorHasOccurredTimeToPanic)
//    { output.ElementToString(tempS2);
//      tempRat1.ElementToString(tempS1);
//      if (i==5)
//      { //Rational::flagAnErrorHasOccurredTimeToPanic=true;
//      }
//    }
    output+=(tempRat1);
//    if(this->flagAnErrorHasOccurredTimeToPanic)
//    { output.ElementToString(tempS2);
//    }
  }
}

void IntegerPoly::MakePolyExponentFromIntRoot(intRoot&r)
{ this->ClearTheObjects();
  this->NumVars=(int)r.size;
  Monomial<Integer> tempM;
  tempM.init((int)r.size);
  tempM.Coefficient.Assign(IOne);
  for (int i=0; i<r.size; i++)
    tempM.degrees[i]=(int) r.TheObjects[i];
  this->AddMonomial(tempM);
}

int IntegerPoly::SizeWithoutDebugString()
{ int Accum=0;
  Accum+=this->HashedList<Monomial<Integer> >::SizeWithoutObjects();
  Accum+=  sizeof(this->NumVars);
  for (int i=0; i<this->ActualSize; i++)
    Accum+=this->TheActualObjects[i].SizeWithoutCoefficient()+sizeof(Integer);
  return Accum;
}

void LaTeXProcedures::beginPSTricks(std::fstream& output)
{ output << "\\begin{pspicture}(8, 8)";
}

void LaTeXProcedures::endPSTricks(std::fstream& output)
{ output << "\\end{pspicture}\\medskip \\\\ \\noindent ";
}

void LaTeXProcedures::beginDocument(std::fstream& output)
{ output << "\\documentclass{article}\n \\usepackage{pstricks} \\begin{document}";
}

void LaTeXProcedures::endLatexDocument(std::fstream& output)
{ output << "\\end{document}";
}

void LaTeXProcedures::GetStringFromColorIndex(int ColorIndex, std::string &output, DrawingVariables& drawInput)
{ switch(ColorIndex)
  { case 0: output.assign("black"); break;
    case 1: output.assign("blue"); break;
    case 2: output.assign("purple"); break;
    case 3: output.assign("green"); break;
    case 4: output.assign("cyan"); break;
    case 5: output.assign("red"); break;
    case 6: output.assign("purple"); break;
    case 7: output.assign("cyan"); break;
    case 56540: output.assign("yellow"); break;
    default:
      output.assign("black");
      break;
  }
  if(ColorIndex==drawInput.Colors[1])
    output.assign("blue");
  if(ColorIndex==drawInput.Colors[2])
    output.assign("purple");
  if(ColorIndex==drawInput.Colors[3])
    output.assign("green");
  if(ColorIndex==drawInput.Colors[4])
    output.assign("cyan");
  if(ColorIndex==drawInput.Colors[5])
    output.assign("red");
  if(ColorIndex==drawInput.Colors[6])
    output.assign("purple");
  if(ColorIndex==drawInput.Colors[7])
    output.assign("cyan");
}

void LaTeXProcedures::drawTextDirectly(double X1, double Y1, const std::string& theText, int ColorIndex, std::fstream& output)
{ output.precision(4);
  X1-=theText.length()* LaTeXProcedures::TextPrintCenteringAdjustmentX;
  Y1+=LaTeXProcedures::TextPrintCenteringAdjustmentY;
  X1/=LaTeXProcedures::ScaleFactor; Y1/=LaTeXProcedures::ScaleFactor;
  output << "\\put(" << X1-LaTeXProcedures::FigureCenterCoordSystemX << ", " << LaTeXProcedures::FigureCenterCoordSystemY-Y1 << "){\\tiny{" << theText << "}}";
}

void LaTeXProcedures::drawline(double X1, double Y1, double X2, double Y2, unsigned long thePenStyle, int ColorIndex, std::fstream& output, DrawingVariables& drawInput)
{ if ((int)thePenStyle== DrawingVariables::PenStyleInvisible)
    return;
  output.precision(4);
  X1/=LaTeXProcedures::ScaleFactor; X2/=LaTeXProcedures::ScaleFactor;
  Y1/=LaTeXProcedures::ScaleFactor; Y2/=LaTeXProcedures::ScaleFactor;
  std::string tempS;
  if (thePenStyle==(unsigned)DrawingVariables::PenStyleDashed)
    tempS="lightgray";
  else
    LaTeXProcedures::GetStringFromColorIndex(ColorIndex, tempS, drawInput);
  output << "\\psline[linewidth=0.3pt, linecolor=" << tempS << "](" << X1-LaTeXProcedures::FigureCenterCoordSystemX << ", " << LaTeXProcedures::FigureCenterCoordSystemY-Y1 << ")" << "(" << X2-LaTeXProcedures::FigureCenterCoordSystemX << ", " << LaTeXProcedures::FigureCenterCoordSystemY-Y2 << ")\n";
}

void thePFcomputation::Run()
{ this->theWeylGroup.MakeEn(6);
  this->theWeylGroup.GenerateRootSystemFromKillingFormMatrix();
  this->theWeylGroup.RootSystem.ComputeDebugString();
  this->ComputeTableAllowed();
  this->ComputeDebugString();
  this->EnumerateRecursively(0, 0, 6);
  Stop();
}

void thePFcomputation::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

void thePFcomputation::ElementToString(std::string& output)
{ std::stringstream out;
  out << "tableForbidden:\n";
  for (int i=0; i<this->tableForbidden.size; i++)
  { out << i << "\t\t\t";
    for (int j=0; j<this->tableForbidden.TheObjects[i].CardinalitySelection; j++)
      out << this->tableForbidden.TheObjects[i].elements[j] << ", ";
    out << "\n";
  }
  output= out.str();
}

void thePFcomputation::ComputeTableAllowed()
{ this->tableForbidden.SetSize(this->theWeylGroup.RootSystem.size);
  this->theKillingForm.Assign(this->theWeylGroup.CartanSymmetric);
  this->theKillingForm.ComputeDebugString();
  this->theForbiddenSelections.SetSize(this->theWeylGroup.RootSystem.size);
  for (int i=0; i<this->theWeylGroup.RootSystem.size; i++)
  { this->tableForbidden.TheObjects[i].init(this->theWeylGroup.RootSystem.size);
    for (int j=0; j<this->theWeylGroup.RootSystem.size; j++)
    { Rational tempRat;
      root::RootScalarRoot(this->theWeylGroup.RootSystem.TheObjects[i], this->theWeylGroup.RootSystem.TheObjects[j], this->theKillingForm, tempRat);
      if (tempRat.IsPositive() || tempRat.NumShort==-2)
        tableForbidden.TheObjects[i].AddSelectionAppendNewIndex(j);
    }
    this->theForbiddenSelections.TheObjects[i].init(this->theWeylGroup.RootSystem.size);
  }
  this->theSelection.init(this->theWeylGroup.RootSystem.size);
  this->LCMdeterminants=1;
  this->TotalNumEnumerated=0;
}

void thePFcomputation::EnumerateRecursively(int depth, int startingIndex, int theDimension)
{ if (depth==theDimension)
  {  //this->theSelection.ComputeDebugString();
    this->TotalNumEnumerated++;
    this->ComputeDeterminantSelection(theDimension);
    return;
  }
  for (int i=startingIndex; i<this->theWeylGroup.RootSystem.size; i++)
    if (!this->theForbiddenSelections.TheObjects[depth].selected[i])
    { this->theSelection.AddSelectionAppendNewIndex(i);
  //    this->theSelection.ComputeDebugString();
      if (depth+1!=theDimension)
        this->ComputeNewRestrictionsFromOld(depth+1, i);
      this->EnumerateRecursively(depth+1, i+1, theDimension);
      this->theSelection.RemoveLastSelection();
    }
}

void thePFcomputation::ComputeNewRestrictionsFromOld(int depth, int newIndex)
{ this->theForbiddenSelections.TheObjects[depth].Assign(this->theForbiddenSelections.TheObjects[depth-1]);
//  this->theForbiddenSelections.TheObjects[depth].ComputeDebugString();
  for(int i=0; i<this->tableForbidden.TheObjects[newIndex].CardinalitySelection; i++)
    this->theForbiddenSelections.TheObjects[depth].AddSelectionAppendNewIndex(this->tableForbidden.TheObjects[newIndex].elements[i]);
}

void thePFcomputation::ComputeDeterminantSelection(int theDimension)
{  static MatrixLargeRational tempMat;
  this->SelectionToMatrixRational(tempMat, theDimension);
  //tempMat.ComputeDebugString();
  Rational tempRat;
  tempMat.ComputeDeterminantOverwriteMatrix(tempRat);
  if (tempRat.NumShort==0) return;
  if (tempRat.NumShort<0){tempRat.Minus(); }
  this->LCMdeterminants= MathRoutines::lcm(tempRat.NumShort, this->LCMdeterminants);
  //tempMat.ComputeDebugString();
}

void thePFcomputation::SelectionToString(std::string &output, int theDimension)
{ MatrixLargeRational tempMat;
  this->SelectionToMatrixRational(tempMat, theDimension);
  tempMat.ElementToString(output);
}

void thePFcomputation::SelectionToMatrixRational(MatrixLargeRational& output, int theDimension)
{ output.init((int)theDimension, (int)theDimension);
  for (int i=0; i<theDimension; i++)
    for (int j=0; j<theDimension; j++)
      output.elements[i][j].Assign(this->theWeylGroup.RootSystem.TheObjects[this->theSelection.elements[i]].TheObjects[j]);
}

void rootSubalgebra::ComputeDynkinDiagramKandCentralizer()
{ this->SimpleBasisK.CopyFromBase(this->genK);
  this->theDynkinDiagram.ComputeDiagramTypeModifyInput(this->SimpleBasisK, this->AmbientWeyl);
  this->SimpleBasisCentralizerRoots.size=0;
  for (int i=0; i<this->AmbientWeyl.RootsOfBorel.size; i++)
    if (this->rootIsInCentralizer(this->AmbientWeyl.RootsOfBorel.TheObjects[i]))
      this->SimpleBasisCentralizerRoots.AddObjectOnTop(this->AmbientWeyl.RootsOfBorel.TheObjects[i]);
  this->theCentralizerDiagram.ComputeDiagramTypeModifyInput(this->SimpleBasisCentralizerRoots, this->AmbientWeyl);
}

void rootSubalgebra::ComputeAllButAmbientWeyl()
{ this->PosRootsKConnectedComponents.size=0;
  this->theKComponentRanks.size=0;
  this->theKEnumerations.size=0;
  this->SimpleBasisK.CopyFromBase(this->genK);
  this->AmbientWeyl.TransformToSimpleBasisGenerators(this->SimpleBasisK);
  this->ComputeKModules();
  this->ComputeCentralizerFromKModulesAndSortKModules();
  this->NilradicalKmods.init(this->kModules.size);
  this->theDynkinDiagram.ComputeDiagramTypeModifyInput(this->SimpleBasisK, this->AmbientWeyl);
  this->theCentralizerDiagram.ComputeDiagramTypeModifyInput(this->SimpleBasisCentralizerRoots, this->AmbientWeyl);
}

void rootSubalgebra::ComputeAll()
{ this->initFromAmbientWeyl();
  this->ComputeAllButAmbientWeyl();
  //this->ComputeDebugString();
}

void rootSubalgebra::ComputeCentralizerFromKModulesAndSortKModules()
{ this->CentralizerKmods.init(this->kModules.size);
  this->CentralizerRoots.size=0;
  this->CentralizerRoots.MakeActualSizeAtLeastExpandOnTop(this->kModules.size);
  this->SimpleBasisCentralizerRoots.size=0;
  this->SimpleBasisCentralizerRoots.MakeActualSizeAtLeastExpandOnTop(this->kModules.size);
  int counter=0;
  for (int i=0; i<this->kModules.size; i++)
    if (this->kModules.TheObjects[i].size==1)
    { this->kModules.SwapTwoIndices(counter, i);
      this->HighestWeightsGmodK.SwapTwoIndices(counter, i);
      this->LowestWeightsGmodK.SwapTwoIndices(counter, i);
      this->CentralizerKmods.AddSelectionAppendNewIndex(counter);
      this->CentralizerRoots.AddRoot(this->kModules.TheObjects[counter].TheObjects[0]);
      this->SimpleBasisCentralizerRoots.AddRoot(this->kModules.TheObjects[counter].TheObjects[0]);
      counter++;
    }
  this->AmbientWeyl.TransformToSimpleBasisGenerators(this->SimpleBasisCentralizerRoots);
}

void rootSubalgebra::initFromAmbientWeyl()
{ this->AmbientWeyl.GenerateRootSystemFromKillingFormMatrix();
}

void WeylGroup::TransformToSimpleBasisGenerators(roots& theGens)
{ for (int i=0; i<theGens.size; i++)
    if (!theGens.TheObjects[i].IsPositiveOrZero())
      theGens.TheObjects[i].MinusRoot();
  bool reductionOccured=true;
  root tempRoot;
  while (reductionOccured)
  { reductionOccured= false;
    for (int i=0; i<theGens.size; i++)
      for (int j=i+1; j<theGens.size; j++)
      {// if (this->flagAnErrorHasOccuredTimeToPanic)
        //  theGens.ComputeDebugString();
        tempRoot.Assign(theGens.TheObjects[i]);
        tempRoot.Subtract(theGens.TheObjects[j]);
        //if (this->flagAnErrorHasOccuredTimeToPanic)
          //tempRoot.ComputeDebugString();
        if (tempRoot.IsEqualToZero())
        { theGens.PopIndexSwapWithLast(j);
          reductionOccured=true;
        }
        if (this->RootSystem.IndexOfObjectHash(tempRoot)!=-1)
        { if (!tempRoot.IsPositiveOrZero())
          { tempRoot.MinusRoot();
            theGens.TheObjects[j].Assign(tempRoot);
          }
          else
            theGens.TheObjects[i].Assign(tempRoot);
          reductionOccured=true;
        }
      }
  }
}

void WeylGroup::TransformToSimpleBasisGeneratorsWRTh(roots& theGens, root& theH)
{ for (int i=0; i<theGens.size; i++)
    if (!this->IsPositiveOrPerpWRTh( theGens.TheObjects[i], theH))
      theGens.TheObjects[i].MinusRoot();
  bool reductionOccured=true;
  root tempRoot;
  while (reductionOccured)
  { reductionOccured= false;
    for (int i=0; i<theGens.size; i++)
      for (int j=i+1; j<theGens.size; j++)
      {// if (this->flagAnErrorHasOccuredTimeToPanic)
        //  theGens.ComputeDebugString();
        tempRoot.Assign(theGens.TheObjects[i]);
        tempRoot.Subtract(theGens.TheObjects[j]);
        //if (this->flagAnErrorHasOccuredTimeToPanic)
          //tempRoot.ComputeDebugString();
        if (tempRoot.IsEqualToZero())
        { theGens.PopIndexSwapWithLast(j);
          reductionOccured=true;
        }
        if (this->RootSystem.IndexOfObjectHash(tempRoot)!=-1)
        { if (!this->IsPositiveOrPerpWRTh(tempRoot, theH))
          { tempRoot.MinusRoot();
            theGens.TheObjects[j].Assign(tempRoot);
          }
          else
            theGens.TheObjects[i].Assign(tempRoot);
          reductionOccured=true;
        }
      }
  }
}

void rootSubalgebra::ComputeExtremeWeightInTheSameKMod(root& input, root& outputW, bool lookingForHighest)
{ outputW.Assign(input);
  for(bool FoundHigher=true; FoundHigher; )
  { FoundHigher=false;
    for (int i=0; i<this->SimpleBasisK.size; i++)
    { root tempRoot;
      tempRoot.Assign(outputW);
      if (lookingForHighest)
        tempRoot.Add(this->SimpleBasisK.TheObjects[i]);
      else
        tempRoot.Subtract(this->SimpleBasisK.TheObjects[i]);
      if (this->AmbientWeyl.RootSystem.IndexOfObjectHash(tempRoot)!=-1)
      { outputW.Assign(tempRoot);
        FoundHigher=true;
      }
      if (tempRoot.IsEqualToZero())
      { outputW.MakeZero(this->AmbientWeyl.CartanSymmetric.NumRows);
        return;
      }
    }
  }
}

void rootSubalgebra::ComputeHighestWeightInTheSameKMod(root& input, root& outputHW)
{ this->ComputeExtremeWeightInTheSameKMod(input, outputHW, true);
}

void rootSubalgebra::ComputeLowestWeightInTheSameKMod(root& input, root& outputLW)
{ this->ComputeExtremeWeightInTheSameKMod(input, outputLW, false);
}

bool rootSubalgebra::RootsDefineASubalgebra(roots& theRoots)
{ root tempRoot;
  for (int i=0; i<theRoots.size; i++)
  { if (!this->IsARoot(theRoots.TheObjects[i]))
      return false;
    for (int j=i+1; j<theRoots.size; j++)
    { tempRoot.Assign(theRoots.TheObjects[i]);
      tempRoot.Add(theRoots.TheObjects[j]);
      if (this->IsARoot(tempRoot))
        if (!theRoots.ContainsObject(tempRoot))
          return false;
    }
  }
  return true;
}

bool rootSubalgebra::IsBKhighest(root& input)
{ for (int i=0; i<this->SimpleBasisK.size; i++)
    if (this->IsARoot(input + this->SimpleBasisK.TheObjects[i]))
      return false;
  return true;
}

bool rootSubalgebra::rootIsInCentralizer(root& input)
{ root tempRoot;
  for(int i=0; i<this->SimpleBasisK.size; i++)
  { tempRoot=input+this->SimpleBasisK.TheObjects[i];
    if (this->IsARoot(tempRoot) || tempRoot.IsEqualToZero())
      return false;
    tempRoot=input-this->SimpleBasisK.TheObjects[i];
    if (this->IsARoot(tempRoot) || tempRoot.IsEqualToZero())
      return false;
  }
  return true;
}

void rootSubalgebra::WriteMultTableAndOppositeKmodsToFile(std::fstream &output, List<List<List<int> > >& inMultTable, List<int>& inOpposites)
{ output << "pairing_table_size: " << inMultTable.size << "\n";
  for (int i=0; i<inMultTable.size; i++)
    for (int j=0; j<inMultTable.size; j++)
    { output << inMultTable.TheObjects[i].TheObjects[j].size << " ";
      for(int k=0; k<inMultTable.TheObjects[i].TheObjects[j].size; k++)
        output << inMultTable.TheObjects[i].TheObjects[j].TheObjects[k] << " ";
    }
  output << "\nopposites: ";
  for (int i=0; i<inMultTable.size; i++)
    output << inOpposites.TheObjects[i] << " ";
}

void rootSubalgebra::ReadMultTableAndOppositeKmodsFromFile(std::fstream& input, List<List<List<int> > >& outMultTable, List<int>& outOpposites)
{ std::string tempS;
  int tempI, theSize;
  input >> tempS >> theSize;
  outMultTable.SetSize(theSize);
  outOpposites.SetSize(theSize);
  for (int i=0; i<theSize; i++)
  { outMultTable.TheObjects[i].SetSize(theSize);
    for (int j=0; j<theSize; j++)
    { input >> tempI;
      outMultTable.TheObjects[i].TheObjects[j].SetSize(tempI);
      for(int k=0; k<outMultTable.TheObjects[i].TheObjects[j].size; k++)
        input >> outMultTable.TheObjects[i].TheObjects[j].TheObjects[k];
    }
  }
  input >> tempS;
  for (int i=0; i<outMultTable.size; i++)
    input >> outOpposites.TheObjects[i];
  assert(tempS=="opposites:");
}

bool rootSubalgebra::rootIsInNilradicalParabolicCentralizer(Selection& positiveSimpleRootsSel, root& input)
{ root tempRoot;
  bool found =true;
  root currentRoot=input;
  bool foundPositive=false;
  while(found)
  { found=false;
    for (int k=0; k<this->SimpleBasisCentralizerRoots.size; k++)
    { tempRoot=currentRoot - this->SimpleBasisCentralizerRoots.TheObjects[k];
      if (this->IsARoot(tempRoot)|| tempRoot.IsEqualToZero())
      { currentRoot.Assign(tempRoot);
        found=true;
        if(positiveSimpleRootsSel.selected[k])
          foundPositive=true;
        if (currentRoot.IsEqualToZero())
          return foundPositive;
      }
    }
  }
  return false;
}

void rootSubalgebra::GeneratePossibleNilradicalsRecursive(Controller& PauseMutex, GlobalVariables& theGlobalVariables, multTableKmods& multTable, List<Selection>& impliedSelections, List<int>& oppositeKmods, rootSubalgebras& owner, int indexInOwner)
{ int& RecursionDepth=owner.RecursionDepthNilradicalsGeneration;
  std::string tempSsel, tempSopposite;
  if (this->flagAnErrorHasOccuredTimeToPanic)
  { multTable.ComputeDebugString(*this);
    std::stringstream out; out << "\n\t";
    for (int i=0; i<oppositeKmods.size; i++)
      out << i << " / " << oppositeKmods.TheObjects[i] << "\t";
    tempSopposite=out.str();
    multTable.DebugString.append(tempSopposite);
  }
  List<int>& counters=owner.CountersNilradicalsGeneration;
  while (RecursionDepth>-1)
  { while(counters.TheObjects[RecursionDepth]<this->kModules.size)
    { if (!impliedSelections.TheObjects[RecursionDepth].selected[counters.TheObjects[RecursionDepth]])
        if (this->IndexIsCompatibleWithPrevious(counters.TheObjects[RecursionDepth], RecursionDepth, multTable, impliedSelections, oppositeKmods, owner, theGlobalVariables))
        { RecursionDepth++;
          counters.TheObjects[RecursionDepth]=counters.TheObjects[RecursionDepth-1];
        }
    /*  if (this->flagAnErrorHasOccuredTimeToPanic)
      { impliedSelections.ElementToStringGeneric(tempSsel, RecursionDepth+1);
        impliedSelections.TheObjects[RecursionDepth].ComputeDebugString();
      }*/
      counters.TheObjects[RecursionDepth]++;
    }
    this->PossibleNilradicalComputation(theGlobalVariables, impliedSelections.TheObjects[RecursionDepth], owner, indexInOwner);
//    if (this->flagAnErrorHasOccuredTimeToPanic)
//      tempSels.AddObjectOnTop(impliedSelections.TheObjects[RecursionDepth]);
    RecursionDepth--;
    if (RecursionDepth>-1)
      counters.TheObjects[RecursionDepth]++;
    PauseMutex.SafePoint();
  }
}

bool rootSubalgebra::ListHasNonSelectedIndexLowerThanGiven(int index, List<int>& tempList, Selection& tempSel)
{ for (int j=0; j<tempList.size; j++)
    if (tempList.TheObjects[j]<index)
      if (!tempSel.selected[tempList.TheObjects[j]])
        return false;
  return true;
}

bool rootSubalgebra::IndexIsCompatibleWithPrevious(int startIndex, int RecursionDepth,  multTableKmods& multTable, List<Selection>& impliedSelections, List<int>& oppositeKmods, rootSubalgebras& owner, GlobalVariables& theGlobalVariables)
{ Selection& targetSel= impliedSelections.TheObjects[RecursionDepth+1];
  Selection& originalSel=impliedSelections.TheObjects[RecursionDepth];
  targetSel.Assign(originalSel);
  targetSel.AddSelectionAppendNewIndex(startIndex);
  for (int k=targetSel.CardinalitySelection-1; k<targetSel.CardinalitySelection; k++)
  { int tempI=targetSel.elements[k];
    for (int i=0; i<targetSel.CardinalitySelection; i++ )
    { if (targetSel.selected[oppositeKmods.TheObjects[targetSel.elements[i]]])
        return false;
      List<int>& tempList=multTable.TheObjects[tempI].TheObjects[targetSel.elements[i]];
      for (int j=0; j<tempList.size; j++)
      { if (tempList.TheObjects[j]<startIndex && !originalSel.selected[tempList.TheObjects[j]])
          return false;
        else
          targetSel.AddSelectionAppendNewIndex(tempList.TheObjects[j]);
      }
    }
  }
  if (!owner.ApproveKmoduleSelectionWRTActionsNormalizerCentralizerNilradical(targetSel, theGlobalVariables))
    return false;
  return true;
}

void rootSubalgebra::PossibleNilradicalComputation(GlobalVariables& theGlobalVariables, Selection& selKmods, rootSubalgebras& owner, int indexInOwner)
{ this->NumNilradicalsAllowed++;
  if (owner.flagCountingNilradicalsOnlyNoComputation)
  { owner.numNilradicalsBySA.TheObjects[indexInOwner]++;
    this->MakeProgressReportPossibleNilradicalComputation(theGlobalVariables, owner, indexInOwner);
    return;
  }
  //this->ComputeDebugString();
  if (this->flagFirstRoundCounting)
    this->NumTotalSubalgebras=this->NumNilradicalsAllowed;
  if (!this->flagFirstRoundCounting)
  { this->NilradicalKmods.Assign(selKmods);
    if(!this->ConeConditionHolds(theGlobalVariables, owner, indexInOwner, owner.flagComputingLprohibitingWeights))
    { this->NumConeConditionFailures++;
      owner.NumConeConditionFailures++;
      if (owner.flagStoringNilradicals)
      { List<List<int> >& currentSAList = owner.storedNilradicals.TheObjects[indexInOwner];
        List<int> newNilradical;
        newNilradical.SetSize(selKmods.CardinalitySelection);
        for (int i=0; i<selKmods.CardinalitySelection; i++)
          newNilradical.TheObjects[i]=selKmods.elements[i];
        int oldIncrement= List<List<int> >::ListActualSizeIncrement;
        List<List<int> >::ListActualSizeIncrement=100;
        currentSAList.AddObjectOnTop(newNilradical);
        List<List<int> >::ListActualSizeIncrement=oldIncrement;
      }
    } else
    {

      //the below commented out code should be incapsulated. It computes whether a given nilradical is a nilradical of a parabolic subalgebra.
      //this task is pushed on the end of the to-do list.
      /* owner.NumConeConditionHoldsBySSpart.TheObjects[indexInOwner]++;
      if (owner.ReportStringNonNilradicalParabolic=="")
      { this->ComputeRootsOfK();
        roots tempNilradical; roots tempOthers; roots tempK;
        for (int i=0; i<this->kModules.size; i++)
          if (this->NilradicalKmods.selected[i])
            tempNilradical.AddListOnTop(this->kModules.TheObjects[i]);
          else
            tempOthers.AddListOnTop(this->kModules.TheObjects[i]);
        for (int i=0; i<this->PositiveRootsK.size; i++)
        { tempOthers.AddObjectOnTop(this->PositiveRootsK.TheObjects[i]);
          tempOthers.AddObjectOnTop(-this->PositiveRootsK.TheObjects[i]);
          tempK.AddObjectOnTop(this->PositiveRootsK.TheObjects[i]);
        }
        if (roots::ConesIntersect(theGlobalVariables, tempNilradical, tempOthers, owner.AmbientWeyl.CartanSymmetric.NumRows))
        { roots tempRoots; std::stringstream out; std::string tempS;
          this->AmbientWeyl.GetEpsilonCoords(tempNilradical, tempRoots, theGlobalVariables);
          tempRoots.ElementToStringEpsilonForm(tempS, true, false, false);
          out << tempS;
          this->AmbientWeyl.GetEpsilonCoords(tempK, tempRoots, theGlobalVariables);
          tempRoots.ElementToStringEpsilonForm(tempS, true, false, false);
          out << "\n\n" << tempS;
          owner.ReportStringNonNilradicalParabolic=out.str();
        }
      }*/
    }
  }
  this->MakeProgressReportPossibleNilradicalComputation(theGlobalVariables, owner, indexInOwner);
}

void rootSubalgebra::MakeProgressReportGenAutos(int progress, int outOf, int found, GlobalVariables& theGlobalVariables)
{ if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()==0)
    return;
  std::stringstream out4, out5;
  out5 << progress+1 << " out of " << outOf << " checked; ";
  out5 << found << " found pos. generators";
  //::theGlobalVariables.theIndicatorVariables.ProgressReportString4=out4.str();
  theGlobalVariables.theIndicatorVariables.ProgressReportString5=out5.str();
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void rootSubalgebra::MakeProgressReportMultTable(int index, int outOf, GlobalVariables& theGlobalVariables)
{ if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()==0)
    return;
  std::stringstream out5;
  out5 << "Computing pairing table: " << index+1 << " out of " << outOf;
  theGlobalVariables.theIndicatorVariables.String5NeedsRefresh=true;
  theGlobalVariables.theIndicatorVariables.ProgressReportString5=out5.str();
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void rootSubalgebra::MakeProgressReportPossibleNilradicalComputation(GlobalVariables& theGlobalVariables, rootSubalgebras& owner, int indexInOwner)
{ if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()==0)
    return;
  if (this->flagMakingProgressReport)
  { std::stringstream out1, out2, out3, out4, out5;
    if (this->flagFirstRoundCounting)
    { out1 << "Counting ss part " << this->theDynkinDiagram.DebugString;
      out2 << "# nilradicals for fixed ss part: " << this->NumTotalSubalgebras;
      owner.NumSubalgebrasCounted++;
      out3 << owner.NumSubalgebrasCounted << " total subalgebras counted";
    }
    else
    { out1 << "Computing ss part " << this->theDynkinDiagram.DebugString;
      out2 << this->NumNilradicalsAllowed << " Nilradicals processed out of " << this->NumTotalSubalgebras;
      owner.NumSubalgebrasProcessed++;
      out3 << "Total # subalgebras processed: " << owner.NumSubalgebrasProcessed;
      out4 << "Num cone condition failures: " << owner.NumConeConditionFailures;
      out5 << "Num failures to find l-prohibiting relations: " << owner.theBadRelations.size;
      theGlobalVariables.theIndicatorVariables.ProgressReportString4=out4.str();
      theGlobalVariables.theIndicatorVariables.ProgressReportString5=out5.str();
    }
    theGlobalVariables.theIndicatorVariables.ProgressReportString1=out1.str();
    theGlobalVariables.theIndicatorVariables.ProgressReportString2=out2.str();
    theGlobalVariables.theIndicatorVariables.ProgressReportString3=out3.str();
    theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
  }
}

void rootSubalgebra::GenerateKmodMultTable(List<List<List<int> > >& output, List<int>& oppositeKmods, GlobalVariables& theGlobalVariables)
{ output.SetSize(this->kModules.size);
  oppositeKmods.SetSize(this->kModules.size);
  int numTotal= this->kModules.size* this->kModules.size;
  for (int i=0; i<this->kModules.size; i++)
  { output.TheObjects[i].SetSize(this->kModules.size);
    for (int j=0; j<this->kModules.size; j++)
    { this->KmodTimesKmod(i, j, oppositeKmods, output.TheObjects[i].TheObjects[j]);
      this->MakeProgressReportMultTable(i*this->kModules.size+j, numTotal, theGlobalVariables);
    }
  }
}

bool rootSubalgebra::IsARoot(const root& input)
{ if (input.size!=this->AmbientWeyl.CartanSymmetric.NumRows)
    return false;
  return !(this->AmbientWeyl.RootSystem.IndexOfObjectHash(input)==-1);
}

bool rootSubalgebra::IsARootOrZero(root& input)
{ return input.IsEqualToZero() || this->IsARoot(input);
}

void rootSubalgebra::KmodTimesKmod(int index1, int index2, List<int>& oppositeKmods, List<int>& output)
{ root tempRoot;
  output.size=0;
  for (int i=0; i<this->kModules.TheObjects[index1].size; i++)
    for (int j=0; j<this->kModules.TheObjects[index2].size; j++)
    { tempRoot.Assign(this->kModules.TheObjects[index1].TheObjects[i]);
      tempRoot.Add(this->kModules.TheObjects[index2].TheObjects[j]);
      tempRoot.ComputeDebugString();
      if (tempRoot.IsEqualToZero())
      { oppositeKmods.TheObjects[index1]=index2;
        oppositeKmods.TheObjects[index2]=index1;
      }
      else
        if (this->IsARoot(tempRoot))
          for (int k=0; k<this->kModules.size; k++)
            if (this->kModules.TheObjects[k].IndexOfObject(tempRoot)!=-1)
            { output.AddOnTopNoRepetition(k);
              break;
            }
    }
}

void rootSubalgebra::ComputeKModules()
{ this->HighestRootsK.size =0;
  this->LowestWeightsGmodK.size=0;
  this->HighestWeightsGmodK.size=0;
  this->kModules.size=0;
  //this->ComputeDebugString();
  this->ComputeRootsOfK();
  root tempLW, tempHW;
  hashedRoots& AllRoots= this->AmbientWeyl.RootSystem;
  this->kModules.MakeActualSizeAtLeastExpandOnTop(AllRoots.size);
  this->HighestRootsK.MakeActualSizeAtLeastExpandOnTop(this->AmbientWeyl.CartanSymmetric.NumRows);
  this->LowestWeightsGmodK.MakeActualSizeAtLeastExpandOnTop(AllRoots.size);
  this->HighestWeightsGmodK.MakeActualSizeAtLeastExpandOnTop(AllRoots.size);
  for (int i=0; i<AllRoots.size; i++)
  { if (this->AllRootsK.IndexOfObject(AllRoots.TheObjects[i])==-1)
    { this->ComputeLowestWeightInTheSameKMod(AllRoots.TheObjects[i], tempLW);
      this->ComputeHighestWeightInTheSameKMod(AllRoots.TheObjects[i], tempHW);
      int x=this->LowestWeightsGmodK.IndexOfObject(tempLW);
      if (x==-1)
      { this->LowestWeightsGmodK.AddRoot(tempLW);
        this->HighestWeightsGmodK.AddRoot(tempHW);
        x=this->LowestWeightsGmodK.size -1;
        this->kModules.SetSize(this->LowestWeightsGmodK.size);
        this->kModules.TheObjects[x].size=0;
      }
      this->kModules.TheObjects[x].AddRoot(AllRoots.TheObjects[i]);
      if (AllRoots.TheObjects[i].IsEqualTo(tempHW))
        this->kModules.TheObjects[x].SwapTwoIndices(0, this->kModules.TheObjects[x].size-1);
    }
    else
    { if (AllRoots.TheObjects[i].IsPositiveOrZero())
      { root tempHW;
        this->ComputeHighestWeightInTheSameKMod(AllRoots.TheObjects[i], tempHW);
        int x=this->HighestRootsK.IndexOfObject(tempHW);
        if (x==-1)
        { this->HighestRootsK.AddRoot(tempHW);
          x=this->HighestRootsK.size -1;
          this->PosRootsKConnectedComponents.SetSize(this->HighestRootsK.size);
        }
        this->PosRootsKConnectedComponents.TheObjects[x].AddRoot(AllRoots.TheObjects[i]);
      }
    }
  }
}

int rootSubalgebra::NumRootsInNilradical()
{ int result=0;
  for (int i=0; i<this->NilradicalKmods.CardinalitySelection; i++)
    result+=this->kModules.TheObjects[this->NilradicalKmods.elements[i]].size;
  return result;
}

int rootSubalgebra::GetIndexKmoduleContainingRoot(root& input)
{ for (int i=0; i<this->kModules.size; i++)
    if (this->kModules.TheObjects[i].ContainsObject(input))
      return i;
  return -1;
}

bool roots::GetNormalSeparatingCones(GlobalVariables& theGlobalVariables, int theDimension, List<root>& coneStrictlyPositiveCoeffs, List<root>& coneNonNegativeCoeffs, root& outputNormal)
{ MatrixLargeRational& matA= theGlobalVariables.matConeCondition1;
  MatrixLargeRational& matb= theGlobalVariables.matConeCondition2;
  MatrixLargeRational& matX= theGlobalVariables.matConeCondition3;
  if (coneStrictlyPositiveCoeffs.size==0)
    return true;
  int numRows= coneStrictlyPositiveCoeffs.size + coneNonNegativeCoeffs.size;
  matA.init((int)numRows, (int)theDimension*2+numRows);
  matA.NullifyAll();
  matb.init((int)numRows, 1);
  matb.NullifyAll();
  for (int i=0; i<coneStrictlyPositiveCoeffs.size; i++)
  { for (int k=0; k<theDimension; k++)
    { matA.elements[i][k].Assign(coneStrictlyPositiveCoeffs.TheObjects[i].TheObjects[k]);
      matA.elements[i][k+theDimension].Assign(matA.elements[i][k]);
      matA.elements[i][k+theDimension].Minus();
    }
    matb.elements[i][0].MakeOne();
    matA.elements[i][theDimension*2+i].MakeMOne();
  }
  for (int i=0; i<coneNonNegativeCoeffs.size; i++)
  { int currentRow=i+coneStrictlyPositiveCoeffs.size;
    for (int k=0; k<theDimension; k++)
    { matA.elements[currentRow][k].Assign(coneNonNegativeCoeffs.TheObjects[i].TheObjects[k]);
      matA.elements[currentRow][k+theDimension].Assign(matA.elements[currentRow][k]);
      matA.elements[currentRow][k+theDimension].Minus();
    }
    matA.elements[currentRow][2*theDimension+currentRow].MakeOne();
  }
  //matA.ComputeDebugString();
  //matb.ComputeDebugString();
  //matX.ComputeDebugString();
  bool result=MatrixLargeRational::SystemLinearEqualitiesWithPositiveColumnVectorHasNonNegativeNonZeroSolution(matA, matb, matX, theGlobalVariables);
  //matA.ComputeDebugString();
  //matb.ComputeDebugString();
  //matX.ComputeDebugString();
  outputNormal.MakeZero(theDimension);
  for (int i=0; i<theDimension; i++)
    outputNormal.TheObjects[i]=matX.elements[i][0]-matX.elements[i+theDimension][0];
  if (result)
  { Rational tempRat;
    for(int i=0; i<coneStrictlyPositiveCoeffs.size; i++)
    { root::RootScalarEuclideanRoot(coneStrictlyPositiveCoeffs.TheObjects[i], outputNormal, tempRat);
      assert(tempRat.IsPositive());
    }
    for(int i=0; i<coneNonNegativeCoeffs.size; i++)
    { root::RootScalarEuclideanRoot(coneNonNegativeCoeffs.TheObjects[i], outputNormal, tempRat);
      assert(tempRat.IsNonPositive());
    }
  }
//  outputNormal.ComputeDebugString();
  return result;
}

bool roots::ConesIntersect(GlobalVariables& theGlobalVariables, List<root>& StrictCone, List<root>& NonStrictCone, int theDimension)
{ MatrixLargeRational& matA= theGlobalVariables.matConeCondition1;
  MatrixLargeRational& matb= theGlobalVariables.matConeCondition2;
  MatrixLargeRational& matX= theGlobalVariables.matConeCondition3;
  if (StrictCone.size==0)
    return false;
  int numCols= StrictCone.size + NonStrictCone.size;
  matA.init((int)theDimension+1, (int)numCols);
  matb.init((int)theDimension+1, 1);
  matb.NullifyAll(); matb.elements[theDimension][0].MakeOne();
  for (int i=0; i<StrictCone.size; i++)
  { for (int k=0; k<theDimension; k++)
      matA.elements[k][i].Assign(StrictCone.TheObjects[i].TheObjects[k]);
    matA.elements[theDimension][i].MakeOne();
  }
  for (int i=0; i<NonStrictCone.size; i++)
  { int currentCol=i+StrictCone.size;
    for (int k=0; k<theDimension; k++)
    { matA.elements[k][currentCol].Assign(NonStrictCone.TheObjects[i].TheObjects[k]);
      matA.elements[k][currentCol].Minus();
    }
    matA.elements[theDimension][currentCol].MakeZero();
  }
  //matA.ComputeDebugString();
  //matb.ComputeDebugString();
  //matX.ComputeDebugString();
  return MatrixLargeRational::SystemLinearEqualitiesWithPositiveColumnVectorHasNonNegativeNonZeroSolution(matA, matb, matX, theGlobalVariables);
}

bool rootSubalgebra::ConeConditionHolds(GlobalVariables& theGlobalVariables, rootSubalgebras& owner, int indexInOwner, roots& NilradicalRoots, roots& Ksingular, bool doExtractRelations)
{ if (roots::ConesIntersect(theGlobalVariables, NilradicalRoots, Ksingular, this->AmbientWeyl.CartanSymmetric.NumRows))
  { if (doExtractRelations)
      this->ExtractRelations(theGlobalVariables.matConeCondition1, theGlobalVariables.matConeCondition3, NilradicalRoots, owner, indexInOwner, theGlobalVariables, Ksingular);
    return false;
  } else
    return true;
}

bool rootSubalgebra::ConeConditionHolds(GlobalVariables& theGlobalVariables, rootSubalgebras& owner, int indexInOwner, bool doExtractRelations)
{ roots& NilradicalRoots= theGlobalVariables.rootsNilradicalRoots;
  roots& Ksingular=theGlobalVariables.rootsConeConditionHolds2;
  if (this->kModules.size==0)
    return true;
  NilradicalRoots.size=0;
  int counter=0;
  for (int i=0; i<this->NilradicalKmods.CardinalitySelection; i++)
  { roots& tempKmod= this->kModules.TheObjects[this->NilradicalKmods.elements[i]];
    for (int j=0; j<tempKmod.size; j++)
    { NilradicalRoots.AddRoot(tempKmod.TheObjects[j]);
      counter++;
    }
  }
  Ksingular.size=0;
  for (int i=0; i<this->kModules.size; i++)
    if (!this->NilradicalKmods.selected[i])
      Ksingular.AddObjectOnTop(this->HighestWeightsGmodK.TheObjects[i]);
  if ( !this->ConeConditionHolds(theGlobalVariables, owner, indexInOwner, NilradicalRoots, Ksingular, doExtractRelations))
    return false;
  else
    return true;
}

bool rootSubalgebra::CheckForSmallRelations(coneRelation& theRel, roots& nilradicalRoots)
{ //return false;
  root tempRoot;
  bool tempBool; int tempI;
  for (int i=0; i<this->kModules.size; i++)
    if (!this->NilradicalKmods.selected[i])
      for (int j=i+1; j<this->kModules.size; j++)
      { if (!this->NilradicalKmods.selected[j])
        { tempRoot.Assign(this->HighestWeightsGmodK.TheObjects[i]);
          tempRoot.Add(this->HighestWeightsGmodK.TheObjects[j]);
          if (!tempRoot.IsEqualToZero())
          { theRel.BetaCoeffs.SetSize(0);
            theRel.Betas.SetSize(0);
            tempI= nilradicalRoots.IndexOfObject(tempRoot);
            if (tempI!=-1)
            { tempBool=true;
              theRel.BetaCoeffs.SetSize(1);
              theRel.Betas.SetSize(1);
              theRel.BetaCoeffs.TheObjects[0].MakeOne();
              theRel.Betas.TheObjects[0].Assign(nilradicalRoots.TheObjects[tempI]);
            } else
              tempBool=  tempRoot.HasStronglyPerpendicularDecompositionWRT(-1, nilradicalRoots, this->AmbientWeyl, theRel.Betas, theRel.BetaCoeffs, true);
            if (tempBool)
            { theRel.Alphas.size=0;
              theRel.AlphaCoeffs.size=0;
              theRel.Alphas.AddObjectOnTop(this->HighestWeightsGmodK.TheObjects[i]);
              theRel.Alphas.AddObjectOnTop(this->HighestWeightsGmodK.TheObjects[j]);
              theRel.AlphaCoeffs.AddObjectOnTop(ROne);
              theRel.AlphaCoeffs.AddObjectOnTop(ROne);
//              theRel.ComputeDebugString(*this, true);
              return true;
            }
          }
        }
      }
  return false;
}

void rootSubalgebra::MatrixToRelation( coneRelation& output, MatrixLargeRational& matA, MatrixLargeRational& matX, int theDimension, roots& NilradicalRoots)
{ output.AlphaCoeffs.size=0;  output.Alphas.size=0;
  output.BetaCoeffs.size=0;  output.Betas.size=0;
  root tempRoot; tempRoot.SetSize(theDimension);
  matX.ScaleToIntegralForMinRationalHeightNoSignChange();
  assert(matA.NumCols==matX.NumRows);
  for (int i=0; i<matA.NumCols; i++)
    if (!matX.elements[i][0].IsEqualToZero())
    { for (int j=0; j<theDimension; j++)
        tempRoot.TheObjects[j].Assign(matA.elements[j][i]);
      assert(matX.elements[i][0].DenShort==1);
      if (i<NilradicalRoots.size)
      { output.Betas.AddObjectOnTop(tempRoot);
        output.BetaCoeffs.AddObjectOnTop(matX.elements[i][0]);
      } else
      { tempRoot.MinusRoot();
        output.Alphas.AddObjectOnTop(tempRoot);
        output.AlphaCoeffs.AddObjectOnTop(matX.elements[i][0]);
      }
    }
}

void rootSubalgebra::ExtractRelations(MatrixLargeRational& matA, MatrixLargeRational& matX, roots& NilradicalRoots, rootSubalgebras& owner, int indexInOwner, GlobalVariables& theGlobalVariables, roots& Ksingular)
{ int theDimension= this->AmbientWeyl.CartanSymmetric.NumRows;
  if (this->flagAnErrorHasOccuredTimeToPanic)
  { this->NilradicalKmods.ComputeDebugString();
    NilradicalRoots.ComputeDebugString();
    matX.ComputeDebugString();
  }
  root tempRoot; tempRoot.MakeZero(theDimension);
  coneRelation theRel; theRel.IndexOwnerRootSubalgebra=indexInOwner;
  if (owner.flagLookingForMinimalRels)
  { theRel.FixRightHandSide(*this, NilradicalRoots);
    theRel.MakeLookCivilized(*this, NilradicalRoots);
    owner.theMinRels.AddRelationNoRepetition(theRel, owner, indexInOwner);
  }
  bool tempBool=this->AttemptTheTripleTrick(theRel, NilradicalRoots, theGlobalVariables);
  if (tempBool)
  { this->NumRelationsWithStronglyPerpendicularDecomposition++;
    theRel.MakeLookCivilized(*this, NilradicalRoots);
    owner.theGoodRelations.AddRelationNoRepetition(theRel, owner, indexInOwner);
  }
  else
  { //if(!this->CheckForSmallRelations(theRel, NilradicalRoots))
    this->MatrixToRelation(theRel, matA, matX, theDimension, NilradicalRoots);
    this->MakeGeneratingSingularVectors(theRel, NilradicalRoots);
    theRel.FixRightHandSide(*this, NilradicalRoots);
    theRel.MakeLookCivilized(*this, NilradicalRoots);
    theRel.ComputeDebugString(owner, true, true);
    if (false)
      if (theRel.theDiagram.DebugString=="$C_3$")
      { Selection tempSel;
        tempSel.init(Ksingular.size);
        int tempNum=MathRoutines::NChooseK(Ksingular.size, 2);
        for (int i=0; i<tempNum; i++)
        { tempSel.incrementSelectionFixedCardinality(2);
          theRel.Alphas.SetSize(2);
          theRel.AlphaCoeffs.SetSize(2);
          theRel.Betas.size=0;
          theRel.BetaCoeffs.size=0;
          for (int j=0; j<tempSel.CardinalitySelection; j++)
            theRel.Alphas.TheObjects[j].Assign(Ksingular.TheObjects[tempSel.elements[j]]);
          if (theRel.IsStrictlyWeaklyProhibiting(*this, NilradicalRoots, theGlobalVariables, owner, indexInOwner))
            break;
        }
      assert(theRel.CheckForBugs(*this, NilradicalRoots));
    }
    owner.theBadRelations.AddObjectOnTopHash(theRel);
  }
}

bool rootSubalgebra::AttemptTheTripleTrick(coneRelation& theRel, roots& NilradicalRoots, GlobalVariables& theGlobalVariables)
{ roots& tempRoots= theGlobalVariables.rootsAttemptTheTripleTrick;
  tempRoots.size=0;
  for (int i=0; i<this->kModules.size; i++)
    if (!this->NilradicalKmods.selected[i])
      if (this->IsGeneratingSingularVectors(i, NilradicalRoots))
        tempRoots.AddObjectOnTop(this->HighestWeightsGmodK.TheObjects[i]);
  //tempRoots.ComputeDebugString();
  return this->AttemptTheTripleTrickWRTSubalgebra(theRel, tempRoots, NilradicalRoots, theGlobalVariables);
}

bool rootSubalgebra::AttemptTheTripleTrickWRTSubalgebra(coneRelation& theRel, roots& highestWeightsAllowed, roots& NilradicalRoots, GlobalVariables& theGlobalVariables)
{ root tempRoot, Accum;
  SelectionWithMaxMultiplicity tempSel;
  roots& chosenAlphas= theGlobalVariables.rootsAttepmtTheTripleTrickWRTSA;
  for (int i=2; i<=MathRoutines::Maximum(highestWeightsAllowed.size, this->AmbientWeyl.CartanSymmetric.NumRows); i++)
  { tempSel.initMaxMultiplicity(highestWeightsAllowed.size, i);
    int NumElts=tempSel.NumCombinationsOfCardinality(i);
    for (int j=0; j<NumElts; j++)
    { tempSel.IncrementSubsetFixedCardinality(i);
      Accum.MakeZero(this->AmbientWeyl.CartanSymmetric.NumRows);
      chosenAlphas.size=0;
      for (int k=0; k<tempSel.elements.size; k++)
      { tempRoot.Assign(highestWeightsAllowed.TheObjects[tempSel.elements.TheObjects[k]]);
        chosenAlphas.AddObjectOnTop(tempRoot);
        tempRoot.MultiplyByInteger(tempSel.Multiplicities.TheObjects[tempSel.elements.TheObjects[k]]);
        Accum.Add(tempRoot);
      }
      theRel.Betas.size=0; theRel.BetaCoeffs.size=0;
      if (!Accum.IsEqualToZero())
        if (Accum.HasStronglyPerpendicularDecompositionWRT(-1, NilradicalRoots, this->AmbientWeyl, theRel.Betas, theRel.BetaCoeffs, true))
        { int startNumBetas=theRel.Betas.size;
          //int numAlphas=tempSel.CardinalitySelectionWithoutMultiplicities();
          //int numParticipatingRoots=numAlphas+startNumBetas;
          DynkinDiagramRootSubalgebra& theDiagram= theGlobalVariables.dynAttemptTheTripleTrick;
          chosenAlphas.AddListOnTop(theRel.Betas);
          //chosenAlphas.ComputeDebugString();
          //theRel.Betas.ComputeDebugString();
          theDiagram.ComputeDiagramTypeModifyInput(chosenAlphas, this->AmbientWeyl);
          int theRank=theDiagram.RankTotal();
          if (theRank>4 || theDiagram.DebugString=="$B_4$" || theDiagram.DebugString=="$C_4$")
          { int goalNumBetas= 2;
            theRel.Betas.size=0; theRel.BetaCoeffs.size=0;
            for (int l=goalNumBetas-1; l<startNumBetas; l++)
              if (Accum.HasStronglyPerpendicularDecompositionWRT(l+1, NilradicalRoots, this->AmbientWeyl, theRel.Betas, theRel.BetaCoeffs, true))
                break;
          }
          theRel.Alphas.SetSize(tempSel.CardinalitySelectionWithoutMultiplicities());
          theRel.AlphaCoeffs.SetSize(tempSel.elements.size);
          for (int k=0; k<tempSel.elements.size; k++)
          { theRel.Alphas.TheObjects[k].Assign(highestWeightsAllowed.TheObjects[tempSel.elements.TheObjects[k]]);
            theRel.AlphaCoeffs.TheObjects[k].AssignInteger(tempSel.Multiplicities.TheObjects[tempSel.elements.TheObjects[k]]);
          }
          //theRel.Alphas.ComputeDebugString();
          //theRel.Betas.ComputeDebugString();
          return true;
        }
    }
  }
  return false;
}

void rootSubalgebra::MakeSureAlphasDontSumToRoot(coneRelation& theRel, roots& NilradicalRoots)
{ root alpha1, alpha2, beta1, tempRoot;
  bool madeChange=true;
  while(madeChange)
  { madeChange=false;
    for (int i=0; i<theRel.Alphas.size; i++)
      for(int j=i+1; j<theRel.Alphas.size; j++)
      { //theRel.ComputeDebugString(*this);
        beta1.Assign(theRel.Alphas.TheObjects[i]);
        beta1.Add(theRel.Alphas.TheObjects[j]);
        if (this->IsARootOrZero(beta1))
        { this->ComputeHighestWeightInTheSameKMod(beta1, tempRoot);
          assert(tempRoot.IsEqualTo(tempRoot));
          if (NilradicalRoots.ContainsObject(beta1))
          { alpha1.Assign(theRel.Alphas.TheObjects[i]);
            alpha2.Assign(theRel.Alphas.TheObjects[j]);
            theRel.Alphas.SetSize(2);
            theRel.AlphaCoeffs.SetSize(2);
            theRel.Alphas.TheObjects[0].Assign(alpha1);
            theRel.Alphas.TheObjects[1].Assign(alpha2);
            theRel.AlphaCoeffs.TheObjects[0].Assign(ROne);
            theRel.AlphaCoeffs.TheObjects[1].Assign(ROne);
            theRel.Betas.SetSize(1);
            theRel.BetaCoeffs.SetSize(1);
            theRel.BetaCoeffs.TheObjects[0].Assign(ROne);
            theRel.Betas.TheObjects[0].Assign(beta1);
            madeChange=false;
            break;
          }
          else
          { int changedIndex=i, otherIndex=j;
            Rational alpha1coeff, alpha2coeff;
            if (alpha1coeff.IsGreaterThanOrEqualTo(alpha2coeff))
            { changedIndex=j;
              otherIndex=i;
            }
            alpha1coeff.Assign(theRel.AlphaCoeffs.TheObjects[changedIndex]);
            alpha2coeff.Assign(theRel.AlphaCoeffs.TheObjects[otherIndex]);
            alpha2.Assign(theRel.Alphas.TheObjects[otherIndex]);
            alpha2coeff.Subtract(alpha1coeff);
            madeChange=true;
            theRel.Alphas.TheObjects[changedIndex].Assign(beta1);
            theRel.AlphaCoeffs.TheObjects[changedIndex].Assign(alpha1coeff);
            if (alpha2coeff.IsEqualToZero())
            { theRel.Alphas.PopIndexSwapWithLast(otherIndex);
              theRel.AlphaCoeffs.PopIndexSwapWithLast(otherIndex);
            } else
            { theRel.Alphas.TheObjects[otherIndex].Assign(alpha2);
              theRel.AlphaCoeffs.TheObjects[otherIndex].Assign(alpha2coeff);
            }
          }
        }
      }
  }
}

void rootSubalgebra::ComputeEpsCoordsWRTk(GlobalVariables& theGlobalVariables)
{ this->kModulesKepsCoords.SetSize(this->kModules.size);
  this->kModulesgEpsCoords.SetSize(this->kModules.size);
  roots& simpleBasisG=theGlobalVariables.rootsComputeEpsCoordsWRTk2;
  int theDimension=this->AmbientWeyl.CartanSymmetric.NumRows;
  simpleBasisG.SetSize(theDimension);
  for (int i=0; i<theDimension; i++)
  { simpleBasisG.TheObjects[i].MakeZero(theDimension);
    simpleBasisG.TheObjects[i].TheObjects[i]=1;
  }
  MatrixLargeRational& InvertedGramMatrix=theGlobalVariables.matComputeEpsCoordsWRTk;
  this->SimpleBasisK.GetGramMatrix(InvertedGramMatrix, this->AmbientWeyl);
  InvertedGramMatrix.Invert(theGlobalVariables);
  roots& tempRoots=theGlobalVariables.rootsComputeEpsCoordsWRTk;
  root tempRoot, tempRoot2, tempRoot3;
  for(int i=0; i<this->kModules.size; i++)
  { tempRoots.size=0;
    for (int j=0; j<this->kModules.TheObjects[i].size; j++)
    { tempRoot.SetSize(this->SimpleBasisK.size);
      for (int k=0; k<this->SimpleBasisK.size; k++)
        this->AmbientWeyl.RootScalarCartanRoot(  this->kModules.TheObjects[i].TheObjects[j], this->SimpleBasisK.TheObjects[k], tempRoot.TheObjects[k]);
      InvertedGramMatrix.ActOnAroot(tempRoot, tempRoot3);
      tempRoot2.MakeZero(this->AmbientWeyl.CartanSymmetric.NumRows);
      for (int j=0; j<this->SimpleBasisK.size; j++)
        tempRoot2+= tempRoot3.TheObjects[j]*this->SimpleBasisK.TheObjects[j];
      tempRoots.AddObjectOnTop(tempRoot2);
    }
//    tempRoots.ComputeDebugString();
    this->AmbientWeyl.GetEpsilonCoordsWRTsubalgebra(this->SimpleBasisK, tempRoots, this->kModulesKepsCoords.TheObjects[i], theGlobalVariables);
    this->AmbientWeyl.GetEpsilonCoordsWRTsubalgebra(simpleBasisG, this->kModules.TheObjects[i], this->kModulesgEpsCoords.TheObjects[i], theGlobalVariables);
    root tempRoot;
    this->kModulesKepsCoords.TheObjects[i].average(tempRoot);
    assert(tempRoot.IsEqualToZero());
   // this->kModulesgEpsCoords.TheObjects[i].Average
     // (tempRoot, this->kModulesgEpsCoords.TheObjects[i].TheObjects[0].size);
    //assert(tempRoot.IsEqualToZero());
  //  this->kModulesEpsCoords.TheObjects[i].ComputeDebugString();
  }
  this->AmbientWeyl.GetEpsilonCoordsWRTsubalgebra(this->SimpleBasisK, this->SimpleBasisK, this->SimpleBasisKEpsCoords, theGlobalVariables);
  this->AmbientWeyl.GetEpsilonCoordsWRTsubalgebra(simpleBasisG, this->SimpleBasisK, this->SimpleBasisgEpsCoords, theGlobalVariables);
}

void rootSubalgebra::Assign(const rootSubalgebra& right)
{ this->AmbientWeyl.Assign(right.AmbientWeyl);
  this->genK.CopyFromBase(right.genK);
  this->AllRootsK.CopyFromBase(right.AllRootsK);
  this->CentralizerKmods.Assign(right.CentralizerKmods);
  this->CentralizerRoots.CopyFromBase(right.CentralizerRoots);
  this->HighestRootsK.CopyFromBase(right.HighestRootsK);
  this->HighestWeightsGmodK.CopyFromBase(right.HighestWeightsGmodK);
  this->kModules.CopyFromBase(right.kModules);
  this->LowestWeightsGmodK.CopyFromBase(right.LowestWeightsGmodK);
  this->flagAnErrorHasOccuredTimeToPanic=right.flagAnErrorHasOccuredTimeToPanic;
  this->theDynkinDiagram.Assign(right.theDynkinDiagram);
  this->theCentralizerDiagram.Assign(right.theCentralizerDiagram);
  this->PositiveRootsK.CopyFromBase(right.PositiveRootsK);
  this->PosRootsKConnectedComponents.CopyFromBase(right.PosRootsKConnectedComponents);
  this->NilradicalKmods.Assign(right.NilradicalKmods);
  this->SimpleBasisCentralizerRoots.CopyFromBase(right.SimpleBasisCentralizerRoots);
  this->SimpleBasisK.CopyFromBase(right.SimpleBasisK);
  this->indicesSubalgebrasContainingK.CopyFromBase(right.indicesSubalgebrasContainingK);
}

void rootSubalgebras::GenerateAllReductiveRootSubalgebrasUpToIsomorphism(GlobalVariables& theGlobalVariables, bool sort, bool computeEpsCoords)
{ this->size=0;
  this->AmbientWeyl.ComputeRho(true);
  //the below is not needed. See proposition Chapter 5 of Todor Milev's phd thesis.
  //this->initDynkinDiagramsNonDecided(this->AmbientWeyl, WeylLetter, WeylRank);
  theGlobalVariables.rootSAsGenerateAll.SetSize(this->AmbientWeyl.CartanSymmetric.NumRows*2+1);
  theGlobalVariables.rootSAsGenerateAll.TheObjects[0].genK.size=0;
  theGlobalVariables.rootSAsGenerateAll.TheObjects[0].AmbientWeyl.Assign(this->AmbientWeyl);
  theGlobalVariables.rootSAsGenerateAll.TheObjects[0].ComputeAll();
  this->GenerateAllReductiveRootSubalgebrasContainingInputUpToIsomorphism(theGlobalVariables.rootSAsGenerateAll, 1, theGlobalVariables);
  if (sort)
    this->SortDescendingOrderBySSRank();
  if(computeEpsCoords)
    for(int i=0; i<this->size; i++)
      this->TheObjects[i].ComputeEpsCoordsWRTk(theGlobalVariables);
}

void rootSubalgebras::GenerateAllReductiveRootSubalgebrasUpToIsomorphism(GlobalVariables& theGlobalVariables, char WeylLetter, int WeylRank, bool sort, bool computeEpsCoords)
{ this->AmbientWeyl.MakeArbitrary(WeylLetter, WeylRank);
  this->GenerateAllReductiveRootSubalgebrasUpToIsomorphism(theGlobalVariables, sort, computeEpsCoords);
}

void rootSubalgebras::GenerateAllReductiveRootSubalgebrasContainingInputUpToIsomorphism(rootSubalgebras& bufferSAs, int RecursionDepth, GlobalVariables& theGlobalVariables)
{ this->AddObjectOnTop(bufferSAs.TheObjects[RecursionDepth-1]);
  int currentAlgebraIndex=this->size-1;
  rootSubalgebra::ProblemCounter++;
  if (RecursionDepth>=bufferSAs.size)
    bufferSAs.SetSize(bufferSAs.size+this->AmbientWeyl.CartanSymmetric.NumRows);
  bufferSAs.TheObjects[RecursionDepth].genK = bufferSAs.TheObjects[RecursionDepth-1].genK;
  bufferSAs.TheObjects[RecursionDepth].AmbientWeyl.Assign(this->AmbientWeyl);
  //if (RecursionDepth>4)
   // return;
  for (int k=0; k<bufferSAs.TheObjects[RecursionDepth-1].kModules.size; k++)
    if (bufferSAs.TheObjects[RecursionDepth-1].HighestWeightsGmodK.TheObjects[k].IsPositiveOrZero())
    { bufferSAs.TheObjects[RecursionDepth].genK.AddObjectOnTop(bufferSAs.TheObjects[RecursionDepth-1].HighestWeightsGmodK.TheObjects[k]);
      bufferSAs.TheObjects[RecursionDepth].ComputeDynkinDiagramKandCentralizer();
      this->MakeProgressReportGenerationSubalgebras(bufferSAs, RecursionDepth, theGlobalVariables, k, bufferSAs.TheObjects[RecursionDepth-1].kModules.size/2);
      int indexSA= this->IndexSubalgebra(theGlobalVariables.rootSAsGenerateAll.TheObjects[RecursionDepth], theGlobalVariables);
      if (indexSA==-1)
      { bufferSAs.TheObjects[RecursionDepth].ComputeAllButAmbientWeyl();
        this->TheObjects[currentAlgebraIndex].indicesSubalgebrasContainingK.AddOnTopNoRepetition(this->size);
        this->GenerateAllReductiveRootSubalgebrasContainingInputUpToIsomorphism(bufferSAs, RecursionDepth+1, theGlobalVariables);
      } else
        this->TheObjects[currentAlgebraIndex].indicesSubalgebrasContainingK.AddOnTopNoRepetition(indexSA);
      bufferSAs.TheObjects[RecursionDepth].genK.PopIndexSwapWithLast(bufferSAs.TheObjects[RecursionDepth].genK.size-1);
    }
}

void rootSubalgebras::MakeProgressReportGenerationSubalgebras(rootSubalgebras& bufferSAs, int RecursionDepth, GlobalVariables& theGlobalVariables, int currentIndex, int TotalIndex)
{ if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()==0)
    return;
  std::stringstream out1, out2, out3, out4, out5;
  std::stringstream* tempOut;
  tempOut=&out1;
  for (int i=0; i<=RecursionDepth; i++)
  { (*tempOut) << bufferSAs.TheObjects[i].theDynkinDiagram.DebugString;
    if (i!=RecursionDepth)
      (*tempOut) << ": ";
    if (i==4)
      tempOut=&out2;
    if (i==6)
      tempOut=&out3;
    if (i==8)
      tempOut=&out4;
  }
  out5 << "Included root " << currentIndex+1 << " out of " << TotalIndex << " Total found SAs: " << this->size;
  theGlobalVariables.theIndicatorVariables.ProgressReportString1=out1.str();
  theGlobalVariables.theIndicatorVariables.ProgressReportString2=out2.str();
  theGlobalVariables.theIndicatorVariables.ProgressReportString3=out3.str();
  theGlobalVariables.theIndicatorVariables.ProgressReportString4=out4.str();
  theGlobalVariables.theIndicatorVariables.ProgressReportString5=out5.str();
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void rootSubalgebras::MakeProgressReportAutomorphisms(ReflectionSubgroupWeylGroup& theSubgroup, rootSubalgebra& theRootSA, GlobalVariables& theGlobalVariables)
{ if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()==0)
    return;
  std::stringstream out4, out1;
  out1 << "k_ss: " << theRootSA.theDynkinDiagram.DebugString << " C(k_ss): " << theRootSA.theCentralizerDiagram.DebugString;
  out4 << "Num elements ";
  if (theSubgroup.truncated)
    out4 << "truncated ";
  out4 << "group preserving k: " << theSubgroup.size;
  theGlobalVariables.theIndicatorVariables.ProgressReportString4=out4.str();
  theGlobalVariables.theIndicatorVariables.ProgressReportString1=out1.str();
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void rootSubalgebras::GenerateActionKintersectBIsos(rootSubalgebra& theRootSA, GlobalVariables& theGlobalVariables)
{ Selection emptySel;
  emptySel.init(theRootSA.SimpleBasisCentralizerRoots.size);
  this->ComputeNormalizerOfCentralizerIntersectNilradical(theGlobalVariables.subGroupActionNormalizerCentralizer, emptySel, theRootSA, theGlobalVariables);
}

void rootSubalgebras::GenerateKintersectBOuterIsos(rootSubalgebra& theRootSA, GlobalVariables& theGlobalVariables)
{ Selection fullSel;
  fullSel.init(theRootSA.SimpleBasisCentralizerRoots.size);
  fullSel.incrementSelectionFixedCardinality(theRootSA.SimpleBasisCentralizerRoots.size);
  this->ComputeNormalizerOfCentralizerIntersectNilradical(theGlobalVariables.subGroupActionNormalizerCentralizer, fullSel, theRootSA, theGlobalVariables);
}

void rootSubalgebras::ComputeActionNormalizerOfCentralizerIntersectNilradical(Selection& SelectedBasisRoots, rootSubalgebra& theRootSA, GlobalVariables& theGlobalVariables)
{ ReflectionSubgroupWeylGroup& theSubgroup=theGlobalVariables.subGroupActionNormalizerCentralizer;
  this->ComputeNormalizerOfCentralizerIntersectNilradical(theSubgroup, SelectedBasisRoots, theRootSA, theGlobalVariables);
  this->ActionsNormalizerCentralizerNilradical.SetSize(theSubgroup.size-1);
  root tempRoot;
  for(int i=0; i<theSubgroup.size-1; i++)
  { this->ActionsNormalizerCentralizerNilradical.TheObjects[i].SetSize(theRootSA.kModules.size);
    for (int j=0; j<theRootSA.kModules.size; j++)
    { tempRoot.Assign(theRootSA.HighestWeightsGmodK.TheObjects[j]);
      theSubgroup.ActByElement(i+1, tempRoot);
      int tempI=theRootSA.GetIndexKmoduleContainingRoot(tempRoot);
      this->ActionsNormalizerCentralizerNilradical.TheObjects[i].TheObjects[j]= tempI;
    //  for (int k=0; k<theRootSA.kModules.TheObjects[j].size; k++)
    //  { tempRoot.Assign(theRootSA.kModules.TheObjects[j].TheObjects[k]);
    //    theSubgroup.ActByElement(i+1, tempRoot);
    //    assert(tempI==theRootSA.GetIndexKmoduleContainingRoot(tempRoot));
    //  }
    }
    if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()!=0)
    { std::stringstream out;
      out << "Computing action of element " << i+1 << " out of " << theSubgroup.size;
      theGlobalVariables.theIndicatorVariables.ProgressReportString4 = out.str();
      theGlobalVariables.MakeReport();
    }
  }
}

void rootSubalgebras::ComputeNormalizerOfCentralizerIntersectNilradical(ReflectionSubgroupWeylGroup& outputSubgroup, Selection& SelectedBasisRoots, rootSubalgebra& theRootSA, GlobalVariables& theGlobalVariables)
{ roots selectedRootsBasisCentralizer;
  selectedRootsBasisCentralizer.size=0;
  for (int i=0; i<SelectedBasisRoots.MaxSize; i++)
    if (!SelectedBasisRoots.selected[i])
      selectedRootsBasisCentralizer.AddObjectOnTop(theRootSA.SimpleBasisCentralizerRoots.TheObjects[i]);
  outputSubgroup.AmbientWeyl.Assign(theRootSA.AmbientWeyl);
  this->MakeProgressReportAutomorphisms(outputSubgroup, theRootSA, theGlobalVariables);
  outputSubgroup.AmbientWeyl.Assign(this->AmbientWeyl);
  theRootSA.GenerateIsomorphismsPreservingBorel(theRootSA, theGlobalVariables, &outputSubgroup, true);
  //std::string tempS;
  //theSubgroup.ElementToString(tempS);
  //theGlobalVariables.theIndicatorVariables.StatusString1=tempS;
  //theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  //theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
  outputSubgroup.ComputeSubGroupFromGeneratingReflections(selectedRootsBasisCentralizer, outputSubgroup.ExternalAutomorphisms, theGlobalVariables, this->UpperLimitNumElementsWeyl, false);
  outputSubgroup.simpleGenerators.CopyFromBase(selectedRootsBasisCentralizer);
  this->CentralizerIsomorphisms.MakeActualSizeAtLeastExpandOnTop(this->size);
  this->CentralizerOuterIsomorphisms.MakeActualSizeAtLeastExpandOnTop(this->size);
  this->CentralizerIsomorphisms.AddObjectOnTop(outputSubgroup);
  this->CentralizerOuterIsomorphisms.SetSize(this->CentralizerIsomorphisms.size);
  this->CentralizerOuterIsomorphisms.LastObject()->ExternalAutomorphisms.CopyFromBase(outputSubgroup.ExternalAutomorphisms);
  this->CentralizerOuterIsomorphisms.LastObject()->AmbientWeyl.Assign(this->AmbientWeyl);
  this->MakeProgressReportAutomorphisms(outputSubgroup, theRootSA, theGlobalVariables);
  //theSubgroup.ComputeDebugString();
}

bool rootSubalgebras::ApproveKmoduleSelectionWRTActionsNormalizerCentralizerNilradical(Selection& targetSel, GlobalVariables& theGlobalVariables)
{ if (!this->flagUsingActionsNormalizerCentralizerNilradical)
    return true;
  for (int i=0; i<this->ActionsNormalizerCentralizerNilradical.size; i++)
    if (!this->ApproveSelAgainstOneGenerator(this->ActionsNormalizerCentralizerNilradical.TheObjects[i], targetSel, theGlobalVariables))
      return false;
  return true;
}

void rootSubalgebras::RaiseSelectionUntilApproval(Selection& targetSel, GlobalVariables& theGlobalVariables)
{ bool raised=true;
  while (raised)
  { raised=false;
    for (int i=0; i<this->ActionsNormalizerCentralizerNilradical.size; i++)
      if(!this->ApproveSelAgainstOneGenerator(this->ActionsNormalizerCentralizerNilradical.TheObjects[i], targetSel, theGlobalVariables))
      { this->ApplyOneGenerator(this->ActionsNormalizerCentralizerNilradical.TheObjects[i], targetSel, theGlobalVariables);
        raised=true;
      }
  }
}

void rootSubalgebras::ApplyOneGenerator(List<int>& generator, Selection& targetSel, GlobalVariables& theGlobalVariables)
{ Selection& tempSel= theGlobalVariables.selApproveSelAgainstOneGenerator;
  tempSel.initNoMemoryAllocation();
  for (int i=0; i<targetSel.CardinalitySelection; i++)
    tempSel.AddSelectionAppendNewIndex(generator.TheObjects[targetSel.elements[i]]);
  targetSel.Assign(tempSel);
}

bool rootSubalgebras::ApproveSelAgainstOneGenerator(List<int>& generator, Selection& targetSel, GlobalVariables& theGlobalVariables)
{ Selection& tempSel= theGlobalVariables.selApproveSelAgainstOneGenerator;
  tempSel.initNoMemoryAllocation();
  for (int i=0; i<targetSel.CardinalitySelection; i++)
    tempSel.AddSelectionAppendNewIndex(generator.TheObjects[targetSel.elements[i]]);
  for (int i=0; i<tempSel.MaxSize; i++)
  { if (targetSel.selected[i] && !tempSel.selected[i])
      return true;
    if (!targetSel.selected[i] && tempSel.selected[i])
      return false;
  }
  return true;
}

int rootSubalgebras::IndexSubalgebra(rootSubalgebra& input, GlobalVariables& theGlobalVariables)
{ this->ProblemCounter++;
  //if (this->ProblemCounter==49)
    //Stop();
  int result=-1;
  for (int j=0; j<this->size; j++)
  { rootSubalgebra& right=this->TheObjects[j];
    if (input.theDynkinDiagram.DebugString == right.theDynkinDiagram.DebugString && input.theCentralizerDiagram.DebugString == right.theCentralizerDiagram.DebugString)
    { result=j;
      if (!this->flagUseDynkinClassificationForIsomorphismComputation)
      { input.ComputeAllButAmbientWeyl();
        if(!input.GenerateIsomorphismsPreservingBorel(right, theGlobalVariables, 0, false))
          result=-1;
      }
      if (result!=-1)
        return result;
    }
  }
  return result;
}

bool rootSubalgebras::IsANewSubalgebra(rootSubalgebra& input, GlobalVariables& theGlobalVariables)
{ return this->IndexSubalgebra(input, theGlobalVariables)==-1;
}

void rootSubalgebra::ComputeRootsOfK()
{ this->AllRootsK.size=0;
  this->PositiveRootsK.size=0;
  hashedRoots& AllRoots=this->AmbientWeyl.RootSystem;
  this->AllRootsK.MakeActualSizeAtLeastExpandOnTop(AllRoots.size);
  this->PositiveRootsK.MakeActualSizeAtLeastExpandOnTop(AllRoots.size);
  for (int i=0; i<AllRoots.size; i++)
  { root tempHW, tempLW;
    this->ComputeHighestWeightInTheSameKMod(AllRoots.TheObjects[i], tempHW);
    this->ComputeLowestWeightInTheSameKMod(AllRoots.TheObjects[i], tempLW);
    if (tempHW.IsEqualToZero() || tempLW.IsEqualToZero())
    { this->AllRootsK.AddRoot(AllRoots.TheObjects[i]);
      if (AllRoots.TheObjects[i].IsPositiveOrZero())
        this->PositiveRootsK.AddRoot(AllRoots.TheObjects[i]);
    }
  }
}

void rootSubalgebra::ComputeDebugString(GlobalVariables& theGlobalVariables)
{ this->ElementToString(this->DebugString, theGlobalVariables);
}

int rootSubalgebra::ProblemCounter2=0;

bool rootSubalgebra::attemptExtensionToIsomorphismNoCentralizer(roots& Domain, roots& Range, GlobalVariables& theGlobalVariables, int RecursionDepth, ReflectionSubgroupWeylGroup* outputAutomorphisms, bool GenerateAllpossibleExtensions, bool* abortKmodule, roots* additionalDomain, roots* additionalRange)
{ int CurrentRank=Domain.GetRankOfSpanOfElements(theGlobalVariables);
  assert(CurrentRank==Range.GetRankOfSpanOfElements(theGlobalVariables));
  if (abortKmodule!=0)
    *abortKmodule=false;
  if (CurrentRank==this->AmbientWeyl.CartanSymmetric.NumRows)
    return this->IsAnIsomorphism(Domain, Range, theGlobalVariables, outputAutomorphisms, additionalDomain, additionalRange);
  if (RecursionDepth>=theGlobalVariables.rootsAttemptExtensionIso1.size)
  { int theDimension= this->AmbientWeyl.CartanSymmetric.NumRows;
    theGlobalVariables.rootsAttemptExtensionIso1.SetSize(theGlobalVariables.rootsAttemptExtensionIso1.size+theDimension);
    theGlobalVariables.rootsAttemptExtensionIso2.SetSize(theGlobalVariables.rootsAttemptExtensionIso2.size+theDimension);
    theGlobalVariables.rootSAAttemptExtensionIso1.SetSize(theGlobalVariables.rootSAAttemptExtensionIso1.size+theDimension);
    theGlobalVariables.rootSAAttemptExtensionIso2.SetSize(theGlobalVariables.rootSAAttemptExtensionIso2.size+theDimension);
    theGlobalVariables.rootsAttemptExtensionIso3.SetSize(theGlobalVariables.rootsAttemptExtensionIso3.size+theDimension);
    theGlobalVariables.rootsAttemptExtensionIso4.SetSize(theGlobalVariables.rootsAttemptExtensionIso4.size+theDimension);
  }
//  if (ProblemCounter==49)
//    Stop();
  roots& domainRec =theGlobalVariables.rootsAttemptExtensionIso1.TheObjects[RecursionDepth];
  roots& rangeRec =theGlobalVariables.rootsAttemptExtensionIso2.TheObjects[RecursionDepth];
  domainRec.CopyFromBase(Domain); rangeRec.CopyFromBase(Range);
  rootSubalgebra& leftSA=theGlobalVariables.rootSAAttemptExtensionIso1.TheObjects[RecursionDepth];
  rootSubalgebra& rightSA= theGlobalVariables.rootSAAttemptExtensionIso2.TheObjects[RecursionDepth];
  Rational tempRatD, tempRatR;
  root& LastRootD=*domainRec.LastObject();
  root& LastRootR=*rangeRec.LastObject();
  if (RecursionDepth!=0)
    for (int i=0; i<domainRec.size; i++)
    { this->AmbientWeyl.RootScalarCartanRoot(domainRec.TheObjects[i], LastRootD, tempRatD);
      this->AmbientWeyl.RootScalarCartanRoot(rangeRec.TheObjects[i], LastRootR, tempRatR);
      if (!tempRatR.IsEqualTo(tempRatD))
        return false;
    }
  leftSA.genK.size=0; rightSA.genK.size=0;
  leftSA.AmbientWeyl.Assign(this->AmbientWeyl);
  rightSA.AmbientWeyl.Assign(this->AmbientWeyl);
  leftSA.genK.AddListOnTop(domainRec); rightSA.genK.AddListOnTop(rangeRec);
  leftSA.ComputeAllButAmbientWeyl(); rightSA.ComputeAllButAmbientWeyl();
  if (RecursionDepth!=0)
    if (leftSA.theDynkinDiagram.DebugString!=rightSA.theDynkinDiagram.DebugString || leftSA.theCentralizerDiagram.DebugString!=rightSA.theCentralizerDiagram.DebugString || rightSA.kModules.size!=leftSA.kModules.size)
    { if (abortKmodule!=0)
        *abortKmodule=true;
      return false;
    }
  int counter =0;
  domainRec.AddObjectOnTop(leftSA.HighestWeightsGmodK.TheObjects[counter]);
  while(domainRec.GetRankOfSpanOfElements(theGlobalVariables)==CurrentRank)
  { counter++;
    assert(leftSA.kModules.size>counter);
    domainRec.PopIndexSwapWithLast(domainRec.size-1);
    domainRec.AddObjectOnTop(leftSA.HighestWeightsGmodK.TheObjects[counter]);
  }
  //find a minimal possible new kmodule to throw in
  for (int i=0; i<leftSA.kModules.size; i++)
    if (leftSA.kModules.TheObjects[i].size> leftSA.kModules.TheObjects[counter].size)
    { domainRec.LastObject()->Assign(leftSA.HighestWeightsGmodK.TheObjects[i]);
      if (domainRec.GetRankOfSpanOfElements(theGlobalVariables)==CurrentRank)
        domainRec.LastObject()->Assign(leftSA.HighestWeightsGmodK.TheObjects[counter]);
      else
        counter=i;
    }
  assert(domainRec.GetRankOfSpanOfElements(theGlobalVariables)==CurrentRank+1);
  roots& firstKmodLeft= leftSA.kModules.TheObjects[counter];
  bool result=false;
  bool tempBool;
  for (int i=0; i<rightSA.kModules.size; i++)
    if (firstKmodLeft.size==rightSA.kModules.TheObjects[i].size)
      for (int j=0; j<firstKmodLeft.size; j++)
      { rangeRec.AddObjectOnTop(rightSA.kModules.TheObjects[i].TheObjects[j]);
        if (rangeRec.GetRankOfSpanOfElements(theGlobalVariables)==(CurrentRank+1))
        { if (this->attemptExtensionToIsomorphismNoCentralizer(domainRec, rangeRec, theGlobalVariables, RecursionDepth+1, outputAutomorphisms, GenerateAllpossibleExtensions, &tempBool, additionalDomain, additionalRange))
          { if (!GenerateAllpossibleExtensions)
              return true;
            else
              result=true;
          }
          else
            if (tempBool)
              break;
        }
        rangeRec.PopIndexSwapWithLast(rangeRec.size-1);
      }
  return result;
}

bool rootSubalgebra::IsAnIsomorphism(roots &domain, roots &range, GlobalVariables& theGlobalVariables, ReflectionSubgroupWeylGroup* outputAutomorphisms, roots* additionalDomain, roots* additionalRange)
{ MatrixLargeRational& matB= theGlobalVariables.matRootSAIso;
  roots& tempRoots= theGlobalVariables.rootsRootSAIso;
  int theDimension= this->AmbientWeyl.CartanSymmetric.NumRows;
  tempRoots.SetSize(theDimension);
  matB.init(theDimension, theDimension);
  this->flagAnErrorHasOccuredTimeToPanic=true;
//  if (this->ProblemCounter==49)
  //  Stop();
  for (int i=0; i<theDimension; i++)
  { for (int j=0; j<theDimension; j++)
      matB.elements[i][j].Assign(domain.TheObjects[i].TheObjects[j]);
    tempRoots.TheObjects[i].MakeZero(theDimension);
  }
  //if (this->flagAnErrorHasOccuredTimeToPanic)
  //{  domain.ComputeDebugString();
  //  range.ComputeDebugString();
  //  matB.ComputeDebugString();
  //}
  matB.Invert(theGlobalVariables);
  Rational tempRat2;
  for (int k=0; k<theDimension; k++)
    for (int i=0; i<theDimension; i++)
      for (int j=0; j<theDimension; j++)
      { tempRat2.Assign(range.TheObjects[j].TheObjects[k]);
        tempRat2.MultiplyBy(matB.elements[i][j]);
        tempRoots.TheObjects[i].TheObjects[k]+=(tempRat2);
      }
  //if (this->flagAnErrorHasOccuredTimeToPanic)
    //tempRoots.ComputeDebugString();
  root tempRoot;
  if (additionalDomain!=0)
    for (int i=0; i<additionalDomain->size; i++)
    { tempRoots.MakeBasisChange(additionalDomain->TheObjects[i], tempRoot);
      if (!tempRoot.IsEqualTo(additionalRange->TheObjects[i]))
        return false;
    }
  for (int i=0; i<this->AmbientWeyl.RootsOfBorel.size; i++)
  { tempRoots.MakeBasisChange(this->AmbientWeyl.RootsOfBorel.TheObjects[i], tempRoot);
    if (!this->IsARoot(tempRoot))
      return false;
  }
  if (outputAutomorphisms!=0)
    outputAutomorphisms->ExternalAutomorphisms.AddObjectOnTop(tempRoots);
  return true;
}

void rootSubalgebra::ElementToHtml(int index, std::string& path, SltwoSubalgebras* sl2s, GlobalVariables& theGlobalVariables)
{ std::fstream output; std::string tempS;
  std::string MyPath, childrenPath;
  MyPath=path; childrenPath=path;
  std::stringstream out;
  out << path << "rootSA" << index;
  childrenPath=out.str();
  out << ".html";
  MyPath=out.str();
  CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(output, MyPath, false, true, false);
  this->ElementToString(tempS, sl2s, index,  false, true, true, theGlobalVariables);
  output << tempS;
  output.close();
}

void rootSubalgebra::ElementToStringHeaderFooter(std::string& outputHeader, std::string& outputFooter, bool useLatex, bool useHtml, bool includeKEpsCoords)
{ outputHeader.clear();
  outputFooter.clear();
  if (useHtml)
  { outputHeader.append("g/k k-submodules<table border=\"1\">\n<tr><th>id</th><th>size</th>");
    outputHeader.append("<th>b\\cap k-lowest weight</th><th>b\\cap k-highest weight</th><th>roots</th>");
    outputHeader.append("<th>epsilon coordinates</th>");
    if (includeKEpsCoords)
      outputHeader.append("<th>epsilon coords wrt k</th>");
    outputHeader.append("</tr>");
    outputFooter.append("</td></tr></table>");
  }
  if(useLatex)
  { if (!includeKEpsCoords)
      outputHeader.append("\n\n\\noindent\\begin{tabular}{|cccccc|} \n \\multicolumn{5}{c}{");
    else
      outputHeader.append("\n\n\\noindent\\begin{tabular}{|ccccccc|} \n \\multicolumn{6}{c}{");
    outputHeader.append("$\\mathfrak{g}/\\mathfrak{k}$ $\\mathfrak{k}$-submodules} \\\\");
    outputHeader.append ("id & size & $\\mathfrak{\\mathfrak{b}\\cap\\mathfrak{k}}$-lowest weight&");
    outputHeader.append(" $\\mathfrak{\\mathfrak{b}\\cap\\mathfrak{k}}$-highest weight& elements");
    outputHeader.append(" & $\\varepsilon$-coordinates ");
    if (includeKEpsCoords)
      outputHeader.append(" & $\\varepsilon$-coordinates wrt $\\mathfrak{k}$");
    outputHeader.append("\\\\");
    outputFooter.append("\\hline \\end{tabular}");
  }
}

void rootSubalgebra::ElementToString(std::string& output, SltwoSubalgebras* sl2s, int indexInOwner, bool useLatex, bool useHtml, bool includeKEpsCoords, GlobalVariables& theGlobalVariables)
{ std::stringstream out;
  std::string tempS;
  std::string latexFooter, latexHeader;
  if (this->SimpleBasisgEpsCoords.size!=this->SimpleBasisK.size || this->SimpleBasisKEpsCoords.size!= this->SimpleBasisK.size || this->kModulesgEpsCoords.size!= this->kModules.size || this->kModulesKepsCoords.size!= this->kModules.size)
    includeKEpsCoords=false;
  int LatexLineCounter=0;
  this->ElementToStringHeaderFooter (latexHeader, latexFooter, useLatex, useHtml, includeKEpsCoords);
  this->theDynkinDiagram.ElementToString(tempS, true);
  if (useLatex)
    out << "\\noindent$\\mathfrak{k}_{ss}:$ ";
  else
  { out << "k_{ss}: ";
    CGIspecificRoutines::clearDollarSigns(tempS, tempS);
  }
  out << tempS;
  if (sl2s!=0)
  { out <<" &nbsp&nbsp&nbsp Contained in: ";
    for (int i=0; i<this->indicesSubalgebrasContainingK.size; i++)
    { if (useHtml)
        out << "<a href=\"./rootHtml_rootSA" << this->indicesSubalgebrasContainingK.TheObjects[i] << ".html\">";
      rootSubalgebra& largerSA= sl2s->theRootSAs.TheObjects[this->indicesSubalgebrasContainingK.TheObjects[i]];
      CGIspecificRoutines::clearDollarSigns(largerSA.theDynkinDiagram.DebugString, tempS);
      out << tempS;
      if (useHtml)
        out << "</a>, ";
    }
    if (useHtml)
      out << "<br> <a href=\"./rootHtml.html\">Back to root subsystem table </a> ";
  }
  this->SimpleBasisK.ElementToString(tempS, useLatex, useHtml, false);
  if (useHtml)
    out << "\n<br>\n";
  if (useLatex)
    out << "\n\\noindent";
  out << " Simple basis: "<<tempS;
  this->SimpleBasisgEpsCoords.ElementToStringEpsilonForm(tempS, useLatex, useHtml, false);
  if (useHtml)
    out << "\n<br>\nSimple basis epsilon form: " << tempS;
  this->SimpleBasisKEpsCoords.ElementToStringEpsilonForm(tempS, useLatex, useHtml, false);
  if (useHtml)
    out << "\n<br>\nSimple basis epsilon form with respect to k: " << tempS;
  this->theCentralizerDiagram.ElementToString(tempS, true);
  if(!useLatex)
    CGIspecificRoutines::clearDollarSigns(tempS, tempS);
  if (useLatex)
    out << "\n\n\\noindent ";
  if (useHtml)
    out << "<br>\n";
  if (useLatex)
    out<< "$C(\\mathfrak{k_{ss}})_{ss}$: ";
  else
    out << "C(k_{ss})_{ss}: ";
  out << tempS;
  //int CartanPieceSize=
    //this->AmbientWeyl.CartanSymmetric.NumRows- this->SimpleBasisCentralizerRoots.size-
    //  this->SimpleBasisK.size;
  //if (CartanPieceSize!=0)
  //{  if (useLatex)
  //    out << "$\\oplus\\mathfrak{h}_" << CartanPieceSize<<"$";
  //  if (useHtml)
  //    out <<"+h_"<<CartanPieceSize;
  //}
  if (useHtml)
    out << "<br>\n simple basis centralizer: ";
  if (useLatex)
    out << "; simple basis centralizer: ";
  this->SimpleBasisCentralizerRoots.ElementToString(tempS, true, true, false);
  out << tempS;
  if (sl2s!=0)
  { if (useHtml)
      out << "\n<br>\n";
    if (useHtml)
      out << "\n<br>";
    List<int> hCharacteristics_S_subalgebras;
    //this->ComputeIndicesSl2s(indexInOwner, *sl2s, hCharacteristics_S_subalgebras);
    hCharacteristics_S_subalgebras.size=0;
    out << "\nCharacteristics of sl(2) subalgebras that have no centralizer in k (total " <<sl2s->IndicesSl2sContainedInRootSA.TheObjects[indexInOwner].size<<"): ";
    for (int i=0; i<sl2s->IndicesSl2sContainedInRootSA.TheObjects[indexInOwner].size; i++)
    { int theSl2index=sl2s->IndicesSl2sContainedInRootSA.TheObjects[indexInOwner].TheObjects[i];
      slTwo& theSl2 = sl2s->TheObjects[theSl2index];
      if (useHtml)
        out << "<a href=\"./sl2s/sl2s.html#sl2index" << theSl2index << "\">";
      out << theSl2.hCharacteristic.ElementToString() << ", ";
      if (useHtml)
        out << "</a>";
      bool isS_subalgebra=true;
//      theSl2.hCharacteristic.ComputeDebugString();
      for (int j=0; j<theSl2.IndicesContainingRootSAs.size; j++)
      { int indexComparison= theSl2.IndicesContainingRootSAs.TheObjects[j];
        if (indexComparison!=indexInOwner && sl2s->theRootSAs.TheObjects[indexComparison].indicesSubalgebrasContainingK.ContainsObject(indexInOwner))
        { isS_subalgebra=false;
          break;
        }
      }
      if (isS_subalgebra)
        hCharacteristics_S_subalgebras.AddObjectOnTop(sl2s->IndicesSl2sContainedInRootSA.TheObjects[indexInOwner].TheObjects[i]);
    }
    if (useHtml)
      out << "\n<br>\n";
    out << "\nS-sl(2) subalgebras in k (total " << hCharacteristics_S_subalgebras.size << "): ";
    for (int i=0; i<hCharacteristics_S_subalgebras.size; i++)
      out << sl2s->TheObjects[hCharacteristics_S_subalgebras.TheObjects[i]].hCharacteristic.ElementToString() << ", ";
  }
  if (useHtml)
    out << "<br>\n Number g/k k-submodules: ";
  if (useLatex)
    out << "\n\n\\noindent Number $\\mathfrak{g}/\\mathfrak{k}$ $\\mathfrak{k}$-submodules: ";
  out << this->LowestWeightsGmodK.size ;
  if (useHtml)
    out << "<br>\n";
  if (useLatex)
    out << "\n\n";
  out << latexHeader;
  this->kModulesgEpsCoords.SetSize(this->kModules.size);
  for (int i=0; i<this->kModules.size; i++)
  { this->LowestWeightsGmodK.TheObjects[i].ElementToString(tempS, useLatex);
    if (useHtml)
      out << "\n<tr><td>";
    if (useLatex)
      out << "\\hline ";
    out << i;
    if (useHtml)
      out << "</td><td>";
    if (useLatex)
      out << " & ";
    out << this->kModules.TheObjects[i].size;
    if (useHtml)
      out << "</td><td>";
    if (useLatex)
      out << " & ";
    out << tempS;
    this->HighestWeightsGmodK.TheObjects[i].ElementToString(tempS, useLatex);
    if (useHtml)
      out << "</td><td>";
    if (useLatex)
      out << " & ";
    out  << tempS;
    if (useHtml)
      out << "</td><td>";
    if (useLatex)
      out << " & \n";
    this->kModules.TheObjects[i].ElementToString(tempS, useLatex, useHtml, true);
    out << tempS;
    if (useHtml)
      out << "</td><td>";
    if (i>=this->kModulesgEpsCoords.size)
      this->AmbientWeyl.GetEpsilonCoords(this->kModules.TheObjects[i], this->kModulesgEpsCoords.TheObjects[i], theGlobalVariables);
    this->kModulesgEpsCoords.TheObjects[i].ElementToStringEpsilonForm(tempS, useLatex, useHtml, true);
    out << tempS;
    if (useLatex)
      out << " & \n";
    if (useHtml)
      out << "</td>";
    if (includeKEpsCoords)
    { if (useHtml)
        out << "<td>";
      if (useLatex)
        out << " & ";
      this->kModulesKepsCoords.TheObjects[i].ElementToStringEpsilonForm(tempS, useLatex, useHtml, true);
      out << tempS;
      if (useHtml)
        out << "</td>";
      if (useLatex)
        out << "\\\\\n";
    }
    if (useHtml)
      out << "</tr>";
    if (LatexLineCounter>this->NumGmodKtableRowsAllowedLatex)
    { LatexLineCounter=0;
      out << latexFooter << latexHeader;
    }
    if (i!=this->kModules.size-1)
    { LatexLineCounter+=this->kModules.TheObjects[i].size;
      if (useLatex)
       if ((LatexLineCounter>this->NumGmodKtableRowsAllowedLatex) && (LatexLineCounter!=this->kModules.TheObjects[i].size))
        { out << latexFooter << latexHeader;
          LatexLineCounter = this->kModules.TheObjects[i].size;
        }
    }
  }
  if (useHtml)
    out << "</table>";
  if (useLatex)
    out << latexFooter;
  if ((useLatex|| useHtml)&& this->theMultTable.size==0 && this->kModules.size!=0)
    this->GenerateKmodMultTable(this->theMultTable, this->theOppositeKmods, theGlobalVariables);
  if (this->theMultTable.size!=0)
  { if (useHtml)
      out << "\n\n Pairing table:\n\n";
    if (useLatex)
      out << "\n\n\\noindent Pairing table:\n\n\\noindent";
    this->theMultTable.ElementToString(tempS, useLatex, useHtml, *this);
    out << tempS << "\n";
  }
  output=out.str();
}

bool rootSubalgebra::IsGeneratingSingularVectors(int indexKmod, roots& NilradicalRoots)
{ root& currentRoot=this->HighestWeightsGmodK.TheObjects[indexKmod];
  root tempRoot;
  for (int i=0; i<NilradicalRoots.size; i++)
  { tempRoot.Assign(currentRoot);
    tempRoot.Add(NilradicalRoots.TheObjects[i]);
    if (this->IsARootOrZero(tempRoot))
      if (!NilradicalRoots.ContainsObject(tempRoot))
        return false;
  }
  return true;
}

void rootSubalgebra::MakeGeneratingSingularVectors(coneRelation& theRelation, roots& nilradicalRoots)
{ bool isMaximal=false;
  root beta, tempRoot;
  //theRelation.ComputeDebugString(*this);
  while (!isMaximal)
  { isMaximal=true;
    for (int i=0; i<theRelation.AlphaCoeffs.size; i++)
    { for (int j=0; j<nilradicalRoots.size; j++)
      { tempRoot.Assign(theRelation.Alphas.TheObjects[i]);
        //theRelation.Alphas.TheObjects[i].ComputeDebugString();
        //nilradicalRoots.TheObjects[j].ComputeDebugString();
        tempRoot.Add(nilradicalRoots.TheObjects[j]);
        //tempRoot.ComputeDebugString();
        //theRelation.ComputeDebugString(*this);
        if ((this->IsARoot(tempRoot) || tempRoot.IsEqualToZero()) &&(!nilradicalRoots.ContainsObject(tempRoot)))
        { this->ComputeHighestWeightInTheSameKMod(tempRoot, tempRoot);
          //tempRoot.ComputeDebugString();
          tempRoot.Subtract(theRelation.Alphas.TheObjects[i]);
          //tempRoot.ComputeDebugString();
          theRelation.Alphas.TheObjects[i].Add(tempRoot);
          int tempI=theRelation.Betas.IndexOfObject(tempRoot);
          if (tempI==-1)
          { theRelation.Betas.AddObjectOnTop(tempRoot);
            theRelation.BetaCoeffs.AddObjectOnTop(theRelation.AlphaCoeffs.TheObjects[i]);
          }
          else
            theRelation.BetaCoeffs.TheObjects[tempI]+=(theRelation.AlphaCoeffs.TheObjects[i]);
          isMaximal=false;
          break;
        }
        if (theRelation.Alphas.TheObjects[i].IsEqualToZero())
        { theRelation.Alphas.PopIndexSwapWithLast(i);
          theRelation.AlphaCoeffs.PopIndexSwapWithLast(i);
          i--;
          isMaximal=false;
          break;
        }
      }
    }
  }
}

void DynkinDiagramRootSubalgebra::Sort()
{ //doing bubble sort
  for (int i=0; i<this->SimpleBasesConnectedComponents.size; i++)
    for (int j=i+1; j<this->SimpleBasesConnectedComponents.size; j++)
    { bool tempBool=false;
      if (this->SimpleBasesConnectedComponents.TheObjects[i].size<this->SimpleBasesConnectedComponents.TheObjects[j].size)
        tempBool=true;
      if (this->SimpleBasesConnectedComponents.TheObjects[i].size==this->SimpleBasesConnectedComponents.TheObjects[j].size)
        tempBool=((this->DynkinTypeStrings.TheObjects[i])<(this->DynkinTypeStrings.TheObjects[j]));
      if (tempBool)
      { this->DynkinTypeStrings.SwapTwoIndices(i, j);
        this->SimpleBasesConnectedComponents.SwapTwoIndices(i, j);
      }
    }
  this->sameTypeComponents.size=0;
  this->indexInUniComponent.SetSize(this->SimpleBasesConnectedComponents.size);
  this->indexUniComponent.SetSize(this->SimpleBasesConnectedComponents.size);
  this->sameTypeComponents.MakeActualSizeAtLeastExpandOnTop(this->SimpleBasesConnectedComponents.size);
  std::string LastString="";
  for (int i=0; i<this->SimpleBasesConnectedComponents.size; i++)
  { if (!(this->DynkinTypeStrings.TheObjects[i]==LastString))
    { this->sameTypeComponents.SetSize(this->sameTypeComponents.size+1);
      this->sameTypeComponents.LastObject()->size=0;
      LastString=this->DynkinTypeStrings.TheObjects[i];
    }
    this->sameTypeComponents.LastObject()->AddObjectOnTop(i);
    this->indexUniComponent.TheObjects[i]=this->sameTypeComponents.size-1;
    this->indexInUniComponent.TheObjects[i]=this->sameTypeComponents.LastObject()->size-1;
  }
}

void ::DynkinDiagramRootSubalgebra::ComputeDiagramTypeKeepInput(const roots& simpleBasisInput, WeylGroup& theWeyl)
{ this->SimpleBasesConnectedComponents.size=0;
  this->SimpleBasesConnectedComponents.MakeActualSizeAtLeastExpandOnTop(simpleBasisInput.size);
  for (int i=0; i<simpleBasisInput.size; i++)
  { int indexFirstComponentConnectedToRoot=-1;
    for (int j=0; j<this->SimpleBasesConnectedComponents.size; j++)
      if (this->SimpleBasesConnectedComponents.TheObjects[j].ContainsARootNonPerpendicularTo(simpleBasisInput.TheObjects[i], theWeyl))
      { if (indexFirstComponentConnectedToRoot==-1)
        { indexFirstComponentConnectedToRoot=j;
          this->SimpleBasesConnectedComponents.TheObjects[j].AddObjectOnTop(simpleBasisInput.TheObjects[i]);
        }
        else
        { this->SimpleBasesConnectedComponents.TheObjects[indexFirstComponentConnectedToRoot].AddListOnTop(this->SimpleBasesConnectedComponents.TheObjects[j]);
          this->SimpleBasesConnectedComponents.PopIndexSwapWithLast(j);
          j--;
        }
      }
    if (indexFirstComponentConnectedToRoot==-1)
    { this->SimpleBasesConnectedComponents.SetSize(this->SimpleBasesConnectedComponents.size+1);
      this->SimpleBasesConnectedComponents.LastObject()->size=0;
      this->SimpleBasesConnectedComponents.LastObject()->AddObjectOnTop(simpleBasisInput.TheObjects[i]);
    }
  }
//  this->SimpleBasesConnectedComponents.ComputeDebugString();
  this->indicesThreeNodes.SetSize(this->SimpleBasesConnectedComponents.size);
//  this->SimpleBasesConnectedComponents.ComputeDebugString();
  this->DynkinTypeStrings.SetSize(this->SimpleBasesConnectedComponents.size);
//  this->SimpleBasesConnectedComponents.ComputeDebugString();
  this->indicesEnds.SetSize(this->SimpleBasesConnectedComponents.size);
//  this->SimpleBasesConnectedComponents.ComputeDebugString();
  this->ComputeDynkinStrings(theWeyl);
  //this->SimpleBasesConnectedComponents.ComputeDebugString();
  this->Sort();
  //this->SimpleBasesConnectedComponents.ComputeDebugString();
  this->ComputeDebugString();
}

bool DynkinDiagramRootSubalgebra::LetterIsDynkinGreaterThanLetter(char letter1, char letter2)
{ if( (letter1=='B' || letter1=='D') && (letter2=='B' || letter2=='D') )
  { if (letter1==letter2)
      return false;
    if (letter1=='B')
      return true;
    else
      return false;
  }
  return letter1>letter2;
}

bool DynkinDiagramRootSubalgebra::IsGreaterThan(DynkinDiagramRootSubalgebra& right)
{ if (this->RankTotal()>right.RankTotal())
    return true;
  if (this->RankTotal()<right.RankTotal())
    return false;
  assert(this->DynkinTypeStrings.size==this->SimpleBasesConnectedComponents.size);
  for (int i=0; i<this->DynkinTypeStrings.size; i++)
  { if (this->SimpleBasesConnectedComponents.TheObjects[i].size>right.SimpleBasesConnectedComponents.TheObjects[i].size)
      return true;
     if (right.SimpleBasesConnectedComponents.TheObjects[i].size>this->SimpleBasesConnectedComponents.TheObjects[i].size)
      return false;
    if (this->LetterIsDynkinGreaterThanLetter( this->DynkinTypeStrings.TheObjects[i].at(1), right.DynkinTypeStrings.TheObjects[i].at(1)))
      return true;
     if (this->LetterIsDynkinGreaterThanLetter( right.DynkinTypeStrings.TheObjects[i].at(1), this->DynkinTypeStrings.TheObjects[i].at(1)))
      return false;
  }
  return this->DebugString>right.DebugString;
}

void DynkinDiagramRootSubalgebra::GetMapFromPermutation(roots& domain, roots& range, List<int>& thePerm, List<List<List<int > > >& theAutos, SelectionWithDifferentMaxMultiplicities& theAutosPerm, DynkinDiagramRootSubalgebra& right)
{ for (int i=0; i<this->SimpleBasesConnectedComponents.size; i++)
    for (int j=0; j<this->SimpleBasesConnectedComponents.TheObjects[i].size; j++)
    { assert(this->SimpleBasesConnectedComponents.TheObjects[i].size==right.SimpleBasesConnectedComponents.TheObjects[thePerm.TheObjects[i]].size);
      domain.AddObjectOnTop( this->SimpleBasesConnectedComponents.TheObjects[i].TheObjects[j]);
      int indexTargetComponent=thePerm.TheObjects[i];
      int indexAutomorphismInComponent=theAutosPerm.Multiplicities.TheObjects[i];
      int indexRoot=theAutos.TheObjects[i].TheObjects[indexAutomorphismInComponent].TheObjects[j];
      range.AddObjectOnTop(right.SimpleBasesConnectedComponents.TheObjects[indexTargetComponent].TheObjects[indexRoot]);
    }
}

void DynkinDiagramRootSubalgebra::ComputeDynkinStrings(WeylGroup& theWeyl)
{ for (int i=0; i<this->SimpleBasesConnectedComponents.size; i++)
    this->ComputeDynkinString(i, theWeyl);
}

void DynkinDiagramRootSubalgebra::ElementToString(std::string& output, bool CombineIsoComponents)
{ std::stringstream out;
  if (!CombineIsoComponents)
    for (int i=0; i<this->SimpleBasesConnectedComponents.size; i++)
    { out << this->DynkinTypeStrings.TheObjects[i];
      if (i!=this->SimpleBasesConnectedComponents.size-1)
        out << "+";
    }
  else
    for (int j=0; j<this->sameTypeComponents.size; j++)
    { int numSameTypeComponents= this->sameTypeComponents.TheObjects[j].size;
      if (numSameTypeComponents!=1)
        out << numSameTypeComponents;
      out << this->DynkinTypeStrings.TheObjects[this->sameTypeComponents.TheObjects[j].TheObjects[0]];
      if (j!=this->sameTypeComponents.size-1)
        out << "+";
    }
  output=out.str();
}

void DynkinDiagramRootSubalgebra::ComputeDynkinString(int indexComponent, WeylGroup& theWeyl)
{ assert(indexComponent<this->SimpleBasesConnectedComponents.size);
  std::stringstream out;
  out << "$";
  roots& currentComponent= this->SimpleBasesConnectedComponents.TheObjects[indexComponent];
  List<int>& currentEnds=this->indicesEnds.TheObjects[indexComponent];
  if (this->numberOfThreeValencyNodes(indexComponent, theWeyl)==1)
  {//type D or E
    //in type D first comes the triple node, then the long string, then the one-root strings
    // the long string is oriented with the end that is connected to the triple node having
    //smaller index
    //in type E similarly the longest string comes first oriented with the root that is linked to the triple node having smaller index
    // then comes the second longest string (oriented in the same fashion)
    // and last the one-root string
    root tripleNode;
    int tripleNodeindex=this->indicesThreeNodes.TheObjects[indexComponent];
    tripleNode.Assign( currentComponent.TheObjects[tripleNodeindex]);
    roots tempRoots;
    tempRoots.CopyFromBase(currentComponent);
    tempRoots.PopIndexSwapWithLast(tripleNodeindex);
    DynkinDiagramRootSubalgebra  tempDiagram;
    tempDiagram.ComputeDiagramTypeKeepInput(tempRoots, theWeyl);
    assert(tempDiagram.SimpleBasesConnectedComponents.size==3);
    List<int> indicesLongComponents;
    indicesLongComponents.size=0;
    Rational tempRat;
    for (int i=0; i<3; i++)
    { if(tempDiagram.SimpleBasesConnectedComponents.TheObjects[i].size>1)
        indicesLongComponents.AddObjectOnTop(i);
      theWeyl.RootScalarCartanRoot(tempDiagram.SimpleBasesConnectedComponents.TheObjects[i].TheObjects[0], currentComponent.TheObjects[tripleNodeindex], tempRat);
      if (tempRat.IsEqualToZero())
        tempDiagram.SimpleBasesConnectedComponents.TheObjects[i].ReverseOrderElements();
    }
    for(int i=0; i<3; i++)
      for(int j=i+1; j<3; j++)
        if (tempDiagram.SimpleBasesConnectedComponents.TheObjects[i].size<tempDiagram.SimpleBasesConnectedComponents.TheObjects[j].size)
        { tempRoots.CopyFromBase(tempDiagram.SimpleBasesConnectedComponents.TheObjects[i]);
          tempDiagram.SimpleBasesConnectedComponents.TheObjects[i].CopyFromBase(tempDiagram.SimpleBasesConnectedComponents.TheObjects[j]);
          tempDiagram.SimpleBasesConnectedComponents.TheObjects[j].CopyFromBase(tempRoots);
        }
    currentComponent.size=0;
    currentComponent.AddObjectOnTop(tripleNode);
    for (int i=0; i<3; i++)
      currentComponent.AddListOnTop(tempDiagram.SimpleBasesConnectedComponents.TheObjects[i]);
    if ( indicesLongComponents.size==1 || indicesLongComponents.size==0)
      out << "D_" << currentComponent.size;
    else
    {//type E
      assert(indicesLongComponents.size==2);
      out << "E_" << currentComponent.size;
    }
  }else
  { Rational length1, length2, tempRat;
    theWeyl.RootScalarCartanRoot(currentComponent.TheObjects[0], currentComponent.TheObjects[0], length1);
    int numLength1=1; int numLength2=0;
    for(int i=1; i<currentComponent.size; i++)
    { theWeyl.RootScalarCartanRoot(currentComponent.TheObjects[i], currentComponent.TheObjects[i],  tempRat);
      if (tempRat.IsEqualTo(length1))
        numLength1++;
      else
      { numLength2++;
        length2.Assign(tempRat);
      }
    }
    if (numLength2==0 )
    { //type A
      out << "A_" << numLength1;
      if (!length1.IsEqualTo(theWeyl.LongRootLength))
        out << "'";
    }
    else
    {//the longer root should have smaller index
      Rational greaterlength, tempRat;
      int numGreaterLength=numLength2;
      int numSmallerLength=numLength1;
      greaterlength.Assign(length2);
      if (length1.IsGreaterThan(length2))
      { greaterlength.Assign(length1);
        numGreaterLength=numLength1;
        numSmallerLength=numLength2;
      }
      theWeyl.RootScalarCartanRoot( currentComponent.TheObjects[currentEnds.TheObjects[0]], currentComponent.TheObjects[currentEnds.TheObjects[0]], tempRat);
      if (greaterlength.IsGreaterThan(tempRat))
        currentEnds.SwapTwoIndices(0, 1);
      if (numLength1==numLength2)
      {//B2, C2, F4 or G2
        if (numLength1!=1)
        { out << "F_4";
          assert(numLength1==2);
        }
        else
        { if (length1.NumShort==6 || length2.NumShort==6)
            out << "G_2";
          else
            out << "B_2=C_2";
        }
      } else
      { if (numGreaterLength>numSmallerLength)
          out << "B_" << currentComponent.size;
        else
          out << "C_" << currentComponent.size;
      }
    }
    currentComponent.SwapTwoIndices(0, currentEnds.TheObjects[0]);
    for (int i=0; i<currentComponent.size; i++)
      for (int j=i+1; j<currentComponent.size; j++)
      { theWeyl.RootScalarCartanRoot(currentComponent.TheObjects[i], currentComponent.TheObjects[j], tempRat);
        if (!tempRat.IsEqualToZero())
        { currentComponent.SwapTwoIndices(i+1, j);
          break;
        }
      }
  }
  out << "$";
  this->DynkinTypeStrings.TheObjects[indexComponent]=out.str();
}

bool DynkinDiagramRootSubalgebra::operator==(const DynkinDiagramRootSubalgebra& right) const
{ if (right.SimpleBasesConnectedComponents.size!= this->SimpleBasesConnectedComponents.size)
    return false;
  for (int i=0; i<this->SimpleBasesConnectedComponents.size; i++)
  { bool tempBool=((this->SimpleBasesConnectedComponents.TheObjects[i].size == right.SimpleBasesConnectedComponents.TheObjects[i].size) &&(this->DynkinTypeStrings.TheObjects[i]==right.DynkinTypeStrings.TheObjects[i]));
    if (!tempBool)
      return false;
  }
  return true;
}

void DynkinDiagramRootSubalgebra::Assign(const DynkinDiagramRootSubalgebra& right)
{ this->DebugString.assign(right.DebugString);
  this->DynkinTypeStrings.CopyFromBase(right.DynkinTypeStrings);
  this->indicesThreeNodes.CopyFromBase(right.indicesThreeNodes);
  this->SimpleBasesConnectedComponents.CopyFromBase(right.SimpleBasesConnectedComponents);
  this->indexInUniComponent.CopyFromBase(right.indexInUniComponent);
  this->indexUniComponent.CopyFromBase(right.indexUniComponent);
  this->indicesEnds.CopyFromBase(right.indicesEnds);
  this->indicesThreeNodes.CopyFromBase(right.indicesThreeNodes);
  this->sameTypeComponents.CopyFromBase(right.sameTypeComponents);
}

void DynkinDiagramRootSubalgebra::GetAutomorphism(List<List<int> >& output, int index)
{ roots& currentComponent= this->SimpleBasesConnectedComponents.TheObjects[index];
  std::string& currentString=this->DynkinTypeStrings.TheObjects[index];
  List<int> thePermutation;
  thePermutation.SetSize(currentComponent.size);
  output.size=0;
  for (int i=0; i<currentComponent.size; i++)
    thePermutation.TheObjects[i]=i;
  output.AddObjectOnTop(thePermutation);
  if (currentString[1]=='A' && currentComponent.size!=1)
  { thePermutation.ReverseOrderElements();
    output.AddObjectOnTop(thePermutation);
  }
  if (currentString[1]=='D')
  { if (currentComponent.size==4)
    {//the automorphism group of the Dynkin Diagram is S3
      thePermutation.TheObjects[1]=2; thePermutation.TheObjects[2]=3; thePermutation.TheObjects[3]=1;
      output.AddObjectOnTop(thePermutation);
      thePermutation.TheObjects[1]=1; thePermutation.TheObjects[2]=3; thePermutation.TheObjects[3]=2;
      output.AddObjectOnTop(thePermutation);
      thePermutation.TheObjects[1]=2; thePermutation.TheObjects[2]=1; thePermutation.TheObjects[3]=3;
      output.AddObjectOnTop(thePermutation);
      thePermutation.TheObjects[1]=3; thePermutation.TheObjects[2]=1; thePermutation.TheObjects[3]=2;
      output.AddObjectOnTop(thePermutation);
      thePermutation.TheObjects[1]=3; thePermutation.TheObjects[2]=2; thePermutation.TheObjects[3]=1;
      output.AddObjectOnTop(thePermutation);
    } else
    { thePermutation.TheObjects[currentComponent.size-2]=currentComponent.size-1;
      thePermutation.TheObjects[currentComponent.size-1]=currentComponent.size-2;
      output.AddObjectOnTop(thePermutation);
    }
  }
  if (currentString=="$E_6$")
  { thePermutation.TheObjects[1]=3; thePermutation.TheObjects[2]=4;
    thePermutation.TheObjects[3]=1; thePermutation.TheObjects[4]=2;
    output.AddObjectOnTop(thePermutation);
  }
}

void DynkinDiagramRootSubalgebra::GetAutomorphisms(List<List<List<int> > > & output)
{ output.SetSize(this->SimpleBasesConnectedComponents.size);
  for (int i=0; i<this->SimpleBasesConnectedComponents.size; i++)
    this->GetAutomorphism( output.TheObjects[i], i);
}

int DynkinDiagramRootSubalgebra::RankTotal()
{ int result=0;
  for (int i=0; i<this->SimpleBasesConnectedComponents.size; i++)
    result+=this->SimpleBasesConnectedComponents.TheObjects[i].size;
  return result;
}

int DynkinDiagramRootSubalgebra::NumRootsGeneratedByDiagram()
{ int result=0;
  assert(this->SimpleBasesConnectedComponents.size==this->DynkinTypeStrings.size);
  for (int i=0; i<this->DynkinTypeStrings.size; i++)
  { int Rank=this->SimpleBasesConnectedComponents.TheObjects[i].size;
    if (this->DynkinTypeStrings.TheObjects[i].at(1)=='A')
      result+=Rank*(Rank+1);
    if (this->DynkinTypeStrings.TheObjects[i].at(1)=='B'|| this->DynkinTypeStrings.TheObjects[i].at(1)=='C')
      result+=Rank*Rank*2;
    if (this->DynkinTypeStrings.TheObjects[i].at(1)=='D')
      result+=Rank*(Rank-1)*2;
    if (this->DynkinTypeStrings.TheObjects[i].at(1)=='E')
    { if (Rank==6)
        result+=72;
      if (Rank==7)
        result+=126;
      if (Rank==8)
        result+=240;
    }
    if (this->DynkinTypeStrings.TheObjects[i].at(1)=='F')
      result+=48;
    if (this->DynkinTypeStrings.TheObjects[i].at(1)=='G')
      result+=12;
  }
  return result;
}

int DynkinDiagramRootSubalgebra::numberOfThreeValencyNodes(int indexComponent, WeylGroup& theWeyl)
{ roots& currentComponent = this->SimpleBasesConnectedComponents.TheObjects[indexComponent];
  int numEnds=0; int result=0;
  this->indicesThreeNodes.TheObjects[indexComponent] =-1;
  this->indicesEnds.TheObjects[indexComponent].size=0;
  for (int i=0; i<currentComponent.size; i++)
  { int counter=0;
    for (int j=0; j<currentComponent.size; j++)
    { Rational tempRat;
      theWeyl.RootScalarCartanRoot(currentComponent.TheObjects[i], currentComponent.TheObjects[j], tempRat);
      if (tempRat.IsNegative())
        counter++;
    }
    assert(counter<=3);
    if (counter==3)
    { result++;
      this->indicesThreeNodes.TheObjects[indexComponent]=i;
    }
    if (counter<=1)
    { numEnds++;
      this->indicesEnds.TheObjects[indexComponent].AddObjectOnTop(i);
    }
  }
  assert(result<=1);
  if (result==1)
    assert(numEnds==3);
  else
    assert(numEnds<=2);
  return result;
}

void rootSubalgebra::GetLinearCombinationFromMaxRankRootsAndExtraRoot(bool DoEnumeration, GlobalVariables& theGlobalVariables)
{ int theDimension = this->AmbientWeyl.CartanSymmetric.NumRows;
  std::stringstream out2;
  std::stringstream out;
  //this->ComputeDebugString(theGlobalVariables);
  out2 << this->DebugString << "\n";
  MatrixLargeRational tempMat;
  this->SimpleBasisK.rootsToMatrix(tempMat);
  tempMat.Invert(theGlobalVariables);
  int counter=0;
  hashedRoots& AllRoots= this->AmbientWeyl.RootSystem;
  for(int i=0; i<AllRoots.size; i++)
  { root linComb;
    if (this->AllRootsK.IndexOfObject(AllRoots.TheObjects[i])==-1)
    { for (int j=0; j<theDimension; j++)
      { linComb.TheObjects[j].MakeZero();
        for(int k=0; k<theDimension; k++)
        { Rational tempRat;
          tempRat.Assign(tempMat.elements[k][j]);
          tempRat.MultiplyBy(AllRoots.TheObjects[i].TheObjects[k]);
          linComb.TheObjects[j]+=(tempRat);
        }
      }
      int x= linComb.FindLCMDenominatorsTruncateToInt();
      linComb.MultiplyByInteger(-x);
      std::string tempS;
      if (this->LinCombToString(AllRoots.TheObjects[i], x, linComb, tempS))
      { out << tempS << "\n";
        counter++;
        if (this->LowestWeightsGmodK.IndexOfObject(AllRoots.TheObjects[i]) !=-1)
          out2 << tempS << "\n";
      }
    }
  }
  out << "\\multicolumn{2}{|c|}{Number of relations: " << counter << " }\\\\\\hline";
  std::string tempS=out.str();
  out2 << "\n\n" << tempS;
  this->DebugString=out2.str();
  if (DoEnumeration)
  { this->TestedRootsAlpha.CopyFromBase(this->LowestWeightsGmodK);
    this->DoKRootsEnumeration(theGlobalVariables);
  }
//  this->GetLinearCombinationFromMaxRankRootsAndExtraRootMethod2();
}

void rootSubalgebra::GetLinearCombinationFromMaxRankRootsAndExtraRootMethod2(GlobalVariables& theGlobalVariables)
{ int theDimension = this->AmbientWeyl.CartanSymmetric.NumRows;
  std::stringstream out;
  out << this->DebugString << "\n\n";
  root tempRoot;
  tempRoot.Assign(this->SimpleBasisK.TheObjects[0]);
  this->ComputeHighestWeightInTheSameKMod(tempRoot, tempRoot);
  hashedRoots& AllRoots= this->AmbientWeyl.RootSystem;
  for (int l=0; l<this->SimpleBasisK.size; l++)
  { Rational tempRat;
    this->AmbientWeyl.RootScalarCartanRoot(tempRoot, this->SimpleBasisK.TheObjects[l], tempRat);
    if (!tempRat.IsEqualToZero())
    { int counter=0;
      roots tempRoots;
      tempRoots.CopyFromBase(this->SimpleBasisK);
      tempRoots.TheObjects[l].Assign(tempRoot);
      MatrixLargeRational tempMat;
      tempRoots.rootsToMatrix(tempMat);
      tempMat.Invert(theGlobalVariables);
      for(int i=0; i<AllRoots.size; i++)
      { root linComb;
        if (this->AllRootsK.IndexOfObject(AllRoots.TheObjects[i])==-1)
        { for (int j=0; j<theDimension; j++)
          { linComb.TheObjects[j].MakeZero();
            for(int k=0; k<theDimension; k++)
            { Rational tempRat;
              tempRat.Assign(tempMat.elements[k][j]);
              tempRat.MultiplyBy(AllRoots.TheObjects[i].TheObjects[k]);
              linComb.TheObjects[j]+=(tempRat);
            }
          }
          int x= linComb.FindLCMDenominatorsTruncateToInt();
          linComb.MultiplyByInteger(-x);
          std::string tempS;
          if (this->LinCombToStringDistinguishedIndex(l, AllRoots.TheObjects[i], x, linComb, tempS))
          { out << tempS << "\n";
            counter++;
          }
        }
      }
      out << "\\multicolumn{2}{|c|}{Number of relations: " << counter << " }\\\\\\hline";
    }
  }
  this->DebugString=out.str();
}

bool rootSubalgebra::LinCombToString(root& alphaRoot, int coeff, root& linComb, std::string& output)
{ int theDimension = this->AmbientWeyl.CartanSymmetric.NumRows;
  if (coeff==1)
    return false;
  std::stringstream out;
  std::string tempS;
  alphaRoot.ElementToString(tempS);
  out << "(" << tempS << ")&$";
  out << coeff << "\\alpha_" << theDimension+1;
  for (int i=0; i<theDimension; i++)
  {  //if (linComb.coordinates[i].IsEqualToZero())
    //  return false;
    linComb.TheObjects[i].ElementToString(tempS);
    if (tempS!="0")
    { if (tempS=="-1")
        tempS="-";
      if (tempS=="1")
        tempS="+";
      if (!(tempS[0]=='+')&& !(tempS[0]=='-'))
        tempS.insert(0, "+");
      out << tempS << "\\beta_" << i+1;
    }
  }
  out << "=0$\\\\";
  output=out.str();
  return true;
}

bool rootSubalgebra::LinCombToStringDistinguishedIndex(int distinguished, root& alphaRoot, int coeff, root& linComb, std::string& output)
{ int theDimension = this->AmbientWeyl.CartanSymmetric.NumRows;
  if (coeff==1)
    return false;
  std::stringstream out;
  std::string tempS;
  alphaRoot.ElementToString(tempS);
  out << "(" << tempS << ")&$";
  out << coeff << "\\alpha_" << theDimension+1;
  for (int i=0; i<theDimension; i++)
  { //if (linComb.coordinates[i].IsEqualToZero())
    //  return false;
    linComb.TheObjects[i].ElementToString(tempS);
    if (tempS!="0")
    { if (tempS=="-1")
        tempS="-";
      if (tempS=="1")
        tempS="+";
      if (!(tempS[0]=='+') && !(tempS[0]=='-'))
        tempS.insert(0, "+");
      out << tempS;
      if (i!=distinguished)
        out << "\\beta_" << i+1;
      else
        out << "\\gamma";
    }
  }
  out << "=0$\\\\";
  output=out.str();
  return true;
}

void rootSubalgebra::DoKRootsEnumeration(GlobalVariables& theGlobalVariables)
{ this->theKEnumerations.SetSize(this->PosRootsKConnectedComponents.size);
  this->theKComponentRanks.SetSize(this->PosRootsKConnectedComponents.size);
  for (int i=0; i<this->PosRootsKConnectedComponents.size; i++)
  { this->theKEnumerations.TheObjects[i].init(this->PosRootsKConnectedComponents.TheObjects[i].size);
    this->PosRootsKConnectedComponents.TheObjects[i].ComputeDebugString();
    this->theKComponentRanks.TheObjects[i]=this->PosRootsKConnectedComponents.TheObjects[i].GetRankOfSpanOfElements(theGlobalVariables);
  }
  this->DoKRootsEnumerationRecursively(0, theGlobalVariables);
}

void rootSubalgebra::DoKRootsEnumerationRecursively(int indexEnumeration, GlobalVariables& theGlobalVariables)
{ int theRank=this->theKComponentRanks.TheObjects[indexEnumeration];
  int numRuns=MathRoutines::NChooseK( this->PosRootsKConnectedComponents.TheObjects[indexEnumeration].size, theRank);
  this->theKEnumerations.TheObjects[indexEnumeration].initNoMemoryAllocation();
  for (int i=0; i<numRuns; i++)
  { this->theKEnumerations.TheObjects[indexEnumeration].incrementSelectionFixedCardinality(theRank);
    if (indexEnumeration<this->PosRootsKConnectedComponents.size-1)
      this->DoKRootsEnumerationRecursively(indexEnumeration+1, theGlobalVariables);
    else
      this->KEnumerationsToLinComb(theGlobalVariables);
  }
}

void rootSubalgebra::KEnumerationsToLinComb(GlobalVariables& theGlobalVariables)
{ int theDimension = this->AmbientWeyl.CartanSymmetric.NumRows;
  MatrixLargeRational tempMat;
  Selection tempSelection;
  tempMat.init((int)theDimension, (int)theDimension);
  int counter=0;
  for (int i=0; i<this->PosRootsKConnectedComponents.size; i++)
  { this->PosRootsKConnectedComponents.TheObjects[i].SelectionToMatrixAppend(this->theKEnumerations.TheObjects[i], theDimension, tempMat, counter);
    counter+=this->theKComponentRanks.TheObjects[i];
  }
  //tempMat.ComputeDebugString();
  if (tempMat.Invert(theGlobalVariables))
  { //tempMat.ComputeDebugString();
    for (int l=0; l<this->TestedRootsAlpha.size; l++)
    { root linComb;
      root& TestedRootAlpha= this->TestedRootsAlpha.TheObjects[l];
      for (int j=0; j<theDimension; j++)
      { linComb.TheObjects[j].MakeZero();
        for(int k=0; k<theDimension; k++)
        { Rational tempRat;
          tempRat.Assign(tempMat.elements[k][j]);
          tempRat.MultiplyBy(TestedRootAlpha.TheObjects[k]);
          linComb.TheObjects[j]+=(tempRat);
        }
      }
      int x= linComb.FindLCMDenominatorsTruncateToInt();
      linComb.MultiplyByInteger(-x);
      bool foundBadCombination=true;
      for (int i=0; i<theDimension; i++)
        if (linComb.TheObjects[i].NumShort==-1 || linComb.TheObjects[i].NumShort== 1)
        { foundBadCombination=false;
          break;
        }
      if (foundBadCombination)
      { std::string tempS;
        this->LinCombToString(TestedRootAlpha, x, linComb, tempS);
        Stop();
      }
    }
  }
}

void PolynomialRationalCoeff::Evaluate(intRoot& values, Rational& output)
{ output.MakeZero();
  std::string tempS;
  Rational tempLRat, tempLRat2;
  for (int i=0; i<this->size; i++)
  { tempLRat.Assign(this->TheObjects[i].Coefficient);
    for (int j=0; j<this->NumVars; j++)
      for (int k=0; k<this->TheObjects[i].degrees[j]; k++)
      { tempLRat.MultiplyByInt(values.TheObjects[j]);
        ParallelComputing::SafePoint();
      }
    output+=(tempLRat);
  }
}

void IndicatorWindowVariables::Assign(IndicatorWindowVariables& right)
{ this->ProgressReportString1=right.ProgressReportString1;
  this->ProgressReportString2= right.ProgressReportString2;
  this->ProgressReportString3= right.ProgressReportString3;
  this->ProgressReportString4= right.ProgressReportString4;
  this->ProgressReportString5= right.ProgressReportString5;
  this->String1NeedsRefresh=right.String1NeedsRefresh;
  this->String2NeedsRefresh=right.String2NeedsRefresh;
  this->String3NeedsRefresh=right.String3NeedsRefresh;
  this->String4NeedsRefresh=right.String4NeedsRefresh;
  this->String5NeedsRefresh=right.String5NeedsRefresh;
  this->StatusString1=right.StatusString1;
  this->StatusString1NeedsRefresh=right.StatusString1NeedsRefresh;
  this->flagRootIsModified= right.flagRootIsModified;
  this->modifiedRoot=right.modifiedRoot;
}

void simplicialCones::ComputeDebugString()
{ this->ElementToString(this->DebugString);
}

void simplicialCones::ElementToString(std::string& output)
{ std::stringstream out;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ComputeDebugString();
    out << this->TheObjects[i].DebugString <<"\n";
  }
  output= out.str();
}

void simplicialCones::initFromDirections(roots& directions, GlobalVariables& theGlobalVariables, CombinatorialChamberContainer& owner)
{ Selection tempSel;
  assert(directions.size>0);
  tempSel.init(directions.size);
  roots tempRoots;
  int theDimension;
  if (directions.size==0)
    return;
  else
    theDimension=directions.TheObjects[0].size;
  this->size=0;
  this->ConesHavingFixedNormal.size=0;
  this->theFacets.ClearTheObjects();
  int maxSize=MathRoutines::NChooseK(directions.size, theDimension);
  int maxNumFacets= 2*MathRoutines::NChooseK(directions.size, theDimension-1);
  this->MakeActualSizeAtLeastExpandOnTop(maxSize);
  this->theFacets.MakeActualSizeAtLeastExpandOnTop(maxNumFacets);
  this->ConesHavingFixedNormal.MakeActualSizeAtLeastExpandOnTop(maxNumFacets);
  for (int i=0; i<maxSize; i++)
  { tempSel.incrementSelectionFixedCardinality(theDimension);
    tempRoots.size=0;
    for (int j=0; j<theDimension; j++)
      tempRoots.AddRoot(directions.TheObjects[tempSel.elements[j]]);
    if (tempRoots.GetRankOfSpanOfElements(theGlobalVariables)==theDimension &&  theDimension!=1)
    { this->SetSize(this->size+1);
    //  if (this->size==53)
    //  { Stop();
    //    tempRoots.ComputeDebugString();
    //  }
      this->LastObject()->ComputeFromDirections(tempRoots, theGlobalVariables, theDimension);
    //  this->LastObject()->ComputeDebugString();
      for (int j=0; j<theDimension; j++)
      { root tempRoot;
        tempRoot.Assign(this->LastObject()->TheObjects[j]);
        tempRoot.ScaleToIntegralMinHeightFirstNonZeroCoordinatePositive();
        int x = this->theFacets.IndexOfObjectHash(tempRoot);
        if (x==-1)
        { this->theFacets.AddObjectOnTopHash(tempRoot);
          this->ConesHavingFixedNormal.SetSize(this->theFacets.size);
          this->ConesHavingFixedNormal.LastObject()->size=0;
          x= this->theFacets.size-1;
        }
        this->ConesHavingFixedNormal.TheObjects[x].AddObjectOnBottom(this->size-1);
      }
    }
  }
  owner.theHyperplanes.CopyFromHash(this->theFacets);
}

bool simplicialCones::SeparatePoints(root& point1, root& point2, root* PreferredNormal)
{ if (PreferredNormal==0)
  { for (int i=0; i<this->size; i++)
      if (this->TheObjects[i].SeparatesPoints(point1, point2))
        return true;
  }
  else
  { root tempRoot;
    tempRoot.Assign(*PreferredNormal);
    tempRoot.ScaleToIntegralMinHeightFirstNonZeroCoordinatePositive();
    int x= this->theFacets.IndexOfObjectHash(tempRoot);
    assert(x!=-1);
    int theSize=this->ConesHavingFixedNormal.TheObjects[x].size;
    for (int i=0; i<theSize; i++)
    { int y= this->ConesHavingFixedNormal.TheObjects[x].TheObjects[i];
      if (this->TheObjects[y].SeparatesPoints(point1, point2))
        return true;
    }
  }
  return false;
}

void  GeneratorsPartialFractionAlgebra::GetMonomialFromExponentAndElongation(intRoot& exponent, int elongation, MonomialInCommutativeAlgebra<Integer, GeneratorsPartialFractionAlgebra, GeneratorPFAlgebraRecord>& output)
{ output.ClearTheObjects();
  output.Coefficient.Assign(IOne);
  int theDimension= exponent.size;
  if (elongation==0 || elongation==-1)
  { for (int i=0; i<theDimension; i++)
    { if (exponent.TheObjects[i]!=0)
      { GeneratorPFAlgebraRecord tempGen;
        tempGen.GeneratorRoot.MakeZero(theDimension); tempGen.GeneratorRoot.TheObjects[i]=1;
        tempGen.Elongation=0;
        int tempI= exponent.TheObjects[i];
        if (elongation==-1) tempI=-tempI;
        output.MultiplyByGenerator(tempGen, tempI);
      }
    }
    if (elongation==-1)
      output.Coefficient.MultiplyBy(IMOne);
    return;
  }
  if (elongation==1)
    return;
  GeneratorPFAlgebraRecord tempGen;
  tempGen.GeneratorRoot= exponent;
  tempGen.Elongation= elongation;
  output.MultiplyByGenerator(tempGen, 1);
}

GeneratorPFAlgebraRecord::GeneratorPFAlgebraRecord()
{ this->ValueIsComputed=false;
  this->Value = new IntegerPoly;
#ifdef CGIversionLimitRAMuse
  ParallelComputing::GlobalPointerCounter++;
  ParallelComputing::CheckPointerCounters();
#endif
}

GeneratorPFAlgebraRecord::~GeneratorPFAlgebraRecord()
{ delete this->Value; this->Value=0;
#ifdef CGIversionLimitRAMuse
  ParallelComputing::GlobalPointerCounter--;
  if(ParallelComputing::GlobalPointerCounter>::ParallelComputing::cgiLimitRAMuseNumPointersInList)std::exit(0);
#endif
}

void GeneratorPFAlgebraRecord::operator =(const GeneratorPFAlgebraRecord& right)
{ this->GeneratorRoot = right.GeneratorRoot;
  this->Elongation = right.Elongation;
  this->ValueIsComputed= right.ValueIsComputed;
  this->Value->Assign(*right.Value);
}

int GeneratorsPartialFractionAlgebra::HashFunction() const
{ return this->GeneratorIndex;
}

void GeneratorsPartialFractionAlgebra::ElementToString(std::string& output, const PolynomialOutputFormat& PolyFormat)const
{ this->ElementToString(output, PolyFormat, -1);
}

void GeneratorsPartialFractionAlgebra::ElementToString(std::string& output, const PolynomialOutputFormat& PolyFormat, int theDimension)const
{ std::string tempS;
  GeneratorPFAlgebraRecord& currentGen= this->theGenerators.TheObjects[this->GeneratorIndex];
  currentGen.ElementToString(tempS, PolyFormat);
  if(this->GeneratorPower==1)
  { output.assign(tempS);
    return;
  }
  std::stringstream out;
  out << "(" << tempS << ")^{" << this->GeneratorPower << "}";
  output=out.str();
}

void GeneratorsPartialFractionAlgebra::ConvertToIntegerPoly(IntegerPoly& output, int theDimension)
{ this->theGenerators.TheObjects[this->GeneratorIndex].GetValue(output, theDimension);
  if (this->GeneratorPower<0)
  { assert(output.size==1);
    assert(output.TheObjects[0].Coefficient.IsEqualTo(IOne));
    Monomial<Integer> tempM;
    tempM.Coefficient.Assign(IOne);
    tempM.init((int)theDimension);
    for (int i=0; i<theDimension; i++)
      tempM.degrees[i]=(int)(output.TheObjects[0].degrees[i]*this->GeneratorPower);
    output.ClearTheObjects();
    output.AddMonomial(tempM);
  }
  if (this->GeneratorPower==0)
  { output.MakeNVarConst((int)theDimension, IOne);
    assert(false);
  }
  if (this->GeneratorPower>1)
    output.RaiseToPower(this->GeneratorPower, IOne);
}

bool GeneratorsPartialFractionAlgebra::operator ==(const GeneratorsPartialFractionAlgebra& right)
{ return this->GeneratorIndex== right.GeneratorIndex;
}

void GeneratorsPartialFractionAlgebra::operator =(const GeneratorsPartialFractionAlgebra& right)
{ this->GeneratorIndex= right.GeneratorIndex;
  this->GeneratorPower= right.GeneratorPower;
}

void PolyPartFractionNumerator::ConvertToIntegerPoly(IntegerPoly& output, int theDimension)
{ output.Nullify((int)theDimension);
  IntegerPoly tempP;
  IntegerPoly tempP2;
  for (int i=0; i<this->size; i++)
  { tempP.MakeNVarConst((int)theDimension, this->TheObjects[i].Coefficient);
    tempP.ComputeDebugString();
    for(int j=0; j<this->TheObjects[i].size; j++)
    { this->TheObjects[i].TheObjects[j].ConvertToIntegerPoly(tempP2, theDimension);
      //tempP2.ComputeDebugString();
      tempP.MultiplyBy(tempP2);
      //tempP.ComputeDebugString();
    }
    output.AddPolynomial(tempP);
    //output.ComputeDebugString();
  }
}

void GeneratorPFAlgebraRecord::ElementToString(std::string& output, const PolynomialOutputFormat& PolyFormat)const
{ std::stringstream out1, out2;
  int theDimension= this->GeneratorRoot.size;
  for (int i=0; i<theDimension; i++)
    if (this->GeneratorRoot.TheObjects[i]!=0)
    { if (this->GeneratorRoot.TheObjects[i]==1)
        out1 << PolyFormat.GetLetterIndex(i);
      else
        out1 << PolyFormat.GetLetterIndex(i) << "^{" << this->GeneratorRoot.TheObjects[i] << "}";
    }
  if (this->Elongation==0)
  { output= out1.str();
    return;
  }
  out2 << "p_{" << this->Elongation << "}(" << out1.str() << ")";
  output= out2.str();
}

void GeneratorPFAlgebraRecord::GetValue(IntegerPoly& output, int theDimension)
{ if (this->ValueIsComputed)
  { output.Assign(*this->Value);
    return;
  }
  output.Nullify((int)theDimension);
  this->ValueIsComputed=true;
  Monomial<Integer> tempM;
  tempM.init((int)theDimension);
  if (this->Elongation>=0)
    tempM.Coefficient.Assign(IOne);
  else
    tempM.Coefficient.Assign(IMOne);
  int tempI= this->Elongation;
  if (tempI<0) {tempI=-tempI; }
  if (tempI==0){tempI=1; }
  for (int i=0; i<tempI; i++)
  { for (int j=0; j<theDimension; j++)
    { if ( this->Elongation<0)
        tempM.degrees[j]=(int) (-this->GeneratorRoot.TheObjects[j]*(i+1));
      if( this->Elongation>0)
        tempM.degrees[j]=(int) (this->GeneratorRoot.TheObjects[j]*i);
      if( this->Elongation==0)
        tempM.degrees[j]=(int) (this->GeneratorRoot.TheObjects[j]);
    }
    output.AddMonomial(tempM);
  }
  this->Value->Assign(output);
}

void PolyPartFractionNumeratorLight::AssignPolyPartFractionNumerator(PolyPartFractionNumerator& from)
{ this->SetSize(from.size);
  this->Coefficients.SetSize(from.size);
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].CopyFromHeavy(from.TheObjects[i]);
    this->Coefficients.TheObjects[i]=from.TheObjects[i].Coefficient.value;
  }
}

void PolyPartFractionNumeratorLight::ComputePolyPartFractionNumerator(PolyPartFractionNumerator& output, int theDimension) const
{ output.Nullify((int)theDimension);
  output.MakeActualSizeAtLeastExpandOnTop(this->size);
  for (int i=0; i<this->size; i++)
  { MonomialInCommutativeAlgebra<Integer, GeneratorsPartialFractionAlgebra, GeneratorPFAlgebraRecord> tempM;
    tempM.Coefficient.value= this->Coefficients.TheObjects[i];
    for (int j=0; j<this->TheObjects[i].size; j++)
      tempM.MultiplyByGenerator(this->TheObjects[i].TheObjects[j]);
    output.AddMonomial(tempM);
  }
}

int PolyPartFractionNumeratorLight::NumGeneratorsUsed()
{ int result=0;
  for (int i=0; i<this->size; i++)
    result+=this->TheObjects[i].size;
  return result;
}

void PolyPartFractionNumeratorLight::AssignPolyPartFractionNumeratorLight(const PolyPartFractionNumeratorLight& right)
{ this->CopyFromLight(right);
  this->Coefficients.CopyFromLight(right.Coefficients);
}

bool affineCone::SplitByAffineHyperplane(affineHyperplane& theKillerPlane, affineCones& output)
{ return true;
}

bool affineCone::WallIsInternalInCone(affineHyperplane& theKillerCandidate)
{ return true;
}

inline int affineCone::GetDimension()
{ if (this->theWalls.size==0)
    return 0;
  return this->theWalls.TheObjects[0].affinePoint.size;
}

inline int affineCone::HashFunction() const
{ int tempMin=MathRoutines::Minimum(this->theWalls.size, ::SomeRandomPrimesSize);
  int result=0;
  for (int i=0; i<tempMin; i++)
    result+= this->theWalls.TheObjects[i].HashFunction()*::SomeRandomPrimes[i];
  return result;
}

void MatrixLargeRational::ComputePotentialChangeGradient(MatrixLargeRational& matA, Selection& BaseVariables, int NumTrueVariables, int ColumnIndex, Rational& outputChangeGradient, bool& hasAPotentialLeavingVariable)
{ hasAPotentialLeavingVariable = false;
  outputChangeGradient.MakeZero();
  for (int j=0; j<matA.NumRows; j++)
  { if (BaseVariables.elements[j]>=NumTrueVariables)
      outputChangeGradient+=(matA.elements[j][ColumnIndex]);
    hasAPotentialLeavingVariable =hasAPotentialLeavingVariable || matA.elements[j][ColumnIndex].IsPositive();
  }
  if (ColumnIndex>=NumTrueVariables)
    outputChangeGradient.Subtract(ROne);
}

void MatrixLargeRational::GetMaxMovementAndLeavingVariableRow(Rational& maxMovement, int& LeavingVariableRow, int EnteringVariable, int NumTrueVariables, MatrixLargeRational& tempMatA, MatrixLargeRational& matX, Selection& BaseVariables)
{ LeavingVariableRow=-1;
  maxMovement.MakeZero();
  for(int i=0; i<tempMatA.NumRows; i++)
  { Rational tempRat;
    tempRat.Assign(tempMatA.elements[i][EnteringVariable]);
    if (tempRat.IsPositive())
    { tempRat.Invert();
      tempRat.MultiplyBy(matX.elements[BaseVariables.elements[i]][0]);
      if (maxMovement.IsGreaterThan(tempRat)|| (LeavingVariableRow==-1 ))
      { maxMovement.Assign(tempRat);
        LeavingVariableRow=i;
      }
    }
  }
}

bool MatrixLargeRational  ::SystemLinearEqualitiesWithPositiveColumnVectorHasNonNegativeNonZeroSolution(MatrixLargeRational& matA, MatrixLargeRational& matb, MatrixLargeRational& outputPoint, GlobalVariables& theGlobalVariables)
//this function return true if Ax=b>=0 has a solution with x>=0 and records a solution x at outputPoint
//else returns false, where b is a given nonnegative column vector, A is an n by m matrix
//and x is a column vector with m entries
{ MatrixLargeRational& tempMatA=theGlobalVariables.matSimplexAlgorithm1;
  MatrixLargeRational& matX=theGlobalVariables.matSimplexAlgorithm2;
  MatrixLargeRational& tempDebugMat=theGlobalVariables.matSimplexAlgorithm3;
  //MatrixLargeRational& tempMatb=theGlobalVariables.matSimplexAlgorithm3;
  Selection& BaseVariables = theGlobalVariables.selSimplexAlg2;
  Rational GlobalGoal; GlobalGoal.MakeZero();
  assert (matA.NumRows== matb.NumRows);
  for (int j=0; j<matb.NumRows; j++)
  { GlobalGoal+=(matb.elements[j][0]);
    assert(!matb.elements[j][0].IsNegative());
  }
  if (GlobalGoal.IsEqualToZero())
    return false;
  int NumTrueVariables=matA.NumCols;
  //tempMatb.Assign(matb);
  tempMatA.init(matA.NumRows, NumTrueVariables+matA.NumRows);
  matX.init(tempMatA.NumCols, 1);
  HashedList<Selection>& VisitedVertices = theGlobalVariables.hashedSelSimplexAlg;
  VisitedVertices.ClearTheObjects();
  BaseVariables.init(tempMatA.NumCols);
  tempMatA.NullifyAll();  matX.NullifyAll();
  for (int j=0; j<matA.NumCols; j++)
    for (int i=0; i<matA.NumRows; i++)
      tempMatA.elements[i][j].Assign(matA.elements[i][j]);
  for (int j=0; j<matA.NumRows; j++)
  { tempMatA.elements[j][j+NumTrueVariables].MakeOne();
    matX.elements[j+NumTrueVariables][0].Assign(matb.elements[j][0]);
    BaseVariables.AddSelectionAppendNewIndex(j+NumTrueVariables);
  }
  if (MatrixLargeRational::flagAnErrorHasOccurredTimeToPanic)
  { tempDebugMat.Assign(tempMatA);
    tempMatA.ComputeDebugString(); matX.ComputeDebugString();
  }
  Rational  PotentialChangeGradient, ChangeGradient; //Change, PotentialChange;
  int EnteringVariable=0;
  bool WeHaveNotEnteredACycle=true;
//  int ProblemCounter=0;
  while (EnteringVariable!=-1 && WeHaveNotEnteredACycle && GlobalGoal.IsPositive())
  {//  ProblemCounter++;
  //  if (ProblemCounter==8)
    //{ BaseVariables.ComputeDebugString();
    //}
    //tempMatA.ComputeDebugString(); matX.ComputeDebugString();
    EnteringVariable=-1; ChangeGradient.MakeZero();
    for (int i=0; i<tempMatA.NumCols; i++)
    { if (!BaseVariables.selected[i])
      { Rational PotentialChangeGradient; bool hasAPotentialLeavingVariable;
        MatrixLargeRational::ComputePotentialChangeGradient(  tempMatA, BaseVariables, NumTrueVariables, i, PotentialChangeGradient, hasAPotentialLeavingVariable);
        if (PotentialChangeGradient.IsGreaterThanOrEqualTo(ChangeGradient) && hasAPotentialLeavingVariable)
        { EnteringVariable= i;
          ChangeGradient.Assign(PotentialChangeGradient);
        }
      }
    }
    if (EnteringVariable!=-1)
    { int LeavingVariableRow;  Rational MaxMovement;
      MatrixLargeRational::GetMaxMovementAndLeavingVariableRow(MaxMovement, LeavingVariableRow, EnteringVariable, NumTrueVariables, tempMatA, matX, BaseVariables);
      Rational tempRat, tempTotalChange;
      assert(!tempMatA.elements[LeavingVariableRow][EnteringVariable].IsEqualToZero());
      tempRat.Assign(tempMatA.elements[LeavingVariableRow][EnteringVariable]);
      tempRat.Invert();
  //    if (BaseVariables.elements[LeavingVariableRow]==34)
  //      tempMatA.ComputeDebugString();
      for (int i=0; i<tempMatA.NumRows; i++)
        assert(tempMatA.elements[i][BaseVariables.elements[i]].IsEqualTo(ROne));
      tempMatA.RowTimesScalar(LeavingVariableRow, tempRat);
      //if (BaseVariables.elements[LeavingVariableRow]==34)
      //  tempMatA.ComputeDebugString();
      tempTotalChange.Assign(MaxMovement);
      tempTotalChange.MultiplyBy(ChangeGradient);
      matX.elements[EnteringVariable][0]+=(MaxMovement);
      if (!tempTotalChange.IsEqualToZero())
      { VisitedVertices.ClearTheObjects();
        GlobalGoal.Subtract(tempTotalChange);
      }
      else
      { //BaseVariables.ComputeDebugString();
        int tempI= VisitedVertices.IndexOfObjectHash(BaseVariables);
        if (tempI==-1)
          VisitedVertices.AddObjectOnTopHash(BaseVariables);
        else
          WeHaveNotEnteredACycle=false;
      }
      //if (BaseVariables.elements[LeavingVariableRow]==34)
      //  tempMatA.ComputeDebugString();
      for (int i=0; i<tempMatA.NumRows; i++)
      { if (!tempMatA.elements[i][EnteringVariable].IsEqualToZero()&& i!=LeavingVariableRow)
        { tempRat.Assign(tempMatA.elements[i][EnteringVariable]);
          tempRat.MultiplyBy(MaxMovement);
          matX.elements[BaseVariables.elements[i]][0].Subtract(tempRat);
          tempRat.Assign(tempMatA.elements[i][EnteringVariable]);
          tempRat.Minus();
          tempMatA.AddTwoRows(LeavingVariableRow, i, 0, tempRat);
        }
        if (i==LeavingVariableRow)
          matX.elements[BaseVariables.elements[i]][0].MakeZero();
        //tempMatA.ComputeDebugString();
        //matX.ComputeDebugString();
      }
      assert(matX.elements[BaseVariables.elements[LeavingVariableRow]][0].IsEqualToZero());
      BaseVariables.selected[BaseVariables.elements[LeavingVariableRow]]=false;
      BaseVariables.elements[LeavingVariableRow]= EnteringVariable;
      BaseVariables.selected[EnteringVariable]= true;
      //BaseVariables.ComputeDebugString();
      for (int i=0; i<tempMatA.NumRows; i++)
        assert(tempMatA.elements[i][BaseVariables.elements[i]].IsEqualTo(ROne));
    }
//    if (::MatrixLargeRational::flagAnErrorHasOccurredTimeToPanic)
//    { MatrixLargeRational tempMat;
//      tempMat.Assign(matX);
//      tempMat.ComputeDebugString();
//      tempDebugMat.ComputeDebugString();
//      tempMat.MultiplyOnTheLeft(tempDebugMat);
//      tempMat.ComputeDebugString();
//      assert(tempMat.IsEqualTo(matb));
//    }
  }
//  std::string tempS;
//  std::stringstream out;
//  for (int i=0; i<BaseVariables.CardinalitySelection; i++)
//  { int tempI=BaseVariables.elements[i];
//    matX.elements[tempI][0].ElementToString(tempS);
//    out << tempS <<"(";
//    if (tempI<matA.NumCols)
//    {  for (int j=0; j<matA.NumRows; j++)
//      { matA.elements[j][tempI].ElementToString(tempS);
//        out << tempS;
//        if (j!=matA.NumRows-1)
//          out <<", ";
//      }
//    } else
//      out<<"dummy column " << i <<" ";
//    out <<")";
//    if (i!=BaseVariables.CardinalitySelection-1)
//      out <<"+";
//  }
//  tempS=out.str();
  for(int i=NumTrueVariables; i<matX.NumRows; i++)
    if (matX.elements[i][0].IsPositive())
      return false;
  outputPoint.Resize(NumTrueVariables, 1, false);
  for (int i=0; i<NumTrueVariables; i++)
    outputPoint.elements[i][0].Assign(matX.elements[i][0]);
  return true;
}

//this function return true if Ax<=b has a solution
//and records a point at outputPoint
//else returns false
bool MatrixLargeRational::SystemLinearInequalitiesHasSolution(MatrixLargeRational& matA, MatrixLargeRational& matb, MatrixLargeRational& outputPoint)
{/* static MatrixLargeRational tempMatA;
  static MatrixLargeRational matX;
  static int NumTrueVariables;
  int numExtraColumns=0;
  static Rational GlobalGoal;
  GlobalGoal.MakeZero();
  assert (matA.NumRows== matb.NumRows);
  for (int j=0; j<matb.NumRows; j++)
    if (matb.elements[j][0].IsNegative())
      numExtraColumns++;
  NumTrueVariables= matA.NumCols;
  tempMatA.init(matA.NumRows, NumTrueVariables*2+matA.NumRows+numExtraColumns);
  matX.init(tempMatA.NumCols, 1);
  static HashedList<Selection> VisitedVertices;
  VisitedVertices.ClearTheObjects();
  static Selection NonZeroSlackVariables;
  static Selection BaseVariables;
  BaseVariables.init(tempMatA.NumCols);
  tempMatA.NullifyAll();
  matX.NullifyAll();
  for (int j=0; j<matA.NumCols; j++)
  {  for (int i=0; i<matA.NumRows; i++)
    {  tempMatA.elements[i][j].Assign(matA.elements[i][j]);
      tempMatA.elements[i][j+NumTrueVariables].Assign(matA.elements[i][j]);
      tempMatA.elements[i][j+NumTrueVariables].Minus();
    }
  }
  int LowestBadIndex= tempMatA.NumCols- numExtraColumns;
  int tempCounter=0;
  for (int j=0; j<matA.NumRows; j++)
  { tempMatA.elements[j][j+NumTrueVariables*2].MakeOne();
    if (matb.elements[j][0].IsNonNegative())
    {  matX.elements[j+NumTrueVariables*2][0].Assign(matb.elements[j][0]);
      BaseVariables.AddSelectionAppendNewIndex(j+NumTrueVariables*2);
    }
    else
    {  int tempI=NumTrueVariables*2+matA.NumRows+tempCounter;
      matX.elements[tempI][0].Assign(matb.elements[j][0]);
      matX.elements[tempI][0].Minus();
      GlobalGoal.Add(matX.elements[tempI][0]);
      tempMatA.elements[j][tempI].Assign(RMOne);
      tempMatA.RowTimesScalar(j, RMOne);
      BaseVariables.AddSelectionAppendNewIndex(tempI);
      tempCounter++;
    }
  }
  tempMatA.ComputeDebugString(); matX.ComputeDebugString();
  static Rational  PotentialChangeGradient, ChangeGradient; //Change, PotentialChange;
  int EnteringVariable=0;
  bool WeHaveNotEnteredACycle=true;
  while (EnteringVariable!=-1 && WeHaveNotEnteredACycle && GlobalGoal.IsPositive())
  { EnteringVariable=-1;
    ChangeGradient.MakeZero();
    for (int i=0; i<tempMatA.NumCols; i++)
    { BaseVariables.ComputeDebugString();
      if (!BaseVariables.selected[i])
      { PotentialChangeGradient.MakeZero();
        bool hasAPotentialLeavingVariable=false;
        for (int j=0; j<tempMatA.NumRows; j++)
        {  if (BaseVariables.elements[j]>=LowestBadIndex)
          {  static Rational tempRat;
            tempRat.Assign(tempMatA.elements[j][i]);
            PotentialChangeGradient.Add(tempRat);
          }
          hasAPotentialLeavingVariable=hasAPotentialLeavingVariable|| tempMatA.elements[j][i].IsPositive();
        }
        if (i>=LowestBadIndex)
          PotentialChangeGradient.Subtract(ROne);
        if (PotentialChangeGradient.IsGreaterThanOrEqualTo(ChangeGradient) && hasAPotentialLeavingVariable)
        { EnteringVariable= i;
          ChangeGradient.Assign(PotentialChangeGradient);
        }
      }
    }
    if (EnteringVariable!=-1)
    {  int LeavingVariableRow=-1;
      static Rational  MaxMovement;
      MaxMovement.MakeZero();
      for(int i=0; i<tempMatA.NumRows; i++)
      { static Rational tempRat;
        tempRat.Assign(tempMatA.elements[i][EnteringVariable]);
        if (tempRat.IsPositive() && BaseVariables.elements[i]>=NumTrueVariables)
        { tempRat.Invert();
          tempRat.MultiplyBy(matX.elements[BaseVariables.elements[i]][0]);
          if (MaxMovement.IsGreaterThan(tempRat)|| (LeavingVariableRow==-1 ))
          { MaxMovement.Assign(tempRat);
            LeavingVariableRow=i;
          }
        }
      }
      static Rational tempRat, tempTotalChange;
      assert(!tempMatA.elements[LeavingVariableRow][EnteringVariable].IsEqualToZero());
      tempRat.Assign(tempMatA.elements[LeavingVariableRow][EnteringVariable]);
      tempRat.Invert();
      tempMatA.RowTimesScalar(LeavingVariableRow, tempRat);
      tempTotalChange.Assign(MaxMovement);
      tempTotalChange.MultiplyBy(ChangeGradient);
      matX.elements[EnteringVariable][0].Add(MaxMovement);
      if (!tempTotalChange.IsEqualToZero())
      {  VisitedVertices.ClearTheObjects();
        GlobalGoal.Subtract(tempTotalChange);
      }
      else
      { int tempI= VisitedVertices.IndexOfObjectHash(BaseVariables);
        if (tempI==-1)
          VisitedVertices.AddObjectOnTopHash(BaseVariables);
        else
          WeHaveNotEnteredACycle=false;
      }
      for (int i=0; i<tempMatA.NumRows; i++)
      {  tempRat.Assign(tempMatA.elements[i][EnteringVariable]);
        tempRat.MultiplyBy(MaxMovement);
        matX.elements[BaseVariables.elements[i]][0].Subtract(tempRat);
        if (!tempMatA.elements[i][EnteringVariable].IsEqualToZero()&& i!=LeavingVariableRow)
        { tempRat.Assign(tempMatA.elements[i][EnteringVariable]);
          tempRat.Minus();
          tempMatA.AddTwoRows(LeavingVariableRow, i, 0, tempRat);
        }
        tempMatA.ComputeDebugString();
        matX.ComputeDebugString();
      }
      BaseVariables.selected[BaseVariables.elements[LeavingVariableRow]]=false;
      BaseVariables.elements[LeavingVariableRow]= EnteringVariable;
      BaseVariables.selected[EnteringVariable]= true;
      BaseVariables.ComputeDebugString();
    }
  }
  for(int i=LowestBadIndex; i<matX.NumRows; i++)
  { if (matX.elements[i][0].IsPositive())
      return false;
  }
  outputPoint.Resize(NumTrueVariables, 1, false);
  for (int i=0; i<NumTrueVariables; i++)
  {  outputPoint.elements[i][0].Assign(matX.elements[i][0]);
    outputPoint.elements[i][0].Subtract(matX.elements[i+NumTrueVariables][0]);
  }*/
  return true;
}

void affineCone::ProjectFromCombinatorialChamber(CombinatorialChamber& input)
{/* this->theWalls.SetSize(input.ExternalWallsNormals.size);
  for(int i=0; i<this->theWalls.size; i++)
  { if (!this->theWalls.TheObjects[i].
          ProjectFromFacetNormal
            (input.ExternalWallsNormals.TheObjects[i]))
    { this->theWalls.PopIndexSwapWithLast(i);
      i--;
    }
  }*/
}

bool affineHyperplane::operator ==(const affineHyperplane& right)
{ root tempRoot1, tempRoot2;
  tempRoot1.Assign(this->normal);
  tempRoot2.Assign(right.normal);
  tempRoot1.ScaleToIntegralMinHeightFirstNonZeroCoordinatePositive();
  tempRoot2.ScaleToIntegralMinHeightFirstNonZeroCoordinatePositive();
  if (!tempRoot1.IsEqualTo(tempRoot2))
    return false;
  Rational tempRat1, tempRat2;
  root::RootScalarEuclideanRoot(tempRoot1, this->affinePoint, tempRat1);
  root::RootScalarEuclideanRoot(tempRoot1, right.affinePoint, tempRat2);
  return tempRat1.IsEqualTo(tempRat2);
}


bool affineHyperplane::ProjectFromFacetNormal(root& input)
{ Rational tempRat;
  int tempI=input.getIndexFirstNonZeroCoordinate();
  assert(tempI!=-1);
  if (tempI==input.size-1)
    return false;
  this->affinePoint.MakeZero(input.size);
  this->affinePoint.SetSize(input.size-1);
  this->affinePoint.TheObjects[tempI].Assign(input.TheObjects[input.size-1]);
  this->affinePoint.TheObjects[tempI].Minus();
  this->affinePoint.TheObjects[tempI].DivideBy(input.TheObjects[tempI]);
  this->normal.Assign(input);
  this->normal.SetSize(input.size-1);
  return true;
}

bool affineHyperplane::ContainsPoint(root& thePoint)
{ Rational tempRat1, tempRat2;
  root::RootScalarEuclideanRoot(this->normal, thePoint, tempRat1);
  root::RootScalarEuclideanRoot(this->normal, this->affinePoint, tempRat2);
  return tempRat2.IsEqualTo(tempRat1);
}

bool affineHyperplane::HasACommonPointWithPositiveTwoToTheNth_ant()
{ Rational tempRat;
  root::RootScalarEuclideanRoot(this->normal, this->affinePoint, tempRat);
  if (tempRat.IsEqualToZero())
    return true;
  for(int i=0; i<this->normal.size; i++)
  { Rational& tempRat2= this->normal.TheObjects[i];
    if (tempRat.IsNegative() && tempRat2.IsNegative())
      return true;
    if (tempRat.IsPositive() && tempRat2.IsPositive())
      return true;
  }
  return false;
}

void affineHyperplane::MakeFromNormalAndPoint(root& inputPoint, root& inputNormal)
{ this->affinePoint.Assign(inputPoint);
  this->normal.Assign(inputNormal);
}

void affineHyperplane::ElementToString(std::string& output)
{ std::stringstream out;
  std::string tempS;
  this->affinePoint.ElementToString(tempS);
  out << "point: " << tempS;
  this->normal.ElementToString(tempS);
  out << " normal: " << tempS;
  output= out.str();
}

int affineHyperplane::HashFunction() const
{ //warning: if normal gets streched, the hashfunction will change!
  root tempNormal;
  tempNormal.Assign(this->normal);
  tempNormal.ScaleToIntegralMinHeightFirstNonZeroCoordinatePositive();
  Rational tempRat;
  root::RootScalarEuclideanRoot(this->normal, this->affinePoint, tempRat);
  return this->normal.HashFunction()+ tempRat.HashFunction();
}

void affineCones::ProjectFromCombinatorialChambers(CombinatorialChamberContainer &input)
{ this->MakeActualSizeAtLeastExpandOnTop(input.size);
  affineCone tempCone;
  for(int i=0; i<input.size; i++)
  { tempCone.ProjectFromCombinatorialChamber(*input.TheObjects[i]);
    this->AddObjectOnTopHash(tempCone);
  }
}

void affineHyperplanes::ElementToString(std::string& output)
{ std::stringstream out;
  for (int i=0; i<this->size; i++)
  { std::string tempS;
    this->TheObjects[i].ElementToString(tempS);
    out << "index: " << i << " " << tempS << "\n";
  }
  output= out.str();
}

void multTableKmods::ElementToString(std::string& output, rootSubalgebra& owner)
{ this->ElementToString(output, false, false, owner);
}

void multTableKmods::ElementToString(std::string& output, bool useLaTeX, bool useHtml, rootSubalgebra& owner)
{  std::stringstream out;
  out << "\t";
  if (!(useLaTeX||useHtml))
    for (int i=0; i<this->size; i++)
      out << i << "\t";
  else
  { if (useHtml)
      out << "<table><tr><th></th>";
    if (useLaTeX)
    { out << "\\begin{tabular}{c|";
      for (int i=0; i<this->size; i++)
        out << "c";
      out << "|} & ";
    }
    for (int i=0; i<this->size; i++)
    { if (useHtml)
        out << "<th>";
      out << i;
      if (useHtml)
        out << "</th>";
      else
      { if (i!=this->size-1)
          out << "&";
      }
    }
    if (useHtml)
      out << "</tr>";
    if (useLaTeX)
      out << "\\\\\\hline";
  }
  for (int i=0; i<this->size; i++)
  { if (useHtml)
      out << "\n<tr><td>";
    out << "\n" << i;
    if (useLaTeX)
      out << " & ";
    if (useHtml)
      out << "</td>";
    for (int j=0; j<this->TheObjects[i].size; j++)
    { if ((j==owner.CentralizerRoots.size-1) && (i<=owner.CentralizerRoots.size-1))
      { if(useLaTeX)
          out << "\\multicolumn{1}{c|}{";
        if(useHtml)
          out << "<td rhs=\"1\">";
      } else
      { if (useHtml)
          out << "<td>";
      }
      for (int k=0; k<this->TheObjects[i].TheObjects[j].size; k++)
        out << this->TheObjects[i].TheObjects[j].TheObjects[k] << ", ";
      if (useLaTeX )
      { if ((j==owner.CentralizerRoots.size-1) && (i<=owner.CentralizerRoots.size-1))
          out << "}";
        if (j!=this->TheObjects[i].size-1)
          out << " & ";
      }
      if (useHtml)
        out << "</td>";
    }
    if (useHtml)
      out << "</tr>";
    if (useLaTeX)
    { out << "\\\\";
      if (i==owner.CentralizerRoots.size-1)
        out << "\\cline{2-" << owner.CentralizerRoots.size+1 << "}";
    }
  }
  if (useLaTeX)
    out << "\n\\hline opposite & ";
  if(useHtml)
    out << "<tr><td>opposite</td>";
  for (int i=0; i<owner.theOppositeKmods.size; i++)
  { if (useHtml)
      out << "<td>";
    out << i << "/" << owner.theOppositeKmods.TheObjects[i];
    if (useHtml)
      out << "</td>";
    if (useLaTeX)
    { if (i!=owner.theOppositeKmods.size-1)
      { if (useLaTeX)
          out << " & ";
        else
          out << "\t";
      }
    }
  }
  if (useLaTeX)
    out << "\n\\end{tabular}";
  output=out.str();
}

rootSubalgebra::rootSubalgebra()
{ this->flagAnErrorHasOccuredTimeToPanic=false;
  this->NumGmodKtableRowsAllowedLatex=35;
  this->flagMakingProgressReport=true;
  this->flagComputeConeCondition=true;
  this->initForNilradicalGeneration();
}

void rootSubalgebra::initForNilradicalGeneration()
{ this->NumNilradicalsAllowed=0;
  this->NumConeConditionFailures=0;
  this->NumRelationsWithStronglyPerpendicularDecomposition=0;
  this->flagFirstRoundCounting=true;
}

void rootsWithMultiplicitiesContainer::ElementToString(std::string& output)
{ std::stringstream out;
  std::string tempS;
  out << "Num Elements: " << this->size << "    \n";
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS);
    out << tempS << "\n";
  }
  output=out.str();
}

void rootWithMultiplicity::ElementToString(std::string& output)
{ std::stringstream out;
  std::string tempS;
  out << this->multiplicity << " (";
  this->::root::ElementToString(tempS);
  out << tempS<< ")";
  output=out.str();
}

void rootsWithMultiplicity::ElementToString(std::string& output)
{ std::string tempS;
  std::stringstream out;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS);
    out <<tempS;
    if (i!=this->size-1)
      out <<" + ";
  }
  output=out.str();
}

void coneRelation::RelationOneSideToStringCoordForm(std::string& output, List<Rational>& coeffs, roots& theRoots, bool EpsilonForm)
{ std::stringstream out;
  std::string tempS;
  for (int i=0; i<theRoots.size; i++)
  { coeffs.TheObjects[i].ElementToString(tempS);
    if (tempS=="1")  tempS="";
    if (tempS=="-1") tempS="-";
    assert(!(tempS=="0"));
    out<< tempS;
    if (!EpsilonForm)
      theRoots.TheObjects[i].ElementToString(tempS);
    else
      theRoots.TheObjects[i].ElementToStringEpsilonForm(tempS, true, false);
    out << "(" << tempS << ")";
    if (i!=theRoots.size-1)
      out << " + ";
  }
   output=out.str();
}


void coneRelation::RelationOneSideToString(std::string& output, const std::string& letterType, List<Rational>& coeffs, List<List<int> >& kComponents, roots& theRoots, bool useLatex, rootSubalgebra& owner)
{ assert(theRoots.size==coeffs.size);
  std::stringstream out;
  std::string tempS;
  if (useLatex)
  { out << "\\begin{tabular}{";
    for (int i=0; i< theRoots.size; i++)
      out << "c";
    out << "}";
  }
  for (int i=0; i<theRoots.size; i++)
  { coeffs.TheObjects[i].ElementToString(tempS);
    if (tempS=="1")  tempS="";
    if (tempS=="-1") tempS="-";
    assert(!(tempS=="0"));
    out << tempS;
    if (!useLatex)
    { theRoots.TheObjects[i].ElementToString(tempS);
      out << "(" << tempS << ")";
      if (i!=theRoots.size-1)
        out << " + ";
    } else
    { out << "$" << letterType << "_" << i+1 << "$";
      if (i!=theRoots.size-1)
        out << "+ & ";
    }
  }
  if (useLatex)
    out << "\\\\";
  List<int> TakenIndices;
  List<int> NumPrimesUniTypicComponent;
  TakenIndices.initFillInObject(owner.theDynkinDiagram.SimpleBasesConnectedComponents.size, -1);
  NumPrimesUniTypicComponent.initFillInObject(owner.theDynkinDiagram.sameTypeComponents.size, -1);
  for (int i=0; i<kComponents.size; i++)
  { if (useLatex)
      out << "\\tiny{ ";
    for (int j=0; j<kComponents.TheObjects[i].size; j++)
    { int index= kComponents.TheObjects[i].TheObjects[j];
      int indexUniComponent=owner.theDynkinDiagram.indexUniComponent.TheObjects[index];
      out << owner.theDynkinDiagram.DynkinTypeStrings.TheObjects[index];
      if (TakenIndices.TheObjects[index]==-1)
      { NumPrimesUniTypicComponent.TheObjects[indexUniComponent]++;
        TakenIndices.TheObjects[index]=NumPrimesUniTypicComponent.TheObjects[indexUniComponent];
      }
      for (int k=0; k<TakenIndices.TheObjects[index]; k++)
        out << "'";
      if (j!=kComponents.TheObjects[i].size-1)
        out << "+";
    }
    if (useLatex)
    { out << " }";
      if(i!=kComponents.size-1)
        out << " & ";
    }
  }
  if (useLatex)
    out << "\\end{tabular}";
  output=out.str();
}

int coneRelation::ElementToString(std::string& output, rootSubalgebras& owners, bool useLatex, bool includeScalarsProductsEachSide, bool includeMixedScalarProducts)
{ std::string tempS;
  std::stringstream out;
  assert(this->AlphaCoeffs.size==this->Alphas.size);
  assert(this->BetaCoeffs.size==this->Betas.size);
  int LatexLineCounter=0;
  this->ComputeConnectedComponents(this->Alphas, owners.TheObjects[this->IndexOwnerRootSubalgebra],  this->AlphaKComponents);
  this->ComputeConnectedComponents(this->Betas, owners.TheObjects[this->IndexOwnerRootSubalgebra], this->BetaKComponents);
  this->RelationOneSideToString(tempS, "\\alpha", this->AlphaCoeffs, this->AlphaKComponents, this->Alphas, useLatex, owners.TheObjects[this->IndexOwnerRootSubalgebra]);
  out << tempS;
  if (useLatex)
    out << " &\\begin{tabular}{c} ";
  out << "=";
  if (useLatex)
    out << " \\\\~ \\end{tabular} & ";
  this->RelationOneSideToString(tempS, "\\beta", this->BetaCoeffs, this->BetaKComponents, this->Betas, useLatex, owners.TheObjects[this->IndexOwnerRootSubalgebra]);
  out << tempS;
  if (useLatex)
    out << " & ";
  this->theDiagram.ElementToString(tempS, true);
  out << tempS;
  this->theDiagramRelAndK.ElementToString(tempS, true);
  if (useLatex)
    out << " & ";
  out << tempS;
  if (includeScalarsProductsEachSide)
  { out << " & ";
    LatexLineCounter+=this->RootsToScalarProductString(this->Alphas, this->Alphas, "\\alpha", "\\alpha", tempS, useLatex, owners.TheObjects[this->IndexOwnerRootSubalgebra]);
    out << tempS;
    LatexLineCounter+=this->RootsToScalarProductString(this->Betas, this->Betas, "\\beta", "\\beta", tempS, useLatex, owners.TheObjects[this->IndexOwnerRootSubalgebra]);
    out << " " << tempS;
  }
  if (includeMixedScalarProducts)
  { LatexLineCounter+= this->RootsToScalarProductString(this->Alphas, this->Betas, "\\alpha", "\\beta", tempS, useLatex, owners.TheObjects[this->IndexOwnerRootSubalgebra]);
    out << tempS;
  }
  out << "\n";
  output=out.str();
  return MathRoutines::Maximum(2, LatexLineCounter);
}

int coneRelation::RootsToScalarProductString(roots& inputLeft, roots& inputRight, const std::string& letterTypeLeft, const std::string& letterTypeRight, std::string& output, bool useLatex, rootSubalgebra& owner)
{ std::string tempS; std::stringstream out;
  int numLinesLatex=0;
  Rational tempRat;
  for (int i=0; i<inputLeft.size; i++)
    for(int j=0; j<inputRight.size; j++)
      if ( i<j || letterTypeLeft!=letterTypeRight)
      { owner.AmbientWeyl.RootScalarCartanRoot(inputLeft.TheObjects[i], inputRight.TheObjects[j], tempRat);
        if (!tempRat.IsEqualToZero())
        { tempRat.ElementToString(tempS);
          out << "$\\langle" << letterTypeLeft << "_" << i+1 << ", " << letterTypeRight << "_" << j+1 << "\\rangle=" << tempS << "$, ";
          numLinesLatex++;
        }
      }
  output= out.str();
  return numLinesLatex;
}

void coneRelation::ComputeConnectedComponents(roots& input, rootSubalgebra& owner, List<List<int> >& output)
{ output.SetSize(input.size);
  for (int i=0; i<input.size; i++)
  { output.TheObjects[i].size=0;
    for (int j=0; j<owner.theDynkinDiagram.SimpleBasesConnectedComponents.size; j++)
      if (owner.theDynkinDiagram.SimpleBasesConnectedComponents.TheObjects[j].ContainsARootNonPerpendicularTo(input.TheObjects[i], owner.AmbientWeyl))
        output.TheObjects[i].AddObjectOnTop(j);
  }
}

bool coneRelation::IsStrictlyWeaklyProhibiting(rootSubalgebra& owner, roots& NilradicalRoots, GlobalVariables& theGlobalVariables, rootSubalgebras& owners, int indexInOwner)
{ roots tempRoots;
  tempRoots.CopyFromBase(this->Alphas);
  tempRoots.AddListOnTop(this->Betas);
  tempRoots.AddListOnTop(owner.genK);
  //owner.AmbientWeyl.TransformToSimpleBasisGenerators(tempRoots);
  this->theDiagram.ComputeDiagramTypeModifyInput(tempRoots, owner.AmbientWeyl);
  if (this->theDiagram.DebugString=="$F_4$")
    return false;
  if (this->theDiagram.DynkinTypeStrings.TheObjects[0]=="$A_1$")
  {//  assert(false);
    Stop();
  }
  ReflectionSubgroupWeylGroup tempSubgroup;
  tempSubgroup.AmbientWeyl.Assign(owner.AmbientWeyl);
  tempSubgroup.ComputeSubGroupFromGeneratingReflections(tempRoots, tempSubgroup.ExternalAutomorphisms, theGlobalVariables, 0, true);
  roots NilradicalIntersection, genSingHW;
  tempRoots.CopyFromBase(tempSubgroup.RootSubsystem);
  tempRoots.ComputeDebugString();
  NilradicalRoots.ComputeDebugString();
  NilradicalRoots.intersectWith(tempRoots, NilradicalIntersection);
  NilradicalIntersection.ComputeDebugString();
  for (int i=0; i<owner.HighestWeightsGmodK.size; i++)
    if (!owner.NilradicalKmods.selected[i] && tempRoots.ContainsObject(owner.HighestWeightsGmodK.TheObjects[i]) && owner.IsGeneratingSingularVectors(i, NilradicalIntersection))
      genSingHW.AddObjectOnTop(owner.HighestWeightsGmodK.TheObjects[i]);
  genSingHW.ComputeDebugString();
  if (owner.ConeConditionHolds(theGlobalVariables, owners, indexInOwner, NilradicalIntersection, genSingHW, false))
    return false;
  if (!owner.AttemptTheTripleTrickWRTSubalgebra(*this, genSingHW, NilradicalIntersection, theGlobalVariables))
    return false;
  this->SortRelation(owner);
  this->FixRepeatingRoots(this->Alphas, this->AlphaCoeffs);
  //this->FixRightHandSide(owner, NilradicalRoots);
  this->ComputeDiagramRelAndK(owner);
  return true;
}

void coneRelation::ComputeTheDiagramAndDiagramRelAndK(rootSubalgebra& owner)
{ roots tempRoots;
  tempRoots.CopyFromBase(this->Alphas);
  tempRoots.AddListOnTop(this->Betas);
  this->theDiagram.ComputeDiagramTypeModifyInput(tempRoots, owner.AmbientWeyl);
  this->ComputeDiagramRelAndK(owner);
}

void coneRelation::MakeLookCivilized(rootSubalgebra& owner, roots& NilradicalRoots)
{ if (this->Alphas.size==0 || this->Betas.size==0)
    return;
  roots tempRoots;
//  this->Alphas.ComputeDebugString();
//  this->Betas.ComputeDebugString();
  tempRoots.CopyFromBase(this->Alphas);
  tempRoots.AddListOnTop(this->Betas);
  //owner.AmbientWeyl.TransformToSimpleBasisGenerators(tempRoots);
  this->theDiagram.ComputeDiagramTypeModifyInput(tempRoots, owner.AmbientWeyl);
  if (this->theDiagram.DynkinTypeStrings.TheObjects[0]=="$A_1$")
  { this->ComputeDiagramRelAndK(owner);
    assert(false);
    Stop();
  }
  this->SortRelation(owner);
  this->FixRepeatingRoots(this->Alphas, this->AlphaCoeffs);
  //this->FixRightHandSide(owner, NilradicalRoots);
  this->ComputeDiagramRelAndK(owner);
}

void coneRelation::GetEpsilonCoords(roots& input, roots& output, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ output.SetSize(input.size);
  roots& tempRoots=theGlobalVariables.rootsGetEpsilonCoords;
  root tempRoot;
  for(int i=0; i<input.size; i++)
  { int WeylRank=this->theDiagram.RankTotal();
    char WeylLetter=this->theDiagram.DebugString.at(1);
    this->theDiagram.SimpleBasesConnectedComponents.CollectionToRoots(tempRoots);
    input.TheObjects[i].GetCoordsInBasis(tempRoots, tempRoot, theGlobalVariables);
    theWeyl.GetEpsilonCoords(  WeylLetter, WeylRank, tempRoots, tempRoot, output.TheObjects[i], theGlobalVariables);
  }
}

void coneRelation::FixRightHandSide(rootSubalgebra& owner, roots& NilradicalRoots)
{ bool hasChanged=true;
  root tempRoot;
  while(hasChanged)
  { hasChanged=false;
    for (int i=0; i<this->Betas.size; i++)
      for (int j=i+1; j<this->Betas.size; j++)
      { tempRoot.Assign(this->Betas.TheObjects[i]);
        tempRoot.Add(this->Betas.TheObjects[j]);
        if (owner.AmbientWeyl.RootSystem.ContainsObjectHash(tempRoot))
        { int leavingIndex=j; int remainingIndex=i;
          if (this->BetaCoeffs.TheObjects[j].IsGreaterThan(this->BetaCoeffs.TheObjects[i]))
          { leavingIndex=i;
            remainingIndex=j;
          }
          this->Betas.TheObjects[leavingIndex].Assign(tempRoot);
          this->BetaCoeffs.TheObjects[remainingIndex].Subtract(this->BetaCoeffs.TheObjects[leavingIndex]);
          if (this->BetaCoeffs.TheObjects[remainingIndex].IsEqualToZero())
          { this->BetaCoeffs.PopIndexSwapWithLast(remainingIndex);
            this->Betas.PopIndexSwapWithLast(remainingIndex);
          }
          assert(NilradicalRoots.ContainsObject(tempRoot));
          hasChanged=true;
        }
      }
  }
}

bool coneRelation::CheckForBugs(rootSubalgebra& owner, roots& NilradicalRoots)
{ for (int i=0; i<this->Alphas.size; i++)
  { int tempI= owner.HighestWeightsGmodK.IndexOfObject(this->Alphas.TheObjects[i]);
    if (tempI==-1)
      return false;
    if (NilradicalRoots.ContainsObject(this->Alphas.TheObjects[i]))
      return false;
  }
  for (int i=0; i<this->Betas.size; i++)
    if (!NilradicalRoots.ContainsObject(this->Betas.TheObjects[i]))
      return false;
  return true;
}

void coneRelation::GetSumAlphas(root& output, int theDimension)
{ assert(this->AlphaCoeffs.size==this->Alphas.size);
  output.MakeZero(theDimension);
  root tempRoot;
  for(int i=0; i<this->Alphas.size; i++)
  { tempRoot.Assign(this->Alphas.TheObjects[i]);
    tempRoot.MultiplyByLargeRational(this->AlphaCoeffs.TheObjects[i]);
    output.Add(tempRoot);
  }
}

void coneRelation::SortRelation(rootSubalgebra& owner)
{ this->ComputeKComponents(this->Alphas, this->AlphaKComponents, owner);
  this->ComputeKComponents(this->Betas, this->BetaKComponents, owner);
  //bubble sort
  for (int i=0; i<this->Alphas.size; i++)
    for (int j=i+1; j<this->Alphas.size; j++)
      if (this->leftSortedBiggerThanOrEqualToRight(this->AlphaKComponents.TheObjects[j], this->AlphaKComponents.TheObjects[i]))
      { this->AlphaCoeffs.SwapTwoIndices(i, j);
        this->Alphas.SwapTwoIndices(i, j);
        this->AlphaKComponents.SwapTwoIndices(i, j);
      }
  for (int i=0; i<this->Betas.size; i++)
    for (int j=i+1; j<this->Betas.size; j++)
      if (this->leftSortedBiggerThanOrEqualToRight(this->BetaKComponents.TheObjects[j], this->BetaKComponents.TheObjects[i]))
      { this->BetaCoeffs.SwapTwoIndices(i, j);
        this->Betas.SwapTwoIndices(i, j);
        this->BetaKComponents.SwapTwoIndices(i, j);
      }
}

void coneRelation::ComputeKComponents(roots& input, List<List<int> >& output, rootSubalgebra& owner)
{ output.SetSize(input.size);
  for(int i=0; i<input.size; i++)
  { output.TheObjects[i].size=0;
    for(int j=0; j<owner.theDynkinDiagram.SimpleBasesConnectedComponents.size; j++)
      if (owner.theDynkinDiagram.SimpleBasesConnectedComponents.TheObjects[j].ContainsARootNonPerpendicularTo(input.TheObjects[i], owner.AmbientWeyl))
        output.TheObjects[i].AddObjectOnTop(j);
  }
}

void coneRelation::ComputeDiagramRelAndK(rootSubalgebra& owner)
{ roots tempRoots;
  tempRoots.size=0;
  tempRoots.MakeActualSizeAtLeastExpandOnTop(owner.AmbientWeyl.CartanSymmetric.NumRows*2);
  tempRoots.AddListOnTop(owner.SimpleBasisK);
  for (int i=0; i<this->theDiagram.SimpleBasesConnectedComponents.size; i++)
    tempRoots.AddListOnTop(this->theDiagram.SimpleBasesConnectedComponents.TheObjects[i]);
  //owner.AmbientWeyl.TransformToSimpleBasisGenerators(tempRoots);
  this->theDiagramRelAndK.ComputeDiagramTypeModifyInput(tempRoots, owner.AmbientWeyl);
}

void coneRelation::FixRepeatingRoots(roots& theRoots, List<Rational>& coeffs)
{ for (int i=0; i<theRoots.size; i++)
  { if (coeffs.TheObjects[i].IsEqualToZero())
    { coeffs.PopIndexSwapWithLast(i);
      theRoots.PopIndexSwapWithLast(i);
      i--;
    }
    for (int j=i+1; j<theRoots.size; j++)
      if (theRoots.TheObjects[i].IsEqualTo(theRoots.TheObjects[j]))
      { coeffs.TheObjects[i]+=(coeffs.TheObjects[j]);
        theRoots.PopIndexSwapWithLast(j);
        coeffs.PopIndexSwapWithLast(j);
        j--;
      }
  }
}

bool coneRelation::leftSortedBiggerThanOrEqualToRight(List<int>& left, List<int>& right)
{ if (left.size>right.size)
    return true;
  if (right.size>left.size)
    return false;
  for(int i=0; i<right.size; i++)
  { if (right.TheObjects[i]>left.TheObjects[i])
      return false;
    if (left.TheObjects[i]>right.TheObjects[i])
      return true;
  }
  return true;
}

bool coneRelation::GenerateAutomorphisms(coneRelation& right, rootSubalgebras& owners)
{ /*if (this->DebugString.length()!=right.DebugString.length())
    return false;
  for (unsigned int i=0; i<this->DebugString.length(); i++)
  {  if (this->DebugString[i]!=right.DebugString[i])
      return false;
  }*/
  if (this->DebugString!=right.DebugString)
    return false;
  return true;
}

void coneRelations::AddRelationNoRepetition(coneRelation& input, rootSubalgebras& owners, int indexInRootSubalgebras)
{ input.ComputeDebugString(owners, true, true);
  int i=this->FitHashSize(input.HashFunction());
  List<int>& theIndices= this->TheHashedArrays[i];
  for (int j=0; j<theIndices.size; j++)
  { if(this->TheObjects[theIndices.TheObjects[j]].GenerateAutomorphisms(input, owners))
      return;
  }
  if (!this->flagIncludeSmallerRelations)
    if (input.theDiagramRelAndK.DebugString!=owners.TheObjects[0].theDynkinDiagram.DebugString)
      return;
  this->AddObjectOnTopHash(input);
  if (this->flagIncludeCoordinateRepresentation)
  {
  }
}

void permutation::initPermutation(int n)
{ this->initIncomplete(n);
  for(int i=0; i<n; i++)
  { this->MaxMultiplicities.TheObjects[i]=n-i-1;
    this->Multiplicities.TheObjects[i]=0;
  }
}

void permutation::initPermutation(List<int>& disjointSubsets, int TotalNumElements)
{ this->initIncomplete(TotalNumElements);
  int counter=0;
  for(int i=0; i<disjointSubsets.size; i++)
  { for (int j=0; j<disjointSubsets.TheObjects[i]; j++)
    { this->MaxMultiplicities.TheObjects[counter]=disjointSubsets.TheObjects[i]-j-1;
      this->Multiplicities.TheObjects[counter]=0;
      counter++;
    }
    TotalNumElements-=disjointSubsets.TheObjects[i];
  }
  assert(TotalNumElements==0);
}

void permutation::incrementAndGetPermutation(List<int>& output)
{ this->IncrementSubset();
  this->GetPermutationLthElementIsTheImageofLthIndex(output);
}

void permutation::GetPermutationLthElementIsTheImageofLthIndex(List<int>& output)
{ int numElements=this->Multiplicities.size;
  output.SetSize(numElements);
  for (int i=0; i<numElements; i++)
    output.TheObjects[i]=i;
  for (int i=0; i<numElements; i++)
    MathRoutines::swap(output.TheObjects[i], output.TheObjects[i+this->Multiplicities.TheObjects[i]]);
}

void rootSubalgebras::ComputeKmodMultTables(GlobalVariables& theGlobalVariables)
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].GenerateKmodMultTable(this->TheObjects[i].theMultTable, this->TheObjects[i].theOppositeKmods, theGlobalVariables);
}

void rootSubalgebras::ComputeAllRootSubalgebrasUpToIso(GlobalVariables& theGlobalVariables, int StartingIndex, int NumToBeProcessed)
{ this->NumSubalgebrasProcessed=0;
  this->NumConeConditionFailures=0;
  this->NumSubalgebrasCounted=0;
  for (int i=StartingIndex; i<NumToBeProcessed+StartingIndex; i++)
  { this->TheObjects[i].flagComputeConeCondition=this->flagComputeConeCondition;
    this->TheObjects[i].GeneratePossibleNilradicals(this->controllerLProhibitingRelations, this->ImpiedSelectionsNilradical, this->parabolicsCounterNilradicalGeneration, theGlobalVariables, false, *this, i);
    if (i!=NumToBeProcessed+StartingIndex-1)
      this->TheObjects[i+1].GeneratePossibleNilradicalsInit(this->ImpiedSelectionsNilradical, this->parabolicsCounterNilradicalGeneration);
  }
}

void rootSubalgebras::ComputeLProhibitingRelations(GlobalVariables& theGlobalVariables)
{ if (this->flagStoringNilradicals)
  { this->storedNilradicals.SetSize(this->size);
  }
  for (; this->IndexCurrentSANilradicalsGeneration<this->NumReductiveRootSAsToBeProcessedNilradicalsGeneration; this->IndexCurrentSANilradicalsGeneration++)
  { this->TheObjects[this->IndexCurrentSANilradicalsGeneration].flagComputeConeCondition=this->flagComputeConeCondition;
    this->TheObjects[this->IndexCurrentSANilradicalsGeneration].GeneratePossibleNilradicals(this->controllerLProhibitingRelations, this->ImpiedSelectionsNilradical, this->parabolicsCounterNilradicalGeneration, theGlobalVariables, this->flagUsingParabolicsInCentralizers, *this, this->IndexCurrentSANilradicalsGeneration);
    if (this->IndexCurrentSANilradicalsGeneration!= this->NumReductiveRootSAsToBeProcessedNilradicalsGeneration-1)
      this->TheObjects[this->IndexCurrentSANilradicalsGeneration+1].GeneratePossibleNilradicalsInit(this->ImpiedSelectionsNilradical, this->parabolicsCounterNilradicalGeneration);
  }
}

void rootSubalgebras::SortDescendingOrderBySSRank()
{//Bubble sort
  rootSubalgebras output;
  List<int> SortingArray;
  List<int> inverseOfSortingArray;
  SortingArray.SetSize(this->size);
  for (int i=0; i<this->size; i++)
    SortingArray.TheObjects[i]=i;
  for (int i=0; i<this->size; i++)
    for (int j=i+1; j<this->size; j++)
      if(this->TheObjects[SortingArray.TheObjects[j]].theDynkinDiagram.IsGreaterThan(this->TheObjects[SortingArray.TheObjects[i]].theDynkinDiagram))
        SortingArray.SwapTwoIndices(i, j);
  inverseOfSortingArray.SetSize(SortingArray.size);
  for(int i=0; i<SortingArray.size; i++)
    inverseOfSortingArray.TheObjects[SortingArray.TheObjects[i]]=i;
  output.MakeActualSizeAtLeastExpandOnTop(this->size);
  for (int i=0; i<this->size; i++)
  { output.AddObjectOnTop(this->TheObjects[SortingArray.TheObjects[i]]);
    List<int>& otherArray=this->TheObjects[SortingArray.TheObjects[i]].indicesSubalgebrasContainingK;
    List<int>& currentArray=output.LastObject()->indicesSubalgebrasContainingK;
    currentArray.MakeActualSizeAtLeastExpandOnTop(otherArray.size);
    currentArray.size=0;
    for(int j=0; j<otherArray.size; j++)
      currentArray.AddObjectOnTop(inverseOfSortingArray.TheObjects[otherArray.TheObjects[j]]);
  }
  for(int i=0; i<this->size; i++)
    this->TheObjects[i].Assign(output.TheObjects[i]);
}

void rootSubalgebras::GetTableHeaderAndFooter(std::string& outputHeader, std::string& outputFooter, bool useLatex, bool useHtml)
{ std::stringstream out1, out2; std::string tempS;
  if (useHtml)
  { out1 <<"<table border=\"1\">\n <colgroup>";
    for (int i=0; i<this->NumColsPerTableLatex; i++)
    { out1<<"<col width=\"80\">";
    }
    out1<<"</colgroup><tr>";
    out2 <<"</td></tr></table>";
  }
  if (useLatex)
  { out1 << "\n\n \\begin{tabular}{";
    for (int i=0; i<this->NumColsPerTableLatex; i++)
      out1 << "c";
    out1 << "}\n";
    out2 << "\\end{tabular}";
  }
  outputFooter=out2.str();
  outputHeader=out1.str();
}

void rootSubalgebras::ElementToHtml(std::string& header, std::string& pathPhysical, std::string& htmlPathServer, SltwoSubalgebras* Sl2s, GlobalVariables& theGlobalVariables)
{ std::fstream output; std::string tempS;
  std::string MyPathPhysical, childrenPathPhysical;
  std::string MyPathServer, childrenPathServer;
  MyPathPhysical=pathPhysical; childrenPathPhysical=pathPhysical;
  MyPathServer=htmlPathServer; childrenPathServer= htmlPathServer;
  MyPathPhysical.append("rootHtml.html"); MyPathServer.append("rootHtml.html");
  childrenPathPhysical.append("rootHtml_"); childrenPathServer.append("rootHtml_");
  CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(output, MyPathPhysical, false, true, false);
  this->ComputeDebugString(false, true, false, &childrenPathPhysical, &childrenPathServer, theGlobalVariables);
  output << "<HTML><title> Root subsystems of " << this->AmbientWeyl.WeylLetter << this->AmbientWeyl.CartanSymmetric.NumRows << "</title>";
  output << "<meta name=\"keywords\" content=\"" << this->AmbientWeyl.WeylLetter << this->AmbientWeyl.CartanSymmetric.NumRows << " root subsystems, root subsystems, root systems";
  if (this->AmbientWeyl.WeylLetter=='E' || this->AmbientWeyl.WeylLetter=='F' || this->AmbientWeyl.WeylLetter=='G' )
    output << ", exceptional Lie algebra";
  output << " \">";
  output << "<BODY>" << header << this->DebugString << "</BODY></HTML>";
  output.close();
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].ElementToHtml(i, childrenPathPhysical, Sl2s, theGlobalVariables);
}

void rootSubalgebras::ElementToString(std::string& output, SltwoSubalgebras* sl2s, bool useLatex, bool useHtml, bool includeKEpsCoords, std::string* htmlPathPhysical, std::string* htmlPathServer, GlobalVariables& theGlobalVariables)
{ std::stringstream out; std::string tempS;
  if (useHtml)
    out << "<a href=\"/tmp/manual_vector_partition.pdf\">Notation and conventions (incomplete). Will evolve to a manual of the program.</a><br>";
  this->ElementToStringDynkinTable(useLatex, useHtml, htmlPathPhysical, htmlPathServer, tempS);
  out << tempS;
  //this->AmbientWeyl.ComputeRho(true);
  //this->ElementToStringCentralizerIsomorphisms(tempS, useLatex, useHtml, theGlobalVariables);
  //out << tempS;
/*  for (int i=0; i<this->size; i++)
  {  this->TheObjects[i].ElementToString(tempS, sl2s, i, useLatex, useHtml, includeKEpsCoords, theGlobalVariables);
    out << tempS <<"\n\n";
  }*/
  output= out.str();
}

void rootSubalgebras::pathToHtmlFileNameElements(int index, std::string* htmlPathServer, std::string& output, bool includeDotHtml)
{ if (htmlPathServer==0)
  { output.clear();
    return;
  }
  std::stringstream out;
  out << *htmlPathServer << "rootSA" << index;
  if (includeDotHtml)
    out << ".html";
  output=out.str();
}

void rootSubalgebras::pathToHtmlReference(int index, std::string& DisplayString, std::string* htmlPathServer, std::string& output)
{ if(htmlPathServer==0)
  { output.clear();
    return;
  }
  std::stringstream out; std::string tempS;
  this->pathToHtmlFileNameElements(index, htmlPathServer, tempS, true);
  out << "<a href=\""<<tempS <<"\">"<<DisplayString<<"</a>";
  output=out.str();
}

void rootSubalgebras::ElementToStringDynkinTable(bool useLatex, bool useHtml, std::string* htmlPathPhysical, std::string* htmlPathServer, std::string& output)
{ std::stringstream out; std::string header, footer, tempS, tempS2, tempS3;
  std::string tooltipSAs="h - fixed Cartan subalgebra. k - subalgebra containing h. k_{ss}=[k, k] - regular semisimple subalgebra in the sense of Dynkin, Semisimple Lie subalgebras of semisimple Lie algebras. k_{ss} is parametrized by a root subsytem of \\Delta(g). C(k_{ss}) consists root spaces with roots strongly orthogonal to \\Delta(k) and a part of the Cartan h";
  this->GetTableHeaderAndFooter(header, footer, useLatex, useHtml);
  int col=0; int row=0;
  this->TheObjects[0].theDynkinDiagram.ElementToString(tempS, true);
  if (useLatex)
    out << "$\\mathfrak{g}$: ";
  else
  { out << "g: ";
    CGIspecificRoutines::clearDollarSigns(tempS, tempS);
  }
  out << tempS << "\n\n";
  for (int i=1; i<this->size; i++)
  { if (col==0 && row==0)
    { out << header;
      if (useHtml)
        out << "<td title=\"" << tooltipSAs << "\">";
    }
    this->TheObjects[i].theDynkinDiagram.ElementToString(tempS, true);
    this->TheObjects[i].theCentralizerDiagram.ElementToString(tempS2, true);
    if (tempS=="") tempS="-";
    if (useLatex)
    { CGIspecificRoutines::subEqualitiesWithSimeq(tempS, tempS);
      CGIspecificRoutines::subEqualitiesWithSimeq(tempS2, tempS2);
      out << "\\begin{tabular}{p{2cm}}\n $\\mathfrak{k}_{ss}$: " << tempS;
      out << "\\\\\n";
    }
    else
    { CGIspecificRoutines::clearDollarSigns(tempS, tempS);
      CGIspecificRoutines::clearDollarSigns(tempS2, tempS2);
      out << "k_{ss}: ";
      if (!useHtml)
        out << tempS;
      else
      { this->pathToHtmlReference(i, tempS, htmlPathServer, tempS3);
        out << tempS3;
      }
    }
    if (useLatex)
      out << "$C(\\mathfrak{k_{ss}})_{ss}$: ";
    else
    { if (useHtml)
        out << "\n<br>\n";
      out << "C(k_{ss})_{ss}: ";
    }
    if (tempS2=="") tempS2="-";
    out << tempS2;
    if (useLatex)
      out << "\\\\\n";
    if (useHtml)
      out << "\n<br>\n";
    if (useLatex)
      out << "\n$\\mathfrak{k}_{ss}$ lies in: ";
    else
      out << "\n k_ss lies in: ";
    if (useLatex)
      out <<  "\\\\\n";
    if (useHtml)
      out << "\n<br>\n";
    int counter=0;
    for(int j=0; j<this->TheObjects[i].indicesSubalgebrasContainingK.size; j++)
    { int tempI=this->TheObjects[i].indicesSubalgebrasContainingK.TheObjects[j];
      this->TheObjects[tempI].theDynkinDiagram.ElementToString(tempS, true);
      if (useLatex)
        CGIspecificRoutines::subEqualitiesWithSimeq(tempS, tempS);
      counter+=(signed)tempS.length();
      if (!useHtml)
        out << tempS << ", ";
      else
      { if (!useLatex)
          CGIspecificRoutines::clearDollarSigns(tempS, tempS);
        this->pathToHtmlReference(tempI, tempS, htmlPathServer, tempS3);
        out << tempS3 << " , ";
      }
      if (useLatex && counter>20)
      { counter=0;
        out << "\\\\\n";
      }
    }
    if (useLatex)
      out << "\\end{tabular}";
    row = (i)/this->NumColsPerTableLatex;
    col = (i)% this->NumColsPerTableLatex;
    if (row == this->NumLinesPerTableLatex)
      row=0;
    if (col==0 && row!=0)
    { if (useLatex)
        out << "\\\\\n\\hline";
      if (useHtml)
      { out << "</td></tr>";
        if(i!=this->size-1)
          out << "<tr><td title=\"" << tooltipSAs << "\">";
      }
    }
    if (col!=0)
    { if (useLatex)
        out << " & ";
      if(useHtml)
        out << "</td>";
      if (i!=this->size-1 && useHtml)
        out << "<td title=\"" << tooltipSAs << "\">";
    }
    if (row==0 && col==0)
      out << footer;
  }
  if (!(col==0 && row==0))
    out << footer;
  out << "\n\n";
  output=out.str();
}

void coneRelations::GetLatexHeaderAndFooter(std::string& outputHeader, std::string& outputFooter)
{ outputHeader.clear();
  outputFooter.clear();
  outputHeader.append("\\begin{tabular}{rcl p{1cm}p{1cm}p{3cm} } \\multicolumn{3}{c}");
  outputHeader.append("{ Relation / linked $\\mathfrak{k}$-components}");
  outputHeader.append(" &$\\alpha_i$'s, $\\beta_i$'s generate & adding $\\mathfrak{k}$ generates&");
  outputHeader.append("Non-zero scalar products\\\\");
  outputFooter.append("\\end{tabular}");
}

void coneRelations::ElementToString(std::string& output, rootSubalgebras& owners, bool useLatex, bool useHtml, std::string* htmlPathPhysical, std::string* htmlPathServer, GlobalVariables& theGlobalVariables)
{ std::stringstream out;
  std::string tempS, header, footer;
  roots tempAlphas, tempBetas;
  this->GetLatexHeaderAndFooter(header, footer);
  if (useLatex)
    out << header;
  int oldIndex=-1;
  int lineCounter=0;
  for(int i=0; i<this->size; i++)
  { if (oldIndex!=this->TheObjects[i].IndexOwnerRootSubalgebra)
    { oldIndex=this->TheObjects[i].IndexOwnerRootSubalgebra;
      if (useLatex)
        out << "\\hline\\multicolumn{5}{c}{$\\mathfrak{k}$-semisimple type: " << owners.TheObjects[oldIndex].theDynkinDiagram.DebugString << "}\\\\\n\\hline\\hline";
      //if (useHtml)
      //{ out << "<table>" << "<tr>"<< owners.TheObjects[oldIndex].theDynkinDiagram.DebugString
       //     <<"</tr>";
      //}
    }
    lineCounter+=this->TheObjects[i].ElementToString(tempS, owners, useLatex, true, true);
    out << tempS;
    if (useLatex)
      out << "\\\\";
    out << "\n";
    if (this->flagIncludeCoordinateRepresentation)
    { lineCounter+=2;
      out << "\\multicolumn{5}{c}{$\\varepsilon$-form~relative~to~the~subalgebra~generated~by~$\\mathfrak{k}$~and~the~relation}\\\\\n";
      this->TheObjects[i].GetEpsilonCoords(this->TheObjects[i].Alphas, tempAlphas, owners.AmbientWeyl, theGlobalVariables);
      this->TheObjects[i].GetEpsilonCoords(this->TheObjects[i].Betas, tempBetas, owners.AmbientWeyl, theGlobalVariables);
      this->TheObjects[i].RelationOneSideToStringCoordForm(tempS, this->TheObjects[i].AlphaCoeffs, tempAlphas, true);
      out << "\\multicolumn{5}{c}{" << tempS;
      this->TheObjects[i].RelationOneSideToStringCoordForm(tempS, this->TheObjects[i].BetaCoeffs, tempBetas, true);
      out << "=" << tempS; //<<"~~~~";
    //  this->TheObjects[i].RelationOneSideToStringCoordForm
    //    (tempS, this->TheObjects[i].AlphaCoeffs, this->TheObjects[i].Alphas, false);
    //  out <<tempS;
    //  this->TheObjects[i].RelationOneSideToStringCoordForm
    //    (tempS, this->TheObjects[i].BetaCoeffs, this->TheObjects[i].Betas, false);
    //  out <<"="<<tempS<<"}\\\\\n";
      out << "}\\\\\\hline\n";
    }
    if (lineCounter>this->NumAllowedLatexLines)
    { out << footer << "\n\n\n" << header;
      lineCounter=0;
    }
  }
  if (useLatex)
    out << footer;
  if (this->flagIncludeSubalgebraDataInDebugString)
  { owners.ElementToString(tempS, 0, useLatex, useHtml, false, htmlPathPhysical, htmlPathServer, theGlobalVariables);
    out << "\n\n\\newpage" << tempS;
  }
  output=out.str();
}

void SemisimpleLieAlgebra::ComputeChevalleyConstants(char WeylLetter, int WeylIndex, GlobalVariables& theGlobalVariables)
{ this->theWeyl.MakeArbitrary(WeylLetter, WeylIndex);
  this->ComputeChevalleyConstants(this->theWeyl, theGlobalVariables);
}

void SemisimpleLieAlgebra::ComputeChevalleyConstants(WeylGroup& input, GlobalVariables& theGlobalVariables)
{ this->theWeyl.CartanSymmetric.Assign(input.CartanSymmetric);
  this->theWeyl.ComputeRho(true);
  this->ChevalleyConstants.init(this->theWeyl.RootSystem.size, this->theWeyl.RootSystem.size);
  this->Computed.init(this->theWeyl.RootSystem.size, this->theWeyl.RootSystem.size);
  this->Computed.NullifyAll(false);
  Selection nonExploredRoots;
  this->flagAnErrorHasOccurredTimeToPanic=false;
  roots& posRoots=this->theWeyl.RootsOfBorel;
  nonExploredRoots.init(posRoots.size);
  for (int i=0; i<posRoots.size; i++)
    nonExploredRoots.AddSelectionAppendNewIndex(i);
  root tempRoot;
  for (int i=0; i<this->theWeyl.RootSystem.size; i++)
    for(int j=i; j<this->theWeyl.RootSystem.size; j++)
    { tempRoot=this->theWeyl.RootSystem.TheObjects[i]+this->theWeyl.RootSystem.TheObjects[j];
      if(!tempRoot.IsEqualToZero())
        if( !this->theWeyl.IsARoot(tempRoot))
        { this->Computed.elements[i][j]=true;
          this->ChevalleyConstants.elements[i][j].MakeZero();
          this->Computed.elements[j][i]=true;
          this->ChevalleyConstants.elements[j][i].MakeZero();
        }
    }
  Rational tempRat;
  while (nonExploredRoots.CardinalitySelection>0)
  { //this->ComputeDebugString();
    //nonExploredRoots.ComputeDebugString();
    int theBorelIndex=nonExploredRoots.elements[0];
    Rational theHeight= posRoots.TheObjects[theBorelIndex].GetHeight();
    for (int i=1; i<nonExploredRoots.CardinalitySelection; i++)
    { posRoots.TheObjects[nonExploredRoots.elements[i]].GetHeight(tempRat);
      if (theHeight.IsGreaterThan(tempRat))
      { theHeight.Assign(tempRat);
        theBorelIndex=nonExploredRoots.elements[i];
      }
    }
    root& theRoot= posRoots.TheObjects[theBorelIndex];
    int theIndex=this->theWeyl.RootSystem.IndexOfObjectHash(theRoot);
    root smallRoot2;
    int FirstIndexFirstPosChoice=-1;
    int FirstIndexFirstNegChoice=-1;
    int SecondIndexFirstPosChoice=-1;
    int SecondIndexFirstNegChoice=-1;
    Rational CurrentHeight;
    for (int i=0; i<this->theWeyl.RootsOfBorel.size; i++)
    { root& smallRoot1=this->theWeyl.RootsOfBorel.TheObjects[i];
      smallRoot1.GetHeight(CurrentHeight);
      int FirstPosIndex= this->theWeyl.RootSystem.IndexOfObjectHash(smallRoot1);
      int FirstNegIndex= this->theWeyl.RootSystem.IndexOfObjectHash(-smallRoot1);
      if (theHeight.IsGreaterThan(CurrentHeight))
      { smallRoot2=theRoot-smallRoot1;
        int SecondPosIndex=this->theWeyl.RootSystem.IndexOfObjectHash(smallRoot2);
        if (FirstPosIndex<SecondPosIndex)
          if (SecondPosIndex!=-1)
          { int SecondNegIndex=this->theWeyl.RootSystem.IndexOfObjectHash(-smallRoot2);
            if (FirstIndexFirstPosChoice==-1)
            { FirstIndexFirstPosChoice=FirstPosIndex;
              SecondIndexFirstPosChoice=SecondPosIndex;
              FirstIndexFirstNegChoice=FirstNegIndex;
              SecondIndexFirstNegChoice= SecondNegIndex;
              this->ChevalleyConstants.elements[FirstNegIndex][SecondNegIndex]=-(1+this->GetMaxQForWhichBetaMinusQAlphaIsARoot(smallRoot1, smallRoot2));
              this->Computed.elements[FirstNegIndex][SecondNegIndex]=true;
            }
            else
              this->ComputeOneChevalleyConstant(FirstIndexFirstPosChoice, SecondIndexFirstPosChoice, FirstNegIndex, SecondNegIndex, theIndex);
            //this->ComputeDebugString();
            this->ExploitSymmetryAndCyclicityChevalleyConstants(FirstNegIndex, SecondNegIndex);
            //this->ComputeDebugString();
          }
      }
      if (this->flagAnErrorHasOccurredTimeToPanic)
        this->ComputeDebugString(false, false, theGlobalVariables);
    }
    nonExploredRoots.selected[theBorelIndex]=false;
    nonExploredRoots.ComputeIndicesFromSelection();
  }
//  this->ComputeDebugString();
//  this->TestForConsistency(theGlobalVariables);
  this->ComputeMultTable(theGlobalVariables);
}

void SemisimpleLieAlgebra::ComputeMultTable(GlobalVariables& theGlobalVariables)
{ int numPosRoots=this->theWeyl.RootsOfBorel.size;
  int theDimension= this->theWeyl.CartanSymmetric.NumRows;
  int numRoots = numPosRoots*2;
  root tempRoot;
  this->theLiebracketPairingCoefficients.init(numRoots+theDimension, numRoots+theDimension);
  this->theLiebracketPairingIndices.init(numRoots+theDimension, numRoots+theDimension);
  this->theLiebracketPairingIndices.NullifyAll(-1);
  this->OppositeRootSpaces.initFillInObject(numRoots+theDimension, -1);
  for (int i=0; i<numRoots; i++)
  { root& left= this->theWeyl.RootSystem.TheObjects[i];
    int indexLeft=this->RootIndexOrderAsInRootSystemToGeneratorIndexNegativeRootsThenCartanThenPositive(i);
    for (int j=0; j<numRoots; j++)
    { root& right= this->theWeyl.RootSystem.TheObjects[j];
      int indexRight= this->RootIndexOrderAsInRootSystemToGeneratorIndexNegativeRootsThenCartanThenPositive(j);
      tempRoot=left+right;
      int indexSum =this->RootIndexOrderAsInRootSystemToGeneratorIndexNegativeRootsThenCartanThenPositive(this->theWeyl.RootSystem.IndexOfObjectHash(tempRoot));
      if (tempRoot.IsEqualToZero())
        this->OppositeRootSpaces.TheObjects[indexLeft]=indexRight;
      this->theLiebracketPairingIndices.elements[indexLeft][indexRight]= indexSum;
      this->theLiebracketPairingCoefficients.elements[indexLeft][indexRight]=this->ChevalleyConstants.elements[i][j];
    }
    for (int j=0; j<theDimension; j++)
    { tempRoot.MakeEi(theDimension, j);
      this->theLiebracketPairingCoefficients.elements[numPosRoots+j][indexLeft]= this->theWeyl.RootScalarCartanRoot(tempRoot, left);
      this->theLiebracketPairingCoefficients.elements[indexLeft][numPosRoots+j]=-this->theWeyl.RootScalarCartanRoot(tempRoot, left);
      this->theLiebracketPairingIndices.elements[numPosRoots+j][indexLeft]=indexLeft;
      this->theLiebracketPairingIndices.elements[indexLeft][numPosRoots+j]=indexLeft;
    }
  }
  for (int i=0; i<theDimension; i++)
    for (int j=0; j<theDimension; j++)
    { this->theLiebracketPairingCoefficients.elements[numPosRoots+i][numPosRoots+j]=0;
      this->theLiebracketPairingIndices.elements[numPosRoots+i][numPosRoots+j]=-1;
    }
}

void SemisimpleLieAlgebra::ExploitSymmetryAndCyclicityChevalleyConstants(int indexI, int indexJ)
{ root& rootI= this->theWeyl.RootSystem.TheObjects[indexI];
  root& rootJ= this->theWeyl.RootSystem.TheObjects[indexJ];
  assert(!(rootI+rootJ).IsEqualToZero());
  //int indexMinusRootI= this->theWeyl.RootSystem.IndexOfObjectHash(-rootI);
  //int indexMinusRootJ= this->theWeyl.RootSystem.IndexOfObjectHash(-rootJ);
  //this->ComputeDebugString();
  this->ExploitSymmetryChevalleyConstants(indexI, indexJ);
  //this->ComputeDebugString();
  //int indexRootIPlusRootJ=this->theWeyl.RootSystem.IndexOfObjectHash(rootI+rootJ);
  int indexMinusRootIMinusRootJ=this->theWeyl.RootSystem.IndexOfObjectHash(-rootI-rootJ);
  this->ExploitTheCyclicTrick(indexI, indexJ, indexMinusRootIMinusRootJ);
  //this->ComputeDebugString();
  //this->ExploitTheCyclicTrick(indexMinusRootI, indexMinusRootJ, indexRootIPlusRootJ);
  //this->ComputeDebugString();
}

void SemisimpleLieAlgebra::ExploitSymmetryChevalleyConstants(int indexI, int indexJ)
{ root& rootI= this->theWeyl.RootSystem.TheObjects[indexI];
  root& rootJ= this->theWeyl.RootSystem.TheObjects[indexJ];
  assert(this->Computed.elements[indexI][indexJ]);
  int indexMinusRootI = this->theWeyl.RootSystem.IndexOfObjectHash(-rootI);
  int indexMinusRootJ = this->theWeyl.RootSystem.IndexOfObjectHash(-rootJ);
  this->ChevalleyConstants.elements[indexJ][indexI].Assign(this->ChevalleyConstants.elements[indexI][indexJ]*(-1));
  //this->ComputeDebugString();
  this->Computed.elements[indexJ][indexI]=true;
  assert(!(rootI+rootJ).IsEqualToZero());
  int i=1+this->GetMaxQForWhichBetaMinusQAlphaIsARoot( this->theWeyl.RootSystem.TheObjects[indexMinusRootI], this->theWeyl.RootSystem.TheObjects[indexMinusRootJ]);
  this->ChevalleyConstants.elements[indexMinusRootI][indexMinusRootJ].AssignInteger(-i*i);
  this->ChevalleyConstants.elements[indexMinusRootI][indexMinusRootJ].DivideBy(this->ChevalleyConstants.elements[indexI][indexJ]);
  this->Computed.elements[indexMinusRootI][indexMinusRootJ]=true;
  //this->ComputeDebugString();
  this->ChevalleyConstants.elements[indexMinusRootJ][indexMinusRootI].Assign(this->ChevalleyConstants.elements[indexMinusRootI][indexMinusRootJ]*(-1));
  this->Computed.elements[indexMinusRootJ][indexMinusRootI]=true;
  //this->ComputeDebugString();
}

void SemisimpleLieAlgebra::ExploitTheCyclicTrick(int i, int j, int k)
{ root& rootI= this->theWeyl.RootSystem.TheObjects[i];
  root& rootK= this->theWeyl.RootSystem.TheObjects[k];
  root& rootJ= this->theWeyl.RootSystem.TheObjects[j];
  assert((rootI+rootK+rootJ).IsEqualToZero());
  assert(!(rootI+rootJ).IsEqualToZero() && !(rootK+rootK).IsEqualToZero() && !(rootJ+rootI).IsEqualToZero());
  assert(this->Computed.elements[i][j]);
  Rational& tempRat= this->ChevalleyConstants.elements[i][j];
  Rational tempRat2= this->theWeyl.RootScalarCartanRoot(rootK, rootK);
  this->ChevalleyConstants.elements[j][k]=(tempRat*this->theWeyl.RootScalarCartanRoot(rootI, rootI))/tempRat2;
  this->Computed.elements[j][k]=true;
  this->ChevalleyConstants.elements[k][i] = (tempRat*this->theWeyl.RootScalarCartanRoot(rootJ, rootJ))/tempRat2;
  this->Computed.elements[k][i]=true;
  this->ExploitSymmetryChevalleyConstants(j, k);
  this->ExploitSymmetryChevalleyConstants(k, i);
}

int SemisimpleLieAlgebra::GetMaxQForWhichBetaMinusQAlphaIsARoot(root& alpha, root& beta)
{ int result=-1;
  root tempRoot;
  tempRoot.Assign(beta);
  while (this->theWeyl.IsARoot(tempRoot))
  { result++;
    tempRoot.Subtract(alpha);
  }
  return result;
}

void SemisimpleLieAlgebra::ComputeOneChevalleyConstant (int indexGamma, int indexDelta, int indexMinusEpsilon, int indexMinusZeta, int indexEta)
{//using formula (**), 2.9, page 49, Samelson, Notes on Lie algebras, 1989
  root& gamma= this->theWeyl.RootSystem.TheObjects[indexGamma];
  root& delta= this->theWeyl.RootSystem.TheObjects[indexDelta];
  root& minusEpsilon= this->theWeyl.RootSystem.TheObjects[indexMinusEpsilon];
  root& eta= this->theWeyl.RootSystem.TheObjects[indexEta];
  root& minusZeta=this->theWeyl.RootSystem.TheObjects[indexMinusZeta];
  assert(eta==gamma+delta);
  assert(this->theWeyl.IsARoot(eta+minusEpsilon));
  assert( this->Computed.elements[indexDelta][indexMinusEpsilon] && this->Computed.elements[indexMinusEpsilon][indexGamma] && this->Computed.elements[indexGamma][indexDelta] );
  assert(!this->ChevalleyConstants.elements[indexGamma][indexDelta].IsEqualToZero());
  int indexDeltaMinusEpsilon= this->theWeyl.RootSystem.IndexOfObjectHash(delta+minusEpsilon);
  int indexGammaMinusEpsilon= this->theWeyl.RootSystem.IndexOfObjectHash(gamma+minusEpsilon);
  Rational FirstSummand, SecondSummand;
  if (indexDeltaMinusEpsilon!=-1)
  { assert(this->Computed.elements[indexGamma][indexDeltaMinusEpsilon] && this->Computed.elements[indexDelta][indexMinusEpsilon]);
    FirstSummand=this->ChevalleyConstants.elements[indexGamma][indexDeltaMinusEpsilon]*this->ChevalleyConstants.elements[indexDelta][indexMinusEpsilon];
  } else
    FirstSummand.MakeZero();
  if (indexGammaMinusEpsilon!=-1)
  { assert(this->Computed.elements[indexDelta][indexGammaMinusEpsilon] && this->Computed.elements[indexMinusEpsilon][indexGamma]);
    SecondSummand =this->ChevalleyConstants.elements[indexDelta][indexGammaMinusEpsilon]*this->ChevalleyConstants.elements[indexMinusEpsilon][indexGamma];
  } else
    SecondSummand.MakeZero();
  this->ChevalleyConstants.elements[indexMinusEpsilon][indexMinusZeta]=(this->theWeyl.RootScalarCartanRoot(eta, eta)/ this->theWeyl.RootScalarCartanRoot(minusZeta, minusZeta))*( FirstSummand+SecondSummand)/ this->ChevalleyConstants.elements[indexGamma][indexDelta];
  this->Computed.elements[indexMinusEpsilon][indexMinusZeta]=true;
}

bool SemisimpleLieAlgebra::TestForConsistency(GlobalVariables& theGlobalVariables)
{ hashedRoots& theRoots=this->theWeyl.RootSystem;
  int theDimension= this->theWeyl.CartanSymmetric.NumRows;
  int TotalDim=theRoots.size+theDimension;
  int numRoots=theRoots.size;
  ElementSimpleLieAlgebra g1, g2, g3, g123, g231, g312, temp;
  g1.Nullify(*this);
  g2.Nullify(*this);
  g3.Nullify(*this);
  //this->ComputeDebugString(false, false, theGlobalVariables);
  for (int i=0; i<TotalDim; i++)
  { g1.Nullify(*this);
    if (i<theRoots.size)
    { g1.coeffsRootSpaces.TheObjects[i]=1;
      g1.NonZeroElements.AddSelectionAppendNewIndex(i);
    }
    else
      g1.Hcomponent.TheObjects[i-theRoots.size]=1;
   // g1.ComputeDebugString(*this, false, true);
    for (int j=0; j<TotalDim; j++)
    { if(g2.NonZeroElements.CardinalitySelection>0)
        g2.coeffsRootSpaces.TheObjects[g2.NonZeroElements.elements[0]]=0;
      g2.NonZeroElements.RemoveLastSelection();
      if (j>numRoots|| j==0)
        g2.Hcomponent.MakeZero(theDimension);
      if (j<theRoots.size)
      { g2.coeffsRootSpaces.TheObjects[j]=1;
        g2.NonZeroElements.AddSelectionAppendNewIndex(j);
      }
      else
        g2.Hcomponent.TheObjects[j-theRoots.size]=1;
     // g2.ComputeDebugString(*this, false, true);
      for (int k=0; k<TotalDim; k++)
      { if(g3.NonZeroElements.CardinalitySelection>0)
          g3.coeffsRootSpaces.TheObjects[g3.NonZeroElements.elements[0]]=0;
        g3.NonZeroElements.RemoveLastSelection();
        if (k>numRoots|| k==0)
          g3.Hcomponent.MakeZero(theDimension);
        if (k<theRoots.size)
        { g3.coeffsRootSpaces.TheObjects[k]=1;
          g3.NonZeroElements.AddSelectionAppendNewIndex(k);
        }
        else
          g3.Hcomponent.TheObjects[k-theRoots.size]=1;
      //  g3.ComputeDebugString(*this, false, true);
        this->LieBracket(g2, g3, temp); this->LieBracket(g1, temp, g123);
        this->LieBracket(g3, g1, temp); this->LieBracket(g2, temp, g231);
        this->LieBracket(g1, g2, temp); this->LieBracket(g3, temp, g312);
        temp=g123;
        temp+=g231;
        temp+=g312;
        //g2.ComputeDebugString(*this, false, true);
        //g3.ComputeDebugString(*this, false, true);
        //g123.ComputeDebugString(*this, false, true);
        //g231.ComputeDebugString(*this, false, true);
        //g312.ComputeDebugString(*this, false, true);
        if (!temp.IsEqualToZero())
        { assert(false);
          return false;
        }
        this->MakeChevalleyTestReport(i, j, k, TotalDim, theGlobalVariables);
      }
    }
  }
  return true;
}

Rational SemisimpleLieAlgebra::GetConstant(const root &root1, const  root &root2)
{ int index1=this->theWeyl.RootSystem.IndexOfObjectHash(root1);
  int index2= this->theWeyl.RootSystem.IndexOfObjectHash(root2);
  Rational tempRat;
  if (index1==-1 || index2==-1)
  { tempRat.MakeZero();
    return tempRat;
  }
  tempRat.Assign(this->ChevalleyConstants.elements[index1][index2]);
  return tempRat;
}

bool SemisimpleLieAlgebra::GetConstantOrHElement(const root& root1, const root& root2, Rational& outputRat, root& outputH)
{ if (!(root1+root2).IsEqualToZero())
  { outputRat=this->GetConstant(root1, root2);
    return true;
  }
  if (this->theWeyl.RootSystem.IndexOfObjectHash(root1)==-1 || this->theWeyl.RootSystem.IndexOfObjectHash(root2)==-1)
  { outputRat.MakeZero();
    return true;
  }
  outputH=(root1*2)/this->theWeyl.RootScalarCartanRoot(root1, root1);
  return false;
}

void SltwoSubalgebras::ComputeDebugStringCurrent()
{ std::string tempS; std::stringstream out;
  for (int i=0; i<this->MultiplicitiesFixedHweight.size; i++)
    out << i-this->IndexZeroWeight << ": " << this->MultiplicitiesFixedHweight.TheObjects[i] << "\n";
  this->DebugString=out.str();
}

void SltwoSubalgebras::MakeProgressReport(int index, int outOf, GlobalVariables& theGlobalVariables)
{ if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()==0)
    return;
  std::stringstream out;
  out << index <<" out of "<< outOf <<" =3^8-1 computed";
  theGlobalVariables.theIndicatorVariables.ProgressReportString1=out.str();
  theGlobalVariables.theIndicatorVariables.String1NeedsRefresh=true;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void slTwo::ComputeDynkinsEpsilon(WeylGroup& theWeyl)
{//outdates, must be erased as soon as I implement an equivalent
  this->DynkinsEpsilon = this->DiagramM.NumRootsGeneratedByDiagram()+this->DiagramM.RankTotal();
  int r=0;
  for (int i=0; i<this->hCharacteristic.size; i++)
    if (!this->hCharacteristic.TheObjects[i].IsEqualToZero())
      r++;
  this->DynkinsEpsilon+= r;
  for (int i=0; i<theWeyl.RootSystem.size; i++)
  { int NumNonZeroFound=0;
    for (int j=0; j<this->hCharacteristic.size; j++)
    { if (theWeyl.RootSystem.TheObjects[i].TheObjects[j]==1)
        NumNonZeroFound++;
      if(NumNonZeroFound>1)
        break;
    }
    if (NumNonZeroFound==1)
      this->DynkinsEpsilon--;
  }
  this->DynkinsEpsilon=0;
  for (int i=0; i<this->hCharacteristic.size; i++)
    if (this->hCharacteristic.TheObjects[i]==1)
      this->DynkinsEpsilon=-1;
  this->DynkinsEpsilon=0;
}

void ElementSimpleLieAlgebra::operator+=(const ElementSimpleLieAlgebra& other)
{ for(int i=0; i<other.NonZeroElements.CardinalitySelection; i++)
    this->coeffsRootSpaces.TheObjects[other.NonZeroElements.elements[i]]+=(other.coeffsRootSpaces.TheObjects[other.NonZeroElements.elements[i]]);
  this->ComputeNonZeroElements();
  this->Hcomponent.Add(other.Hcomponent);
}

bool ElementSimpleLieAlgebra::IsEqualToZero()const
{ for (int i=0; i<this->NonZeroElements.CardinalitySelection; i++)
    if(!this->coeffsRootSpaces.TheObjects[this->NonZeroElements.elements[i]].IsEqualToZero())
      return false;
  if (!this->Hcomponent.IsEqualToZero())
    return false;
  return true;
}

void ElementSimpleLieAlgebra::init
(const SemisimpleLieAlgebra& owner)
{ this->init(owner.theWeyl.RootSystem.size, owner.theWeyl.CartanSymmetric.NumRows);
}

void ElementSimpleLieAlgebra::init
  (int numRoots, int theAlgebraRank)
{ this->Hcomponent.SetSize(theAlgebraRank);
  this->coeffsRootSpaces.SetSize(numRoots);
  this->NonZeroElements.init(numRoots);
}

void ElementSimpleLieAlgebra::Nullify(const SemisimpleLieAlgebra& owner)
{ this->Nullify(owner.GetNumPosRoots()*2, owner.GetRank());
}

void ElementSimpleLieAlgebra::Nullify(int numRoots, int theAlgebraRank)
{ this->init(numRoots, theAlgebraRank);
  this->Hcomponent.MakeZero(theAlgebraRank);
  for(int j=0; j<this->coeffsRootSpaces.size; j++)
    this->coeffsRootSpaces.TheObjects[j].MakeZero();
  this->NonZeroElements.init(this->coeffsRootSpaces.size);
}

void SemisimpleLieAlgebra::LieBracket(const ElementSimpleLieAlgebra& g1, const ElementSimpleLieAlgebra& g2, ElementSimpleLieAlgebra& output)const
{ assert(&output!=&g1 && &output!=&g2);
  output.Nullify(*this);
  root tempRoot, root1plusRoot2;
  Rational tempRat;
  int i1, i2;
  int g1NumZero=g1.NonZeroElements.CardinalitySelection;
  int g2NumZero=g2.NonZeroElements.CardinalitySelection;
  for (int counter1=0; counter1<g1NumZero; counter1++)
    for (int counter2=0; counter2<g2NumZero; counter2++)
    { i1=g1.NonZeroElements.elements[counter1];
      i2=g2.NonZeroElements.elements[counter2];
      assert(!g1.coeffsRootSpaces.TheObjects[i1].IsEqualToZero() && !g2.coeffsRootSpaces.TheObjects[i2].IsEqualToZero());
      root& root1= this->theWeyl.RootSystem.TheObjects[i1];
      root& root2= this->theWeyl.RootSystem.TheObjects[i2];
      root1plusRoot2=root1+root2;
      if (root1plusRoot2.IsEqualToZero())
      { tempRat.Assign(g1.coeffsRootSpaces.TheObjects[i1]);
        tempRat.MultiplyBy(g2.coeffsRootSpaces.TheObjects[i2]);
        tempRoot.Assign(root1);
        tempRoot.DivByLargeRational(this->theWeyl.RootScalarCartanRoot(root1, root1)/(tempRat*2));
        output.Hcomponent.Add(tempRoot);
      }
      else
      { if (!this->ChevalleyConstants.elements[i1][i2].IsEqualToZero())
        { int theIndex=this->theWeyl.RootSystem.IndexOfObjectHash(root1plusRoot2);
          tempRat.Assign(g1.coeffsRootSpaces.TheObjects[i1]);
          tempRat.MultiplyBy(g2.coeffsRootSpaces.TheObjects[i2]);
          output.coeffsRootSpaces.TheObjects[theIndex]+=(tempRat*this->ChevalleyConstants.elements[i1][i2]);
        }
      }
    }
  ElementSimpleLieAlgebra const* element1;
  ElementSimpleLieAlgebra const* element2;
  Rational order; order.MakeOne();
  element1=&g1; element2=&g2;
  for (int l=0; l<2; l++)
  { for (int j=0; j<element2->NonZeroElements.CardinalitySelection; j++)
    { this->theWeyl.RootScalarCartanRoot(this->theWeyl.RootSystem.TheObjects[element2->NonZeroElements.elements[j]], element1->Hcomponent, tempRat);
      tempRat.MultiplyBy(element2->coeffsRootSpaces.TheObjects[element2->NonZeroElements.elements[j]]);
      tempRat.MultiplyBy(order);
      output.coeffsRootSpaces.TheObjects[element2->NonZeroElements.elements[j]]+=(tempRat);
    }
    order.MakeMOne();
    element1=&g2;
    element2=&g1;
  }
  output.ComputeNonZeroElements();
}

void ElementSimpleLieAlgebra::TimesConstant(const Rational& input)
{ for (int i=0; i<this->NonZeroElements.CardinalitySelection; i++)
    this->coeffsRootSpaces.TheObjects[this->NonZeroElements.elements[i]]*=input;
  if (input.IsEqualToZero())
    this->ComputeNonZeroElements();
}

void ElementSimpleLieAlgebra::ComputeNonZeroElements()
{ this->NonZeroElements.init(this->coeffsRootSpaces.size);
  for (int i=0; i<this->coeffsRootSpaces.size; i++)
    if (!this->coeffsRootSpaces.TheObjects[i].IsEqualToZero())
      this->NonZeroElements.AddSelectionAppendNewIndex(i);
}

bool SemisimpleLieAlgebra::FindComplementaryNilpotent( ElementSimpleLieAlgebra& e, ElementSimpleLieAlgebra& output, GlobalVariables& theGlobalVariables)
{ assert(e.Hcomponent.IsEqualToZero());
  e.ComputeNonZeroElements();
  root Difference;
  //format of the system
  //let an element of the simple lie algebra be written so that the first theWeyl.RootSystem.size
  // coordinates correspond to the root spaces g^\alpha,
  // and the last rank(g) coordinates correspond to the elements of the cartan.
  //then ad(e) is a linear operator which has theWeyl.RootSystem.size+theDimension rows and columns.
  //Then ad(e)ad(e)(f)=-2e, so this gives us a linear system for f.
  int theDimension = this->theWeyl.CartanSymmetric.NumRows;
  MatrixLargeRational theSystem, adESquaredadE, targetElt;
  int NumRoots=this->theWeyl.RootSystem.size;
  int NumRows=NumRoots+theDimension;
  theSystem.init(NumRows, NumRows);
  targetElt.init(NumRoots*2+theDimension, 1);
  targetElt.NullifyAll();
  theSystem.NullifyAll();
  assert(e.Hcomponent.IsEqualToZero());
  this->GetAdNilpotentElement(theSystem, e);
  theSystem.MultiplyOnTheLeft(theSystem, adESquaredadE);
  for (int i=0; i<e.NonZeroElements.CardinalitySelection; i++)
    targetElt.elements[e.NonZeroElements.elements[i]][0].Assign(e.coeffsRootSpaces.TheObjects[e.NonZeroElements.elements[i]]*(-2));
  adESquaredadE.Resize(NumRows+NumRoots, NumRows, true);
  for (int i= 0; i<NumRoots; i++)
    for(int j=0; j<NumRows; j++)
      adESquaredadE.elements[i+NumRows][j].Assign(theSystem.elements[i][j]);
  //targetH.ComputeDebugString();
  //theSystem.ComputeDebugString();
  MatrixLargeRational result;
  bool hasSolution =theSystem.Solve_Ax_Equals_b_ModifyInputReturnFirstSolutionIfExists(adESquaredadE, targetElt, result);
  //result.ComputeDebugString();
  if (hasSolution)
  { output.Nullify(*this);
    output.Hcomponent.MakeZero(theDimension);
    for (int i=0; i<this->theWeyl.RootSystem.size; i++)
      output.coeffsRootSpaces.TheObjects[i].Assign(result.elements[i][0]);
    output.ComputeNonZeroElements();
  }
  return hasSolution;
}

bool SemisimpleLieAlgebra::AttemptExtendingHEtoHEF(root& h, ElementSimpleLieAlgebra& e, ElementSimpleLieAlgebra& output, GlobalVariables& theGlobalVariables)
{ assert(e.Hcomponent.IsEqualToZero());
  e.ComputeNonZeroElements();
  root Difference;
  //format of the system
  //let an element of the simple lie algebra be written so that the first theWeyl.RootSystem.size
  // coordinates correspond to the root spaces g^\alpha,
  // and the last rank(g) coordinates correspond to the elements of the cartan.
  //then ad(e) is a linear operator which has theWeyl.RootSystem.size+theDimension rows and columns.
  //Then ad(e)ad(e)(f)=-2e, so this gives us a linear system for f.
  int theDimension = this->theWeyl.CartanSymmetric.NumRows;
  MatrixLargeRational theSystem, targetElt;
  int NumRoots=this->theWeyl.RootSystem.size;
  int NumRows=NumRoots+theDimension;
  theSystem.init( NumRows, NumRows);
  targetElt.init(NumRows, 1);
  targetElt.NullifyAll();
  theSystem.NullifyAll();
  assert(e.Hcomponent.IsEqualToZero());
  this->GetAdNilpotentElement(theSystem, e);
  for (int i=0; i<h.size; i++)
    targetElt.elements[i+NumRoots][0].Assign(h.TheObjects[i]);
  h.ComputeDebugString();
  theSystem.ComputeDebugString();
  MatrixLargeRational result;
  bool hasSolution = theSystem.Solve_Ax_Equals_b_ModifyInputReturnFirstSolutionIfExists(theSystem, targetElt, result);
  result.ComputeDebugString();
  if (hasSolution)
  { output.Nullify(*this);
    output.Hcomponent.MakeZero(theDimension);
    for (int i=0; i<this->theWeyl.RootSystem.size; i++)
      output.coeffsRootSpaces.TheObjects[i].Assign(result.elements[i][0]);
    output.ComputeNonZeroElements();
  }
  return hasSolution;
}

void SemisimpleLieAlgebra::GetAdNilpotentElement(MatrixLargeRational& output, ElementSimpleLieAlgebra& e)
{ roots theBasis;
  int theDimension= this->theWeyl.CartanSymmetric.NumRows;
  theBasis.SetSize(theDimension);
  for(int i=0; i<theDimension; i++)
  { theBasis.TheObjects[i].MakeZero(theDimension);
    theBasis.TheObjects[i].TheObjects[i].MakeOne();
  }
  int NumRoots= this->theWeyl.RootSystem.size;
  for (int i=0; i<NumRoots; i++)
    for (int j=0; j<e.NonZeroElements.CardinalitySelection; j++)
    { int indexE = e.NonZeroElements.elements[j];
      root& rootE = this->theWeyl.RootSystem.TheObjects[indexE];
      root& rootF= this->theWeyl.RootSystem.TheObjects[i];
      root relation = rootE+rootF;
      if (!relation.IsEqualToZero())
      { int indexRel = this->theWeyl.RootSystem.IndexOfObjectHash(relation);
        if (indexRel!=-1)
          output.elements[indexRel][i].Assign(  e.coeffsRootSpaces.TheObjects[indexE]*this->ChevalleyConstants.elements[indexE][i]);
      } else
      {  //if (h!=0)
        for (int k=0; k<theDimension; k++)
          output.elements[NumRoots+k][i].Assign(e.coeffsRootSpaces.TheObjects[indexE]*rootE.TheObjects[k]*2/this->theWeyl.RootScalarCartanRoot(rootE, rootE));
      }
      for(int j=0; j<theDimension; j++)
        output.elements[indexE][j+NumRoots].Assign(this->theWeyl.RootScalarCartanRoot(theBasis.TheObjects[j], rootE)*e.coeffsRootSpaces.TheObjects[indexE]*(-1));
    }
}

void ElementSimpleLieAlgebra::MultiplyByRational(SemisimpleLieAlgebra& owner, const Rational& theNumber)
{ if (theNumber.IsEqualToZero())
  { this->Nullify(owner);
    return;
  }
  this->Hcomponent.MultiplyByLargeRational(theNumber);
  for(int i=0; i<this->NonZeroElements.CardinalitySelection; i++)
    this->coeffsRootSpaces.TheObjects[this->NonZeroElements.elements[i]].MultiplyBy(theNumber);
}

std::string ElementSimpleLieAlgebra::ElementToStringNegativeRootSpacesFirst(bool useCompactRootNotation, bool useRootNotation, SemisimpleLieAlgebra& owner)
{ std::stringstream out;
  std::string tempS;
  if (this->NonZeroElements.CardinalitySelection==0 && this->Hcomponent.IsEqualToZero())
    return "0";
  for (int i=0; i<this->NonZeroElements.CardinalitySelection; i++)
  { int theIndex=this->NonZeroElements.elements[i];
    int DisplayIndex=owner.RootIndexToDisplayIndexNegativeSpacesFirstThenCartan(theIndex);
    if (!this->coeffsRootSpaces.TheObjects[theIndex].IsNegative()&& i!=0)
      out << "+";
    tempS=this->coeffsRootSpaces.TheObjects[theIndex].ElementToString();
    if (tempS=="1")
      tempS="";
    if (tempS=="-1")
      tempS="-";
    out << tempS << "g_{" << DisplayIndex << "}";
  }
  if (this->Hcomponent.IsEqualToZero())
    return out.str();
  if (useCompactRootNotation && owner.theWeyl.RootSystem.ContainsObjectHash(this->Hcomponent))
  { root tempRoot=this->Hcomponent;
    if (tempRoot.IsNegativeOrZero())
    { out << "-";
      tempRoot.MinusRoot();
    }
    out << "h_{" << owner.RootIndexToDisplayIndexNegativeSpacesFirstThenCartan(owner.theWeyl.RootSystem.IndexOfObjectHash(tempRoot)) << "}";
    return out.str();
  }
  if (useRootNotation)
    tempS=this->Hcomponent.ElementToStringLetterFormat("\\alpha", true);
  else
    tempS=this->Hcomponent.ElementToStringLetterFormat("h", true);
  if (tempS[0]!='-' && this->NonZeroElements.CardinalitySelection>0)
    out << "+";
  if (useRootNotation)
    out << "h_{" << tempS << "}";
  else
    out << tempS;
  return out.str();
}

void ElementSimpleLieAlgebra::ElementToString(std::string& output, bool useHtml, bool useLatex, bool usePNG, std::string* physicalPath, std::string* htmlPathServer)const
{ std::stringstream out; std::string tempS;
  if (this->IsEqualToZero())
    out << "0";
  if (useLatex)
    out << "$";
  for (int i=0; i<this->NonZeroElements.CardinalitySelection; i++)
  { this->coeffsRootSpaces.TheObjects[this->NonZeroElements.elements[i]].ElementToString(tempS);
    if (tempS=="1")
      tempS="";
    if (tempS=="-1")
      tempS="-";
    if (i!=0)
    { if (tempS!="")
      { if (tempS[0]!='-')
          out << "+";
      } else
        out << "+";
    }
    out << tempS << "g_{" << this->NonZeroElements.elements[i]+1 << "}";
  }
  for (int i=0; i<this->Hcomponent.size; i++)
    if (!this->Hcomponent.TheObjects[i].IsEqualToZero())
    { this->Hcomponent.TheObjects[i].ElementToString(tempS);
      if (tempS=="1")
        tempS="";
      if (tempS=="-1")
        tempS="-";
      if (tempS!="")
      { if (tempS[0]!='-')
          out << "+";
      } else
        out << "+";
      out << tempS << "h_{\\alpha_{" << i+1 << "}}";
    }
  if(useLatex)
    out << "$";
  output= out.str();
}

void ElementSimpleLieAlgebra::SetCoefficient(const root& indexingRoot, Rational& theCoeff, const SemisimpleLieAlgebra& owner)
{ int index= owner.theWeyl.RootSystem.IndexOfObjectHash(indexingRoot);
  if (index!=-1)
    this->coeffsRootSpaces.TheObjects[index].Assign(theCoeff);
  this->ComputeNonZeroElements();
}

void ElementSimpleLieAlgebra::SetCoefficient(const root& indexingRoot, int theCoeff, const SemisimpleLieAlgebra& owner)
{ Rational tempRat=theCoeff;
  this->SetCoefficient(indexingRoot, tempRat, owner);
}

void SemisimpleLieAlgebra::ElementToString(std::string& output, bool useHtml, bool useLatex, bool usePNG, GlobalVariables& theGlobalVariables, std::string* physicalPath, std::string* htmlServerPath, List<std::string>* outputPNGFileNames, List<std::string>* outputLatexToPNGstrings)
{ std::stringstream outTable, outNotation;
  std::string tempS;
  if (physicalPath==0 || htmlServerPath==0 || outputPNGFileNames==0 || outputLatexToPNGstrings==0)
    usePNG=false;
  if(usePNG)
  { useHtml=true;
    useLatex=true;
  }
  int numRoots=this->theWeyl.RootSystem.size;
  int theDimension= this->theWeyl.CartanSymmetric.NumRows;
  roots theBasis;
  theBasis.SetSize(theDimension);
  if (usePNG)
    outNotation << "\\begin{tabular}{l}";
  for (int i=0; i<theDimension; i++)
  { theBasis.TheObjects[i].MakeZero(theDimension);
    theBasis.TheObjects[i].TheObjects[i].MakeOne();
    outNotation << theBasis.TheObjects[i].ElementToString();
    outNotation << "$=:\\alpha_{" << i+1 << "}$ \\\\";
  }
  root tempRoot;
  for (int i=theDimension; i<numRoots; i++)
  { this->theWeyl.RootSystem.TheObjects[i].GetCoordsInBasis(theBasis, tempRoot, theGlobalVariables);
    //this->theWeyl.RootSystem.TheObjects[i].ComputeDebugString();
    //tempRoot.ComputeDebugString();
    this->theWeyl.RootSystem.TheObjects[i].ElementToString(tempS);
    outNotation <<tempS<<"=";
    outNotation <<"$";
    for (int j=0; j<theDimension; j++)
    { tempRoot.TheObjects[j].ElementToString(tempS);
      if (tempS!="0")
      { if (tempS=="1")
          tempS="";
        if (tempS=="-1")
          tempS="-";
        if (j!=0)
        { if (tempS!="")
          { if (tempS[0]!='-')
              outNotation << "+";
          } else
            outNotation << "+";
        }
        outNotation << tempS << "\\alpha_{" << j+1 << "}";
      }
    }
    outNotation << "=: \\alpha_{" << i+1 << "} $";
    if (usePNG)
      outNotation << "\\\\";
  }
  for (int i=0; i<theDimension; i++)
  { outNotation << "$h_{\\alpha_" << i+1 << "} (g^{\\gamma}) := \\langle\\gamma, \\alpha_{" << i+1 << " } \\rangle g^{\\gamma}$, for any $\\gamma$.\n\n";
    if (usePNG)
      outNotation << "\\\\\n";
  }
  outTable << "\n\n";
  if (usePNG)
    outNotation << "\\end{tabular}";
  if (useLatex)
  { outTable << "\\begin{tabular}{c";
    for(int i=0; i<numRoots; i++)
      outTable << "c";
    outTable << "}";
    outTable << "$[\\bullet, \\bullet]$&";
  }
  for (int i=0; i<numRoots; i++)
  { outTable << "$g^{\\alpha_{" << i+1 << "}}$";
    if (i!=numRoots-1)
      outTable << "&";
  }
  outTable << "\\\\\n";
  Rational tempRat;
  for (int i=0; i<this->ChevalleyConstants.NumRows; i++)
  { outTable << "$g^{\\alpha_{" << i+1 << "}}$&";
    for (int j=0; j<this->ChevalleyConstants.NumCols; j++)
    { if (this->Computed.elements[i][j])
      { this->ChevalleyConstants.elements[i][j].ElementToString(tempS);
        if (tempS=="1")
          tempS="";
        if (tempS=="-1")
          tempS="-";
        if (tempS=="0")
          outTable << "0, ";
        else
        { tempRoot=this->theWeyl.RootSystem.TheObjects[i]+this->theWeyl.RootSystem.TheObjects[j];
          int index=this->theWeyl.RootSystem.IndexOfObjectHash(tempRoot);
          outTable << "$" << tempS << "g^{\\alpha_{" << index+1 << "}}$, ";
        }
      }
      else
      { root& theRoot= this->theWeyl.RootSystem.TheObjects[i];
        tempRat=2;
        tempRat.DivideBy(this->theWeyl.RootScalarCartanRoot(theRoot, theRoot));
        if (theRoot.IsNegativeOrZero())
          tempRat.Minus();
        tempRat.ElementToString(tempS);
        if (tempS=="1")
          tempS="";
        if (tempS=="-1")
          tempS="-";
        outTable << "$"<< tempS << "h_{\\alpha_{" << i+1 << "}}$";
      }
      if (useLatex && j!=this->ChevalleyConstants.NumCols-1)
        outTable << " & ";
      else
        if(!useLatex)
          outTable << "\t";
    }
    if (useLatex)
      outTable << "\\\\";
    outTable << "\n";
  }
  if (useLatex)
    outTable << "\\end{tabular}";
  //this->ChevalleyConstants.ElementToString(tempS);
  //out <<"\n"<< tempS<<"\n";
  if (usePNG)
  { std::stringstream out2;
    out2 << "<BODY><HTML></BODY>";
    ///////////////////////////
    tempS=outNotation.str();
    outputLatexToPNGstrings->AddObjectOnTop(tempS);
    tempS=*physicalPath;
    tempS.append("notation.tex");
    outputPNGFileNames->AddObjectOnTop(tempS);
    out2 << "<img src=\"" << (*htmlServerPath) << "notation.png\">\n<br>\n";
    ///////////////////////////
    tempS= outTable.str();
    outputLatexToPNGstrings->AddObjectOnTop(tempS);
    tempS=*physicalPath;
    tempS.append("StructureConstants_latex.tex");
    outputPNGFileNames->AddObjectOnTop(tempS);
    out2 << "<img src=\"" << (*htmlServerPath) << "StructureConstants_latex.png\">";
    ///////////////////////////
    out2 << "</BODY></HTML>";
    output=out2.str();
  }
  else
  { tempS=outTable.str();
    outNotation << tempS;
    output=outNotation.str();
  }
}

void SemisimpleLieAlgebra::MakeSl2ProgressReport(int progress, int found, int foundGood, int DifferentHs, int outOf, GlobalVariables& theGlobalVariables)
{ if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()==0)
    return;
  std::stringstream out2, out3;
  out2 << "found " << found << " out of " << progress+1 << " processed out of total " << outOf<<" candidates";
  out3 << foundGood << " good subalgebras realizing " << DifferentHs << " different h's";
  theGlobalVariables.theIndicatorVariables.ProgressReportString2=out2.str();
  theGlobalVariables.theIndicatorVariables.ProgressReportString3=out3.str();
  theGlobalVariables.theIndicatorVariables.String2NeedsRefresh=true;
  theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=true;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void SemisimpleLieAlgebra::MakeSl2ProgressReportNumCycles(  int progress, int outOf,  GlobalVariables& theGlobalVariables)
{ if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()==0)
    return;
  std::stringstream out4;
  out4 << "Searching fixed characteristic: " << progress << " out of " << outOf;
  theGlobalVariables.theIndicatorVariables.ProgressReportString4=out4.str();
  theGlobalVariables.theIndicatorVariables.String4NeedsRefresh=true;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void SemisimpleLieAlgebra::MakeChevalleyTestReport(int i, int j, int k, int Total, GlobalVariables& theGlobalVariables)
{ if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()==0)
    return;
  std::stringstream out2, out3;
  int x=(i*Total*Total+j*Total+k+1);
  out2 << "i: " << i+1 << " of " << Total << " j: " << j+1 << " of " << Total << " k: " << k+1 << " of " << Total;
  out3 << "Total progress: " << x << " out of " << (Total*Total*Total);
  theGlobalVariables.theIndicatorVariables.ProgressReportString2=out2.str();
  theGlobalVariables.theIndicatorVariables.ProgressReportString3=out3.str();
  //if (x%100==0)
  { theGlobalVariables.theIndicatorVariables.String2NeedsRefresh=true;
    theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=true;
  } //else
  //{ theGlobalVariables.theIndicatorVariables.String2NeedsRefresh=false;
   // theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=false;
  //}
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

//////////////////////////////////////////////////////////////
//Automatic prover code starts here://////////
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////

int minimalRelationsProverState::ProblemCounter=0;
int ::minimalRelationsProverStates::ProblemCounter=0;

bool StopDebug()
{ return true;
}

bool minimalRelationsProverState::SumWithNoPosRootIsARoot(root& input, WeylGroup& theWeyl)
{ root tempRoot;
  for (int j=0; j<this->PositiveKroots.size; j++)
  { tempRoot=input+this->PositiveKroots.TheObjects[j];
    if(theWeyl.IsARoot(tempRoot))
      return false;
  }
  return true;
}

bool minimalRelationsProverState::IsBKSingularImplied(root& input, WeylGroup& theWeyl)
{ if (!this->SumWithNoPosRootIsARoot(input, theWeyl))
    return false;
  root tempRoot;
  for (int j=0; j<theWeyl.RootSystem.size; j++)
    if (!this->nonPositiveKRoots.ContainsObject( theWeyl.RootSystem.TheObjects[j]))
    { tempRoot=input+theWeyl.RootSystem.TheObjects[j];
      if(theWeyl.IsARoot(tempRoot))
        return false;
    }
  return true;
}

void minimalRelationsProverState::SortAlphasAndBetas(GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{ roots& theAlphas = this->PartialRelation.Alphas;
  roots& theBetas  = this->PartialRelation.Betas;
  for(int i=0; i<theAlphas.size; i++)
    for (int j=i+1; j<theAlphas.size; j++)
      if (this->Root1IsGreaterThanRoot2(j, i, theAlphas, theBetas, theGlobalVariables, theWeyl))
        theAlphas.SwapTwoIndices(i, j);
  for(int i=0; i<theBetas.size; i++)
    for (int j=i+1; j<theBetas.size; j++)
      if (this->Root1IsGreaterThanRoot2(j, i, theBetas, theAlphas, theGlobalVariables, theWeyl))
        theBetas.SwapTwoIndices(i, j);
}

void minimalRelationsProverStateFixedK::SortAlphasAndBetas(GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{ roots& theAlphas = this->PartialRelation.Alphas;
  roots& theBetas  = this->PartialRelation.Betas;
  for(int i=0; i<theAlphas.size; i++)
    for (int j=i+1; j<theAlphas.size; j++)
      if (minimalRelationsProverState::Root1IsGreaterThanRoot2(j, i, theAlphas, theBetas, theGlobalVariables, theWeyl))
        theAlphas.SwapTwoIndices(i, j);
  for(int i=0; i<theBetas.size; i++)
    for (int j=i+1; j<theBetas.size; j++)
      if (minimalRelationsProverState::Root1IsGreaterThanRoot2(j, i, theBetas, theAlphas, theGlobalVariables, theWeyl))
        theBetas.SwapTwoIndices(i, j);
}

bool minimalRelationsProverState::Root1IsGreaterThanRoot2  (  int index1, int index2, roots& setWeBelongTo, roots& setOtherSet, GlobalVariables &theGlobalVariables, WeylGroup &theWeyl)
{ root& root1=setWeBelongTo.TheObjects[index1];
  root& root2=setWeBelongTo.TheObjects[index2];
  bool IsLong1, IsLong2;
  int NumLongValue1, NumMixedValue1, NumShortValue1,  NumMinusLongValue1, NumMinusMixedValue1, NumMinusShortValue1, NumLongValue2, NumMixedValue2, NumShortValue2,  NumMinusLongValue2, NumMinusMixedValue2, NumMinusShortValue2;
  minimalRelationsProverState::GetNumberScalarProductsData(root1, setWeBelongTo, IsLong1, NumLongValue1, NumMixedValue1, NumShortValue1, NumMinusLongValue1, NumMinusMixedValue1, NumMinusShortValue1, theGlobalVariables, theWeyl);
  minimalRelationsProverState::GetNumberScalarProductsData(root2, setWeBelongTo, IsLong2, NumLongValue2, NumMixedValue2, NumShortValue2, NumMinusLongValue2, NumMinusMixedValue2, NumMinusShortValue2, theGlobalVariables, theWeyl);
  if (IsLong1> IsLong2) return true;
  if (IsLong1< IsLong2) return false;
  if (NumLongValue1>NumLongValue2) return true;
  if (NumLongValue1<NumLongValue2) return false;
  if (NumMixedValue1>NumMixedValue2) return true;
  if (NumMixedValue1<NumMixedValue2) return false;
  if (NumShortValue1>NumShortValue2) return true;
  if (NumShortValue1<NumShortValue2) return false;
  if (NumMinusLongValue1>NumMinusLongValue2) return true;
  if (NumMinusLongValue1<NumMinusLongValue2) return false;
  if (NumMinusMixedValue1>NumMinusMixedValue2) return true;
  if (NumMinusMixedValue1<NumMinusMixedValue2) return false;
  if (NumMinusShortValue1>NumMinusShortValue2) return true;
  if (NumMinusShortValue1<NumMinusShortValue2) return false;
  return false;
}

void minimalRelationsProverState::GetNumberScalarProductsData(root& input, roots& theRoots, bool& isLong, int& NumLongValue, int& NumMixedValue, int& NumShortValue, int& NumMinusLongValue, int& NumMinusMixedValue, int& NumMinusShortValue, GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{ Rational tempRat = theWeyl.RootScalarCartanRoot(input, input);
  isLong=false; NumMinusShortValue=0;
  NumLongValue=0; NumMixedValue=0; NumShortValue=0; NumMinusLongValue=0;
  NumMinusMixedValue=0;
  if (tempRat.IsEqualTo(theWeyl.LongRootLength))
    isLong=true;
  Rational tempRat2;
  for (int i=0; i<theRoots.size; i++)
    if (!input.IsEqualTo(theRoots.TheObjects[i]))
    { theWeyl.RootScalarCartanRoot(input, theRoots.TheObjects[i], tempRat);
      if (!tempRat.IsEqualToZero())
      { theWeyl.RootScalarCartanRoot(theRoots.TheObjects[i], theRoots.TheObjects[i], tempRat2);
        bool otherIsLong=false;
        bool ScalarProdIsPositive=tempRat.IsPositive();
        if (theWeyl.LongRootLength.IsEqualTo(tempRat2))
          otherIsLong=true;
        if (!(otherIsLong==isLong))
        { if (ScalarProdIsPositive)
            NumMixedValue++;
          else
            NumMinusMixedValue++;
        } else
        { if (isLong)
          { if (ScalarProdIsPositive)
              NumLongValue++;
            else
              NumMinusLongValue++;
          }  else
          { if (ScalarProdIsPositive)
              NumShortValue++;
            else
              NumMinusShortValue++;
          }
        }
      }
    }
}

bool minimalRelationsProverState::SatisfyNonLnonBKSingularRoots(WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{  root tempRoot;
  //this->nonBKSingularGmodLRoots.ComputeDebugString();
  //this->ComputeDebugString(theWeyl, theGlobalVariables);
  for (int i=0; i<this->nonLNonSingularRoots.size; i++)
  { root& theRoot= this->nonLNonSingularRoots.TheObjects[i];
    int LastFoundIndex=-1;
    int NumFoundIndices=0;
    for(int j=0; j<theWeyl.RootSystem.size; j++)
    { tempRoot=theRoot+theWeyl.RootSystem.TheObjects[j];
      if (theWeyl.IsARoot(tempRoot))
      { if (this->PositiveKroots.ContainsObject(theWeyl.RootSystem.TheObjects[j]))
        { NumFoundIndices++;
          LastFoundIndex=j;
          break;
        }
        if (!this->nonPositiveKRoots.ContainsObject(theWeyl.RootSystem.TheObjects[j]))
        { NumFoundIndices++;
          LastFoundIndex=j;
        }
      }
    }
    if (NumFoundIndices==0)
    { this->StateIsInternallyPossible=false;
      return false;
    }
    if (NumFoundIndices==1)
      this->PositiveKroots.AddOnTopNoRepetition(theWeyl.RootSystem.TheObjects[LastFoundIndex]);
  }
  this->nonLNonSingularRootsInNeedOfPosKroots.size=0;
  for (int i=0; i<this->nonLNonSingularRoots.size; i++)
    if (this->SumWithNoPosRootIsARoot(this->nonLNonSingularRoots.TheObjects[i], theWeyl))
    { this->flagNeedsAdditionOfPositiveKroots=true;
      this->nonLNonSingularRootsInNeedOfPosKroots.AddOnTopNoRepetition(this->nonLNonSingularRoots.TheObjects[i]);
    }
  return true;
}

bool minimalRelationsProverState::ComputeStateReturnFalseIfDubious(minimalRelationsProverStates& owner, GlobalVariables& theGlobalVariables, WeylGroup& theWeyl, bool AssumeGlobalMinimalityRHS)
{ this->StateIsInternallyPossible=true;
  this->InternalStateIsComputed=true;
//  this->StateIsDubious=false;
  this->NilradicalRoots.AddRootSnoRepetition(this->PartialRelation.Betas);
  this->BKSingularGmodLRoots.AddRootSnoRepetition(this->PartialRelation.Alphas);
  this->PositiveKroots.AddRootSnoRepetition(this->ChosenPositiveKroots);
  SelectionWithMaxMultiplicity selBetas, selAlphas;
  selBetas.initMaxMultiplicity(this->PartialRelation.Betas.size, 1);
  selAlphas.initMaxMultiplicity(this->PartialRelation.Alphas.size, 1);
  int NumAlphas= MathRoutines::KToTheNth(selAlphas.MaxMultiplicity+1, this->PartialRelation.Alphas.size);
  int NumBetas=MathRoutines::KToTheNth(selBetas.MaxMultiplicity+1, this->PartialRelation.Betas.size);
//  this->ComputeDebugString(theWeyl, theGlobalVariables);
  for (int i=0; i<NumAlphas; i++)
  { for (int j=0; j<NumBetas; j++)
    { if (this->CanBeShortened(this->PartialRelation, selAlphas, selBetas, theWeyl, AssumeGlobalMinimalityRHS))
      { this->StateIsInternallyPossible=false;
        return false;
      }
      selBetas.IncrementSubset();
      this->MakeProgressReportCanBeShortened(i*NumBetas+j, NumAlphas*NumBetas, theGlobalVariables);
    }
    selAlphas.IncrementSubset();
  }
//  this->ComputeDebugString(theWeyl, theGlobalVariables);
  if (! this->ComputeCommonSenseImplicationsReturnFalseIfContradiction(theWeyl, theGlobalVariables))
  { this->StateIsInternallyPossible=false;
    return false;
  }
//  this->ComputeDebugString(theWeyl, theGlobalVariables);
  roots tempRoots;
  tempRoots.AddListOnTop(this->PartialRelation.Alphas);
  tempRoots.AddListOnTop(this->PartialRelation.Betas);
  if (tempRoots.GetRankOfSpanOfElements(theGlobalVariables)< this->PartialRelation.Betas.size+this->PartialRelation.Alphas.size)
  { if (!roots::ConesIntersect(theGlobalVariables, this->PartialRelation.Betas, this->PartialRelation.Alphas, theWeyl.CartanSymmetric.NumRows))
    { this->StateIsInternallyPossible=false;
      return false;
    }
    this->StateIsComplete=true;
    return true;
  }
   roots possibleAlphas, possibleBetas;
  this->GetPossibleAlphasAndBetas(possibleAlphas, possibleBetas, theWeyl);
  if (!roots::ConesIntersect(theGlobalVariables, possibleBetas, possibleAlphas, theWeyl.CartanSymmetric.NumRows))
  { this->StateIsInternallyPossible=false;
    return false;
  }
  this->ComputeDebugString(theWeyl, theGlobalVariables);
  return true;
}

bool minimalRelationsProverStateFixedK::ComputeStateReturnFalseIfDubious(GlobalVariables& theGlobalVariables, WeylGroup& theWeyl, bool AssumeGlobalMinimalityRHS)
{ this->StateIsPossible=true;
//  this->StateIsDubious=false;
  for (int i=0; i<this->PartialRelation.Betas.size; i++)
    this->theNilradicalModules.AddSelectionAppendNewIndex(this->owner->GetModuleIndex(this->PartialRelation.Betas.TheObjects[i]));
  for (int i=0; i<this->PartialRelation.Alphas.size; i++)
    this->theGmodLmodules.AddSelectionAppendNewIndex(this->owner->GetModuleIndex(this->PartialRelation.Alphas.TheObjects[i]));
  SelectionWithMaxMultiplicity selBetas, selAlphas;
  selBetas.initMaxMultiplicity(this->PartialRelation.Betas.size, 1);
  selAlphas.initMaxMultiplicity(this->PartialRelation.Alphas.size, 1);
  int NumAlphas= MathRoutines::KToTheNth(selAlphas.MaxMultiplicity+1, this->PartialRelation.Alphas.size);
  int NumBetas=MathRoutines::KToTheNth(selBetas.MaxMultiplicity+1, this->PartialRelation.Betas.size);
//  this->ComputeDebugString(theWeyl, theGlobalVariables);
  for (int i=0; i<NumAlphas; i++)
  { for (int j=0; j<NumBetas; j++)
    { if (this->CanBeShortened(this->PartialRelation, selAlphas, selBetas, theWeyl, AssumeGlobalMinimalityRHS))
      { this->StateIsPossible=false;
        return false;
      }
      selBetas.IncrementSubset();
      this->MakeProgressReportCanBeShortened(i*NumBetas+j, NumAlphas*NumBetas, theGlobalVariables);
    }
    selAlphas.IncrementSubset();
  }
//  this->ComputeDebugString(theWeyl, theGlobalVariables);
  if (! this->ComputeCommonSenseImplicationsReturnFalseIfContradictionFixedK(theWeyl, theGlobalVariables))
  { this->StateIsPossible=false;
    return false;
  }
//  this->ComputeDebugString(theWeyl, theGlobalVariables);
  //A relation consists always of minimally linearly dependent vectors, hence the below check.
  roots tempRoots;
  tempRoots.AddListOnTop(this->PartialRelation.Alphas);
  tempRoots.AddListOnTop(this->PartialRelation.Betas);
  if (tempRoots.GetRankOfSpanOfElements(theGlobalVariables)< this->PartialRelation.Betas.size+this->PartialRelation.Alphas.size)
  { if (!roots::ConesIntersect(theGlobalVariables, this->PartialRelation.Betas, this->PartialRelation.Alphas, theWeyl.CartanSymmetric.NumRows))
    { this->StateIsPossible=false;
      return false;
    }
    this->StateIsComplete=true;
    return true;
  }

   roots possibleAlphas, possibleBetas;
  this->GetPossibleAlphasAndBetas(possibleAlphas, possibleBetas, theWeyl);
  if (!roots::ConesIntersect(theGlobalVariables, possibleBetas, possibleAlphas, theWeyl.CartanSymmetric.NumRows))
  { this->StateIsPossible=false;
    return false;
  }
  this->ComputeDebugString(theWeyl, theGlobalVariables);
  return true;
}

void minimalRelationsProverState::MakeProgressReportCanBeShortened(int checked, int outOf, GlobalVariables& theGlobalVariables)
{ std::stringstream out5;
  out5 << checked+1 << " checked out of " << outOf;
  theGlobalVariables.theIndicatorVariables.ProgressReportString5=out5.str();
  //::theGlobalVariables.theIndicatorVariables.String1NeedsRefresh=false;
  //::theGlobalVariables.theIndicatorVariables.String2NeedsRefresh=false;
  //::theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=false;
  //::theGlobalVariables.theIndicatorVariables.String4NeedsRefresh=false;
  theGlobalVariables.theIndicatorVariables.String5NeedsRefresh=true;
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=false;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void minimalRelationsProverStateFixedK::MakeProgressReportCanBeShortened(int checked, int outOf, GlobalVariables& theGlobalVariables)
{ std::stringstream out5;
  out5 << checked+1 << " checked out of " << outOf;
  theGlobalVariables.theIndicatorVariables.ProgressReportString5=out5.str();
  //::theGlobalVariables.theIndicatorVariables.String1NeedsRefresh=false;
  //::theGlobalVariables.theIndicatorVariables.String2NeedsRefresh=false;
  //::theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=false;
  //::theGlobalVariables.theIndicatorVariables.String4NeedsRefresh=false;
  theGlobalVariables.theIndicatorVariables.String5NeedsRefresh=true;
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=false;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void minimalRelationsProverState::GetPossibleAlphasAndBetas(roots& outputAlphas, roots& outputBetas, WeylGroup& theWeyl)
{ outputBetas.size=0; outputAlphas.size=0;
  for (int i=0; i<theWeyl.RootSystem.size; i++)
  { if (!this->nonBKSingularGmodLRoots.ContainsObject(theWeyl.RootSystem.TheObjects[i]))
      outputAlphas.AddObjectOnTop(theWeyl.RootSystem.TheObjects[i]);
    if (!this->nonBetas.ContainsObject(theWeyl.RootSystem.TheObjects[i]))
      outputBetas.AddObjectOnTop(theWeyl.RootSystem.TheObjects[i]);
  }
}

void minimalRelationsProverStateFixedK::GetPossibleAlphasAndBetas(roots& outputAlphas, roots& outputBetas, WeylGroup& theWeyl)
{ outputBetas.size=0; outputAlphas.size=0;
  for (int i=0; i<this->owner->theK.kModules.size; i++)
  { if (!this->theNilradicalModules.selected[i])
      outputAlphas.AddObjectOnTop(this->owner->theK.HighestWeightsGmodK.TheObjects[i]);
    if (!this->theGmodLmodules.selected[i])
      outputBetas.AddListOnTop(this->owner->theK.kModules.TheObjects[i]);
  }
}

bool minimalRelationsProverState::IsSeparatingCones(root& input, bool& oneBetaIsPositive, WeylGroup& theWeyl)
{ return minimalRelationsProverStateFixedK::IsSeparatingCones(input, this->PartialRelation.Alphas, this->PartialRelation.Betas, oneBetaIsPositive, theWeyl);
}

bool minimalRelationsProverStateFixedK::IsSeparatingCones(root& input, bool& oneBetaIsPositive, WeylGroup& theWeyl)
{ return this->IsSeparatingCones(input, this->PartialRelation.Alphas, this->PartialRelation.Betas, oneBetaIsPositive, theWeyl);
}

bool minimalRelationsProverStateFixedK::IsSeparatingCones(root& input, roots& theAlphas, roots& theBetas, bool& oneBetaIsPositive, WeylGroup& theWeyl)
{ bool foundPosBeta=false;
  bool foundNegBeta=false;
  bool foundPosAlpha=false;
  bool foundNegAlpha=false;
  Rational tempRat;
  for (int i=0; i<theBetas.size; i++)
  { tempRat=theWeyl.RootScalarCartanRoot(theBetas.TheObjects[i], input);
    if (tempRat.IsPositive())
    { if (foundNegBeta)
        return false;
      foundPosBeta=true;
    }
    if (tempRat.IsNegative())
    { if (foundPosBeta)
        return false;
      foundNegBeta=true;
    }
  }
  for (int i=0; i<theAlphas.size; i++)
  { tempRat=theWeyl.RootScalarCartanRoot(theAlphas.TheObjects[i], input);
    if (tempRat.IsPositive())
    { if (foundNegAlpha || foundPosBeta)
        return false;
      foundPosAlpha=true;
    }
    if (tempRat.IsNegative())
    { if (foundPosAlpha || foundNegBeta)
        return false;
      foundNegAlpha=true;
    }
  }
  if (!(foundPosBeta|| foundNegBeta || foundPosAlpha || foundNegAlpha))
    return false;
  oneBetaIsPositive=foundPosBeta;
  return true;
}

void minimalRelationsProverStateFixedK::WriteToFile(std::fstream& output, GlobalVariables& theGlobalVariables)
{ output <<"\n\n\n\nNum_isos: " << this->indicesIsosRespectingInitialNilradicalChoice.size<<"\n";
  for (int i=0; i<this->indicesIsosRespectingInitialNilradicalChoice.size; i++)
    output <<this->indicesIsosRespectingInitialNilradicalChoice.TheObjects[i]<<" ";
  output << "\nAlphas: ";
  this->PartialRelation.Alphas.WriteToFile(output, theGlobalVariables);
  output << "Betas: ";
  this->PartialRelation.Betas.WriteToFile(output, theGlobalVariables);
  output<<"\nSeparating_normal: ";
  this->SeparatingNormalUsed.WriteToFile(output);
  output <<"Num_possible_children: " << this->PossibleChildStates.size<<"\n";
  output <<"Active_child: " << this->activeChild<<"\n";
  output <<"Children: ";
  for (int i=0; i<this->PossibleChildStates.size; i++)
    output <<this->PossibleChildStates.TheObjects[i]<<" ";
  output<<"\nthe_choices_we_make: ";
  this->theChoicesWeMake.WriteToFile(output, theGlobalVariables);
  output<<"\nNon_L_modules: ";
  this->theGmodLmodules.WriteToFile(output);
  output<<"\nN_modules: ";
  this->theNilradicalModules.WriteToFile(output);
  output<<"\nNon-alphas: ";
  this->nonAlphas.WriteToFile(output, theGlobalVariables);
  output<<"\nNon-betas: ";
  this->nonBetas.WriteToFile(output, theGlobalVariables);
}

void ::minimalRelationsProverStateFixedK::ReadFromFile(std::fstream &input, GlobalVariables&  theGlobalVariables)
{ std::string tempS;
  int tempI;
  input>>tempS >> tempI;  assert(tempS=="Num_isos:");
  this->indicesIsosRespectingInitialNilradicalChoice.SetSize(tempI);
  for (int i=0; i<this->indicesIsosRespectingInitialNilradicalChoice.size; i++)
    input>>this->indicesIsosRespectingInitialNilradicalChoice.TheObjects[i];
  input >>tempS;
  this->PartialRelation.Alphas.ReadFromFile(input, theGlobalVariables);
  input >> tempS;
  this->PartialRelation.Betas.ReadFromFile(input, theGlobalVariables);
  input>>tempS;
  this->SeparatingNormalUsed.ReadFromFile(input);
  input >>tempS >> tempI;
  this->PossibleChildStates.SetSize(tempI);
  input >>tempS >> this->activeChild;
  input >>tempS;
  for (int i=0; i<this->PossibleChildStates.size; i++)
    input >>this->PossibleChildStates.TheObjects[i];
  input>>tempS;
  this->theChoicesWeMake.ReadFromFile(input, theGlobalVariables);
  input>>tempS;
  this->theGmodLmodules.ReadFromFile(input);
  input>>tempS;
  this->theNilradicalModules.ReadFromFile(input);
  input>>tempS;
  this->nonAlphas.ReadFromFile(input, theGlobalVariables);
  input>>tempS;
  this->nonBetas.ReadFromFile(input, theGlobalVariables);
  assert(tempS=="Non-betas:");
}

void minimalRelationsProverState::WriteToFile(std::fstream& output, GlobalVariables&  theGlobalVariables)
{ output<< "\nAlphas: ";
  this->PartialRelation.Alphas.WriteToFile(output, theGlobalVariables);
  output<<"\nBetas: ";
  this->PartialRelation.Betas.WriteToFile(output, theGlobalVariables);
  output<<"\nActive_child(non-updated_see_header_for_true_data): " << this->activeChild <<" "<< this->PossibleChildStates.size<<" ";
  for (int i=0; i<this->PossibleChildStates.size; i++)
    output<< this->PossibleChildStates.TheObjects[i]<<" ";
  output<<"\nThe_choices_we_make: ";
  this->theChoicesWeMake.WriteToFile(output, theGlobalVariables);
  output<<"\nChosen_positive_Kroots: ";
  this->ChosenPositiveKroots.WriteToFile(output, theGlobalVariables);
  output<<"\nState_possible: "<<this->StateIsInternallyPossible;
  /*output<<"\nBk_singular: ";
  this->BKSingularGmodLRoots.WriteToFile(output, theGlobalVariables);
  output<<"\nChosen_normal_eps_form: ";
  this->currentSeparatingNormalEpsilonForm.WriteToFile(output);
  output<<"\nNeedsPosKroots: "<<this->flagNeedsAdditionOfPositiveKroots;
  output<<"\nNilradical_roots: ";
  this->NilradicalRoots.WriteToFile(output, theGlobalVariables);
  output<<"\nNon-alphas: ";
  this->nonAlphas.WriteToFile(output, theGlobalVariables);
  output<<"\nNon-betas: ";
  this->nonBetas.WriteToFile(output, theGlobalVariables);
  output<<"\nNonBK_singularGmodLroots: ";
  this->nonBKSingularGmodLRoots.WriteToFile(output, theGlobalVariables);
  output<<"\nNon_Kroots: ";
  this->nonKRoots.WriteToFile(output, theGlobalVariables);
  output<<"\nNon_L_non_singular: ";
  this->nonLNonSingularRoots.WriteToFile(output, theGlobalVariables);
  output<<"\nNon_L_non_singular_need_posK: ";
  this->nonLNonSingularRootsInNeedOfPosKroots.WriteToFile(output, theGlobalVariables);
  output<<"\nNon_L_aleviated: ";
  this->nonLNonSingularsAleviatedByChosenPosKRoots.WriteToFile(output, theGlobalVariables);
  output<<"\nNon_L_roots: ";
  this->nonLRoots.WriteToFile(output, theGlobalVariables);
  output<<"\nNon_nilradical_roots: ";
  this->nonNilradicalRoots.WriteToFile(output, theGlobalVariables);
  output<<"\nNon_PosKroots: ";
  this->nonPositiveKRoots.WriteToFile(output, theGlobalVariables);
  output<<"\nPosKroots: ";
  this->PositiveKroots.WriteToFile(output, theGlobalVariables); */
}

void minimalRelationsProverState::ReadFromFile(std::fstream& input, GlobalVariables&  theGlobalVariables)
{ std::string tempS; int tempI;
  input>> tempS;
  this->PartialRelation.Alphas.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->PartialRelation.Betas.ReadFromFile(input, theGlobalVariables);
  input>> tempS >> this->activeChild>>tempI;
  this->PossibleChildStates.SetSize(tempI);
  for (int i=0; i<this->PossibleChildStates.size; i++)
    input>> this->PossibleChildStates.TheObjects[i];
  input>> tempS;
  this->theChoicesWeMake.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->ChosenPositiveKroots.ReadFromFile(input, theGlobalVariables);
  input>> tempS>>this->StateIsInternallyPossible;
  assert(tempS=="State_possible:");
/*
  input>> tempS;
  this->BKSingularGmodLRoots.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->currentSeparatingNormalEpsilonForm.ReadFromFile(input);
  input>> tempS>>this->flagNeedsAdditionOfPositiveKroots;
  input>> tempS;
  this->NilradicalRoots.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->nonAlphas.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->nonBetas.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->nonBKSingularGmodLRoots.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->nonKRoots.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->nonLNonSingularRoots.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->nonLNonSingularRootsInNeedOfPosKroots.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->nonLNonSingularsAleviatedByChosenPosKRoots.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->nonLRoots.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->nonNilradicalRoots.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->nonPositiveKRoots.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->PositiveKroots.ReadFromFile(input, theGlobalVariables); */
}

void minimalRelationsProverStateFixedK::GetCertainGmodLhighestAndNilradicalRoots(roots& outputAGmodLhighest, roots& outputNilradicalRoots, WeylGroup& theWeyl)
{ outputAGmodLhighest.size=0; outputNilradicalRoots.size=0;
  for (int i=0; i<this->owner->theK.kModules.size; i++)
  { if (this->theNilradicalModules.selected[i])
      outputNilradicalRoots.AddListOnTop(this->owner->theK.kModules.TheObjects[i]);
    if (this->theGmodLmodules.selected[i])
      outputAGmodLhighest.AddObjectOnTop(this->owner->theK.HighestWeightsGmodK.TheObjects[i]);
  }
}

void ::minimalRelationsProverStatesFixedK::WriteToFile(std::fstream& output, GlobalVariables& theGlobalVariables)
{ output <<"Weyl_letter: " << this->theWeylGroup.WeylLetter << " dim: "<< this->theWeylGroup.CartanSymmetric.NumRows<<"\n";
  output<<"Simple_basis_K: ";
  //this->theK.SimpleBasisK.ComputeDebugString();
  this->theK.SimpleBasisK.WriteToFile(output, theGlobalVariables);
  this->theIsos.WriteToFile(output, theGlobalVariables);
  output<<"\nState_stack_size: "<< this->theIndexStack.size<<" ";
  for (int i=0; i<this->theIndexStack.size; i++)
    output << this->theIndexStack.TheObjects[i]<<" ";
  output<<"\nNum_states: "<< this->size<<"\n";
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].WriteToFile(output, theGlobalVariables);
  this->theK.WriteMultTableAndOppositeKmodsToFile(output, this->theK.theMultTable, this->theK.theOppositeKmods);
}

void ::minimalRelationsProverStatesFixedK::ReadFromFile(std::fstream& input, GlobalVariables& theGlobalVariables)
{ std::string tempS;
  int tempI;
  input >> tempS>> this->theWeylGroup.WeylLetter >> tempS>> tempI;
  if (tempI<=0)
    return;
  this->theWeylGroup.MakeArbitrary(this->theWeylGroup.WeylLetter, tempI);
  input>> tempS;
  this->theK.genK.ReadFromFile(input, theGlobalVariables);
  this->theK.genK.ComputeDebugString();
  this->theIsos.ReadFromFile(input, theGlobalVariables);
  input>>tempS>>tempI;
  this->theIndexStack.SetSize(tempI);
  for (int i=0; i<this->theIndexStack.size; i++)
    input>>this->theIndexStack.TheObjects[i];
  input>> tempS>> tempI;
  this->SetSize(tempI);
  for(int i=0; i<this->size; i++)
  { this->TheObjects[i].ReadFromFile(input, theGlobalVariables);
    this->TheObjects[i].owner=this;
  }
  this->theK.ReadMultTableAndOppositeKmodsFromFile(input, this->theK.theMultTable, this->theK.theOppositeKmods);
  this->theWeylGroup.ComputeRho(true);
  this->initShared(this->theWeylGroup, theGlobalVariables);
  this->theIsos.ComputeSubGroupFromGeneratingReflections(this->theIsos.simpleGenerators, this->theIsos.ExternalAutomorphisms, theGlobalVariables, -1, false);
  this->theK.ComputeAll();
  this->flagComputationIsInitialized=true;
  if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()!=0)
    if (this->theIndexStack.size>0)
    { int tempI= *this->theIndexStack.LastObject();
      this->TheObjects[tempI].ComputeDebugString(this->theWeylGroup, theGlobalVariables);
      theGlobalVariables.theIndicatorVariables.StatusString1=this->TheObjects[tempI].DebugString;
      theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
      theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
    }
  //this->theK.GenerateKmodMultTable(this->theK.theMultTable, this->theK.theOppositeKmods, theGlobalVariables);
}

void minimalRelationsProverStatesFixedK::WriteToFile(std::string& fileName, GlobalVariables&  theGlobalVariables)
{ CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(this->theFile, fileName, false, true, false);
  this->WriteToFile(this->theFile, theGlobalVariables);
  this->theFile.close();
}

void minimalRelationsProverStatesFixedK::ReadFromFile(std::string& fileName, GlobalVariables&  theGlobalVariables)
{ if(!rootFKFTcomputation::OpenDataFile(this->theFile, fileName))
    return;
  this->ReadFromFile(this->theFile, theGlobalVariables);
  this->theFile.close();
}

void minimalRelationsProverStates::WriteToFileAppend( GlobalVariables&  theGlobalVariables)
{ if (this->size-this->sizeByLastPurge >200)
  { this->sizeByLastSave=0;
    this->PurgeImpossibleStates();
  }
  if (this->sizeByLastSave!=0)
    CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(this->theFileBody, this->FileBodyString, true, false, false);
  else
    CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(this->theFileBody, this->FileBodyString, false, true, false);
  CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(this->theFileHeader, this->FileHeaderString, false, true, false);
  assert(this->theFileHeader.is_open());
  this->WriteToFileAppend(this->theFileHeader, this->theFileBody, theGlobalVariables);
  this->theFileHeader.close();
  this->theFileBody.close();
}

void minimalRelationsProverStates::ReadFromFile(GlobalVariables&  theGlobalVariables)
{ if(!rootFKFTcomputation::OpenDataFile(this->theFileBody, this->FileBodyString))
    return;
  if(!rootFKFTcomputation::OpenDataFile(this->theFileHeader, this->FileHeaderString))
    return;
  this->ReadFromFile(this->theFileHeader, this->theFileBody, theGlobalVariables);
  this->theFileHeader.close();
  this->theFileBody.close();
}

void minimalRelationsProverStates::WriteToFileAppend(std::fstream& outputHeader, std::fstream& outputBody, GlobalVariables& theGlobalVariables)
{ outputHeader <<"Weyl_letter: " << this->theWeylGroup.WeylLetter << " dim: "<< this->theWeylGroup.CartanSymmetric.NumRows<<"\n" <<"\nNum_states: "<<this->size;
  outputHeader<<"\nState_stack_size: "<< this->theIndexStack.size<<" ";
  for (int i=0; i<this->theIndexStack.size; i++)
    outputHeader << this->theIndexStack.TheObjects[i]<<" ";
  outputHeader<<"\nActive_child_list: ";
  for (int i=0; i<this->size; i++)
    outputHeader<<this->TheObjects[i].activeChild<<" ";
  outputHeader<< "\nTree_structure_excluding_complete_states: ";
  for(int i=0; i<this->size; i++)
  { outputHeader<<"\nChild_index "<<i<<" size: "<< this->TheObjects[i].PossibleChildStates.size<<" ";
    for (int j=0; j<this->TheObjects[i].PossibleChildStates.size; j++)
      outputHeader<< this->TheObjects[i].PossibleChildStates.TheObjects[j]<<" ";
  }
  outputHeader<< "\nTree_structure_complete_states: ";
  for(int i=0; i<this->size; i++)
  { outputHeader<<"\nChild_index "<<i<<" size: "<< this->TheObjects[i].CompleteChildStates.size<<" ";
    for (int j=0; j<this->TheObjects[i].CompleteChildStates.size; j++)
      outputHeader<< this->TheObjects[i].CompleteChildStates.TheObjects[j]<<" ";
    outputHeader<<"Num_impossible: "<< this->TheObjects[i].NumImpossibleChildren<<" ";
  }
  for (int i=this->sizeByLastSave; i<this->size; i++)
  { outputBody<<"\n\n\nState_index: "<< i<<" \n";
    this->TheObjects[i].WriteToFile(outputBody, theGlobalVariables);
    if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()!=0)
    { std::stringstream out3;
      out3<< i+1<<" out of "<< this->size<< " states stored to disk";
      theGlobalVariables.theIndicatorVariables.ProgressReportString3= out3.str();
      theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=true;
      theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
    }
  }
  this->sizeByLastSave=this->size;
}

void minimalRelationsProverStates::ReadFromFile(std::fstream& inputHeader, std::fstream& inputBody, GlobalVariables& theGlobalVariables)
{ std::string tempS; int tempI;
  inputHeader >>tempS >> this->theWeylGroup.WeylLetter >>tempS>> tempI;
  this->theWeylGroup.MakeArbitrary(this->theWeylGroup.WeylLetter, tempI);
  inputHeader>>tempS>>tempI;
  this->SetSize(tempI);
  inputHeader >>tempS>> tempI;
  this->theIndexStack.SetSize(tempI);
  for (int i=0; i<this->theIndexStack.size; i++)
    inputHeader>>this->theIndexStack.TheObjects[i];
  List<int> theActiveChildren;
  List< List<int> > thePossibleChildStates, theCompleteChildStates;
  theActiveChildren.SetSize(this->size);
  thePossibleChildStates.SetSize(this->size);
  theCompleteChildStates.SetSize(this->size);
  inputHeader>>tempS;
  assert(tempS=="Active_child_list:");
  for (int i=0; i<this->size; i++)
    inputHeader>>theActiveChildren.TheObjects[i];
  inputHeader>> tempS;
  for(int i=0; i<this->size; i++)
  { inputHeader>>tempS>>tempI>> tempS>>tempI;
    assert(tempS=="size:");
    thePossibleChildStates.TheObjects[i].SetSize(tempI);
    for (int j=0; j<tempI; j++)
      inputHeader>> thePossibleChildStates.TheObjects[i].TheObjects[j];
  }
  inputHeader>> tempS;
  assert(tempS=="Tree_structure_complete_states:");
  for(int i=0; i<this->size; i++)
  { inputHeader>>tempS>>tempI>> tempS>>tempI;
    assert(tempS=="size:");
    theCompleteChildStates.TheObjects[i].SetSize(tempI);
    for (int j=0; j<tempI; j++)
      inputHeader>> theCompleteChildStates.TheObjects[i].TheObjects[j];
    inputHeader>>tempS>>this->TheObjects[i].NumImpossibleChildren;
    assert(tempS=="Num_impossible:");
  }
  for (int i=0; i<this->size; i++)
  { inputBody>> tempS>>tempI;
    assert(tempI==i);
    this->TheObjects[i].ReadFromFile(inputBody, theGlobalVariables);
    this->TheObjects[i].owner=this;
    this->TheObjects[i].activeChild=theActiveChildren.TheObjects[i];
    this->TheObjects[i].PossibleChildStates.CopyFromBase(thePossibleChildStates.TheObjects[i]);
    this->TheObjects[i].CompleteChildStates.CopyFromBase(theCompleteChildStates.TheObjects[i]);
    if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()!=0)
    { std::stringstream out3;
      out3<< i+1<<" out of "<< this->size<< " states read from disk";
      theGlobalVariables.theIndicatorVariables.ProgressReportString3= out3.str();
      theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=false;
      theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=true;
      theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
    }
  }
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  this->initShared(this->theWeylGroup, theGlobalVariables);
  if (this->theIndexStack.size>0)
  { int currentI=*this->theIndexStack.LastObject();
    this->TheObjects[currentI].ComputeDebugString(this->theWeylGroup, theGlobalVariables);
    this->MakeProgressReportCurrentState(currentI, theGlobalVariables, this->theWeylGroup);
    this->MakeProgressReportStack(theGlobalVariables, this->theWeylGroup);
  }
  this->sizeByLastSave=this->size;
}

void minimalRelationsProverState::ReduceMemoryUse()
{ if (!this->InternalStateIsComputed)
    return;
  this->InternalStateIsComputed=false;
  this->theScalarProducts.ReleaseMemory();
  this->BKSingularGmodLRoots.ReleaseMemory();
  this->nonBKSingularGmodLRoots.ReleaseMemory();
  this->PositiveKroots.ReleaseMemory();
  this->nonPositiveKRoots.ReleaseMemory();
  this->NilradicalRoots.ReleaseMemory();
  this->nonNilradicalRoots.ReleaseMemory();
  this->nonKRoots.ReleaseMemory();
  this->nonAlphas.ReleaseMemory();
  this->nonBetas.ReleaseMemory();
  this->nonLRoots.ReleaseMemory();
  this->nonLNonSingularsAleviatedByChosenPosKRoots.ReleaseMemory();
  this->nonLNonSingularRoots.ReleaseMemory();
  this->nonLNonSingularRootsInNeedOfPosKroots.ReleaseMemory();
}

void minimalRelationsProverState::ComputeIsPossible(minimalRelationsProverStates& theOwner)
{ if (this->CompleteChildStates.size>0)
  { this->StateIsPossible=true;
    return;
  }
  this->StateIsPossible=false;
  for (int i=0; i<this->PossibleChildStates.size; i++)
    if (theOwner.TheObjects[this->PossibleChildStates.TheObjects[i]].StateIsPossible)
    { this->StateIsPossible=true;
      return;
    }
}

void minimalRelationsProverState::Assign(const minimalRelationsProverState& right)
{ this->initFromParent(right);
  this->StateIsPossible=right.StateIsPossible;
  this->theScalarProducts.Assign(right.theScalarProducts);
  this->currentSeparatingNormalEpsilonForm.Assign(right.currentSeparatingNormalEpsilonForm);
  this->PossibleChildStates= right.PossibleChildStates;
  this->CompleteChildStates= right.CompleteChildStates;
  this->NumImpossibleChildren=right.NumImpossibleChildren;
  this->activeChild=right.activeChild;
}

void minimalRelationsProverState::initFromParent(const minimalRelationsProverState& right)
{ this->PartialRelation=right.PartialRelation;
  this->BKSingularGmodLRoots.CopyFromBase(right.BKSingularGmodLRoots);
  this->nonBKSingularGmodLRoots.CopyFromBase(right.nonBKSingularGmodLRoots);
  this->PositiveKroots.CopyFromBase(right.PositiveKroots);
  this->nonPositiveKRoots.CopyFromBase(right.nonPositiveKRoots);
  this->NilradicalRoots.CopyFromBase(right.NilradicalRoots);
  this->nonNilradicalRoots.CopyFromBase(right.nonNilradicalRoots);
  this->nonKRoots.CopyFromBase(right.nonKRoots);
  this->nonAlphas.CopyFromBase(right.nonAlphas);
  this->nonBetas.CopyFromBase(right.nonBetas);
  this->owner=right.owner;
  this->StateIsInternallyPossible=right.StateIsInternallyPossible;
  this->StateIsComplete=right.StateIsComplete;
  this->ChosenPositiveKroots=right.ChosenPositiveKroots;
  this->theChoicesWeMake.CopyFromBase(right.theChoicesWeMake);
  this->nonLRoots.CopyFromBase(right.nonLRoots);
  this->nonLNonSingularsAleviatedByChosenPosKRoots=right.nonLNonSingularsAleviatedByChosenPosKRoots;
  this->flagNeedsAdditionOfPositiveKroots=right.flagNeedsAdditionOfPositiveKroots;
  this->nonLNonSingularRoots=right.nonLNonSingularRoots;
  this->nonLNonSingularRootsInNeedOfPosKroots=right.nonLNonSingularRootsInNeedOfPosKroots;
}

void minimalRelationsProverStateFixedK::Assign(const minimalRelationsProverStateFixedK& right)
{ this->theNilradicalModules.Assign(right.theNilradicalModules);
  this->theGmodLmodules.Assign(right.theGmodLmodules);
  this->owner=right.owner;
  this->nonAlphas.CopyFromBase(right.nonAlphas);
  this->nonBetas.CopyFromBase(right.nonBetas);
  this->PartialRelation.Alphas.CopyFromBase(right.PartialRelation.Alphas);
  this->PartialRelation.Betas.CopyFromBase(right.PartialRelation.Betas);
  this->StateIsPossible=right.StateIsPossible;
  this->StateIsComplete=right.StateIsComplete;
  this->theScalarProducts.Assign(right.theScalarProducts);
  this->theChoicesWeMake.CopyFromBase(right.theChoicesWeMake);
  this->currentSeparatingNormalEpsilonForm.Assign(right.currentSeparatingNormalEpsilonForm);
  this->flagNeedsAdditionOfPositiveKroots=right.flagNeedsAdditionOfPositiveKroots;
  this->ImpossibleChildStates= right.ImpossibleChildStates;
  this->PossibleChildStates.CopyFromBase( right.PossibleChildStates);
  this->CompleteChildStates= right.CompleteChildStates;
  this->activeChild=right.activeChild;
  this->indicesIsosRespectingInitialNilradicalChoice.CopyFromBase(right.indicesIsosRespectingInitialNilradicalChoice);
  this->SeparatingNormalUsed.Assign(right.SeparatingNormalUsed);
}

void minimalRelationsProverStateFixedK::initFromParentState(minimalRelationsProverStateFixedK& parent)
{ this->theNilradicalModules.Assign(parent.theNilradicalModules);
  this->theGmodLmodules.Assign(parent.theGmodLmodules);
  this->owner=parent.owner;
  this->nonAlphas.CopyFromBase(parent.nonAlphas);
  this->nonBetas.CopyFromBase(parent.nonBetas);
  this->PartialRelation=parent.PartialRelation;
  this->StateIsPossible=parent.StateIsPossible;
  this->StateIsComplete=parent.StateIsComplete;
  this->theScalarProducts.Assign(parent.theScalarProducts);
  this->theChoicesWeMake.CopyFromBase(parent.theChoicesWeMake);
  this->currentSeparatingNormalEpsilonForm.MakeZero(0);
  this->flagNeedsAdditionOfPositiveKroots=false;
  this->ImpossibleChildStates.size=0;
  this->PossibleChildStates.size=0;
  this->CompleteChildStates.size=0;
  this->activeChild=-1;
  this->indicesIsosRespectingInitialNilradicalChoice.CopyFromBase(parent.indicesIsosRespectingInitialNilradicalChoice);
  this->SeparatingNormalUsed.MakeZero(0);
}

void minimalRelationsProverStates::MakeProgressReportCurrentState(int index, GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{ std::stringstream out; std::string tempS;
  out << this->TheObjects[index].DebugString;
  out<<"\r\nPreferred dual basis: "<<this->PreferredDualBasisEpsilonCoords.DebugString;
  theGlobalVariables.theIndicatorVariables.StatusString1=out.str();
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
  //::theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=false;
}

void minimalRelationsProverStatesFixedK::MakeProgressReportCurrentState(  int index, GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{ std::stringstream out; std::string tempS;
  out << this->TheObjects[index].DebugString;
  out<<"\r\nPreferred dual basis: "<<this->PreferredDualBasisEpsilonCoords.DebugString;
  theGlobalVariables.theIndicatorVariables.StatusString1=out.str();
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
  //::theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=false;
}

void minimalRelationsProverStates::MakeProgressReportIsos(int progress, int numSearchedWithinState, int outOf, GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{ std::stringstream out3;
  out3 <<"Searching for automorphisms: " << progress+1 << " from "<< this->size << " states; "<< numSearchedWithinState+1<<" out of "<< outOf <<" possibilities within current state";
  theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=true;
  //::theGlobalVariables.theIndicatorVariables.String1NeedsRefresh=false;
  //::theGlobalVariables.theIndicatorVariables.String2NeedsRefresh=false;
  //::theGlobalVariables.theIndicatorVariables.String4NeedsRefresh=false;
  //::theGlobalVariables.theIndicatorVariables.String5NeedsRefresh=false;
  theGlobalVariables.theIndicatorVariables.ProgressReportString3=out3.str();
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void minimalRelationsProverStatesFixedK::MakeProgressReportIsos(int progress, int numSearchedWithinState, int outOf, GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{ std::stringstream out3;
  out3 <<"Searching for automorphisms: " << progress+1 << " from "<< this->size << " states; "<< numSearchedWithinState+1<<" out of "<< outOf <<" possibilities within current state";
  theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=true;
  //::theGlobalVariables.theIndicatorVariables.String1NeedsRefresh=false;
  //::theGlobalVariables.theIndicatorVariables.String2NeedsRefresh=false;
  //::theGlobalVariables.theIndicatorVariables.String4NeedsRefresh=false;
  //::theGlobalVariables.theIndicatorVariables.String5NeedsRefresh=false;
  //::theGlobalVariables.theIndicatorVariables.ProgressReportString3=out3.str();
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void minimalRelationsProverStates::MakeProgressReportChildStates(int numSearched, int outOf, int NewFound, GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{ this->MakeProgressReportStack(theGlobalVariables, theWeyl);
  std::stringstream out4;
  out4<<"Computing children states: "<< numSearched+1<<" out of "<< outOf << "; "<< this->TheObjects[*this->theIndexStack.LastObject()].PossibleChildStates.size<<" possible ";
  theGlobalVariables.theIndicatorVariables.String4NeedsRefresh=true;
//  ::theGlobalVariables.theIndicatorVariables.String1NeedsRefresh=false;
//  ::theGlobalVariables.theIndicatorVariables.String2NeedsRefresh=false;
//  ::theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=false;
//  ::theGlobalVariables.theIndicatorVariables.String5NeedsRefresh=false;
  theGlobalVariables.theIndicatorVariables.ProgressReportString4=out4.str();
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void minimalRelationsProverStatesFixedK::MakeProgressReportChildStates(int numSearched, int outOf, int NewFound, GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{ this->MakeProgressReportStack(theGlobalVariables, theWeyl);
  std::stringstream out4;
  out4<<"Computing children states: "<< numSearched+1<<" out of "<< outOf << "; " << this->TheObjects[*this->theIndexStack.LastObject()].PossibleChildStates.size<<" possible, "
        << this->TheObjects[*this->theIndexStack.LastObject()].ImpossibleChildStates.size<<" impossible ";
  theGlobalVariables.theIndicatorVariables.String4NeedsRefresh=true;
//  ::theGlobalVariables.theIndicatorVariables.String1NeedsRefresh=false;
//  ::theGlobalVariables.theIndicatorVariables.String2NeedsRefresh=false;
//  ::theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=false;
//  ::theGlobalVariables.theIndicatorVariables.String5NeedsRefresh=false;
  theGlobalVariables.theIndicatorVariables.ProgressReportString4=out4.str();
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}
void minimalRelationsProverStates::MakeProgressReportStack(GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{ std::stringstream out1, out2, out3, out4;
  std::stringstream* tempOut1=&out1;
  for (int i=0; i<this->theIndexStack.size; i++)
  { int currentIndex=this->theIndexStack.TheObjects[i];
    (*tempOut1)  << currentIndex << ": " << this->TheObjects[currentIndex].activeChild+1<< " of "<< this->TheObjects[currentIndex].PossibleChildStates.size  <<"; ";
    if (i==4)  tempOut1=&out2;
    if (i==8)  tempOut1=&out3;
  //  if (i==12)  tempOut1=&out4;
  }
  if (theIndexStack.size!=0)
    (*tempOut1)<< this->TheObjects[*this->theIndexStack.LastObject()].PartialRelation.Alphas.size<<" alphas + ... = "<<this->TheObjects[*this->theIndexStack.LastObject()].PartialRelation.Betas.size<<" betas + ...";
  theGlobalVariables.theIndicatorVariables.ProgressReportString1=out1.str();
  theGlobalVariables.theIndicatorVariables.ProgressReportString2=out2.str();
  if (this->theIndexStack.size>8)
    theGlobalVariables.theIndicatorVariables.ProgressReportString3=out3.str();
  theGlobalVariables.theIndicatorVariables.ProgressReportString4=out4.str();
  theGlobalVariables.theIndicatorVariables.String1NeedsRefresh=true;
  theGlobalVariables.theIndicatorVariables.String2NeedsRefresh=true;
  theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=true;
  theGlobalVariables.theIndicatorVariables.String4NeedsRefresh=true;
//  ::theGlobalVariables.theIndicatorVariables.String5NeedsRefresh=false;
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=false;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void minimalRelationsProverStatesFixedK::MakeProgressReportStack(GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{ std::stringstream out1, out2, out3, out4;
  std::stringstream* tempOut1=&out1;
  for (int i=0; i<this->theIndexStack.size; i++)
  { int currentIndex=this->theIndexStack.TheObjects[i];
    (*tempOut1)  << currentIndex << ": " << this->TheObjects[currentIndex].activeChild+1<< " of "<< this->TheObjects[currentIndex].PossibleChildStates.size  <<"; ";
    if (i==4)  tempOut1=&out2;
    if (i==8)  tempOut1=&out3;
  //  if (i==12)  tempOut1=&out4;
  }
  if (theIndexStack.size!=0)
    (*tempOut1)<< this->TheObjects[*this->theIndexStack.LastObject()].PartialRelation.Alphas.size <<" alphas + ... = " <<this->TheObjects[*this->theIndexStack.LastObject()].PartialRelation.Betas.size <<" betas + ...";
  theGlobalVariables.theIndicatorVariables.ProgressReportString1=out1.str();
  theGlobalVariables.theIndicatorVariables.ProgressReportString2=out2.str();
  if (this->theIndexStack.size>8)
    theGlobalVariables.theIndicatorVariables.ProgressReportString3=out3.str();
  theGlobalVariables.theIndicatorVariables.ProgressReportString4=out4.str();
  theGlobalVariables.theIndicatorVariables.String1NeedsRefresh=true;
  theGlobalVariables.theIndicatorVariables.String2NeedsRefresh=true;
  theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=true;
  theGlobalVariables.theIndicatorVariables.String4NeedsRefresh=true;
//  ::theGlobalVariables.theIndicatorVariables.String5NeedsRefresh=false;
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=false;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

bool minimalRelationsProverState::RootIsGoodForProblematicIndex(root& input, int problemIndex, bool AddingAlphas, bool NeedPositiveContribution, roots& theDualBasis, WeylGroup& theWeyl)
{ if (AddingAlphas)
  { if (this->nonAlphas.ContainsObject(input))
      return false;
  }else
    if (this->nonBetas.ContainsObject(input))
      return false;
  Rational tempRat=theWeyl.RootScalarCartanRoot(input, theDualBasis.TheObjects[problemIndex]);
  if (NeedPositiveContribution &&  tempRat.IsPositive())
    return true;
  if (!NeedPositiveContribution && tempRat.IsNegative())
    return true;
  return false;
}

bool minimalRelationsProverState::RootIsGoodForPreferredSimpleRoot(root& input, int preferredIndex, bool& GoodForAlpha, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables, root& AlphasMinusBetas)
{ Rational tempRat1, tempRat2;
  tempRat2=AlphasMinusBetas.TheObjects[preferredIndex]; tempRat2.AssignAbsoluteValue();
  tempRat1= AlphasMinusBetas.TheObjects[preferredIndex]-input.TheObjects[preferredIndex];
  tempRat1.AssignAbsoluteValue();
  if (tempRat2.IsGreaterThan(tempRat1))
    if (!this->nonBetas.ContainsObject(input))
    { GoodForAlpha=false;
      return true;
    }
  tempRat1=AlphasMinusBetas.TheObjects[preferredIndex]+input.TheObjects[preferredIndex];
  tempRat1.AssignAbsoluteValue();
  if (tempRat2.IsGreaterThan(tempRat1))
    if (!this->nonBKSingularGmodLRoots.ContainsObject(input))
    { GoodForAlpha=true;
      return true;
    }
  return false;
}

minimalRelationsProverState::minimalRelationsProverState()
{ this->StateIsComplete=false;
  this->StateIsPossible=true;
  this->InternalStateIsComputed=false;
  this->flagNeedsAdditionOfPositiveKroots=false;
  this->NumImpossibleChildren=0;
  this->activeChild=-1;
}

minimalRelationsProverStateFixedK::minimalRelationsProverStateFixedK()
{ this->StateIsComplete=false;
  this->flagNeedsAdditionOfPositiveKroots=false;
  this->activeChild=-1;
}

bool minimalRelationsProverState::IsAGoodPosRootsKChoice(WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ theWeyl.GenerateAdditivelyClosedSubset(this->PositiveKroots, this->PositiveKroots);
  for (int i=0; i<this->BKSingularGmodLRoots.size; i++)
    if (!this->SumWithNoPosRootIsARoot(this->BKSingularGmodLRoots.TheObjects[i], theWeyl))
      return false;
  return true;
}

bool minimalRelationsProverState::FindBetaWithoutTwoAlphas(root& outputBeta, roots& inputBetas, roots& inputAlphas, WeylGroup& theWeyl)
{ for (int i=0; i<inputBetas.size; i++)
    if (inputAlphas.NumRootsConnectedTo(inputBetas.TheObjects[i], theWeyl)<2)
    { outputBeta.Assign(inputBetas.TheObjects[i]);
      return true;
    }
  return false;
}

bool minimalRelationsProverStates::StateIsEqualTo(minimalRelationsProverState& theState, int IndexOther, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ return this->ExtendToIsomorphismRootSystem(theState, IndexOther, theGlobalVariables, theWeyl);
}

bool minimalRelationsProverStates::AddOnTopNoRepetition(int ParentIndex, minimalRelationsProverState& theState, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ if (theState.PartialRelation.Alphas.size+theState.PartialRelation.Betas.size<7)
    for (int i=0; i<this->size; i++)
      if (this->StateIsEqualTo(theState, i, theWeyl, theGlobalVariables))
        return false;
  this->AddObjectOnTop(theState);
  return true;
}

void minimalRelationsProverState::ComputeScalarProductsMatrix(GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{ return this->ComputeScalarProductsMatrix(  theGlobalVariables, theWeyl, this->PartialRelation.Alphas, this->PartialRelation.Betas, this->theScalarProducts);
}

void minimalRelationsProverState::ComputeScalarProductsMatrix(GlobalVariables& theGlobalVariables, WeylGroup& theWeyl, roots& theAlphas, roots& theBetas, MatrixLargeRational& output)
{ roots& tempRoots=theGlobalVariables.rootsProverStateComputation1;
  tempRoots.size=0;
  tempRoots.AddListOnTop(theAlphas);
  tempRoots.AddListOnTop(theBetas);
  output.init(tempRoots.size, tempRoots.size);
  for (int i=0; i<tempRoots.size; i++)
    for (int j=0; j<tempRoots.size; j++)
      theWeyl.RootScalarCartanRoot(tempRoots.TheObjects[i], tempRoots.TheObjects[j], output.elements[i][j]);
}

void minimalRelationsProverState::ElementToString( std::string& output, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables, bool displayEpsilons)
{ std::string tempS; std::stringstream out;
  for(int i=0; i<this->PartialRelation.Alphas.size; i++)
  { this->PartialRelation.Alphas.TheObjects[i].ElementToString(tempS);
    out << "a_"<<i+1<<tempS <<" + ";
  }
  out <<"... = ";
  for(int i=0; i<this->PartialRelation.Betas.size; i++)
  { this->PartialRelation.Betas.TheObjects[i].ElementToString(tempS);
    out << "b_"<<i+1<<tempS <<" + ";
  }
  out <<"...     (a_i, b_i>0)\r\n";
  root tempRoot; roots tempRoots;
  for(int i=0; i<this->PartialRelation.Alphas.size; i++)
  { theWeyl.GetEpsilonCoords(this->PartialRelation.Alphas.TheObjects[i], tempRoot, theGlobalVariables);
    tempRoot.ElementToStringEpsilonForm(tempS, false, false);
    out << "a_"<<i+1<<"("<<tempS <<") + ";
  }
  out <<"... = ";
  for(int i=0; i<this->PartialRelation.Betas.size; i++)
  { theWeyl.GetEpsilonCoords(this->PartialRelation.Betas.TheObjects[i], tempRoot, theGlobalVariables);
    tempRoot.ElementToStringEpsilonForm(tempS, false, false);
    out << "b_"<<i+1<<"("<<tempS <<") + ";
  }
  out <<"...";
  this->currentSeparatingNormalEpsilonForm.ElementToStringEpsilonForm(tempS, false, false);
  out <<"\nCurrent separating normal: " << tempS;
  out <<"\r\nChildren states: "<<  this->PossibleChildStates.size <<" possible, "<< this->NumImpossibleChildren <<" impossible, "<< this->CompleteChildStates.size
        <<" complete. Index next possible child to explore: " << this->activeChild+2;
  roots AlphaChildren, BetaChildren, Kchildren;
  for (int i=0; i<this->PossibleChildStates.size; i++)
  { minimalRelationsProverState& child = owner->TheObjects[this->PossibleChildStates.TheObjects[i]];
    if (this->PartialRelation.Alphas.size<child.PartialRelation.Alphas.size)
    { theWeyl.GetEpsilonCoords(*child.theChoicesWeMake.LastObject(), tempRoot, theGlobalVariables);
      AlphaChildren.AddObjectOnTop(tempRoot);
    }
    if (this->PartialRelation.Betas.size<child.PartialRelation.Betas.size)
    { theWeyl.GetEpsilonCoords(*child.theChoicesWeMake.LastObject(), tempRoot, theGlobalVariables);
      BetaChildren.AddObjectOnTop(tempRoot);
    }
    if (this->ChosenPositiveKroots.size<child.ChosenPositiveKroots.size)
    { theWeyl.GetEpsilonCoords(*child.ChosenPositiveKroots.LastObject(), tempRoot, theGlobalVariables);
      Kchildren.AddObjectOnTop(tempRoot);
    }
  }
  //assert(!(AlphaChildren.size+BetaChildren.size+Kchildren.size==0));
  if (AlphaChildren.size>0)
  { AlphaChildren.ElementToStringEpsilonForm(tempS, false, false, false);
    out <<"\r\nNew alphas added next: " <<tempS;
  }
  if (BetaChildren.size>0)
  { BetaChildren.ElementToStringEpsilonForm(tempS, false, false, false);
    out <<"\r\nNew betas added next: " <<tempS;
  }
  if (Kchildren.size>0)
  { Kchildren.ElementToStringEpsilonForm(tempS, false, false, false);
    out <<"\r\nNew k-roots added next: " <<tempS;
  }
  if(!displayEpsilons)
    this->ChosenPositiveKroots.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->ChosenPositiveKroots, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out <<"\r\nPositive choices for K-roots made("<<this->ChosenPositiveKroots.size<<"): " << tempS;
  if(!displayEpsilons)
    this->nonLNonSingularRootsInNeedOfPosKroots.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->nonLNonSingularRootsInNeedOfPosKroots, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out <<"\r\nNon-L non-singular roots in need of a K- positive root("<<this->nonLNonSingularRootsInNeedOfPosKroots.size <<"): " << tempS;
  if (!displayEpsilons)
    this->theChoicesWeMake.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->theChoicesWeMake, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out <<"\r\nThe choices we make("<<this->theChoicesWeMake.size <<"): "<< tempS;
  if (!displayEpsilons)
    this->BKSingularGmodLRoots.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->BKSingularGmodLRoots, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out <<"\r\nBK singular g mod l roots("<< this->BKSingularGmodLRoots.size<<"): "<< tempS;
  if (!displayEpsilons)
    this->nonAlphas.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->nonAlphas, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out <<"\r\nNon-alphas("<< this->nonAlphas.size<<"): "<< tempS;
  if (!displayEpsilons)
    this->nonBetas.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->nonBetas, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out <<"\r\nNon-betas("<<this->nonBetas.size <<"): "<< tempS;
  if (!displayEpsilons)
    this->nonBKSingularGmodLRoots.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->nonBKSingularGmodLRoots, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out <<"\r\nnon BK-singular g mod l roots("<< this->nonBKSingularGmodLRoots.size<<"): "<< tempS;
  if (!displayEpsilons)
    this->NilradicalRoots.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->NilradicalRoots, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out << "\r\nNilradical roots("<< this->NilradicalRoots.size<<"): "<< tempS;
  if (!displayEpsilons)
    this->nonNilradicalRoots.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->nonNilradicalRoots, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out << "\r\nnon-nilradical roots("<< this->nonNilradicalRoots.size<<"): "<< tempS;
  if (!displayEpsilons)
    this->PositiveKroots.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->PositiveKroots, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out << "\r\nPositive roots of K("<<this->PositiveKroots.size <<"): "<< tempS;
  if (!displayEpsilons)
    this->nonKRoots.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->nonKRoots, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out <<"\r\nNon-roots of K("<<this->nonKRoots.size <<"): "<< tempS;
  if (!displayEpsilons)
    this->nonPositiveKRoots.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->nonPositiveKRoots, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out <<"\r\nNon-positive roots of K("<< this->nonPositiveKRoots.size<<"): "<< tempS;
  if (!displayEpsilons)
    this->nonLRoots.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->nonLRoots, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out <<"\r\nNon-L roots("<<this->nonLRoots.size <<"): "<< tempS;
  if (!displayEpsilons)
    this->nonLNonSingularRoots.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->nonLNonSingularRoots, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out <<"\r\nNon-L non-singular roots("<< this->nonLNonSingularRoots.size<<"): "<< tempS;
  if (!this->StateIsInternallyPossible)
    out << "\r\n I am Impossible!";
  if (this->StateIsComplete)
    out <<"\r\nI am complete!";
  out<<"\r\n\n";
  output=out.str();
}

void minimalRelationsProverStateFixedK::ElementToString( std::string& output, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables, bool displayEpsilons)
{ std::string tempS; std::stringstream out;
  for(int i=0; i<this->PartialRelation.Alphas.size; i++)
  { this->PartialRelation.Alphas.TheObjects[i].ElementToString(tempS);
    out << "a_"<<i+1<<tempS <<" + ";
  }
  out <<"... = ";
  for(int i=0; i<this->PartialRelation.Betas.size; i++)
  { this->PartialRelation.Betas.TheObjects[i].ElementToString(tempS);
    out << "b_"<<i+1<<tempS <<" + ";
  }
  out <<"...     (a_i, b_i>0)\r\n";
  root tempRoot; roots tempRoots;
  for(int i=0; i<this->PartialRelation.Alphas.size; i++)
  { theWeyl.GetEpsilonCoords(this->PartialRelation.Alphas.TheObjects[i], tempRoot, theGlobalVariables);
    tempRoot.ElementToStringEpsilonForm(tempS, false, false);
    out << "a_"<<i+1<<"("<<tempS <<") + ";
  }
  out <<"... = ";
  for(int i=0; i<this->PartialRelation.Betas.size; i++)
  { theWeyl.GetEpsilonCoords(this->PartialRelation.Betas.TheObjects[i], tempRoot, theGlobalVariables);
    tempRoot.ElementToStringEpsilonForm(tempS, false, false);
    out << "b_"<<i+1<<"("<<tempS <<") + ";
  }
  out <<"...";
  this->currentSeparatingNormalEpsilonForm.ElementToStringEpsilonForm(tempS, false, false);
  out <<"\nCurrent separating normal: " << tempS;
  out <<"\nInternal separating normal: " << this->SeparatingNormalUsed.ElementToString();
  out<<"\r\nChildren states: "<<  this->PossibleChildStates.size <<" possible, "<< this->ImpossibleChildStates.size <<" impossible, " << this->CompleteChildStates.size<<" complete. Index next possible child to explore: " << this->activeChild+2;
  roots AlphaChildren, BetaChildren, Kchildren;
  for (int i=0; i<this->PossibleChildStates.size; i++)
  { minimalRelationsProverStateFixedK& child = owner->TheObjects[this->PossibleChildStates.TheObjects[i]];
    if (this->PartialRelation.Alphas.size<child.PartialRelation.Alphas.size)
    { theWeyl.GetEpsilonCoords(*child.theChoicesWeMake.LastObject(), tempRoot, theGlobalVariables);
      AlphaChildren.AddObjectOnTop(tempRoot);
    }
    if (this->PartialRelation.Betas.size<child.PartialRelation.Betas.size)
    { theWeyl.GetEpsilonCoords(*child.theChoicesWeMake.LastObject(), tempRoot, theGlobalVariables);
      BetaChildren.AddObjectOnTop(tempRoot);
    }
  }
  //assert(!(AlphaChildren.size+BetaChildren.size+Kchildren.size==0));
  if (AlphaChildren.size>0)
  { AlphaChildren.ElementToStringEpsilonForm(tempS, false, false, false);
    out <<"\r\nNew alphas added next: " <<tempS;
  }
  if (BetaChildren.size>0)
  { BetaChildren.ElementToStringEpsilonForm(tempS, false, false, false);
    out <<"\r\nNew betas added next: " <<tempS;
  }
  if (Kchildren.size>0)
  { Kchildren.ElementToStringEpsilonForm(tempS, false, false, false);
    out <<"\r\nNew k-roots added next: " <<tempS;
  }
  if (!displayEpsilons)
    this->theChoicesWeMake.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->theChoicesWeMake, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out <<"\r\nThe choices we make: "<< tempS;
  if (!displayEpsilons)
    this->nonAlphas.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->nonAlphas, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out <<"\r\nNon alphas("<< this->nonAlphas.size<<"): "<< tempS;
  if (!displayEpsilons)
    this->nonBetas.ElementToString(tempS);
  else
  { theWeyl.GetEpsilonCoords(this->nonBetas, tempRoots, theGlobalVariables);
    tempRoots.ElementToStringEpsilonForm(tempS, false, false, false);
  }
  out <<"\r\nNon betas("<<this->nonBetas.size<<"): "<< tempS;
  out<<"\r\nG mod L modules(" <<this->theGmodLmodules.CardinalitySelection<<"): ";
  for (int i=0; i<this->theGmodLmodules.CardinalitySelection; i++)
    out<< this->theGmodLmodules.elements[i]<<" ";
  out<<"\r\nNilradical modules(" <<this->theNilradicalModules.CardinalitySelection<<"): ";
  for (int i=0; i<this->theNilradicalModules.CardinalitySelection; i++)
    out<< this->theNilradicalModules.elements[i]<<" ";
  if (!this->StateIsPossible)
    out << "\r\n I am Impossible!";
  if (this->StateIsComplete)
    out <<"\r\nI am complete!";
  out<<"\r\n\n";
  out <<"Call stack: ";
  for (int i=0; i<this->owner->theIndexStack.size; i++)
  { out << "state "<<this->owner->theIndexStack.TheObjects[i];
    if (i!=this->owner->theIndexStack.size-1)
      out<<"-> ";
  }
  output=out.str();
}

void minimalRelationsProverStates::ElementToString(std::string& output, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ std::string tempS; std::stringstream out;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS, theWeyl, theGlobalVariables, true);
    out <<tempS<<"\n\n";
  }
  output=out.str();
}

void minimalRelationsProverStates::ComputePreferredDualBasis(char WeylLetter, int theDimension, GlobalVariables& theGlobalVariables)
{ this->PreferredDualBasis.SetSize(theDimension);
  for (int i=0; i<theDimension; i++)
    this->PreferredDualBasis.TheObjects[i].MakeZero(theDimension);
  if (WeylLetter=='D')
    for (int i=0; i<theDimension; i++)
    { for (int j=i; j<theDimension-2; j++)
        this->PreferredDualBasis.TheObjects[i].TheObjects[j]=2;
      this->PreferredDualBasis.TheObjects[i].TheObjects[theDimension-1]=1;
      this->PreferredDualBasis.TheObjects[i].TheObjects[theDimension-2]=1;
      if (i==theDimension-1)
        this->PreferredDualBasis.TheObjects[i].TheObjects[theDimension-2]=-1;
    }
  if (WeylLetter=='E' && theDimension==8)
  { this->PreferredDualBasis.SetSize(0);
    //for (int i=0; i<theDimension; i++)
     // this->PreferredDualBasis.TheObjects[i].TheObjects[i].MakeOne();
/*    for (int i=0; i<7; i++)
    { this->PreferredDualBasis.TheObjects[i].TheObjects[1]=1;
      this->PreferredDualBasis.TheObjects[i].TheObjects[2]=-1;
      for (int j=0; j<i; j++)
        this->PreferredDualBasis.TheObjects[i].TheObjects[j+2]+=2;
    }
    this->PreferredDualBasis.TheObjects[7].TheObjects[0]=4;
    this->PreferredDualBasis.TheObjects[7]-=this->PreferredDualBasis.TheObjects[0];
    for (int i=1; i< 7; i++)
      this->PreferredDualBasis.TheObjects[7]+=this->PreferredDualBasis.TheObjects[i]; */
  }
  int oldsize=PreferredDualBasis.size;
  for (int i=0; i<oldsize; i++)
    PreferredDualBasis.AddObjectOnTop(-PreferredDualBasis.TheObjects[i]);
  this->theWeylGroup.GetEpsilonCoords( this->PreferredDualBasis, this->PreferredDualBasisEpsilonCoords, theGlobalVariables);
  this->PreferredDualBasisEpsilonCoords.ElementToStringEpsilonForm( this->PreferredDualBasisEpsilonCoords.DebugString, false, false, false);
}

void minimalRelationsProverStates::initShared(WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ this->theWeylGroup.ComputeRho(true);
  this->isomorphismComputer.AmbientWeyl.Assign(this->theWeylGroup);
  this->isomorphismComputer.ComputeAll();
  this->flagAssumeGlobalMinimalityRHS=false;
  this->invertedCartan.Assign(this->theWeylGroup.CartanSymmetric);
  this->invertedCartan.Invert(theGlobalVariables);
  this->flagComputationIsInitialized=true;
}

void minimalRelationsProverStates::GenerateStartingState(ComputationSetup& theSetup, GlobalVariables& theGlobalVariables, char WeylLetter, int theDimension)
{ if (this->flagComputationIsInitialized)
    return;
  this->WriteToFileAppend(theGlobalVariables);
  minimalRelationsProverState tempState;
  this->theWeylGroup.MakeArbitrary(WeylLetter, theDimension);
  this->PreferredDualBasis.size=0;
  this->initShared(this->theWeylGroup, theGlobalVariables);
  this->ComputePreferredDualBasis(WeylLetter, theDimension, theGlobalVariables);
  this->size=0;
  root tempRoot;
  tempRoot.Assign(this->theWeylGroup.RootSystem.TheObjects[7]);
  tempState.PartialRelation.Alphas.AddObjectOnTop(tempRoot);
  for (int i=0; i<this->theWeylGroup.RootSystem.size; i++)
    if (this->theWeylGroup.RootSystem.TheObjects[i]!=tempRoot && this->theWeylGroup.RootScalarCartanRoot(tempRoot, this->theWeylGroup.RootSystem.TheObjects[i]).IsPositive() )
    { tempState.PartialRelation.Betas.AddObjectOnTop(this->theWeylGroup.RootSystem.TheObjects[i]);
      break;
    }
  tempState.theChoicesWeMake.AddObjectOnTop(tempState.PartialRelation.Betas.TheObjects[0]);
  tempState.theChoicesWeMake.AddObjectOnTop(tempState.PartialRelation.Alphas.TheObjects[0]);
  tempState.owner=this;
  this->AddObjectOnTop(tempState);
  this->LastObject()->ComputeStateReturnFalseIfDubious(*this, theGlobalVariables, this->theWeylGroup, this->flagAssumeGlobalMinimalityRHS);
  this->LastObject()->ComputeScalarProductsMatrix(theGlobalVariables, this->theWeylGroup);
  this->LastObject()->ComputeDebugString(this->theWeylGroup, theGlobalVariables);
  this->theIndexStack.AddObjectOnTop(0);
  this->MakeProgressReportCurrentState(0, theGlobalVariables, this->theWeylGroup);
  this->ComputeLastStackIndex(this->theWeylGroup, theGlobalVariables);
}

void WeylGroup::GenerateRootSubsystem(roots& theRoots)
{ root tempRoot;
  int oldsize=theRoots.size;
  for (int i=0; i<oldsize; i++)
    theRoots.AddOnTopNoRepetition(-theRoots.TheObjects[i]);
  for (int i =0; i<theRoots.size; i++)
    for (int j=0; j<theRoots.size; j++)
    { tempRoot= theRoots.TheObjects[i]+theRoots.TheObjects[j];
      if (this->IsARoot(tempRoot))
        theRoots.AddOnTopNoRepetition(tempRoot);
    }
}

void WeylGroup::GetEpsilonCoords(List<root>& input, roots& output, GlobalVariables& theGlobalVariables)
{ roots tempRoots;
  tempRoots.MakeEiBasis(this->CartanSymmetric.NumRows);
  this->GetEpsilonCoordsWRTsubalgebra(tempRoots, input, output, theGlobalVariables);
}

void WeylGroup::GetEpsilonCoords(root& input, root& output, GlobalVariables& theGlobalVariables)
{ roots tempRoots;
  roots tempInput, tempOutput;
  tempInput.AddObjectOnTop(input);
  tempRoots.SetSize(this->CartanSymmetric.NumRows);
  for (int i=0; i<this->CartanSymmetric.NumRows; i++)
  { tempRoots.TheObjects[i].MakeZero(this->CartanSymmetric.NumRows);
    tempRoots.TheObjects[i].TheObjects[i].MakeOne();
  }
  this->GetEpsilonCoordsWRTsubalgebra(tempRoots, tempInput, tempOutput, theGlobalVariables);
  output.Assign(tempOutput.TheObjects[0]);
}

bool minimalRelationsProverStates::CheckConsistencyOfTree()
{ bool result=true;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].activeChild>-1 && this->TheObjects[i].activeChild<this->TheObjects[i].PossibleChildStates.size)
      if (!this->theIndexStack.ContainsObject(i))
      { result=false;
        assert(false);
      }
  return  result;
}

bool minimalRelationsProverStates::ExtendToIsomorphismRootSystem(minimalRelationsProverState& theState, int indexOther, GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{  //return true;
  theState.SortAlphasAndBetas(theGlobalVariables, theWeyl);
  theState.ComputeScalarProductsMatrix(theGlobalVariables, theWeyl);
  minimalRelationsProverState& theOtherState=this->TheObjects[indexOther];
  //rootSubalgebra& theRootSA=theGlobalVariables.rootSAProverIsos;
  roots& theAlphas = theState.PartialRelation.Alphas;
  roots& theBetas  = theState.PartialRelation.Betas;
  roots& theKroots = theState.ChosenPositiveKroots;
  roots& theOtherAlphas = theOtherState.PartialRelation.Alphas;
  roots& theOtherBetas  = theOtherState.PartialRelation.Betas;
  roots& theOtherKroots = theOtherState.ChosenPositiveKroots;
  if (theAlphas.size!=theOtherAlphas.size)
    return false;
  if (theBetas.size!=theOtherBetas.size)
    return false;
  if(theKroots.size!= theOtherKroots.size)
    return false;
  DynkinDiagramRootSubalgebra diagram1, diagram2;
  roots tempRoots; tempRoots.CopyFromBase(theState.PositiveKroots);
  diagram1.ComputeDiagramTypeModifyInput(tempRoots, theWeyl);
  tempRoots.CopyFromBase(theState.PositiveKroots);
  diagram2.ComputeDiagramTypeModifyInput(tempRoots, theWeyl);
  if (!(diagram1==diagram2))
    return false;
  List<int> tempList;
  permutation thePermAlphas, thePermBetas, thePermK, tempPermAlphas, tempPermBetas, tempPermK;
  this->GetIsoTypicComponents(theAlphas, theBetas, thePermAlphas, theState, theWeyl,  theGlobalVariables);
  this->GetIsoTypicComponents(theBetas, theAlphas, thePermBetas, theState, theWeyl, theGlobalVariables);
  this->GetIsoTypicComponents(theKroots, theAlphas, thePermK, theState, theWeyl, theGlobalVariables);
  this->GetIsoTypicComponents(theOtherAlphas, theOtherBetas, tempPermAlphas, theOtherState, theWeyl,  theGlobalVariables);
  this->GetIsoTypicComponents(theOtherBetas, theOtherAlphas, tempPermBetas, theOtherState, theWeyl, theGlobalVariables);
  this->GetIsoTypicComponents(theOtherKroots, theOtherAlphas, tempPermK, theOtherState, theWeyl, theGlobalVariables);
  if (!thePermAlphas.HasSameMaxMultiplicities(tempPermAlphas) || !thePermBetas.HasSameMaxMultiplicities(tempPermBetas) || !thePermK.HasSameMaxMultiplicities(tempPermK))
    return false;
  int NumCyclesAlphas = thePermAlphas.getTotalNumSubsets();
  int NumCyclesBetas  = thePermBetas.getTotalNumSubsets();
  int NumCyclesK= thePermK.getTotalNumSubsets();
  roots theDomain, thePermutedAlphas, thePermutedBetas, thePermutedKs, theRange;
  theRange.size=0;
  theRange.AddListOnTop(theOtherKroots);
  theRange.AddListOnTop(theOtherAlphas);
  theRange.AddListOnTop(theOtherBetas);
  MatrixLargeRational theOtherMatrix, thisMatrix;
  this->TheObjects[indexOther].ComputeScalarProductsMatrix(theGlobalVariables, theWeyl, theOtherAlphas, theOtherBetas, theOtherMatrix);
  this->TheObjects[indexOther].theScalarProducts.ComputeDebugString();
  bool DomainAndRangeGenerateNonIsoSAs;
  //theDomain.AddListOnTop(theState.ChosenPositiveKroots);
  for (int l=0; l<NumCyclesK; l++)
  { thePermutedKs.size=0;
    thePermK.GetPermutationLthElementIsTheImageofLthIndex(tempList);
    for (int k=0; k<tempList.size; k++)
    { root& tempRoot=theKroots.TheObjects[tempList.TheObjects[k]];
      thePermutedKs.AddObjectOnTop(tempRoot);
      theDomain.AddObjectOnTop(tempRoot);
    }
    for(int i=0; i<NumCyclesAlphas; i++)
    { theDomain.size=theKroots.size;
      thePermutedAlphas.size=0;
      thePermAlphas.GetPermutationLthElementIsTheImageofLthIndex(tempList);
      for (int k=0; k<tempList.size; k++)
      { root& tempRoot=theAlphas.TheObjects[tempList.TheObjects[k]];
        thePermutedAlphas.AddObjectOnTop(tempRoot);
        theDomain.AddObjectOnTop(tempRoot);
      }
      //theDomain.ComputeDebugString();
      for (int j=0; j<NumCyclesBetas; j++)
      { theDomain.size=theAlphas.size+theKroots.size;
        thePermutedBetas.size=0;
        thePermBetas.GetPermutationLthElementIsTheImageofLthIndex(tempList);
        for (int k=0; k<tempList.size; k++)
        { root& tempRoot=theBetas.TheObjects[tempList.TheObjects[k]];
          thePermutedBetas.AddObjectOnTop(tempRoot);
          theDomain.AddObjectOnTop(tempRoot);
        }
  //      theDomain.ComputeDebugString();
        this->MakeProgressReportIsos( indexOther, (l*NumCyclesAlphas+ i)*NumCyclesBetas+j, NumCyclesK*NumCyclesBetas*NumCyclesAlphas, theGlobalVariables, theWeyl);
        theState.ComputeScalarProductsMatrix(theGlobalVariables, theWeyl, thePermutedAlphas, thePermutedBetas, thisMatrix);
        if (thisMatrix.IsEqualTo(theOtherMatrix))
        { if (this->isomorphismComputer.attemptExtensionToIsomorphism(theDomain, theRange,  theGlobalVariables, 0, false, theWeyl, &DomainAndRangeGenerateNonIsoSAs))
            return true;
          else
            if (DomainAndRangeGenerateNonIsoSAs)
              return false;
        }
        thePermBetas.IncrementSubset();
      }
      thePermAlphas.IncrementSubset();
    }
    thePermK.IncrementSubset();
  }
  //theSA.attemptExtensionToIsomorphismNoCentralizer
  return false;
}

void minimalRelationsProverStates::GetIsoTypicComponents(roots& theRoots, roots& theOtherTypeRoots, permutation& outputComponents, minimalRelationsProverState& theState, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ List<int> tempList;
  if(theRoots.size==0)
  { tempList.size=0;
    outputComponents.initPermutation(tempList, 0);
    return;
  }
  tempList.MakeActualSizeAtLeastExpandOnTop(theRoots.size);
  rootsCollection& isotypicPieces=theGlobalVariables.rootsExtendToIsomorphismRootSystem1;
  isotypicPieces.MakeActualSizeAtLeastExpandOnTop(theRoots.size);
  isotypicPieces.SetSize(1);
  isotypicPieces.TheObjects[0].size=0;
  isotypicPieces.TheObjects[0].AddObjectOnTop(theRoots.TheObjects[0]);
  tempList.size=0;
  for (int i=1; i<theRoots.size; i++)
  { if (theState.Root1IsGreaterThanRoot2  (i-1, i, theRoots, theOtherTypeRoots, theGlobalVariables, theWeyl))
    { tempList.AddObjectOnTop(isotypicPieces.LastObject()->size);
      isotypicPieces.SetSize(isotypicPieces.size+1);
      isotypicPieces.LastObject()->size=0;
    }
    isotypicPieces.LastObject()->AddObjectOnTop(theRoots.TheObjects[i]);
  }
  tempList.AddObjectOnTop(isotypicPieces.LastObject()->size);
  outputComponents.initPermutation(tempList, theRoots.size);
}

void minimalRelationsProverStatesFixedK::GetIsoTypicComponents(roots& theRoots, roots& theOtherTypeRoots, permutation& outputComponents, minimalRelationsProverStateFixedK& theState, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ List<int> tempList;
  if(theRoots.size==0)
  { tempList.size=0;
    outputComponents.initPermutation(tempList, 0);
    return;
  }
  tempList.MakeActualSizeAtLeastExpandOnTop(theRoots.size);
  rootsCollection& isotypicPieces=theGlobalVariables.rootsExtendToIsomorphismRootSystem1;
  isotypicPieces.MakeActualSizeAtLeastExpandOnTop(theRoots.size);
  isotypicPieces.SetSize(1);
  isotypicPieces.TheObjects[0].size=0;
  isotypicPieces.TheObjects[0].AddObjectOnTop(theRoots.TheObjects[0]);
  tempList.size=0;
  for (int i=1; i<theRoots.size; i++)
  { if (::minimalRelationsProverState::Root1IsGreaterThanRoot2  (i-1, i, theRoots, theOtherTypeRoots, theGlobalVariables, theWeyl))
    { tempList.AddObjectOnTop(isotypicPieces.LastObject()->size);
      isotypicPieces.SetSize(isotypicPieces.size+1);
      isotypicPieces.LastObject()->size=0;
    }
    isotypicPieces.LastObject()->AddObjectOnTop(theRoots.TheObjects[i]);
  }
  tempList.AddObjectOnTop(isotypicPieces.LastObject()->size);
  outputComponents.initPermutation(tempList, theRoots.size);
}

bool rootSubalgebra::attemptExtensionToIsomorphism(roots& Domain, roots& Range, GlobalVariables& theGlobalVariables, ReflectionSubgroupWeylGroup* outputAutomorphisms, bool actOnCentralizerOnly, WeylGroup& theWeyl, bool* DomainAndRangeGenerateNonIsoSAs)
{ if (outputAutomorphisms!=0)
    outputAutomorphisms->ExternalAutomorphisms.size=0;
  if (DomainAndRangeGenerateNonIsoSAs!=0)
    *DomainAndRangeGenerateNonIsoSAs=false;
  //rootSubalgebra::ProblemCounter++;
  rootSubalgebra& theDomainRootSA = theGlobalVariables.rootSAAttemptExtensionToIso1;
  rootSubalgebra& theRangeRootSA  = theGlobalVariables.rootSAAttemptExtensionToIso2;
  theDomainRootSA.AmbientWeyl.Assign(theWeyl);
  theRangeRootSA.AmbientWeyl.Assign(theWeyl);
  theDomainRootSA.genK.CopyFromBase(Domain);
  theRangeRootSA.genK.CopyFromBase(Range);
  theDomainRootSA.ComputeAllButAmbientWeyl();
  theRangeRootSA.ComputeAllButAmbientWeyl();
  if (theDomainRootSA.theDynkinDiagram.DebugString!= theRangeRootSA.theDynkinDiagram.DebugString || theDomainRootSA.theCentralizerDiagram.DebugString!=theRangeRootSA.theCentralizerDiagram.DebugString)
  { if (DomainAndRangeGenerateNonIsoSAs!=0)
      *DomainAndRangeGenerateNonIsoSAs=true;
    return false;
  }
  roots isoDomain, isoRange;
  permutation permComponentsCentralizer;
  List<int> tempList, tempPermutation1, tempPermutation2;
  SelectionWithDifferentMaxMultiplicities tempAutosCentralizer;
  List<List<List<int> > > CentralizerDiagramAutomorphisms;
  theDomainRootSA.theCentralizerDiagram.GetAutomorphisms(CentralizerDiagramAutomorphisms);
  theDomainRootSA.theCentralizerDiagram.ComputeDebugString();
  tempAutosCentralizer.initIncomplete(CentralizerDiagramAutomorphisms.size);
  for (int i=0; i<CentralizerDiagramAutomorphisms.size; i++)
    tempAutosCentralizer.MaxMultiplicities.TheObjects[i] = CentralizerDiagramAutomorphisms.TheObjects[i].size-1;
  tempList.SetSize(theDomainRootSA.theCentralizerDiagram.sameTypeComponents.size);
  int tempSize=0;
  for (int i=0; i<theDomainRootSA.theCentralizerDiagram.sameTypeComponents.size; i++)
  { tempList.TheObjects[i]=theDomainRootSA.theCentralizerDiagram.sameTypeComponents.TheObjects[i].size;
    tempSize+=tempList.TheObjects[i];
  }
  permComponentsCentralizer.initPermutation(tempList, tempSize);
  int tempI2= permComponentsCentralizer.getTotalNumSubsets();
  int NumAutosCentralizer= tempAutosCentralizer.getTotalNumSubsets();
  permComponentsCentralizer.GetPermutationLthElementIsTheImageofLthIndex(tempPermutation2);
  for (int i=0; i<Domain.size; i++)
  { isoDomain.AddObjectOnTop(Domain.TheObjects[i]);
    if (isoDomain.GetRankOfSpanOfElements(theGlobalVariables)<isoDomain.size)
      isoDomain.PopLastObject();
    else
      isoRange.AddObjectOnTop(Range.TheObjects[i]);
  }
  if (isoRange.GetRankOfSpanOfElements(theGlobalVariables)<isoRange.size)
    return false;
  int givenSize=isoDomain.size;
  for(int j=0; j<tempI2; j++)
  { for(int l=0; l<NumAutosCentralizer; l++)
    { isoDomain.size=givenSize; isoRange.size=givenSize;
      theDomainRootSA.theCentralizerDiagram.GetMapFromPermutation(isoDomain, isoRange, tempPermutation2, CentralizerDiagramAutomorphisms, tempAutosCentralizer, theRangeRootSA.theCentralizerDiagram);
      if (theDomainRootSA.attemptExtensionToIsomorphismNoCentralizer(  isoDomain, isoRange, theGlobalVariables, 0, outputAutomorphisms, false, 0, &Domain, &Range))//GenerateAllAutos))
        if (outputAutomorphisms==0)
          return true;
      if (outputAutomorphisms!=0)
        theDomainRootSA.MakeProgressReportGenAutos( l+NumAutosCentralizer*j, tempI2*NumAutosCentralizer, outputAutomorphisms->ExternalAutomorphisms.size, theGlobalVariables);
      tempAutosCentralizer.IncrementSubset();
    }
    permComponentsCentralizer.incrementAndGetPermutation(tempPermutation2);
  }
  return false;
}

bool minimalRelationsProverState::ComputeCommonSenseImplicationsReturnFalseIfContradiction(WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ root tempRoot;
  this->flagNeedsAdditionOfPositiveKroots=false;
  for (int i=0; i<this->PositiveKroots.size; i++)
    this->nonPositiveKRoots.AddOnTopNoRepetition(-this->PositiveKroots.TheObjects[i]);
  for (int j=0; j<theWeyl.RootSystem.size; j++)
  { root& tested=theWeyl.RootSystem.TheObjects[j];
    for (int i=0; i<this->BKSingularGmodLRoots.size; i++)
    { tempRoot = this->BKSingularGmodLRoots.TheObjects[i]+tested;
      if (theWeyl.IsARoot(tempRoot))
      { this->nonPositiveKRoots.AddOnTopNoRepetition(tested);
        this->nonAlphas.AddOnTopNoRepetition(tested);
      }
    }
    for (int i=0; i<this->PartialRelation.Betas.size; i++)
      if (theWeyl.IsARoot(this->PartialRelation.Betas.TheObjects[i]+tested))
        this->nonBetas.AddOnTopNoRepetition(theWeyl.RootSystem.TheObjects[j]);
  }
  theWeyl.GenerateAdditivelyClosedSubset(this->PositiveKroots, this->PositiveKroots);
  roots& tempRoots=theGlobalVariables.rootsProverStateComputation2;
  tempRoots.CopyFromBase(this->PositiveKroots);
  theWeyl.GenerateRootSubsystem(tempRoots);
  tempRoots.AddListOnTop(this->NilradicalRoots);
  int oldsize= tempRoots.size;
  theWeyl.GenerateAdditivelyClosedSubset(tempRoots, tempRoots);
  for(int i=oldsize; i<tempRoots.size; i++)
    this->NilradicalRoots.AddObjectOnTop(tempRoots.TheObjects[i]);
  for (int i=0; i<theWeyl.RootSystem.size; i++)
  { root& theRoot=theWeyl.RootSystem.TheObjects[i];
    if (this->nonPositiveKRoots.ContainsObject(theRoot) && this->nonPositiveKRoots.ContainsObject(-theRoot))
    { this->nonKRoots.AddOnTopNoRepetition(theRoot);
      this->nonKRoots.AddOnTopNoRepetition(theRoot);
    }
  }
  this->nonKRoots.intersectWith(this->nonNilradicalRoots, this->nonLRoots);
  for (int i=0; i<this->nonLRoots.size; i++)
    if (this->IsBKSingularImplied(this->nonLRoots.TheObjects[i], theWeyl))
      this->BKSingularGmodLRoots.AddOnTopNoRepetition(this->nonLRoots.TheObjects[i]);
  this->nonLRoots.intersectWith(this->nonBKSingularGmodLRoots, this->nonLNonSingularRoots);
  for (int i=0; i<this->NilradicalRoots.size; i++)
  { this->nonNilradicalRoots.AddOnTopNoRepetition(-this->NilradicalRoots.TheObjects[i]);
    this->nonBKSingularGmodLRoots.AddOnTopNoRepetition(this->NilradicalRoots.TheObjects[i]);
    this->nonPositiveKRoots.AddOnTopNoRepetition(-this->NilradicalRoots.TheObjects[i]);
    this->nonPositiveKRoots.AddOnTopNoRepetition(this->NilradicalRoots.TheObjects[i]);
  }
  for (int i=0; i<this->BKSingularGmodLRoots.size; i++)
  { this->nonNilradicalRoots.AddOnTopNoRepetition(this->BKSingularGmodLRoots.TheObjects[i]);
    this->nonPositiveKRoots.AddOnTopNoRepetition(this->BKSingularGmodLRoots.TheObjects[i]);
    this->nonPositiveKRoots.AddOnTopNoRepetition(-this->BKSingularGmodLRoots.TheObjects[i]);
  }
  if (!this->SatisfyNonLnonBKSingularRoots(theWeyl, theGlobalVariables))
    return false;
  for (int i=0; i<this->PositiveKroots.size; i++)
  { this->nonNilradicalRoots.AddOnTopNoRepetition( this->PositiveKroots.TheObjects[i]);
    this->nonNilradicalRoots.AddOnTopNoRepetition(-this->PositiveKroots.TheObjects[i]);
    this->nonBKSingularGmodLRoots.AddOnTopNoRepetition( this->PositiveKroots.TheObjects[i]);
    this->nonBKSingularGmodLRoots.AddOnTopNoRepetition(-this->PositiveKroots.TheObjects[i]);
  }
  this->nonAlphas.AddRootSnoRepetition(this->nonBKSingularGmodLRoots);
  this->nonBetas.AddRootSnoRepetition(this->nonNilradicalRoots);
  if(this->nonLNonSingularRoots.HasACommonElementWith(this->BKSingularGmodLRoots))
    return false;
  if ( this->nonLRoots.HasACommonElementWith(this->NilradicalRoots) || this->nonLRoots.HasACommonElementWith(this->PositiveKroots))
    return false;
  if (this->nonNilradicalRoots.HasACommonElementWith(this->NilradicalRoots))
    return false;
  if (this->PositiveKroots.HasACommonElementWith(this->nonPositiveKRoots))
    return false;
  if (this->BKSingularGmodLRoots.HasACommonElementWith(this->nonBKSingularGmodLRoots))
    return false;
  return true;
}

bool minimalRelationsProverState::CanBeShortened(coneRelation& theRelation, SelectionWithMaxMultiplicity& selAlphas, SelectionWithMaxMultiplicity& selBetas, WeylGroup& theWeyl, bool AssumeGlobalMinimalityRHS)
{  //selAlphas.ComputeDebugString();
  //selBetas.ComputeDebugString();
  if (selBetas.CardinalitySelectionWithMultiplicities()==0 && selAlphas.CardinalitySelectionWithMultiplicities()==0)
    return false;
  root Candidate; Candidate.MakeZero(theWeyl.CartanSymmetric.NumRows);
  root tempRoot;
  for(int i=0; i<selBetas.elements.size; i++)
  { tempRoot.Assign(theRelation.Betas.TheObjects[selBetas.elements.TheObjects[i]]);
    tempRoot.MultiplyByInteger(selBetas.Multiplicities.TheObjects[selBetas.elements.TheObjects[i]]);
    Candidate.Subtract(tempRoot);
  }
  for(int i=0; i<selAlphas.elements.size; i++)
  { tempRoot.Assign(theRelation.Alphas.TheObjects[selAlphas.elements.TheObjects[i]]);
    tempRoot.MultiplyByInteger(selAlphas.Multiplicities.TheObjects[selAlphas.elements.TheObjects[i]]);
    Candidate.Add(tempRoot);
  }
  bool bothSelsAreMaximal =( selBetas.CardinalitySelectionWithoutMultiplicities() == theRelation.Betas.size ) && ( selAlphas.CardinalitySelectionWithoutMultiplicities()== theRelation.Alphas.size) ;
  bool bothSelsHaveZeroesAndOnes= selBetas.HasMultiplicitiesZeroAndOneOnly() && selAlphas.HasMultiplicitiesZeroAndOneOnly();
  if (Candidate.IsEqualToZero())
  { if (  bothSelsAreMaximal && selBetas.CardinalitySelectionWithMultiplicities()!=0)
      return false;
    return true;
  }
  root MinusCandidate = -Candidate;
  if (theWeyl.IsARoot(Candidate))
  {  this->nonPositiveKRoots.AddOnTopNoRepetition(Candidate);
    if( !bothSelsAreMaximal)
    { this->nonNilradicalRoots.AddOnTopNoRepetition(Candidate);
      if (this->NilradicalRoots.ContainsObject(Candidate))
        return true;
    }
    if(bothSelsHaveZeroesAndOnes && ( selAlphas.CardinalitySelectionWithMultiplicities()>0 || selBetas.CardinalitySelectionWithMultiplicities()>1))
    { this->nonNilradicalRoots.AddOnTopNoRepetition(MinusCandidate);
      if (this->NilradicalRoots.ContainsObject(MinusCandidate))
        return true;
    }
    if(bothSelsHaveZeroesAndOnes && (selAlphas.elements.size>1 || ( AssumeGlobalMinimalityRHS && selBetas.elements.size>0 && selAlphas.elements.size==1 )))
    { this->nonBKSingularGmodLRoots.AddOnTopNoRepetition(Candidate);
      if (this->BKSingularGmodLRoots.ContainsObject(Candidate))
        return true;
    }
    if (!bothSelsAreMaximal && selBetas.CardinalitySelectionWithMultiplicities()>0)
    { this->nonBKSingularGmodLRoots.AddOnTopNoRepetition(MinusCandidate);
      if (this->BKSingularGmodLRoots.ContainsObject(MinusCandidate))
        return true;
    }
    if (selAlphas.elements.size==1)
    { this->nonPositiveKRoots.AddOnTopNoRepetition(Candidate);
      this->nonPositiveKRoots.AddOnTopNoRepetition(MinusCandidate);
      this->nonKRoots.AddOnTopNoRepetition(Candidate);
      this->nonKRoots.AddOnTopNoRepetition(MinusCandidate);
    }
  }
  return false;
}

bool minimalRelationsProverStateFixedK::CanBeShortened( coneRelation& theRelation, SelectionWithMaxMultiplicity& selAlphas, SelectionWithMaxMultiplicity& selBetas, WeylGroup& theWeyl, bool AssumeGlobalMinimalityRHS)
{  //selAlphas.ComputeDebugString();
  //selBetas.ComputeDebugString();
  if (selBetas.CardinalitySelectionWithMultiplicities()==0 && selAlphas.CardinalitySelectionWithMultiplicities()==0)
    return false;
  root Candidate; Candidate.MakeZero(theWeyl.CartanSymmetric.NumRows);
  root tempRoot;
  for(int i=0; i<selBetas.elements.size; i++)
  { tempRoot.Assign(theRelation.Betas.TheObjects[selBetas.elements.TheObjects[i]]);
    tempRoot.MultiplyByInteger(selBetas.Multiplicities.TheObjects[selBetas.elements.TheObjects[i]]);
    Candidate.Subtract(tempRoot);
  }
  for(int i=0; i<selAlphas.elements.size; i++)
  { tempRoot.Assign(theRelation.Alphas.TheObjects[selAlphas.elements.TheObjects[i]]);
    tempRoot.MultiplyByInteger(selAlphas.Multiplicities.TheObjects[selAlphas.elements.TheObjects[i]]);
    Candidate.Add(tempRoot);
  }
  bool bothSelsAreMaximal = ( selBetas.CardinalitySelectionWithoutMultiplicities() == theRelation.Betas.size ) && ( selAlphas.CardinalitySelectionWithoutMultiplicities()== theRelation.Alphas.size) ;
  bool bothSelsHaveZeroesAndOnes= selBetas.HasMultiplicitiesZeroAndOneOnly() && selAlphas.HasMultiplicitiesZeroAndOneOnly();
  if (Candidate.IsEqualToZero())
  { if (  bothSelsAreMaximal && selBetas.CardinalitySelectionWithMultiplicities()!=0)
      return false;
    return true;
  }
  root MinusCandidate = -Candidate;
  if (theWeyl.IsARoot(Candidate))
  { int indexModuleCandidate= this->owner->GetModuleIndex(Candidate);
    int indexModuleMinusCandidate=this->owner->GetModuleIndex(MinusCandidate);
    if (indexModuleCandidate==-1)
    { assert(indexModuleMinusCandidate==-1);
      if (Candidate.IsNegativeOrZero())
        return false;
      if (selAlphas.CardinalitySelectionWithMultiplicities()==0&& selBetas.CardinalitySelectionWithMultiplicities()!=0)
        return false;
    }
    else
    {  assert(indexModuleMinusCandidate!=-1);
      if( !bothSelsAreMaximal)
      { this->theGmodLmodules.AddSelectionAppendNewIndex(indexModuleCandidate);
        if (this->theNilradicalModules.selected[indexModuleCandidate])
          return true;
      }
      if(bothSelsHaveZeroesAndOnes && ( selAlphas.CardinalitySelectionWithMultiplicities()>0 || selBetas.CardinalitySelectionWithMultiplicities()>1))
      { this->theGmodLmodules.AddSelectionAppendNewIndex(indexModuleMinusCandidate);
        if (this->theNilradicalModules.selected[indexModuleMinusCandidate])
          return true;
      }
      if(bothSelsHaveZeroesAndOnes && (selAlphas.elements.size>1 || ( AssumeGlobalMinimalityRHS && selBetas.elements.size>0 && selAlphas.elements.size==1 )))
        if (this->owner->theK.IsBKhighest(Candidate))
        {  this->theNilradicalModules.AddSelectionAppendNewIndex(indexModuleCandidate);
          this->theGmodLmodules.AddSelectionAppendNewIndex(indexModuleMinusCandidate);
          if (this->theGmodLmodules.selected[indexModuleCandidate] || this->theNilradicalModules.selected[indexModuleMinusCandidate])
            return true;
        }
      if (!bothSelsAreMaximal && selBetas.CardinalitySelectionWithMultiplicities()>0)
        if (this->owner->theK.IsBKhighest(MinusCandidate))
        { this->theNilradicalModules.AddSelectionAppendNewIndex(indexModuleMinusCandidate);
          this->theGmodLmodules.AddSelectionAppendNewIndex(indexModuleCandidate);
          if (this->theNilradicalModules.selected[indexModuleCandidate]|| this->theGmodLmodules.selected[indexModuleMinusCandidate])
            return true;
        }
    }
  }
  return false;
}

bool minimalRelationsProverStates::GetNormalSeparatingConesReturnTrueIfOneBetaIsPositive(int index, root& outputNormal, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ bool result;
  int theDimension= theWeyl.CartanSymmetric.NumRows;
  if (!this->GetNormalSeparatingConesFromPreferredBasis(index, this->PreferredDualBasis, outputNormal, theWeyl, theGlobalVariables, result))
    if(!this->GetNormalSeparatingConesFromPreferredBasis(index, this->TheObjects[index].theChoicesWeMake, outputNormal, theWeyl, theGlobalVariables, result))
      if(!this->GetNormalSeparatingConesFromPreferredBasis(index, this->TheObjects[index].BKSingularGmodLRoots, outputNormal, theWeyl, theGlobalVariables, result))
        if(!this->GetNormalSeparatingConesFromPreferredBasis(index, this->TheObjects[index].NilradicalRoots, outputNormal, theWeyl, theGlobalVariables, result))
          if(!this->GetNormalSeparatingConesFromPreferredBasis(index, this->TheObjects[index].nonLNonSingularRootsInNeedOfPosKroots, outputNormal, theWeyl, theGlobalVariables, result))
            if(!this->GetNormalSeparatingConesFromPreferredBasis(index, this->TheObjects[index].nonLNonSingularRoots, outputNormal, theWeyl, theGlobalVariables, result))
              if (!this->GetNormalSeparatingConesFromPreferredBasis(index, this->TheObjects[index].nonBKSingularGmodLRoots, outputNormal, theWeyl, theGlobalVariables, result))
                if (!this->GetNormalSeparatingConesFromPreferredBasis(index, this->TheObjects[index].nonNilradicalRoots, outputNormal, theWeyl, theGlobalVariables, result))
                  if(!this->GetNormalSeparatingConesFromPreferredBasis(index, this->TheObjects[index].ChosenPositiveKroots, outputNormal, theWeyl, theGlobalVariables, result))
                    if(!this->GetNormalSeparatingConesFromPreferredBasis(index, this->theWeylGroup.RootSystem, outputNormal, theWeyl, theGlobalVariables, result))
                    { root tempRoot;
                      bool tempBool= roots::GetNormalSeparatingCones( theGlobalVariables, theDimension, this->TheObjects[index].NilradicalRoots, this->TheObjects[index].PartialRelation.Alphas, tempRoot);
                      assert(tempBool);
                      this->invertedCartan.ActOnAroot(tempRoot, outputNormal);
                    }
  theWeyl.GetEpsilonCoords(outputNormal, this->TheObjects[index].currentSeparatingNormalEpsilonForm, theGlobalVariables);
  this->TheObjects[index].ComputeDebugString(theWeyl, theGlobalVariables);
  this->MakeProgressReportCurrentState(index, theGlobalVariables, theWeyl);
  return result;
}

bool minimalRelationsProverStatesFixedK::GetNormalSeparatingConesReturnTrueIfOneBetaIsPositive(int index, root& outputNormal, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ bool result;
  int theDimension= theWeyl.CartanSymmetric.NumRows;
  minimalRelationsProverStateFixedK& theState= this->TheObjects[index];
  roots posAlphas, posBetas, theCertainNilradicalRoots, theCertainGmodLhighestRoots;
  theState.GetPossibleAlphasAndBetas(posAlphas, posBetas, theWeyl);
  theState.GetCertainGmodLhighestAndNilradicalRoots(theCertainGmodLhighestRoots, theCertainNilradicalRoots, theWeyl);
  if(!this->GetNormalSeparatingConesFromPreferredBasis(index, theState.theChoicesWeMake, outputNormal, theWeyl, theGlobalVariables, result))
  //  if(!this->GetNormalSeparatingConesFromPreferredBasis
  //      (index, this->theK.SimpleBasisCentralizerRoots, outputNormal, theWeyl, theGlobalVariables, result))
//    if(!this->GetNormalSeparatingConesFromPreferredBasis
//        (index, this->theK.SimpleBasisK, outputNormal, theWeyl, theGlobalVariables, result))
    if(!this->GetNormalSeparatingConesFromPreferredBasis(index, theCertainGmodLhighestRoots, outputNormal, theWeyl, theGlobalVariables, result))
      if(!this->GetNormalSeparatingConesFromPreferredBasis(index, theCertainNilradicalRoots, outputNormal, theWeyl, theGlobalVariables, result))
        if(!this->GetNormalSeparatingConesFromPreferredBasis(index, posAlphas, outputNormal, theWeyl, theGlobalVariables, result))
          if(!this->GetNormalSeparatingConesFromPreferredBasis(index, posBetas, outputNormal, theWeyl, theGlobalVariables, result))
            if(!this->GetNormalSeparatingConesFromPreferredBasis(index, this->theWeylGroup.RootSystem, outputNormal, theWeyl, theGlobalVariables, result))
            { root tempRoot;
              bool tempBool= roots::GetNormalSeparatingCones( theGlobalVariables, theDimension, theCertainNilradicalRoots, this->TheObjects[index].PartialRelation.Alphas, tempRoot);
              assert(tempBool);
              this->invertedCartan.ActOnAroot(tempRoot, outputNormal);
            }
  this->TheObjects[index].ComputeDebugString(theWeyl, theGlobalVariables);
  this->MakeProgressReportCurrentState(index, theGlobalVariables, theWeyl);
  return result;
}

bool minimalRelationsProverState::StateAllowsPositiveKChoice  (root& theCandidate, root& theNonSingularRoot, GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{ if ( this->nonPositiveKRoots.ContainsObject(theCandidate) ||  !theWeyl.IsARoot(theCandidate+theNonSingularRoot))
    return  false;
  assert(! this->PositiveKroots.ContainsObject(theCandidate) );
  assert(this->ChosenPositiveKroots.size==this->nonLNonSingularsAleviatedByChosenPosKRoots.size);
  for(int i=0; i<this->nonLNonSingularsAleviatedByChosenPosKRoots.size; i++)
    if ( theWeyl.IsARoot(theCandidate+this->ChosenPositiveKroots.TheObjects[i]+this->nonLNonSingularsAleviatedByChosenPosKRoots.TheObjects[i]) && theWeyl.IsARoot(this->nonLNonSingularsAleviatedByChosenPosKRoots.TheObjects[i]+theCandidate))
      return false;
  return true;
}

void minimalRelationsProverStates::BranchByAddingKRoots(int index, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ if (this->TheObjects[index].flagNeedsAdditionOfPositiveKroots)
  { minimalRelationsProverState& theState=this->TheObjects[index];
    minimalRelationsProverState newState;
    assert(theState.nonLNonSingularRootsInNeedOfPosKroots.size>0);
    root& firstRoot=theState.nonLNonSingularRootsInNeedOfPosKroots.TheObjects[0];
    firstRoot.ComputeDebugString();
    theState.nonKRoots.ComputeDebugString();
    theState.ComputeDebugString(theWeyl, theGlobalVariables);
    int TotalCounter=0; int Counter2=0;
    for (int j=0; j<theWeyl.RootSystem.size; j++)
     if (theState.StateAllowsPositiveKChoice(theWeyl.RootSystem.TheObjects[j] , firstRoot, theGlobalVariables, theWeyl))
       TotalCounter++;
    for (int j=0; j<theWeyl.RootSystem.size; j++)
     if (theState.StateAllowsPositiveKChoice(theWeyl.RootSystem.TheObjects[j] , firstRoot, theGlobalVariables, theWeyl))
     { this->MakeProgressReportChildStates(Counter2, TotalCounter, this->TheObjects[index].PossibleChildStates.size, theGlobalVariables, theWeyl);
       Counter2++;
       newState.initFromParent(theState);
       newState.ChosenPositiveKroots.AddObjectOnTop(theWeyl.RootSystem.TheObjects[j]);
       newState.nonLNonSingularsAleviatedByChosenPosKRoots.AddObjectOnTop(theWeyl.RootSystem.TheObjects[j]);
       this->ExtensionStep(index, theWeyl, theGlobalVariables, newState);
     }
  }
}

void minimalRelationsProverStates::PurgeImpossibleStates()
{ List<int> newIndices;
  newIndices.SetSize(this->size);
  int counter=0;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].StateIsPossible|| this->theIndexStack.ContainsObject(i))
    { newIndices.TheObjects[i]=counter;
      if (counter!=i)
        this->TheObjects[counter].Assign(this->TheObjects[i]);
      counter++;
    }
    else
    { newIndices.TheObjects[i]=-1;
      if (this->theIndexStack.ContainsObject(i))
        assert(!this->theIndexStack.ContainsObject(i));
    }
  this->size=counter;
  for(int i=0; i<this->size; i++)
  { minimalRelationsProverState& theState=this->TheObjects[i];
    counter=0;
    for (int j=0; j<theState.PossibleChildStates.size; j++)
    { int tempI= newIndices.TheObjects[theState.PossibleChildStates.TheObjects[j]];
      if (tempI!=-1)
      { theState.PossibleChildStates.TheObjects[counter]=tempI;
        if (j==theState.activeChild)
          theState.activeChild=counter;
        counter++;
      }
    }
    theState.PossibleChildStates.size=counter;
    counter=0;
    for (int j=0; j<theState.CompleteChildStates.size; j++)
    { int tempI= newIndices.TheObjects[theState.CompleteChildStates.TheObjects[j]];
      if (tempI!=-1)
      { theState.CompleteChildStates.TheObjects[counter]=tempI;
        counter++;
      }
    }
//    theState.activeChild= newIndices.TheObjects[theState.activeChild];
    theState.CompleteChildStates.size=counter;
  }
  for (int i=0; i<this->theIndexStack.size; i++)
  { int tempI=newIndices.TheObjects[this->theIndexStack.TheObjects[i]];
    assert(tempI!=-1);
    this->theIndexStack.TheObjects[i]=tempI;
  }
  this->sizeByLastPurge=this->size;
}

void minimalRelationsProverStates::ReduceMemoryUse(GlobalVariables& theGlobalVariables)
{ if (false)
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ReduceMemoryUse();
    if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()!=0)
    { std::stringstream out;
      out << "Releasing memory " << i+1 << " out of " << this->size << " states";
      theGlobalVariables.theIndicatorVariables.ProgressReportString1=out.str();
      theGlobalVariables.theIndicatorVariables.String1NeedsRefresh=true;
      theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
    }
  }
  this->NumFullyComputed=0;
}

int minimalRelationsProverStates::CountNumSeparatingNormals(roots& theAlphas, roots& theBetas, WeylGroup& theWeyl)
{ int counter=0;
  bool tempBool;
  for (int i=0; i<theWeyl.RootsOfBorel.size; i++)
    if (minimalRelationsProverStateFixedK::IsSeparatingCones(theWeyl.RootsOfBorel.TheObjects[i], theAlphas, theBetas, tempBool, theWeyl))
      counter++;
  return counter;
}

void minimalRelationsProverStates::ComputeLastStackIndex(WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ int index= *this->theIndexStack.LastObject();
  this->MakeProgressReportCurrentState(index, theGlobalVariables, theWeyl);
  if (!this->TheObjects[index].StateIsInternallyPossible || this->TheObjects[index].StateIsComplete)
    return;
  if (!this->TheObjects[index].InternalStateIsComputed)
    this->TheObjects[index].ComputeStateReturnFalseIfDubious(*this, theGlobalVariables, theWeyl, this->flagAssumeGlobalMinimalityRHS);
  this->NumFullyComputed++;
  if (!this->TheObjects[index].StateIsInternallyPossible || this->TheObjects[index].StateIsComplete)
    return;
  if (this->NumFullyComputed>4000)
    this->ReduceMemoryUse(theGlobalVariables);
//  this->BranchByAddingKRoots(index, theWeyl, theGlobalVariables);
  root theBeta, theAlpha, theMinusAlpha, theMinusBeta;
  this->TheObjects[index].PossibleChildStates.size=0;
  minimalRelationsProverState newState;
  int theDimension=theWeyl.CartanSymmetric.NumRows;
  Rational tempRat;
   if (!roots::ConesIntersect(theGlobalVariables, this->TheObjects[index].PartialRelation.Alphas, this->TheObjects[index].NilradicalRoots, theDimension))
  { root NormalSeparatingCones;
    bool oneBetaIsPositive = this->GetNormalSeparatingConesReturnTrueIfOneBetaIsPositive(index, NormalSeparatingCones, theWeyl, theGlobalVariables);
    this->TheObjects[index].ComputeDebugString(theWeyl, theGlobalVariables);
    this->MakeProgressReportCurrentState(index, theGlobalVariables, theWeyl);
    bool addFirstAlpha=true;
    flagSearchForOptimalSeparatingRoot=false; //(this->TheObjects[index].PartialRelation.Alphas.size+this->TheObjects[index].PartialRelation.Betas.size<7);
    if (this->flagSearchForOptimalSeparatingRoot)
    { int minNumChildren=theWeyl.RootSystem.size;
      int oldSize=this->size;
      root tempNormal;
      bool tempBetaPos;
      int NumNormalsToCheck=1+this->CountNumSeparatingNormals(this->TheObjects[index].PartialRelation.Alphas, this->TheObjects[index].PartialRelation.Betas, theWeyl);
      int counter=-1;
      for (int i=-1;  i<theWeyl.RootsOfBorel.size; i++)
      { if (i!=-1)
          tempNormal= theWeyl.RootsOfBorel.TheObjects[i];
        else
          tempNormal= NormalSeparatingCones;
        if (this->TheObjects[index].IsSeparatingCones(tempNormal, tempBetaPos, theWeyl))
        { counter++;
          this->InvokeExtensionOfState(index, minNumChildren, tempBetaPos, tempNormal, true, theWeyl, theGlobalVariables);
          if (this->size-oldSize<minNumChildren)
          { NormalSeparatingCones.Assign(tempNormal);
            NormalSeparatingCones.ComputeDebugString();
            theWeyl.GetEpsilonCoords(NormalSeparatingCones, this->TheObjects[index].currentSeparatingNormalEpsilonForm, theGlobalVariables);
            oneBetaIsPositive=tempBetaPos;
            minNumChildren=this->size-oldSize;
          }
          this->size=oldSize;
          this->TheObjects[index].PossibleChildStates.size=0;
          if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()!=0)
          { theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=true;
            std::stringstream out3;
            out3 << counter+1 << " out of " << NumNormalsToCheck << " normals tested, best hit " << minNumChildren << " children";
            theGlobalVariables.theIndicatorVariables.ProgressReportString3= out3.str();
            theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
          }
        }
      }
    }
    this->InvokeExtensionOfState(index, -1, oneBetaIsPositive, NormalSeparatingCones, addFirstAlpha, theWeyl, theGlobalVariables);
  }
  else
  { this->MakeProgressReportCurrentState(index, theGlobalVariables, theWeyl);
    this->TheObjects[index].StateIsComplete=true;
  }
//  this->TheObjects[index].ComputeDebugString(theWeyl, theGlobalVariables);
}

void minimalRelationsProverStates::TheFullRecursion(WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ while (this->theIndexStack.size>0)
  { this->RecursionStep(theWeyl, theGlobalVariables);
    if (this->theIndexStack.size>0)
      this->MakeProgressReportCurrentState(*this->theIndexStack.LastObject(), theGlobalVariables, theWeyl);
    this->CheckConsistencyOfTree();
    this->WriteToFileAppend(theGlobalVariables);
    this->CheckConsistencyOfTree();
  }
}

void minimalRelationsProverStatesFixedK::TheFullRecursionFixedK(WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ while (this->theIndexStack.size>0)
  { this->RecursionStepFixedK(theWeyl, theGlobalVariables);
    if (this->theIndexStack.size>0)
      this->MakeProgressReportCurrentState(*this->theIndexStack.LastObject(), theGlobalVariables, theWeyl);
    this->WriteToFile(this->ProverFileName, theGlobalVariables);
  }
}

void minimalRelationsProverStates::RecursionStep(WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ if (this->theIndexStack.size<1)
    return;
  int currentIndex=*this->theIndexStack.LastObject();
  if(this->TheObjects[currentIndex].activeChild>=this->TheObjects[currentIndex].PossibleChildStates.size-1)
  {  this->theIndexStack.PopLastObject();
    minimalRelationsProverState& theState= this->TheObjects[currentIndex];
    theState.ComputeIsPossible(*this);
    if (!theState.StateIsPossible && this->theIndexStack.size>0)
      this->TheObjects[*this->theIndexStack.LastObject()].NumImpossibleChildren++;
    theState.activeChild=-2;
  }
  else
  { this->TheObjects[currentIndex].activeChild++;
    this->theIndexStack.AddObjectOnTop(this->TheObjects[currentIndex].PossibleChildStates.TheObjects[this->TheObjects[currentIndex].activeChild]);
    this->ComputeLastStackIndex(theWeyl, theGlobalVariables);
    this->MakeProgressReportStack(theGlobalVariables, theWeyl);
  }
}

void minimalRelationsProverStatesFixedK::RecursionStepFixedK (WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ if (this->theIndexStack.size<1)
    return;
  int currentIndex= *this->theIndexStack.LastObject();
  if(this->TheObjects[currentIndex].activeChild>=this->TheObjects[currentIndex].PossibleChildStates.size-1)
    this->theIndexStack.PopLastObject();
  else
  { this->TheObjects[currentIndex].activeChild++;
    this->theIndexStack.AddObjectOnTop(this->TheObjects[currentIndex].PossibleChildStates.TheObjects[this->TheObjects[currentIndex].activeChild]);
    this->ComputeLastStackIndexFixedK(theWeyl, theGlobalVariables);
    this->MakeProgressReportStack(theGlobalVariables, theWeyl);
  }
}

void minimalRelationsProverStates::TestAddingExtraRoot( int Index, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables, root& theRoot, bool AddAlpha, int indexAddedRoot, root& normalSeparatingCones, bool oneBetaIsPositive)
{ minimalRelationsProverState newState;
  bool tempBool;
  Rational tempRat=theWeyl.RootScalarCartanRoot(theRoot, normalSeparatingCones);
  if (tempRat.IsEqualToZero())
    return;
  if (AddAlpha)
  { if (oneBetaIsPositive==tempRat.IsNegative())
      return;
  } else
    if (oneBetaIsPositive==tempRat.IsPositive())
      return;
  if (AddAlpha)
    tempBool =
      !this->TheObjects[Index].PartialRelation.Alphas.ContainsObject(theRoot)&& !this->TheObjects[Index].nonAlphas.ContainsObject(theRoot) &&
      !this->TheObjects[Index].nonBKSingularGmodLRoots.ContainsObject(theRoot);
  else
    tempBool = !this->TheObjects[Index].PartialRelation.Betas.ContainsObject(theRoot) && !this->TheObjects[Index].nonBetas.ContainsObject(theRoot);
  if (tempBool)
  { newState.initFromParent(this->TheObjects[Index]);
    if (AddAlpha)
      newState.PartialRelation.Alphas.AddObjectOnTop(theRoot);
    else
      newState.PartialRelation.Betas.AddObjectOnTop(theRoot);
    newState.theChoicesWeMake.AddObjectOnTop(theRoot);
    this->ExtensionStep(Index, theWeyl, theGlobalVariables, newState);
  }
}

void minimalRelationsProverStatesFixedK::TestAddingExtraRootFixedK( int Index, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables, root& theRoot, bool AddAlpha, int indexAddedRoot, root& normalSeparatingCones, bool oneBetaIsPositive)
{ minimalRelationsProverStateFixedK newState;
  bool tempBool;
  int indexModule= this->theK.GetIndexKmoduleContainingRoot(theRoot);
  if (indexModule==-1)
    return;
  Rational tempRat=theWeyl.RootScalarCartanRoot(theRoot, normalSeparatingCones);
  if (tempRat.IsEqualToZero())
    return;
  if (AddAlpha)
  { if (oneBetaIsPositive==tempRat.IsNegative())
      return;
  } else
    if (oneBetaIsPositive==tempRat.IsPositive())
      return;
  if (AddAlpha)
    tempBool =
      this->theK.HighestWeightsGmodK.ContainsObject(theRoot) && !this->TheObjects[Index].theNilradicalModules.selected[indexModule] &&
      !this->TheObjects[Index].nonAlphas.ContainsObject(theRoot);
  else
    tempBool = !this->TheObjects[Index].theGmodLmodules.selected[indexModule]&& !this->TheObjects[Index].nonAlphas.ContainsObject(theRoot);
  if (tempBool)
  { newState.initFromParentState(this->TheObjects[Index]);
    if (AddAlpha)
      newState.PartialRelation.Alphas.AddObjectOnTop(theRoot);
    else
      newState.PartialRelation.Betas.AddObjectOnTop(theRoot);
    newState.theChoicesWeMake.AddObjectOnTop(theRoot);
    this->ExtensionStepFixedK(Index, theWeyl, theGlobalVariables, newState);
  }
}

void minimalRelationsProverStates::ExtensionStep( int index, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables, minimalRelationsProverState& newState)
{ newState.ComputeStateReturnFalseIfDubious(*this, theGlobalVariables, theWeyl, this->flagAssumeGlobalMinimalityRHS);
  if (newState.StateIsInternallyPossible)
  { int currentNewIndex=this->size;
    if (this->AddOnTopNoRepetition(index, newState, theWeyl, theGlobalVariables))
    { //this->TheObjects[currentNewIndex].ComputeStateReturnFalseIfDubious
      //  (theGlobalVariables, theWeyl,  this->flagAssumeGlobalMinimalityRHS);
  //    this->ComputeDebugString(theWeyl, theGlobalVariables);
      this->TheObjects[currentNewIndex].ComputeDebugString(theWeyl, theGlobalVariables);
      if (this->TheObjects[currentNewIndex].StateIsInternallyPossible && !this->TheObjects[currentNewIndex].StateIsComplete)
      { //if (this->TheObjects[currentNewIndex].StateIsDubious)
        //  this->RemoveDoubt(currentNewIndex, theWeyl, theGlobalVariables);
        //else
        this->TheObjects[index].PossibleChildStates.AddObjectOnTop(currentNewIndex);
        this->TheObjects[index].activeChild=-1;
      } else
        if(this->TheObjects[currentNewIndex].StateIsInternallyPossible)
          this->TheObjects[index].CompleteChildStates.AddObjectOnTop(currentNewIndex);
    }
  } else
    this->TheObjects[index].NumImpossibleChildren++;
}

bool minimalRelationsProverStates::GetSeparatingRootIfExistsFromSet(roots* choicePreferrence, int* choiceIndex, roots& ConeOneStrictlyPositive, roots& ConeNonPositive, root& output, WeylGroup& TheWeyl, GlobalVariables& theGlobalVariables, List<root>& theNormalCandidates)
{ Rational tempRat;
  bool foundSeparatingRoot=false;
  if (choicePreferrence!=0)
    *choiceIndex= choicePreferrence->size;
  for (int i=0; i<theNormalCandidates.size; i++)
  { bool isGood=true;
    bool oneFound=false;
    root& Candidate=theNormalCandidates.TheObjects[i];
    for (int j=0; j<ConeOneStrictlyPositive.size; j++)
    { tempRat=TheWeyl.RootScalarCartanRoot(ConeOneStrictlyPositive.TheObjects[j], Candidate);
      if ( tempRat.IsNegative())
      { isGood=false;
        break;
      } else
        if (tempRat.IsPositive())
          oneFound=true;
    }
    if (!oneFound)
      isGood=false;
    if (isGood)
      for (int j=0; j<ConeNonPositive.size; j++)
        if ( TheWeyl.RootScalarCartanRoot(ConeNonPositive.TheObjects[j], Candidate).IsPositive())
        { isGood=false;
          break;
        }
    if (isGood)
    { foundSeparatingRoot=true;
//      output.ComputeDebugString();
      if (choicePreferrence==0)
      { output.Assign(Candidate);
        return true;
      } else
      { for (int i=0; i<choicePreferrence->size; i++)
          if (TheWeyl.RootScalarCartanRoot(Candidate, choicePreferrence->TheObjects[i]).IsPositive())
            if (i<*choiceIndex)
            { *choiceIndex=i;
              output.Assign(Candidate);
              break;
            }
      }
    }
  }
  if (foundSeparatingRoot)
    return true;
  return false;
}

bool minimalRelationsProverStates::GetNormalSeparatingConesFromPreferredBasis( int theIndex, List<root>&inputPreferredBasis, root& output, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables, bool& oneBetaIsPositive )
{ minimalRelationsProverState& theRel=this->TheObjects[theIndex];
  roots& theAlphas = theRel.PartialRelation.Alphas;
  roots& theBetas = theRel.PartialRelation.Betas;
  int firstChoiceSeparated1, firstChoiceSeparated2;
  root rootCandidate;
  bool result=false;
  if( this->GetSeparatingRootIfExistsFromSet( &theRel.theChoicesWeMake, &firstChoiceSeparated1, theAlphas, theBetas, rootCandidate, theWeyl, theGlobalVariables, inputPreferredBasis))
  { oneBetaIsPositive=false;
    output.Assign(rootCandidate);
    result=true;
  }
  if( this->GetSeparatingRootIfExistsFromSet( &theRel.theChoicesWeMake, &firstChoiceSeparated2, theBetas, theAlphas, rootCandidate, theWeyl, theGlobalVariables, inputPreferredBasis))
    if (!(result && firstChoiceSeparated1<firstChoiceSeparated2))
    { result=true;
      oneBetaIsPositive=true;
      output.Assign(rootCandidate);
    }
  return result;
}

bool minimalRelationsProverStatesFixedK::GetNormalSeparatingConesFromPreferredBasis( int theIndex, List<root>&inputPreferredBasis, root& output, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables, bool& oneBetaIsPositive )
{ minimalRelationsProverStateFixedK& theRel=this->TheObjects[theIndex];
  roots& theAlphas = theRel.PartialRelation.Alphas;
  roots& theBetas = theRel.PartialRelation.Betas;
  int firstChoiceSeparated1, firstChoiceSeparated2;
  root rootCandidate;
  bool result=false;
  if( minimalRelationsProverStates::GetSeparatingRootIfExistsFromSet( &theRel.theChoicesWeMake, &firstChoiceSeparated1, theAlphas, theBetas, rootCandidate, theWeyl, theGlobalVariables, inputPreferredBasis))
  { oneBetaIsPositive=false;
    output.Assign(rootCandidate);
    result=true;
  }
  if(  minimalRelationsProverStates::GetSeparatingRootIfExistsFromSet( &theRel.theChoicesWeMake, &firstChoiceSeparated2, theBetas, theAlphas, rootCandidate, theWeyl, theGlobalVariables, inputPreferredBasis))
    if (!(result && firstChoiceSeparated1<firstChoiceSeparated2))
    { result=true;
      oneBetaIsPositive=true;
      output.Assign(rootCandidate);
    }
  return result;
}

int rootSubalgebra::ProblemCounter=0;
bool rootSubalgebra::GenerateIsomorphismsPreservingBorel(rootSubalgebra& right, GlobalVariables& theGlobalVariables, ReflectionSubgroupWeylGroup* outputAutomorphisms, bool actOnCentralizerOnly)
{ if (this->theDynkinDiagram.DebugString!= right.theDynkinDiagram.DebugString)
    return false;
  if (this->theCentralizerDiagram.DebugString!= right.theCentralizerDiagram.DebugString)
    return false;
  if (outputAutomorphisms!=0)
  { outputAutomorphisms->ExternalAutomorphisms.size=0;
    outputAutomorphisms->simpleGenerators.size=0;
    outputAutomorphisms->simpleGenerators.CopyFromBase(this->SimpleBasisCentralizerRoots);
  }
  roots isoDomain, isoRange;
  permutation permComponents, permComponentsCentralizer;
  List<int> tempList, tempPermutation1, tempPermutation2;
  SelectionWithDifferentMaxMultiplicities tempAutos, tempAutosCentralizer;
  List<List<List<int> > > DiagramAutomorphisms, CentralizerDiagramAutomorphisms;
  this->theDynkinDiagram.GetAutomorphisms(DiagramAutomorphisms);
  this->theCentralizerDiagram.GetAutomorphisms(CentralizerDiagramAutomorphisms);
  tempAutos.initIncomplete(DiagramAutomorphisms.size);
  tempAutosCentralizer.initIncomplete(CentralizerDiagramAutomorphisms.size);
  for (int i=0; i<DiagramAutomorphisms.size; i++)
    tempAutos.MaxMultiplicities.TheObjects[i]= DiagramAutomorphisms.TheObjects[i].size-1;
  for (int i=0; i<CentralizerDiagramAutomorphisms.size; i++)
    tempAutosCentralizer.MaxMultiplicities.TheObjects[i]= CentralizerDiagramAutomorphisms.TheObjects[i].size-1;
  tempList.SetSize(this->theDynkinDiagram.sameTypeComponents.size);
  int tempSize=0;
  for (int i=0; i<this->theDynkinDiagram.sameTypeComponents.size; i++)
  { tempList.TheObjects[i]= this->theDynkinDiagram.sameTypeComponents.TheObjects[i].size;
    tempSize+=tempList.TheObjects[i];
  }
  permComponents.initPermutation(tempList, tempSize);
  tempList.SetSize(this->theCentralizerDiagram.sameTypeComponents.size);
  tempSize=0;
  for (int i=0; i<this->theCentralizerDiagram.sameTypeComponents.size; i++)
  { tempList.TheObjects[i]= this->theCentralizerDiagram.sameTypeComponents.TheObjects[i].size;
    tempSize+=tempList.TheObjects[i];
  }
  permComponentsCentralizer.initPermutation(tempList, tempSize);
  int tempI1;
  int NumAutos;
  tempI1= permComponents.getTotalNumSubsets();
  NumAutos=tempAutos.getTotalNumSubsets();
  int tempI2= permComponentsCentralizer.getTotalNumSubsets();
  int NumAutosCentralizer= tempAutosCentralizer.getTotalNumSubsets();
  permComponents.GetPermutationLthElementIsTheImageofLthIndex(tempPermutation1);
  permComponentsCentralizer.GetPermutationLthElementIsTheImageofLthIndex(tempPermutation2);
  for (int i=0; i<tempI1; i++)
  { for(int j=0; j<tempI2; j++)
    { for (int k=0; k<NumAutos; k++)
      { for(int l=0; l<NumAutosCentralizer; l++)
        { isoDomain.size=0; isoRange.size=0;
          this->theDynkinDiagram.GetMapFromPermutation(isoDomain, isoRange, tempPermutation1, DiagramAutomorphisms, tempAutos, right.theDynkinDiagram);
          this->theCentralizerDiagram.GetMapFromPermutation(isoDomain, isoRange, tempPermutation2, CentralizerDiagramAutomorphisms, tempAutosCentralizer, right.theCentralizerDiagram);
          if (this->attemptExtensionToIsomorphismNoCentralizer(isoDomain, isoRange, theGlobalVariables, 0, outputAutomorphisms, false, 0, 0, 0))//GenerateAllAutos))
            if (outputAutomorphisms==0)
              return true;
          if (outputAutomorphisms!=0)
            this->MakeProgressReportGenAutos( l+NumAutosCentralizer*(k+NumAutos*(j+i*tempI2)), tempI1*tempI2*NumAutos*NumAutosCentralizer, outputAutomorphisms->ExternalAutomorphisms.size, theGlobalVariables);
          tempAutosCentralizer.IncrementSubset();
        }
        tempAutos.IncrementSubset();
      }
      permComponentsCentralizer.incrementAndGetPermutation(tempPermutation2);
    }
    permComponents.incrementAndGetPermutation(tempPermutation1);
  }
  return false;
}

int minimalRelationsProverStatesFixedK::GetModuleIndex(root& input)
{ int tempI= this->theWeylGroup.RootSystem.IndexOfObjectHash(input);
  if (tempI==-1)
    return -1;
  return this->IndexKmoduleByRoots.TheObjects[tempI];
}

void minimalRelationsProverStatesFixedK::initShared(WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ this->theK.AmbientWeyl.Assign(this->theWeylGroup);
  this->theK.ComputeAll();
  this->IndexKmoduleByRoots.SetSize(this->theWeylGroup.RootSystem.size);
  for (int i=0; i<this->theWeylGroup.RootSystem.size; i++)
    this->IndexKmoduleByRoots.TheObjects[i]=this->theK.GetIndexKmoduleContainingRoot(this->theWeylGroup.RootSystem.TheObjects[i]);
  this->theIsos.AmbientWeyl.Assign(this->theWeylGroup);

}

void minimalRelationsProverStatesFixedK::GenerateStartingStatesFixedK(ComputationSetup& theSetup, GlobalVariables& theGlobalVariables, char WeylLetter, int theDimension)
{ if (this->flagComputationIsInitialized)
    return;
  minimalRelationsProverStateFixedK tempState; tempState.owner=this;
  this->theWeylGroup.MakeArbitrary(WeylLetter, theDimension);
  this->theWeylGroup.ComputeRho(false);
  this->isomorphismComputer.AmbientWeyl.Assign(this->theWeylGroup);
  this->isomorphismComputer.ComputeAll();
  this->PreferredDualBasis.size=0;
  this->flagAssumeGlobalMinimalityRHS=false;
  this->invertedCartan.Assign(this->theWeylGroup.CartanSymmetric);
  this->invertedCartan.Invert(theGlobalVariables);
  //this->ComputePreferredDualBasis(WeylLetter, theDimension, theGlobalVariables);
  this->size=0;
  this->theK.genK.SetSize(4);
  this->theK.genK.TheObjects[0].InitFromIntegers(8, 1, 0, 0, 0, 0, 0, 0, 0);
  this->theK.genK.TheObjects[1].InitFromIntegers(8, 0, 1, 0, 0, 0, 0, 0, 0);
  this->theK.genK.TheObjects[2].InitFromIntegers(8, 0, 0, 0, 0, 1, 0, 0, 0);
  this->theK.genK.TheObjects[3].InitFromIntegers(8, 0, 0, 0, 0, 0, 0, 1, 0);
  this->initShared(this->theWeylGroup, theGlobalVariables);
  this->theK.GenerateIsomorphismsPreservingBorel(this->theK, theGlobalVariables, &this->theIsos, true);
  this->theK.GenerateKmodMultTable(this->theK.theMultTable, this->theK.theOppositeKmods, theGlobalVariables);
  this->theIsos.simpleGenerators.size=0;
  this->theIsos.ComputeSubGroupFromGeneratingReflections(this->theK.SimpleBasisCentralizerRoots, this->theIsos.ExternalAutomorphisms, theGlobalVariables, 20000, true);
  tempState.theNilradicalModules.init(this->theK.kModules.size);
  tempState.theGmodLmodules.init(this->theK.kModules.size);
  this->AddObjectOnTop(tempState);
  int numParabolics=MathRoutines::TwoToTheNth(this->theK.SimpleBasisCentralizerRoots.size);
  //this->theIsos.simpleGenerators.ComputeDebugString();
  //this->theK.SimpleBasisCentralizerRoots.ComputeDebugString();
  Selection selCentralizerNilradical;
  selCentralizerNilradical.init(this->theK.SimpleBasisCentralizerRoots.size);
  roots InitialCentralizerNilradicalChoicePositiveSimpleRoots, tempRoots, tempRoots2;
  for (int i=0; i<numParabolics; i++)
  { tempState.initFromParentState(this->TheObjects[0]);
    for (int j=0; j<this->theWeylGroup.RootSystem.size; j++)
    { root& tempRoot=this->theWeylGroup.RootSystem.TheObjects[j];
      if (this->theK.rootIsInCentralizer(tempRoot))
      { if (this->theK.rootIsInNilradicalParabolicCentralizer(selCentralizerNilradical, tempRoot))
          tempState.theNilradicalModules.AddSelectionAppendNewIndex(this->theK.GetIndexKmoduleContainingRoot(tempRoot));
        else
          tempState.theGmodLmodules.AddSelectionAppendNewIndex(this->theK.GetIndexKmoduleContainingRoot(tempRoot));
      }
    }
    InitialCentralizerNilradicalChoicePositiveSimpleRoots.size=0;
    tempState.indicesIsosRespectingInitialNilradicalChoice.size=0;
    for (int i=0; i<selCentralizerNilradical.CardinalitySelection; i++)
      InitialCentralizerNilradicalChoicePositiveSimpleRoots.AddObjectOnTop(this->theK.SimpleBasisCentralizerRoots.TheObjects[selCentralizerNilradical.elements[i]]);
    for (int i=0; i<this->theIsos.size; i++)
    { this->theIsos.ActByElement(i, InitialCentralizerNilradicalChoicePositiveSimpleRoots, tempRoots);
      tempRoots.intersectWith(InitialCentralizerNilradicalChoicePositiveSimpleRoots, tempRoots2);
      assert(tempRoots.size==InitialCentralizerNilradicalChoicePositiveSimpleRoots.size);
      if (tempRoots2.size==tempRoots.size)
        tempState.indicesIsosRespectingInitialNilradicalChoice.AddObjectOnTop(i);
    }
    this->ExtensionStepFixedK(0, theWeylGroup, theGlobalVariables, tempState);
    selCentralizerNilradical.incrementSelection();
  }
  this->theIndexStack.AddObjectOnTop(0);
  this->TheObjects[0].activeChild=-1;
  this->MakeProgressReportCurrentState(0, theGlobalVariables, this->theWeylGroup);
  //this->WriteToFile(theGlobalVariables);
  this->theFile.flush();
  this->flagComputationIsInitialized=true;
}

void ReflectionSubgroupWeylGroup::WriteToFile(std::fstream& output, GlobalVariables& theGlobalVariables)
{  output << "generator_reflections: ";
  this->simpleGenerators.WriteToFile(output, theGlobalVariables);
  output <<"\nouter_generators: ";
  this->ExternalAutomorphisms.WriteToFile(output, theGlobalVariables);
}

void ReflectionSubgroupWeylGroup::ReadFromFile(std::fstream& input, GlobalVariables& theGlobalVariables)
{ std::string tempS;
  input>> tempS;
  this->simpleGenerators.ReadFromFile(input, theGlobalVariables);
  input>> tempS;
  this->ExternalAutomorphisms.ReadFromFile(input, theGlobalVariables);
}

void ReflectionSubgroupWeylGroup::ComputeSubGroupFromGeneratingReflections(roots& generators, rootsCollection& ExternalAutos, GlobalVariables& theGlobalVariables, int UpperLimitNumElements,  bool recomputeAmbientRho)
{ hashedRoots& orbitRho = theGlobalVariables.hashedRootsComputeSubGroupFromGeneratingReflections;
  this->truncated=false;
  this->ClearTheObjects();
  orbitRho.ClearTheObjects();
  if (this->AmbientWeyl.CartanSymmetric.NumRows<1)
    return;
  if (recomputeAmbientRho)
    this->AmbientWeyl.ComputeRho(false);
  this->simpleGenerators.CopyFromBase(generators);
  this->AmbientWeyl.TransformToSimpleBasisGenerators(this->simpleGenerators);
  this->ComputeRootSubsystem();
  ElementWeylGroup tempEW;
  tempEW.size=0;
  root tempRoot;
  tempRoot.Assign(this->AmbientWeyl.rho);
  // rho is invariant under external graph automorphisms (!)
  //Hence the below lines. Needs to be fixed (mathematically).
  //for the time being the below lines remain, until I think of how to do it properly.
  tempRoot.MultiplyByInteger(50);
  tempRoot.TheObjects[0].AddInteger(1);
  orbitRho.AddObjectOnTopHash(tempRoot);
  this->AddObjectOnTopHash(tempEW);
  root currentRoot;
  for (int i=0; i<this->size; i++)
  { tempEW=this->TheObjects[i];
    for (int j=0; j<this->simpleGenerators.size; j++)
    { this->AmbientWeyl.ReflectBetaWRTAlpha(this->simpleGenerators.TheObjects[j], orbitRho.TheObjects[i], false, currentRoot);
      if (!orbitRho.ContainsObjectHash(currentRoot))
      { orbitRho.AddObjectOnTopHash(currentRoot);
        tempEW.AddObjectOnTop(j);
        this->AddObjectOnTopHash(tempEW);
        tempEW.PopLastObject();
      }
    }
    for (int j=1; j<ExternalAutos.size; j++)
    { ExternalAutos.TheObjects[j].MakeBasisChange(orbitRho.TheObjects[i], currentRoot);
      if (!orbitRho.ContainsObjectHash(currentRoot))
      { orbitRho.AddObjectOnTopHash(currentRoot);
        tempEW.AddObjectOnTop(j+this->simpleGenerators.size);
        this->AddObjectOnTopHash(tempEW);
        tempEW.PopLastObject();
      }
    }
    if (UpperLimitNumElements>0)
      if (this->size>=UpperLimitNumElements)
      { this->truncated=true;
        return;
      }
/*    if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()!=0)
    { std::stringstream out;
      out << "Generated: " << i+1<<" elements";
      theGlobalVariables.theIndicatorVariables.StatusString1=out.str();
      theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
      theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
    }*/
  }
}

bool ReflectionSubgroupWeylGroup::GenerateOrbitReturnFalseIfTruncated(root& input, roots& outputOrbit, int UpperLimitNumElements)
{ hashedRoots theOrbit;
  bool result = true;
  theOrbit.ClearTheObjects();
  root tempRoot=input;
  theOrbit.AddObjectOnTopHash(tempRoot);
  for (int i=0; i<theOrbit.size; i++)
  { for (int j=0; j<this->simpleGenerators.size; j++)
    { this->AmbientWeyl.ReflectBetaWRTAlpha(this->simpleGenerators.TheObjects[j], theOrbit.TheObjects[i], false, tempRoot);
      theOrbit.AddObjectOnTopNoRepetitionOfObjectHash(tempRoot);
    }
    for (int j=1; j<this->ExternalAutomorphisms.size; j++)
    { this->ExternalAutomorphisms.TheObjects[j].MakeBasisChange(theOrbit.TheObjects[i], tempRoot);
      theOrbit.AddObjectOnTopNoRepetitionOfObjectHash(tempRoot);
    }
    if (UpperLimitNumElements>0)
      if (theOrbit.size>=UpperLimitNumElements)
      { result=false;
        break;
      }
  }
  outputOrbit.CopyFromBase(theOrbit);
  return result;
}

void minimalRelationsProverStatesFixedK::ExtensionStepFixedK(int index, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables, minimalRelationsProverStateFixedK& newState)
{ newState.ComputeStateReturnFalseIfDubious(theGlobalVariables, theWeyl, this->flagAssumeGlobalMinimalityRHS);
  if (newState.StateIsPossible)
  { int currentNewIndex=this->size;
    if (this->AddObjectOnTopNoRepetitionOfObjectFixedK(index, newState, theWeyl, theGlobalVariables))
    { this->TheObjects[currentNewIndex].ComputeDebugString(theWeyl, theGlobalVariables);
      if (this->TheObjects[currentNewIndex].StateIsPossible && !this->TheObjects[currentNewIndex].StateIsComplete)
      { this->TheObjects[index].PossibleChildStates.AddObjectOnTop(currentNewIndex);
        this->TheObjects[index].activeChild=-1;
      } else
        if(!this->TheObjects[currentNewIndex].StateIsPossible)
          this->TheObjects[index].ImpossibleChildStates.AddObjectOnTop(currentNewIndex);
        else
          this->TheObjects[index].CompleteChildStates.AddObjectOnTop(currentNewIndex);
    }
  }
}

bool minimalRelationsProverStatesFixedK::AddObjectOnTopNoRepetitionOfObjectFixedK( int ParentIndex, minimalRelationsProverStateFixedK& theState, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ for (int i=0; i<this->size; i++)
    if (this->ExtendToIsomorphismRootSystemFixedK(theState, i, theGlobalVariables, theWeyl))
      return false;
  this->AddObjectOnTop(theState);
  return true;
}

bool minimalRelationsProverStatesFixedK::ExtendToIsomorphismRootSystemFixedK(minimalRelationsProverStateFixedK& theState, int indexOther, GlobalVariables& theGlobalVariables, WeylGroup& theWeyl)
{ theState.SortAlphasAndBetas(theGlobalVariables, theWeyl);
  minimalRelationsProverStateFixedK& theOtherState=this->TheObjects[indexOther];
  roots& theAlphas = theState.PartialRelation.Alphas;
  roots& theBetas  = theState.PartialRelation.Betas;
  roots& theOtherAlphas = theOtherState.PartialRelation.Alphas;
  roots& theOtherBetas  = theOtherState.PartialRelation.Betas;
  if (theAlphas.size!=theOtherAlphas.size)
    return false;
  if (theBetas.size!=theOtherBetas.size)
    return false;
  if (theOtherState.indicesIsosRespectingInitialNilradicalChoice!= theState.indicesIsosRespectingInitialNilradicalChoice)
    return false;
  DynkinDiagramRootSubalgebra diagram1, diagram2;
  roots tempRoots1, tempRoots2;
  tempRoots1.CopyFromBase(this->theK.SimpleBasisK);  tempRoots1.AddListOnTop(theAlphas);
  diagram1.ComputeDiagramTypeModifyInput(tempRoots1, this->theWeylGroup);
  tempRoots2.CopyFromBase(this->theK.SimpleBasisK); tempRoots2.AddListOnTop(theOtherAlphas);
  diagram2.ComputeDiagramTypeModifyInput(tempRoots2, this->theWeylGroup);
  if (!(diagram1==diagram2))
    return false;
  tempRoots1.AddListOnTop(theBetas);
  diagram1.ComputeDiagramTypeModifyInput(tempRoots1, this->theWeylGroup);
  tempRoots2.AddListOnTop(theOtherBetas);
  diagram2.ComputeDiagramTypeModifyInput(tempRoots2, this->theWeylGroup);
  if (!(diagram1==diagram2))
    return false;
  tempRoots1.CopyFromBase(this->theK.SimpleBasisK);  tempRoots1.AddListOnTop(theBetas);
  diagram1.ComputeDiagramTypeModifyInput(tempRoots1, this->theWeylGroup);
  tempRoots2.CopyFromBase(this->theK.SimpleBasisK); tempRoots2.AddListOnTop(theOtherBetas);
  diagram2.ComputeDiagramTypeModifyInput(tempRoots2, this->theWeylGroup);
  if (!(diagram1==diagram2))
    return false;
  List<int> tempList;
  permutation thePermAlphas, thePermBetas, tempPermAlphas, tempPermBetas;
  this->GetIsoTypicComponents(theAlphas, theBetas, thePermAlphas, theState, theWeyl,  theGlobalVariables);
  this->GetIsoTypicComponents(theBetas, theAlphas, thePermBetas, theState, theWeyl, theGlobalVariables);
  this->GetIsoTypicComponents(theOtherAlphas, theOtherBetas, tempPermAlphas, theOtherState, theWeyl,  theGlobalVariables);
  this->GetIsoTypicComponents(theOtherBetas, theOtherAlphas, tempPermBetas, theOtherState, theWeyl, theGlobalVariables);
  if (!thePermAlphas.HasSameMaxMultiplicities(tempPermAlphas) || !thePermBetas.HasSameMaxMultiplicities(tempPermBetas))
    return false;
  roots tempRoots3, tempRoots4;
  for(int i=0; i<theState.indicesIsosRespectingInitialNilradicalChoice.size; i++)
  { this->theIsos.ActByElement(theState.indicesIsosRespectingInitialNilradicalChoice.TheObjects[i], theAlphas, tempRoots1);
    this->theIsos.ActByElement(theState.indicesIsosRespectingInitialNilradicalChoice.TheObjects[i], theBetas, tempRoots2);
    theOtherAlphas.intersectWith(tempRoots1, tempRoots3);
    theOtherBetas.intersectWith(tempRoots2, tempRoots4);
    if (tempRoots1.size==tempRoots3.size&& tempRoots2.size==tempRoots4.size)
      return true;
  }
  return false;
}

void ReflectionSubgroupWeylGroup::ActByElement(int index, root& theRoot)
{ root tempRoot;
  this->ActByElement(index, theRoot, tempRoot);
  theRoot.Assign(tempRoot);
}

void ReflectionSubgroupWeylGroup::ActByElement(int index, root& input, root& output)
{ assert(&input!=&output);
  ElementWeylGroup& tempEW= this->TheObjects[index];
  int NumElts=tempEW.size;
  root tempRoot;
  output.Assign(input);
  for (int i=0; i<NumElts; i++)
  { int tempI=tempEW.TheObjects[i];
    if(tempI<this->simpleGenerators.size)
      this->AmbientWeyl.ReflectBetaWRTAlpha(this->simpleGenerators.TheObjects[tempI], output, false, output);
    else
    { tempI-=this->simpleGenerators.size;
      this->ExternalAutomorphisms.TheObjects[tempI].MakeBasisChange(output, tempRoot);
      output.Assign(tempRoot);
    }
  }
}

void ReflectionSubgroupWeylGroup::ActByElement(int index, roots& input, roots& output)
{ assert(&input!=&output);
  output.SetSize(input.size);
  for (int i=0; i<input.size; i++)
    this->ActByElement(index, input.TheObjects[i], output.TheObjects[i]);
}

void minimalRelationsProverStatesFixedK::ComputeLastStackIndexFixedK(WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ int index= *this->theIndexStack.LastObject();
  this->MakeProgressReportCurrentState(index, theGlobalVariables, theWeyl);
  if (this->TheObjects[index].PartialRelation.Alphas.size==0 && this->TheObjects[index].PartialRelation.Betas.size==0)
  { minimalRelationsProverStateFixedK theNewState;
    for (int i=0; i<this->theK.HighestWeightsGmodK.size; i++)
    { theNewState.initFromParentState(this->TheObjects[index]);
      theNewState.PartialRelation.Alphas.AddObjectOnTop(this->theK.HighestWeightsGmodK.TheObjects[i]);
      theNewState.theChoicesWeMake.AddObjectOnTop(this->theK.HighestWeightsGmodK.TheObjects[i]);
      this->ExtensionStepFixedK(index, theWeyl, theGlobalVariables, theNewState);
      this->MakeProgressReportChildStates( i, this->theK.HighestWeightsGmodK.size, this->TheObjects[index].PossibleChildStates.size, theGlobalVariables, theWeyl);
    }
    return;
  }
  if (!this->TheObjects[index].StateIsPossible || this->TheObjects[index].StateIsComplete)
    return;
  root theBeta, theAlpha, theMinusAlpha, theMinusBeta;
  this->TheObjects[index].PossibleChildStates.size=0;
  minimalRelationsProverState newState;
  int theDimension=theWeyl.CartanSymmetric.NumRows;
  Rational tempRat;
  roots theNilradicalRoots, tempRoots;
  this->TheObjects[index].GetCertainGmodLhighestAndNilradicalRoots(tempRoots, theNilradicalRoots, theWeyl);
  if (!roots::ConesIntersect( theGlobalVariables, theNilradicalRoots, this->TheObjects[index].PartialRelation.Alphas, theDimension))
  { root NormalSeparatingCones;
    bool oneBetaIsPositive = this->GetNormalSeparatingConesReturnTrueIfOneBetaIsPositive(index, NormalSeparatingCones, theWeyl, theGlobalVariables);
    this->TheObjects[index].ComputeDebugString(theWeyl, theGlobalVariables);
    this->MakeProgressReportCurrentState(index, theGlobalVariables, theWeyl);
    bool addFirstAlpha=true;
    if (this->flagSearchForOptimalSeparatingRoot)
    { int minNumChildren=theWeyl.RootSystem.size;
      int oldSize=this->size;
      root tempNormal;
      bool tempBetaPos;
      for (int i=-1;  i<theWeyl.RootsOfBorel.size; i++)
      { if (i!=-1)
          tempNormal= theWeyl.RootsOfBorel.TheObjects[i];
        else
          tempNormal= NormalSeparatingCones;
        if (this->TheObjects[index].IsSeparatingCones(tempNormal, tempBetaPos, theWeyl))
        { this->InvokeExtensionOfState(index, minNumChildren, tempBetaPos, tempNormal, true, theWeyl, theGlobalVariables);
          if (this->size-oldSize<minNumChildren)
          { NormalSeparatingCones.Assign(tempNormal);
            NormalSeparatingCones.ComputeDebugString();
            theWeyl.GetEpsilonCoords(NormalSeparatingCones, this->TheObjects[index].currentSeparatingNormalEpsilonForm, theGlobalVariables);
            oneBetaIsPositive=tempBetaPos;
            minNumChildren=this->size-oldSize;
          }
          this->size=oldSize;
          this->TheObjects[index].PossibleChildStates.size=0;
          if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()!=0)
          { theGlobalVariables.theIndicatorVariables.String3NeedsRefresh=true;
            std::stringstream out3;
            out3<< i+1 <<" out of  "<< theWeyl.RootsOfBorel.size<<" normals tested, best hit "<<minNumChildren<<" children";
            theGlobalVariables.theIndicatorVariables.ProgressReportString3= out3.str();
            theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
          }
        }
      }
    }
    this->TheObjects[index].SeparatingNormalUsed.Assign(NormalSeparatingCones);
    this->InvokeExtensionOfState(index, -1, oneBetaIsPositive, NormalSeparatingCones, addFirstAlpha, theWeyl, theGlobalVariables);
  }
  else
  { this->MakeProgressReportCurrentState(index, theGlobalVariables, theWeyl);
    this->TheObjects[index].StateIsComplete=true;
  }
//  this->TheObjects[index].ComputeDebugString(theWeyl, theGlobalVariables); */
}

void ::minimalRelationsProverStatesFixedK::InvokeExtensionOfState(int index, int UpperLimitChildren, bool oneBetaIsPositive, root& NormalSeparatingCones, bool addFirstAlpha, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ for (int i=0; i<theWeyl.RootSystem.size; i++)
  { if (UpperLimitChildren>=0)
      if (this->TheObjects[index].PossibleChildStates.size>=UpperLimitChildren)
        return;
    this->TestAddingExtraRootFixedK( index, theWeyl, theGlobalVariables, theWeyl.RootSystem.TheObjects[i], addFirstAlpha, i, NormalSeparatingCones, oneBetaIsPositive);
    this->MakeProgressReportChildStates( i, theWeyl.RootSystem.size*2, this->TheObjects[index].PossibleChildStates.size, theGlobalVariables, theWeyl);
  }
  for (int i=0; i<theWeyl.RootSystem.size; i++)
  { if (UpperLimitChildren>=0)
      if (this->TheObjects[index].PossibleChildStates.size>=UpperLimitChildren)
        return;
    this->TestAddingExtraRootFixedK( index, theWeyl, theGlobalVariables, theWeyl.RootSystem.TheObjects[i], !addFirstAlpha, i, NormalSeparatingCones, oneBetaIsPositive);
    this->MakeProgressReportChildStates( i+theWeyl.RootSystem.size, theWeyl.RootSystem.size*2, this->TheObjects[index].PossibleChildStates.size, theGlobalVariables, theWeyl);
  }
}

void minimalRelationsProverStates::InvokeExtensionOfState(int index, int UpperLimitChildren, bool oneBetaIsPositive, root& NormalSeparatingCones, bool addFirstAlpha, WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ for (int i=0; i<theWeyl.RootSystem.size; i++)
  { if (UpperLimitChildren>=0)
      if (this->TheObjects[index].PossibleChildStates.size>=UpperLimitChildren)
        return;
    this->TestAddingExtraRoot( index, theWeyl, theGlobalVariables, theWeyl.RootSystem.TheObjects[i], addFirstAlpha, i, NormalSeparatingCones, oneBetaIsPositive);
    this->MakeProgressReportChildStates( i, theWeyl.RootSystem.size*2, this->TheObjects[index].PossibleChildStates.size, theGlobalVariables, theWeyl);
  }
  for (int i=0; i<theWeyl.RootSystem.size; i++)
  { if (UpperLimitChildren>=0)
      if (this->TheObjects[index].PossibleChildStates.size>=UpperLimitChildren)
        return;
    this->TestAddingExtraRoot( index, theWeyl, theGlobalVariables, theWeyl.RootSystem.TheObjects[i], !addFirstAlpha, i, NormalSeparatingCones, oneBetaIsPositive);
    this->MakeProgressReportChildStates( i+theWeyl.RootSystem.size, theWeyl.RootSystem.size*2, this->TheObjects[index].PossibleChildStates.size, theGlobalVariables, theWeyl);
  }
}

bool minimalRelationsProverStateFixedK::ComputeCommonSenseImplicationsReturnFalseIfContradictionFixedK(WeylGroup& theWeyl, GlobalVariables& theGlobalVariables)
{ root tempRoot;
  rootSubalgebra& kAlg= this->owner->theK;
  for (int i=0; i<this->theNilradicalModules.CardinalitySelection; i++)
    for(int j=0; j<this->theNilradicalModules.CardinalitySelection; j++)
    { int i1= this->theNilradicalModules.elements[i];
      int i2= this->theNilradicalModules.elements[j];
      for (int k=0; k<kAlg.theMultTable.TheObjects[i1].TheObjects[i2].size; k++)
        this->theNilradicalModules.AddSelectionAppendNewIndex(kAlg.theMultTable.TheObjects[i1].TheObjects[i2].TheObjects[k]);
    }
  for (int i=0; i<this->theNilradicalModules.CardinalitySelection; i++)
  { int theIndex = this->theNilradicalModules.elements[i];
    if (this->theGmodLmodules.selected[theIndex])
      return false;
    if (this->theNilradicalModules.selected[this->owner->theK.theOppositeKmods.TheObjects[theIndex]])
      return false;
  }
  for (int i=0; i<this->theGmodLmodules.CardinalitySelection; i++)
  { int theIndex = this->theGmodLmodules.elements[i];
    if (this->theNilradicalModules.selected[theIndex])
      return false;
  }
  for(int i=0; i<this->owner->theK.kModules.size; i++)
    if (!this->theNilradicalModules.selected[i]&& !this->theGmodLmodules.selected[i])
    { for (int k=0; k<this->PartialRelation.Alphas.size; k++)
        if (theWeyl.IsARoot(this->PartialRelation.Alphas.TheObjects[k]+this->owner->theK.HighestWeightsGmodK.TheObjects[i]))
        { this->nonAlphas.AddOnTopNoRepetition(this->owner->theK.HighestWeightsGmodK.TheObjects[i]);
          break;
        }
      for (int j=0; j<this->owner->theK.kModules.TheObjects[i].size; j++)
      { root& theRoot= this->owner->theK.kModules.TheObjects[i].TheObjects[j];
        for (int k=0; k<this->PartialRelation.Betas.size; k++)
        { theRoot.ComputeDebugString();  this->PartialRelation.Betas.TheObjects[k].ComputeDebugString();
          if (theWeyl.IsARoot(this->PartialRelation.Betas.TheObjects[k]+theRoot))
          { this->nonBetas.AddOnTopNoRepetition(theRoot);
            break;
          }
         }
      }
    }
  return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Code for generation of Dyck paths
//motivational article:  E. Feigin, G. Fourier, P. Littelmann, "PBW filtration and bases for irreducible modules in type A_n", preprint 2009
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <> int List<DyckPath>::ListActualSizeIncrement=2000;

bool DyckPath::IamComplete(DyckPaths& owner)
{ if (this->thePathNodes.size<=0)
    return false;
  if (owner.AllowedEndNodes.selected[*this->thePathNodes.LastObject()])
    return true;
  return false;
}

void DyckPath::Assign(const DyckPath& other)
{ this->thePathNodes.CopyFromLight(other.thePathNodes);
  this->thePathEdgesTaken.CopyFromLight(other.thePathEdgesTaken);
}

void DyckPaths::initPathGraphTypesABC()
{ root tempRoot, tempRoot2;
  int theDimension= this->AmbientWeyl.CartanSymmetric.NumRows;
  this->NumCompletePaths=theDimension;
  this->AmbientWeyl.ComputeRho(true);
  this->PositiveRoots.AddRootsOnTopHash(this->AmbientWeyl.RootsOfBorel);
  this->pathGraphPairsOfNodes.SetSize(this->PositiveRoots.size);
  this->pathGraphEdgeLabels.SetSize(this->PositiveRoots.size);
  List<int> tempList;
  this->AllowedEndNodes.init(this->PositiveRoots.size);
  for (int i=0; i<this->pathGraphPairsOfNodes.size; i++)
  { this->pathGraphPairsOfNodes.TheObjects[i].size=0;
    this->pathGraphEdgeLabels.TheObjects[i].size=0;
    root& theRoot= this->PositiveRoots.TheObjects[i];
    for (int j=0; j<theDimension; j++)
    { tempRoot.MakeEi(theDimension, j);
      //tempRoot.ComputeDebugString();
      tempRoot2=theRoot-tempRoot;
      //tempRoot2.ComputeDebugString();
      if (this->PositiveRoots.ContainsObjectHash(tempRoot2))
        if (this->SimpleRootAllowedToBeSubtractedTypesABC(j, theRoot))
        { this->pathGraphPairsOfNodes.TheObjects[i].AddObjectOnTop(this->PositiveRoots.IndexOfObjectHash(tempRoot2));
          this->pathGraphEdgeLabels.TheObjects[i].AddObjectOnTop(-j-1);
        }
      tempRoot2=theRoot+tempRoot;
      //tempRoot2.ComputeDebugString();
      if (this->PositiveRoots.ContainsObjectHash(tempRoot2))
        if (this->SimpleRootAllowedToBeAddedTypesABC(j, theRoot))
        { this->pathGraphPairsOfNodes.TheObjects[i].AddObjectOnTop(this->PositiveRoots.IndexOfObjectHash(tempRoot2));
          this->pathGraphEdgeLabels.TheObjects[i].AddObjectOnTop(j+1);
        }
    }
    if (this->pathGraphPairsOfNodes.TheObjects[i].size==0)
      this->AllowedEndNodes.AddSelectionAppendNewIndex(i);
  }
}

void DyckPaths::GenerateAllDyckPathsTypesABC()
{ int theDimension= this->AmbientWeyl.CartanSymmetric.NumRows;
  this->SetSize(1+theDimension);
  this->TheObjects[0].thePathNodes.size=0;
  this->TheObjects[0].thePathEdgesTaken.size=0;
  this->initPathGraphTypesABC();
  root tempRoot;
  this->LastNonExploredIndex=1;
  for (int i=0; i<theDimension; i++)
  { tempRoot.MakeEi(theDimension, i);
    this->TheObjects[i+1].thePathNodes.SetSize(1);
    this->TheObjects[i+1].thePathEdgesTaken.SetSize(1);
    int tempI=this->PositiveRoots.IndexOfObjectHash(tempRoot);
    this->TheObjects[i+1].thePathNodes.TheObjects[0]=tempI;
    this->AllowedEndNodes.AddSelectionAppendNewIndex(tempI);
    this->TheObjects[i+1].thePathEdgesTaken.TheObjects[0]=i+1;
  }
  this->GenerateAllDyckPathsTypesABCRecursive();
}

bool DyckPaths::SimpleRootAllowedToBeAddedTypesABC(int simpleRootIndex, root& output)
{ int lastNonZeroCoord=output.getIndexLastNonZeroCoordinate();
  if (simpleRootIndex>=lastNonZeroCoord+1)
    return true;
  if (output.TheObjects[simpleRootIndex]>0)
    return true;
  return false;
}

bool DyckPaths::SimpleRootAllowedToBeSubtractedTypesABC(int simpleRootIndex, root& output)
{ int firstNonZeroCoord=output.getIndexFirstNonZeroCoordinate();
  if (simpleRootIndex==firstNonZeroCoord)
    if (output.TheObjects[simpleRootIndex]==1)
      return true;
  return false;
}

void DyckPaths::GenerateAllDyckPathsTypesABCRecursive()
{ List<int> pathEdgesTaken;
  List<int> pathNodes;
  while (this->LastNonExploredIndex<this->size)
  { //this->ComputeDebugString();
    pathEdgesTaken.AssignLight(this->TheObjects[this->LastNonExploredIndex].thePathEdgesTaken);
    pathNodes.AssignLight(this->TheObjects[this->LastNonExploredIndex].thePathNodes);
    int NewNodeNumber=pathEdgesTaken.size+1;
    pathEdgesTaken.SetSize(NewNodeNumber);
    pathNodes.SetSize(NewNodeNumber);
    int currentRootIndex=*this->TheObjects[this->LastNonExploredIndex].thePathNodes.LastObject();
    for (int i=0; i<this->pathGraphPairsOfNodes.TheObjects[currentRootIndex].size; i++)
    { *pathEdgesTaken.LastObject()=this->pathGraphEdgeLabels.TheObjects[currentRootIndex].TheObjects[i];
      *pathNodes.LastObject()=this->pathGraphPairsOfNodes.TheObjects[currentRootIndex].TheObjects[i];
      this->SetSize(this->size+1);
      this->LastObject()->thePathEdgesTaken.CopyFromHeavy(pathEdgesTaken);
      this->LastObject()->thePathNodes.CopyFromHeavy(pathNodes);
      if (this->AllowedEndNodes.selected[*pathNodes.LastObject()])
        this->NumCompletePaths++;
    }
    this->LastNonExploredIndex++;
  }
}

void DyckPaths::ElementToString(std::string& output,  bool useHtml)
{ std::stringstream out; std::string tempS;
  this->PositiveRoots.ElementToString(tempS, useHtml);
  out <<"Positive roots:\n ";
  if (useHtml)
    out << "<br>\n";
  out << tempS;
  if (useHtml)
    out << "\n<br>\n";
  out <<"\nHalf sum of positive roots: " << this->AmbientWeyl.rho.ElementToString()<<"\n";
  if (useHtml)
    out << "\n<br><br><br>\n";
  out <<"\n\n\n*********************************************************************";
  if (useHtml)
    out << "\n<br>\n ";
  out << "The allowed starting roots are the simple ones";
  if (useHtml)
    out << "\n<br>\n ";
  out << "The allowed ending roots are: ";
  for (int i=0; i<this->AllowedEndNodes.CardinalitySelection; i++)
    out <<this->PositiveRoots.TheObjects[this->AllowedEndNodes.elements[i]].ElementToString()<<", ";
  if (useHtml)
    out << "\n<br><br><br>\n";
  out <<"\n\n\n*********************************************************************";
  if (useHtml)
    out << "\n<br>\n";
  out<<"\nNumber complete paths (not including the zero path): "<< this->NumCompletePaths;
  if (useHtml)
    out << "\n<br>\n";
  out << "List of complete paths: ";
  if (useHtml)
    out << "\n<br>\n";
  int counter=0;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].IamComplete(*this))
    { counter++;
      this->TheObjects[i].ElementToString(tempS, *this, useHtml, false);
      if (useHtml)
        out << "\n<br>\n";
      out << "\nPath counter " << counter <<": "<< tempS<<"\n";
    }
  if (useHtml)
    out << "\n<br><br><br>\n";
  out <<"\n\n\n*********************************************************************";
  if (useHtml)
    out << "\n<br>\n";
  out<<"\nFull number of paths (including the zero path): "<< this->size;
  if (useHtml)
    out << "\n<br>\n";
  out << "Full list of paths: ";
  if (useHtml)
    out << "\n<br>\n";
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS, *this, useHtml, false);
    if (useHtml)
      out << "\n<br>\n";
    out << "\nPath index " << i <<": "<< tempS<<"\n";
  }
  if (useHtml)
    out << "\n<br>\n<br>\n<br>\n*********************************************************************<br>\n";
  out << "Path list with internal node/edge information: ";
  if (useHtml)
    out << "\n<br>\n";
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS, *this, useHtml, true);
    if (useHtml)
      out << "\n<br>\n";
    out << "\nPath index " << i <<": "<< tempS<<"\n";
  }
  if (useHtml)
    out << "\n<br><br><br>\n";
  out <<"\n\n\n*********************************************************************";
  if (useHtml)
    out << "\n<br>\n";
  if (useHtml)
    out << "\n<br>\n";
  for (int i=0; i<this->pathGraphPairsOfNodes.size; i++)
  { if (useHtml)
      out << "\n<br>\n";
    out << "\nNode " << i<< " linked to: ";
    for (int j=0; j<this->pathGraphPairsOfNodes.TheObjects[i].size; j++)
      out << this->pathGraphPairsOfNodes.TheObjects[i].TheObjects[j]<< ", ";
    if (useHtml)
      out << "\n<br>\n";
    out <<"\nCoordiante form: ";
    for (int j=0; j<this->pathGraphPairsOfNodes.TheObjects[i].size; j++)
      out << this->PositiveRoots.TheObjects[i].ElementToString()<<"->"<< this->PositiveRoots.TheObjects[this->pathGraphPairsOfNodes.TheObjects[i].TheObjects[j]].ElementToString()<<"; ";
    if (useHtml)
      out << "\n<br>\n";
    out << "\nCorresponding edges: ";
    for (int j=0; j<this->pathGraphEdgeLabels.TheObjects[i].size; j++)
      out << this->pathGraphEdgeLabels.TheObjects[i].TheObjects[j]<< ", ";
  }
  output=out.str();
}

void DyckPath::ElementToString(std::string& output, DyckPaths& owner,  bool useHtml, bool WithDetail)
{ std::stringstream out; std::string tempS;
  if (WithDetail)
  { if (useHtml)
    out << "\n<br>\n";
    out <<"\nNodes: ";
    for (int i=0; i<this->thePathNodes.size; i++)
      out << this->thePathNodes.TheObjects[i]<<", ";
    if (useHtml)
      out << "\n<br>\n";
    out <<"\nPaths: ";
    for (int i=0; i<this->thePathEdgesTaken.size; i++)
      out << this->thePathEdgesTaken.TheObjects[i]<<", ";
    if (useHtml)
      out << "\n<br>\n";
    out << "\nCoordinate form: ";
  }
  for (int i=0; i<this->thePathNodes.size; i++)
  { out << owner.PositiveRoots.TheObjects[this->thePathNodes.TheObjects[i]].ElementToString();
    if (i!=this->thePathNodes.size-1)
      out <<"->";
  }
  output=out.str();
}

bool ElementWeylAlgebra::IsLetter(char theLetter)
{
  return false;
}

void ElementWeylAlgebra::operator=(const std::string& input)
{ /*for (int i=0; i<input.size(); i++)
  { std::ostream formatter;
    if (input.at(i)=='x')

  }*/
}

void ElementWeylAlgebra::MultiplyTwoMonomials(Monomial<Rational>& left, Monomial<Rational>& right, PolynomialRationalCoeff& OrderedOutput)
{ Monomial<Rational> buffer;
  SelectionWithDifferentMaxMultiplicities tempSel;
  assert(left.NumVariables%2==0);
  int theDimension=left.NumVariables/2;
  tempSel.Multiplicities.initFillInObject(theDimension, 0);
  tempSel.MaxMultiplicities.SetSize(theDimension);
  for (int i=0; i<theDimension; i++)
    tempSel.MaxMultiplicities.TheObjects[i]=left.degrees[theDimension+i];
  tempSel.elements.initFillInObject(theDimension, 0);
  buffer.init(left.NumVariables);
  assert(left.NumVariables==right.NumVariables);
  OrderedOutput.Nullify(left.NumVariables);
  int numCycles= tempSel.getTotalNumSubsets();
  Rational coeffProd;
  coeffProd.Assign(left.Coefficient);
  coeffProd.MultiplyBy(right.Coefficient);
  for (int i=0; i<numCycles; i++)
  { buffer.Coefficient.Assign(coeffProd);
    for (int k=0; k< theDimension; k++)
    { int multDrop=(int)tempSel.Multiplicities.TheObjects[k];
      buffer.Coefficient.MultiplyBy(Rational::NChooseK(left.degrees[theDimension+k], multDrop)*Rational::NChooseK(right.degrees[k], multDrop)* Rational::Factorial(multDrop));
      buffer.degrees[k]=left.degrees[k]+right.degrees[k]-multDrop;
      buffer.degrees[k+theDimension]= left.degrees[k+theDimension]+right.degrees[k+theDimension]-multDrop;
    }
    OrderedOutput.AddMonomial(buffer);
    tempSel.IncrementSubset();
  }
}

void ElementWeylAlgebra::LieBracketOnTheLeftMakeReport(ElementWeylAlgebra& standsOnTheLeft, GlobalVariables& theGlobalVariables, std::string& report)
{ std::stringstream out;
  this->ComputeDebugString(false, false);
  standsOnTheLeft.ComputeDebugString(false, false);
  out << "\\begin{eqnarray*}&&["<< standsOnTheLeft.DebugString<<" , "<< this->DebugString<< " ]= ";
  this->LieBracketOnTheLeft(standsOnTheLeft, theGlobalVariables);
  this->ComputeDebugString(false, false);
  out << this->DebugString<<"\\end{eqnarray*}\n";
  report=out.str();
}

void ElementWeylAlgebra::LieBracketOnTheRightMakeReport(ElementWeylAlgebra& standsOnTheRight, GlobalVariables& theGlobalVariables, std::string& report)
{ std::stringstream out;
  this->ComputeDebugString(false, false);
  standsOnTheRight.ComputeDebugString(false, false);
  out << "\\begin{eqnarray*}&&["<< this->DebugString<< " , "<<standsOnTheRight.DebugString<<" ]= ";
  this->LieBracketOnTheRight(standsOnTheRight, theGlobalVariables);
  this->ComputeDebugString(false, false);
  out << this->DebugString<<"\\end{eqnarray*}\n";
  report=out.str();
}

void ElementWeylAlgebra::LieBracketOnTheLeft(ElementWeylAlgebra& standsOnTheLeft, GlobalVariables& theGlobalVariables)
{ ElementWeylAlgebra tempEl1, tempEl2;
  tempEl1.Assign(*this);
  tempEl1.MultiplyOnTheLeft(standsOnTheLeft, theGlobalVariables);
  //tempEl1.ComputeDebugString(false);
  tempEl2.Assign(standsOnTheLeft);
  tempEl2.MultiplyOnTheLeft(*this, theGlobalVariables);
  //tempEl2.ComputeDebugString(false);
  this->Assign(tempEl1);
  this->Subtract(tempEl2);
  //this->ComputeDebugString(false);
}

void ElementWeylAlgebra::MakeConst(int NumVars, const Rational& theConst)
{ this->Nullify(NumVars);
  Monomial<Rational> tempM;
  tempM.init((int)this->NumVariables*2);
  tempM.Coefficient.Assign(theConst);
  this->StandardOrder.AddMonomial(tempM);
}

void ElementWeylAlgebra::LieBracketOnTheRight(ElementWeylAlgebra& standsOnTheRight, GlobalVariables& theGlobalVariables)
{ ElementWeylAlgebra tempEl1, tempEl2;
  tempEl1.Assign(standsOnTheRight);
  tempEl1.MultiplyOnTheLeft(*this, theGlobalVariables);
  //tempEl1.ComputeDebugString(false);
  tempEl2.Assign(*this);
  tempEl2.MultiplyOnTheLeft(standsOnTheRight, theGlobalVariables);
  //tempEl2.ComputeDebugString(false);
  this->Assign(tempEl1);
  this->Subtract(tempEl2);
  //this->ComputeDebugString(false);
}

void ElementWeylAlgebra::MultiplyOnTheLeft(ElementWeylAlgebra& standsOnTheLeft, GlobalVariables& theGlobalVariables)
{ PolynomialRationalCoeff buffer;
  PolynomialRationalCoeff Accum;
  Accum.Nullify((int) this->NumVariables*2);
  for (int j=0; j<standsOnTheLeft.StandardOrder.size; j++)
    for (int i=0; i<this->StandardOrder.size; i++)
    { this->MultiplyTwoMonomials(standsOnTheLeft.StandardOrder.TheObjects[j], this->StandardOrder.TheObjects[i], buffer);
      Accum.AddPolynomial(buffer);
    }
  this->StandardOrder.Assign(Accum);
}

void ElementWeylAlgebra::MultiplyOnTheRight(const ElementWeylAlgebra& standsOnTheRight)
{ PolynomialRationalCoeff buffer;
  PolynomialRationalCoeff Accum;
  Accum.Nullify((int) this->NumVariables*2);
  for (int j=0; j<standsOnTheRight.StandardOrder.size; j++)
    for (int i=0; i<this->StandardOrder.size; i++)
    { this->MultiplyTwoMonomials(this->StandardOrder.TheObjects[i], standsOnTheRight.StandardOrder.TheObjects[j], buffer);
      Accum.AddPolynomial(buffer);
    }
  this->StandardOrder.Assign(Accum);
}

void ElementWeylAlgebra::ElementToString(std::string& output, List<std::string>& alphabet, bool useLatex, bool useBeginEqnArray)
{ std::stringstream out;
  std::string tempS;
  int numLettersSinceLastNewLine=0;
  if (useLatex && useBeginEqnArray)
    out << "\\begin{eqnarray*}&&";
  if (this->StandardOrder.IsEqualToZero())
    out << 0;
  for (int i=0; i<this->StandardOrder.size; i++)
  { this->StandardOrder.TheObjects[i].Coefficient.ElementToString(tempS);
    bool hasMinus=(tempS[0]=='-');
    if (this->StandardOrder.TheObjects[i].TotalDegree()!=0)
    { if (tempS=="1")
        tempS="";
      if (tempS=="-1")
        tempS="-";
    }
    if (!hasMinus && i!=0)
      out << '+';
    out << tempS;
    for (int k=0; k<this->NumVariables; k++)
      if (this->StandardOrder.TheObjects[i].degrees[k]!=0)
      { out << "{" << alphabet.TheObjects[k] << "}";
        int tempI=(int) this->StandardOrder.TheObjects[i].degrees[k];
        if (tempI!=1)
          out << "^{" << tempI << "}";
      }
    for (int k=0; k<this->NumVariables; k++)
      if (this->StandardOrder.TheObjects[i].degrees[this->NumVariables+ k]!=0)
      { out << "\\partial_{" << alphabet.TheObjects[k] << "}";
        numLettersSinceLastNewLine++;
        int tempI=this->StandardOrder.TheObjects[i].degrees[this->NumVariables+k];
        if (tempI!=1)
          out << "^{" << tempI << "}";
      }
    if (numLettersSinceLastNewLine>12 && i!= this->StandardOrder.size-1 && useLatex)
    { numLettersSinceLastNewLine=0;
      out <<"\\\\&&\n";
    }
  }
  if (useLatex && useBeginEqnArray)
    out << "\\end{eqnarray*}";
  output=out.str();
}

void ElementWeylAlgebra::ElementToString(std::string& output, bool useXYs, bool useLatex, bool useBeginEqnArray)
{ List<std::string> alphabet;
  alphabet.SetSize(this->NumVariables);
  int numCycles=this->NumVariables;
  if (useXYs)
  { assert(this->NumVariables%2==0);
    numCycles= this->NumVariables/2;
  }
  for (int i=0; i<numCycles; i++)
  { std::stringstream out, out2;
    out << "x_{" << i+1 << "}";
    alphabet.TheObjects[i]= out.str();
    if (useXYs)
    { out2 << "y_{" << i+1 << "}";
      alphabet.TheObjects[i+numCycles]= out2.str();
    }
  }
  this->ElementToString(output, alphabet, useLatex, useBeginEqnArray);
}

void ElementWeylAlgebra::SetNumVariablesPreserveExistingOnes(int newNumVars)
{ if (newNumVars<this->NumVariables)
    this->NumVariables=newNumVars;
  PolynomialRationalCoeff Accum;
  Accum.Nullify((int)newNumVars*2);
  Accum.MakeActualSizeAtLeastExpandOnTop(this->StandardOrder.size);
  Monomial<Rational> tempM;
  for (int i=0; i<this->StandardOrder.size; i++)
  { tempM.init((int)newNumVars*2);
    for (int j=0; j< this->NumVariables; j++)
    { tempM.degrees[j]=this->StandardOrder.TheObjects[i].degrees[j];
      tempM.degrees[j+newNumVars]=this->StandardOrder.TheObjects[i].degrees[j+this->NumVariables];
    }
    tempM.Coefficient.Assign(this->StandardOrder.TheObjects[i].Coefficient);
    Accum.AddMonomial(tempM);
  }
  this->NumVariables= newNumVars;
  this->StandardOrder.Assign(Accum);
}

void ElementWeylAlgebra::MakeGEpsPlusEpsInTypeD(int i, int j, int NumVars)
{ this->Nullify(NumVars*2);
  Monomial<Rational> tempMon;
  tempMon.Coefficient.MakeOne();
  tempMon.MakeConstantMonomial((int)this->NumVariables*2, tempMon.Coefficient);
  tempMon.degrees[i]=1;
  tempMon.degrees[j+this->NumVariables+NumVars]=1;
  this->StandardOrder.AddMonomial(tempMon);

  tempMon.Coefficient.MakeMOne();
  tempMon.MakeConstantMonomial((int)this->NumVariables*2, tempMon.Coefficient);
  tempMon.degrees[j]=1;
  tempMon.degrees[i+this->NumVariables+NumVars]=1;
  this->StandardOrder.AddMonomial(tempMon);
}

void ElementWeylAlgebra::MakeGEpsMinusEpsInTypeD(int i, int j, int NumVars)
{ this->Nullify(NumVars*2);
  Monomial<Rational> tempMon;
  tempMon.Coefficient.MakeOne();
  tempMon.MakeConstantMonomial((int)this->NumVariables*2, tempMon.Coefficient);
  tempMon.degrees[i]=1;
  tempMon.degrees[j+this->NumVariables]=1;
  this->StandardOrder.AddMonomial(tempMon);

  tempMon.Coefficient.MakeMOne();
  tempMon.MakeConstantMonomial((int)this->NumVariables*2, tempMon.Coefficient);
  tempMon.degrees[j+NumVars]=1;
  tempMon.degrees[i+this->NumVariables+NumVars]=1;
  this->StandardOrder.AddMonomial(tempMon);
}

void ElementWeylAlgebra::MakeGMinusEpsMinusEpsInTypeD(int i, int j, int NumVars)
{ this->Nullify(NumVars*2);
  Monomial<Rational> tempMon;
  tempMon.Coefficient.MakeOne();
  tempMon.MakeConstantMonomial((int)this->NumVariables*2, tempMon.Coefficient);
  tempMon.degrees[i+NumVars]=1;
  tempMon.degrees[j+this->NumVariables]=1;
  this->StandardOrder.AddMonomial(tempMon);

  tempMon.Coefficient.MakeMOne();
  tempMon.MakeConstantMonomial((int)this->NumVariables*2, tempMon.Coefficient);
  tempMon.degrees[j+NumVars]=1;
  tempMon.degrees[i+this->NumVariables]=1;
  this->StandardOrder.AddMonomial(tempMon);
}

void ElementWeylAlgebra::Makedidj(int i, int j, int NumVars)
{ this->Nullify(NumVars);
  Monomial<Rational> tempMon;
  tempMon.Coefficient.MakeOne();
  tempMon.MakeConstantMonomial((int)this->NumVariables*2, tempMon.Coefficient);
  tempMon.degrees[i+NumVars]++;
  tempMon.degrees[j+NumVars]++;
  this->StandardOrder.AddMonomial(tempMon);
}

void ElementWeylAlgebra::Makexixj(int i, int j, int NumVars)
{ this->Nullify(NumVars);
  Monomial<Rational> tempMon;
  tempMon.Coefficient.MakeOne();
  tempMon.MakeConstantMonomial((int)this->NumVariables*2, tempMon.Coefficient);
  tempMon.degrees[i]++;
  tempMon.degrees[j]++;
  this->StandardOrder.AddMonomial(tempMon);
}

void ElementWeylAlgebra::Makexi(int i, int NumVars)
{ this->Nullify(NumVars);
  Monomial<Rational> tempMon;
  tempMon.Coefficient.MakeOne();
  tempMon.MakeConstantMonomial((int)this->NumVariables*2, tempMon.Coefficient);
  tempMon.degrees[i]++;
  this->StandardOrder.AddMonomial(tempMon);
}

void ElementWeylAlgebra::Makedi(int i, int NumVars)
{ this->Nullify(NumVars);
  Monomial<Rational> tempMon;
  tempMon.Coefficient.MakeOne();
  tempMon.MakeConstantMonomial((int)this->NumVariables*2, tempMon.Coefficient);
  tempMon.degrees[i+NumVars]++;
  this->StandardOrder.AddMonomial(tempMon);
}

void ElementWeylAlgebra::Makexidj(int i, int j, int NumVars)
{ this->Nullify(NumVars);
  Monomial<Rational> tempMon;
  tempMon.Coefficient.MakeOne();
  tempMon.MakeConstantMonomial((int)this->NumVariables*2, tempMon.Coefficient);
  tempMon.degrees[i]=1;
  tempMon.degrees[NumVars+j]=1;
  this->StandardOrder.AddMonomial(tempMon);
}

void ElementWeylAlgebra::Nullify(int NumVars)
{ this->NumVariables=NumVars;
  this->StandardOrder.Nullify ((int)this->NumVariables*2);
}

void IrreducibleFiniteDimensionalModule::ElementToString(std::string& output)
{ std::stringstream out; std::string tempS;
  this->theMatrix.ElementToString(tempS);
  out << "The matrix :\n " << tempS << "\n\n";
  this->thePathMatrix.ElementToString(tempS);
  out << "The matrix of the polytope:\n " << tempS << "\n\n";
  this->thePaths.ElementToString(tempS, false);
  out << tempS;
  output = out.str();
}

void IrreducibleFiniteDimensionalModule::InitAndPrepareTheChambersForComputation(int IndexWeyl, CombinatorialChamberContainer& theChambers, GlobalVariables& theGlobalVariables)
{// reference:  E. Feigin, G. Fourier, P. Littelmann, "PBW filtration and bases for irreducible modules in type A_n", preprint 2009
  int theDimension= IndexWeyl;
  this->thePaths.AmbientWeyl.MakeAn(theDimension);
  this->thePaths.GenerateAllDyckPathsTypesABC();
  this->thePaths.ComputeGoodPathsExcludeTrivialPath();
  this->thePathMatrix.init(this->thePaths.GoodPaths.size, this->thePaths.PositiveRoots.size);
  this->thePathMatrix.NullifyAll(0);
  for (int i=0; i<this->thePaths.GoodPaths.size; i++)
    for (int j=0; j<this->thePaths.TheObjects[this->thePaths.GoodPaths.TheObjects[i]].thePathNodes.size; j++)
      this->thePathMatrix.elements[i][this->thePaths.TheObjects[this->thePaths.GoodPaths.TheObjects[i]].thePathNodes.TheObjects[j]]=1;
  this->theMatrix.Assign(this->thePathMatrix);
  this->theMatrix.Resize(this->thePaths.GoodPaths.size + theDimension, this->thePaths.PositiveRoots.size+this->thePaths.GoodPaths.size, true);
  for (int j=0; j<theDimension; j++)
  { for (int i=0; i<this->thePaths.PositiveRoots.size; i++)
      this->theMatrix.elements[j+this->thePaths.GoodPaths.size][i]= this->thePaths.PositiveRoots.TheObjects[i].TheObjects[j];
    for (int i=0; i<this->thePaths.GoodPaths.size; i++)
      this->theMatrix.elements[j+this->thePaths.GoodPaths.size][i+this->thePaths.PositiveRoots.size]=0;
  }
  for (int i=0; i<this->thePaths.GoodPaths.size; i++)
    for (int j=0; j<this->thePaths.GoodPaths.size; j++)
      this->theMatrix.elements[i][j+this->thePaths.PositiveRoots.size]=(i==j)? 1 : 0;
  this->theColumnsOfTheMatrix.AssignMatrixColumns(this->theMatrix);
  theChambers.theDirections.CopyFromBase(this->theColumnsOfTheMatrix);
  theChambers.theDirections.ReverseOrderElements();
  theChambers.AmbientDimension= this->theMatrix.NumRows;
  theChambers.theCurrentIndex=-1;
  theChambers.theDirections.ComputeDebugString();
}

void DyckPaths::ComputeGoodPathsExcludeTrivialPath()
{ int counter=0;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].IamComplete(*this))
      counter++;
  this->GoodPaths.MakeActualSizeAtLeastExpandOnTop(counter);
  this->GoodPaths.size=0;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].IamComplete(*this))
      this->GoodPaths.AddObjectOnTop(i);
}

void slTwo::ElementToStringModuleDecomposition(bool useLatex, bool useHtml, std::string& output)
{ std::stringstream out;
  if (useLatex)
    out << "$";
  for (int i=0; i<this->highestWeights.size; i++)
  { if (this->multiplicitiesHighestWeights.TheObjects[i]>1)
      out << this->multiplicitiesHighestWeights.TheObjects[i];
    out << "V_{" << this->highestWeights.TheObjects[i] << "}";
    if (i!=this->highestWeights.size-1)
      out << "+";
  }
  if (useLatex)
    out << "$";
  output=out.str();
}

void slTwo::ElementToStringModuleDecompositionMinimalContainingRegularSAs(bool useLatex, bool useHtml, SltwoSubalgebras& owner, std::string& output)
{ std::stringstream out;
  std::string tempS;
  if (useLatex)
    out<<"$";
  if (useHtml)
  { out <<"<table><tr><td align=\"center\">Char.</td>";
    for (int i=0; i<this->IndicesMinimalContainingRootSA.size; i++)
    { rootSubalgebra& theSA= owner.theRootSAs.TheObjects[this->IndicesMinimalContainingRootSA.TheObjects[i]];
      CGIspecificRoutines::clearDollarSigns(theSA.theDynkinDiagram.DebugString, tempS);
      out << "<td align=\"center\">Decomp. " << tempS <<"</td>";
    }
    out << "</tr>\n";
  }
  out << "<tr><td align=\"center\"> " << this->hCharacteristic.ElementToString() << "</td>";
  for (int k=0; k<this->IndicesMinimalContainingRootSA.size; k++)
  { rootSubalgebra& theSA= owner.theRootSAs.TheObjects[this->IndicesMinimalContainingRootSA.TheObjects[k]];
    CGIspecificRoutines::clearDollarSigns(theSA.theDynkinDiagram.DebugString, tempS);
    if (useHtml)
      out <<"<td align=\"center\">";
    for (int i=0; i<this->HighestWeightsDecompositionMinimalContainingRootSA.TheObjects[k].size; i++)
    { if (this->MultiplicitiesDecompositionMinimalContainingRootSA.TheObjects[k].TheObjects[i]>1)
        out << this->MultiplicitiesDecompositionMinimalContainingRootSA.TheObjects[k].TheObjects[i];
      out << "V_{"<<this->HighestWeightsDecompositionMinimalContainingRootSA.TheObjects[k].TheObjects[i]<<"}";
      if (i!=this->HighestWeightsDecompositionMinimalContainingRootSA.TheObjects[k].size-1)
        out << "+";
    }
    if (useHtml)
      out << "</td>";
    out << "\n";
  }
  if (useHtml)
    out << "</tr></table>";
  if (useLatex)
    out << "$";
  output=out.str();
}

void slTwo::ElementToHtmlCreateFormulaOutputReference(const std::string& formulaTex, std::stringstream& output, bool usePNG, bool useHtml, SltwoSubalgebras& container, std::string* physicalPath, std::string* htmlPathServer)
{ if (!usePNG)
  { output << formulaTex;
    //if (useHtml)
      //output<<"\n<br>\n";
    return;
  }
  std::stringstream tempStream;
  container.texFileNamesForPNG.SetSize(container.texFileNamesForPNG.size+1);
  container.texStringsEachFile.SetSize(container.texFileNamesForPNG.size);
  (*container.texStringsEachFile.LastObject())=formulaTex;
  tempStream << (*physicalPath) << "fla";
  tempStream << container.texFileNamesForPNG.size << ".tex";
  container.texFileNamesForPNG.TheObjects[container.texFileNamesForPNG.size-1]=tempStream.str();
  output << "<img src=\"" << (*htmlPathServer) << "fla" << container.texFileNamesForPNG.size << ".png\">";
  if (useHtml)
    output << "\n<br>\n";
}

void slTwo::ElementToString(std::string& output, GlobalVariables& theGlobalVariables, SltwoSubalgebras& container, int indexInContainer, bool useLatex, bool useHtml, bool usePNG, std::string* physicalPath, std::string* htmlPathServer, PolynomialOutputFormat& PolyFormatLocal)
{ std::stringstream out;  std::string tempS;
  this->hCharacteristic.ElementToString(tempS);
  out << "<a name=\"sl2index" << indexInContainer << "\">h-characteristic: " <<  tempS << "</a>";
  this->preferredAmbientSimpleBasis.ElementToString(tempS, false, false, false);
  if (physicalPath==0 || htmlPathServer==0)
  { usePNG=false;
    useHtml=false;
  }
  if (useHtml)
    out << "<br>";
  out << "\nSimple basis ambient algebra w.r.t defining h: " << tempS;
  roots tempRoots;
  MatrixLargeRational tempMat;
  if (useHtml)
    out << "<br>";
  if (this->IndicesContainingRootSAs.size>1)
  { out << "Number of containing regular semisimple subalgebras: " << this->IndicesContainingRootSAs.size;
    if (useHtml)
    out << "<br>";
  }
  for (int i=0; i<this->IndicesContainingRootSAs.size; i++)
  { out << "\nContaining regular semisimple subalgebra number " << i+1 << ": ";
    rootSubalgebra& currentSA= container.theRootSAs.TheObjects[this->IndicesContainingRootSAs.TheObjects[i]];
    if (useHtml)
    { out << "<a href=\"" << (*htmlPathServer) << "../rootHtml_rootSA" << this->IndicesContainingRootSAs.TheObjects[i] << ".html\">";
      currentSA.theDynkinDiagram.ElementToString(tempS, true);
      CGIspecificRoutines::clearDollarSigns(tempS, tempS);
    }
    currentSA.theDynkinDiagram.GetSimpleBasisInBourbakiOrder(tempRoots);
    out << tempS;
    if(useHtml)
      out << "</a>";
    tempRoots.ElementToString(tempS, useLatex, useHtml, false);
    if (useHtml)
      out << "<br>";
    out << "\nSimple basis subalgebra: " << tempS;
    currentSA.theDynkinDiagram.GetKillingFormMatrixUseBourbakiOrder(tempMat, this->owner->theWeyl);
    if (!usePNG)
      tempMat.ElementToString(tempS, useHtml, useLatex);
    else
    { std::stringstream tempStreamX;
      tempMat.ElementToString(tempS, false, true);
      tempStreamX << "\\[" << tempS << "\\]";
      tempS=tempStreamX.str();
    }
    if (useHtml)
      out << "<br>";
    out << "\nSymmetric Cartan matrix in Bourbaki order:\n";
    if (useHtml)
    { out << "<br>";
      this->ElementToHtmlCreateFormulaOutputReference(tempS, out, usePNG, useHtml, container, physicalPath, htmlPathServer);
    } else
      out << tempS;
  }
  out << "\nsl(2)-module decomposition of the ambient Lie algebra: ";
  this->ElementToStringModuleDecomposition(useLatex || usePNG, useHtml, tempS);
  this->ElementToHtmlCreateFormulaOutputReference(tempS, out, usePNG, useHtml, container, physicalPath, htmlPathServer);
  container.IndicesSl2decompositionFlas.SetSize(container.size);
  container.IndicesSl2decompositionFlas.TheObjects[indexInContainer]=container.texFileNamesForPNG.size-1;
  out << "\nThe below list one possible realization of the sl(2) subalgebra.";
  if (useHtml)
    out << "\n<br>\n";
  std::stringstream tempStreamH, tempStreamE, tempStreamF, tempStreamHE, tempStreamHF, tempStreamEF;
  this->theH.ElementToString(tempS, useHtml, useLatex);
  tempStreamH << "\n$h=$ $" << tempS << "$";
  tempS= tempStreamH.str();
  this->ElementToHtmlCreateFormulaOutputReference(tempS, out, usePNG, useHtml, container, physicalPath, htmlPathServer);
  this->theE.ElementToString(tempS, useHtml, useLatex);
  tempStreamE << "\n$e=$ $" << tempS << "$";
  tempS= tempStreamE.str();
  this->ElementToHtmlCreateFormulaOutputReference(tempS, out, usePNG, useHtml, container, physicalPath, htmlPathServer);
  this->theF.ElementToString(tempS, useHtml, useLatex);
  tempStreamF << "\n$f=$ $" << tempS << "$";
  tempS= tempStreamF.str();
  this->ElementToHtmlCreateFormulaOutputReference(tempS, out, usePNG, useHtml, container, physicalPath, htmlPathServer);
  out << "\n\nThe below are the Lie brackets of the above elements. Printed for debugging.";
  if (useHtml)
    out << "\n<br>\n";
  this->bufferEbracketF.ElementToString(tempS, useHtml, useLatex);
  tempStreamEF << "\n$[e, f]=$ $" << tempS << "$";
  tempS= tempStreamEF.str();
  this->ElementToHtmlCreateFormulaOutputReference(tempS, out, usePNG, useHtml, container, physicalPath, htmlPathServer);
  this->bufferHbracketE.ElementToString(tempS, useHtml, useLatex);
  tempStreamHE << "\n$[h, e]=$ $" << tempS << "$";
  tempS= tempStreamHE.str();
  this->ElementToHtmlCreateFormulaOutputReference(tempS, out, usePNG, useHtml, container, physicalPath, htmlPathServer);
  this->bufferHbracketF.ElementToString(tempS, useHtml, useLatex);
  tempStreamHF << "\n$[h, f]=$ $" << tempS << "$";
  tempS= tempStreamHF.str();
  this->ElementToHtmlCreateFormulaOutputReference(tempS, out, usePNG, useHtml, container, physicalPath, htmlPathServer);
  //this->theSystemMatrixForm.ElementToString(tempS);
  //out <<"\nSystem matrix form we try to solve:\n"<< tempS;
  //this->theSystemColumnVector.ElementToString(tempS);
  //out <<"\nColumn vector of the system:\n"<<tempS;
  std::stringstream tempStreamActual;
  for (int i=0; i<this->theSystemToBeSolved.size; i++)
  { this->theSystemToBeSolved.TheObjects[i].ElementToString(tempS, PolyFormatLocal);
    if (tempS=="")
    { if (useLatex || usePNG)
        tempStreamActual << "~\\\\";
      else
        tempStreamActual << "\n\n";
    }
    else
      tempStreamActual << "\\noindent \\begin{eqnarray*}&&" << tempS << "=0\\end{eqnarray*}\n\n";
  }
  out << "\nThe system we need to solve:\n";
  if (useHtml)
    out << "\n<br>\n";
  tempS= tempStreamActual.str();
  this->ElementToHtmlCreateFormulaOutputReference(tempS, out, usePNG, useHtml, container, physicalPath, htmlPathServer);
  output = out.str();
}

void slTwo::ElementToHtml(std::string& filePath)
{ std::fstream theFile;
  std::string theFileName=filePath;
  theFileName.append("theSlTwo.txt");
  CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(theFile, filePath, false, true, false);
}

void SemisimpleLieAlgebra::FindSl2Subalgebras(SltwoSubalgebras& output, GlobalVariables& theGlobalVariables)
{ output.theRootSAs.GenerateAllReductiveRootSubalgebrasUpToIsomorphism(theGlobalVariables, true, true);
  //output.theRootSAs.ComputeDebugString(false, false, false, 0, 0, theGlobalVariables);
  output.IndicesSl2sContainedInRootSA.SetSize(output.theRootSAs.size);
  output.IndicesSl2sContainedInRootSA.MakeActualSizeAtLeastExpandOnTop(output.theRootSAs.size*2);
  for (int i=0; i<output.IndicesSl2sContainedInRootSA.size; i++)
    output.IndicesSl2sContainedInRootSA.TheObjects[i].size=0;
  theGlobalVariables.theIndicatorVariables.StatusString1=output.theRootSAs.DebugString;
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
  for (int i=0; i<output.theRootSAs.size-1; i++)
    output.theRootSAs.TheObjects[i].GetSsl2SubalgebrasAppendListNoRepetition(output, i, theGlobalVariables, *this);
  for (int i=0; i<output.size; i++)
  { slTwo& theSl2= output.TheObjects[i];
    theSl2.IndicesMinimalContainingRootSA.MakeActualSizeAtLeastExpandOnTop(theSl2.IndicesContainingRootSAs.size);
    theSl2.IndicesMinimalContainingRootSA.size=0;
    for (int j=0; j<theSl2.IndicesContainingRootSAs.size; j++)
    { bool isMinimalContaining=true;
//      rootSubalgebra& currentRootSA = output.theRootSAs.TheObjects[];
      for (int k=0; k<theSl2.IndicesContainingRootSAs.size; k++)
      { rootSubalgebra& theOtherRootSA = output.theRootSAs.TheObjects[theSl2.IndicesContainingRootSAs.TheObjects[k]];
        if (theOtherRootSA.indicesSubalgebrasContainingK.ContainsObject(theSl2.IndicesContainingRootSAs.TheObjects[j]))
        { isMinimalContaining=false;
          break;
        }
      }
      if (isMinimalContaining)
        theSl2.IndicesMinimalContainingRootSA.AddOnTopNoRepetition(theSl2.IndicesContainingRootSAs.TheObjects[j]);
    }
    output.ComputeModuleDecompositionsOfAmbientLieAlgebra(theGlobalVariables);
  }
  //tempRootSA.GetSsl2Subalgebras(tempSl2s, theGlobalVariables, *this);
}

void SemisimpleLieAlgebra::FindSl2Subalgebras(SltwoSubalgebras& output, char WeylLetter, int WeylRank, GlobalVariables& theGlobalVariables)
{ output.theRootSAs.AmbientWeyl.MakeArbitrary(WeylLetter, WeylRank);
  this->theWeyl.MakeArbitrary(WeylLetter, WeylRank);
  this->FindSl2Subalgebras(output, theGlobalVariables);
}

void rootSubalgebra::GetSsl2SubalgebrasAppendListNoRepetition(SltwoSubalgebras& output, int indexInContainer, GlobalVariables& theGlobalVariables, SemisimpleLieAlgebra& theLieAlgebra)
{ //reference: Dynkin, semisimple Lie algebras of simple lie algebras, theorems 10.1-10.4
  Selection theRootsWithZeroCharacteristic;
  roots RootsWithCharacteristic2;
  RootsWithCharacteristic2.MakeActualSizeAtLeastExpandOnTop(this->PositiveRootsK.size);
  DynkinDiagramRootSubalgebra tempDiagram;
  int theRelativeDimension = this->SimpleBasisK.size;
  theRootsWithZeroCharacteristic.init(theRelativeDimension);
  MatrixLargeRational InvertedRelativeKillingForm;
  InvertedRelativeKillingForm.init(theRelativeDimension, theRelativeDimension);
  for (int k=0; k<theRelativeDimension; k++)
    for (int j=0; j<theRelativeDimension; j++)
      InvertedRelativeKillingForm.elements[k][j]=this->AmbientWeyl.RootScalarCartanRoot(this->SimpleBasisK.TheObjects[k], this->SimpleBasisK.TheObjects[j]);
  InvertedRelativeKillingForm.Invert(theGlobalVariables);
  theLieAlgebra.ComputeChevalleyConstants(this->AmbientWeyl, theGlobalVariables);
  //int relativeDimension =
  int numCycles= MathRoutines::TwoToTheNth(theRootsWithZeroCharacteristic.MaxSize);
  roots tempRoots;
  tempRoots.MakeActualSizeAtLeastExpandOnTop(theRootsWithZeroCharacteristic.MaxSize);
  roots relativeRootSystem;
  this->PositiveRootsK.GetCoordsInBasis(this->SimpleBasisK, relativeRootSystem, theGlobalVariables);
  slTwo theSl2;
  theSl2.owner = &theLieAlgebra;
  for (int i=0; i<numCycles; i++, theRootsWithZeroCharacteristic.incrementSelection())
  { tempRoots.size=0;
    for (int j=0; j<theRootsWithZeroCharacteristic.CardinalitySelection; j++)
      tempRoots.AddObjectOnTop(this->SimpleBasisK.TheObjects[theRootsWithZeroCharacteristic.elements[j]]);
    tempDiagram.ComputeDiagramTypeModifyInput(tempRoots, this->AmbientWeyl);
    int theSlack=0;
    RootsWithCharacteristic2.size=0;
    for (int j=0; j<relativeRootSystem.size; j++)
    { Rational DimTwoSpace=0;
      for (int k=0; k<theRelativeDimension; k++)
        if (!theRootsWithZeroCharacteristic.selected[k])
        { DimTwoSpace+=relativeRootSystem.TheObjects[j].TheObjects[k];
          if (DimTwoSpace>1)
            break;
        }
      if (DimTwoSpace==1)
      { theSlack++;
        RootsWithCharacteristic2.AddObjectOnTop(this->PositiveRootsK.TheObjects[j]);
      }
    }
    int theDynkinEpsilon = tempDiagram.NumRootsGeneratedByDiagram() + theRelativeDimension - theSlack;
    //if Dynkin's epsilon is not zero the subalgebra cannot be an S sl(2) subalgebra.
    //otherwise, as far as I understand, it always is (but generators still have to be found)
    //this is done in the below code.
    theRootsWithZeroCharacteristic.ComputeDebugString();
    if (theDynkinEpsilon==0)
    { root tempRoot, tempRoot2;
      tempRoot.MakeZero(theRelativeDimension);
      for (int k=0; k<theRelativeDimension; k++)
        if(!theRootsWithZeroCharacteristic.selected[k])
          tempRoot.TheObjects[k]=2;
      InvertedRelativeKillingForm.ActOnAroot(tempRoot, tempRoot2);
      theSl2.theH.Nullify(theLieAlgebra);
      theSl2.theH.Hcomponent.MakeZero(this->AmbientWeyl.CartanSymmetric.NumRows);
      for(int j=0; j<theRelativeDimension; j++)
        theSl2.theH.Hcomponent+= this->SimpleBasisK.TheObjects[j]*tempRoot2.TheObjects[j];
      theSl2.theE.Nullify(theLieAlgebra);
      theSl2.theF.Nullify(theLieAlgebra);
      //theSl2.ComputeDebugString(false, false, theGlobalVariables);
      if(theLieAlgebra.AttemptExtendingHEtoHEFWRTSubalgebra(RootsWithCharacteristic2, relativeRootSystem, theRootsWithZeroCharacteristic, this->SimpleBasisK, theSl2.theH.Hcomponent, theSl2.theE, theSl2.theF, theSl2.theSystemMatrixForm, theSl2.theSystemToBeSolved, theSl2.theSystemColumnVector, theGlobalVariables))
      { int indexIsoSl2;
        theSl2.MakeReportPrecomputations(theGlobalVariables, output, output.size, indexInContainer, *this);
        if(output.ContainsSl2WithGivenHCharacteristic(theSl2.hCharacteristic, &indexIsoSl2))
        { output.TheObjects[indexIsoSl2].IndicesContainingRootSAs.AddObjectOnTop(indexInContainer);
          output.IndicesSl2sContainedInRootSA.TheObjects[indexInContainer].AddObjectOnTop(indexIsoSl2);
        }
        else
        { output.IndicesSl2sContainedInRootSA.TheObjects[indexInContainer].AddObjectOnTop(output.size);
          output.AddObjectOnTopHash(theSl2);
        }
      }
      else
        output.BadHCharacteristics.AddObjectOnTop(theSl2.theH.Hcomponent);
    }
  }
}

bool SemisimpleLieAlgebra:: AttemptExtendingHEtoHEFWRTSubalgebra(roots& RootsWithCharacteristic2, roots& relativeRootSystem, Selection& theZeroCharacteristics, roots& simpleBasisSA, root& h, ElementSimpleLieAlgebra& outputE, ElementSimpleLieAlgebra& outputF, MatrixLargeRational& outputMatrixSystemToBeSolved, PolynomialsRationalCoeff& outputSystemToBeSolved, MatrixLargeRational& outputSystemColumnVector, GlobalVariables& theGlobalVariables)
{ if (theZeroCharacteristics.CardinalitySelection== theZeroCharacteristics.MaxSize)
    return false;
  roots SelectedExtraPositiveRoots;
  roots rootsInPlay;
  rootsInPlay.size=0;
  SelectedExtraPositiveRoots.size=0;
  int theRelativeDimension = simpleBasisSA.size;
//  int theDimension= this->theWeyl.CartanSymmetric.NumRows;
  assert(theRelativeDimension==theZeroCharacteristics.MaxSize);
  root tempRoot, tempRoot2;
  //format. We are looking for an sl(2) for which e= a_0 g^\alpha_0+\dots a_kg^\alpha_k, and f=b_0 g^{-\alpha_0}+... +b_kg^{-\alpha_k}
  //where the first \alpha's are ordered as in rootsInPlay.
  //Those are ordered as such: first come  the simple roots of characteristic 2, and the last \alpha's are the members of SelectedExtraPositiveRoots
  //(i.e. roots equal to the sum of one simple root of characteristic 2 a simple root of characteristic 0).
  // Then the first k variables of the polynomials below will be a_0, ..., a_k., and the last k variables will be the b_i's
  // the l^th polynomial will correspond to the coefficient of g^\alpha_{l/2}, where l/2 is the index of the root of SelectedExtraPositiveRoots, if l is even, and to the
  // coefficient of  g^{-\alpha_{(l+1)/2}} otherwise
  for (int i=0; i<theRelativeDimension; i++)
    if (!theZeroCharacteristics.selected[i])
      rootsInPlay.AddObjectOnTop(simpleBasisSA.TheObjects[i]);
    else
      for (int j=0; j<theRelativeDimension; j++)
        if (!theZeroCharacteristics.selected[j])
        { tempRoot= simpleBasisSA.TheObjects[i]+simpleBasisSA.TheObjects[j];
          if (this->theWeyl.IsARoot(tempRoot))
            SelectedExtraPositiveRoots.AddObjectOnTop(tempRoot);
        }
  SelectedExtraPositiveRoots.size=0;
  for (int i=0; i<RootsWithCharacteristic2.size; i++)
    if (!simpleBasisSA.ContainsObject(RootsWithCharacteristic2.TheObjects[i]))
      SelectedExtraPositiveRoots.AddObjectOnTop(RootsWithCharacteristic2.TheObjects[i]);
  int numRootsChar2 = rootsInPlay.size;
  rootsInPlay.AddListOnTop(SelectedExtraPositiveRoots);
  int halfNumberVariables = rootsInPlay.size;
  int numberVariables = halfNumberVariables*2;
  Monomial<Rational> tempM;
  tempM.init((int)numberVariables);
  MatrixLargeRational coeffsF;
  coeffsF.init(1, halfNumberVariables);
  for (int i=0; i<numRootsChar2; i++)
    coeffsF.elements[0][i]=i+1; //(i%2==0)? 1: 2;
  for (int i=numRootsChar2; i<coeffsF.NumCols; i++)
    coeffsF.elements[0][i]=i+1;
  this->initHEFSystemFromECoeffs(theRelativeDimension, theZeroCharacteristics, rootsInPlay, simpleBasisSA, SelectedExtraPositiveRoots, numberVariables, numRootsChar2, halfNumberVariables, h, coeffsF, outputMatrixSystemToBeSolved, outputSystemColumnVector, outputSystemToBeSolved);
  MatrixLargeRational tempMat, tempMatColumn, tempMatResult;
  tempMat.Assign(outputMatrixSystemToBeSolved);
  tempMatColumn.Assign(outputSystemColumnVector);
  outputF.Nullify(*this);
  outputE.Nullify(*this);
//  if(MatrixLargeRational::Solve_Ax_Equals_b_ModifyInputReturnFirstSolutionIfExists(outputMatrixSystemToBeSolved, outputSystemColumnVector, tempMatResult))
  if(MatrixLargeRational::Solve_Ax_Equals_b_ModifyInputReturnFirstSolutionIfExists(tempMat, tempMatColumn, tempMatResult))
  { for (int i=0; i<rootsInPlay.size; i++)
    { outputF.SetCoefficient(-rootsInPlay.TheObjects[i], coeffsF.elements[0][i], *this);
      outputE.SetCoefficient(rootsInPlay.TheObjects[i], tempMatResult.elements[i][0], *this);
    }
    return true;
  }
  return true;
}

void SemisimpleLieAlgebra::initHEFSystemFromECoeffs(int theRelativeDimension, Selection& theZeroCharacteristics, roots& rootsInPlay, roots& simpleBasisSA, roots& SelectedExtraPositiveRoots, int numberVariables, int numRootsChar2, int halfNumberVariables, root& targetH, MatrixLargeRational& inputFCoeffs, MatrixLargeRational& outputMatrixSystemToBeSolved, MatrixLargeRational& outputSystemColumnVector, PolynomialsRationalCoeff& outputSystemToBeSolved)
{ root tempRoot;
  static int ProblemCounter=0;
  ProblemCounter++;
  Monomial<Rational> tempM;
  Rational tempRat;
  hashedRoots RootSpacesThatNeedToBeKilled;
  RootSpacesThatNeedToBeKilled.ClearTheObjects();
  //List<int> IndicesEquationsByRootSpace;
  RootSpacesThatNeedToBeKilled.MakeActualSizeAtLeastExpandOnTop(this->theWeyl.RootSystem.size);
//  IndicesEquationsByRootSpace.MakeActualSizeAtLeastExpandOnTop(this->theWeyl.RootSystem.size);
  outputSystemToBeSolved.size=0;
  outputMatrixSystemToBeSolved.init(0, numberVariables);
  //outputSystemToBeSolved.ComputeDebugString();
  for (int i=0; i<rootsInPlay.size; i++)
    for (int j=0; j<rootsInPlay.size; j++)
    { tempRoot= rootsInPlay.TheObjects[i]-rootsInPlay.TheObjects[j];
      if (this->theWeyl.IsARoot(tempRoot))
      { int indexEquation= RootSpacesThatNeedToBeKilled.IndexOfObjectHash(tempRoot);
        if (indexEquation==-1)
        { RootSpacesThatNeedToBeKilled.AddObjectOnTopHash(tempRoot);
          indexEquation=outputSystemToBeSolved.size;
//          IndicesEquationsByRootSpace.AddObjectOnTop(indexEquation);
          outputSystemToBeSolved.SetSize(outputSystemToBeSolved.size+1);
          outputSystemToBeSolved.LastObject()->Nullify((int)numberVariables);
        }
        tempM.init((int)numberVariables);
        tempM.degrees[i]=1;
        tempM.degrees[j+halfNumberVariables]=1;
        tempM.Coefficient= this->GetConstant(rootsInPlay.TheObjects[i], -rootsInPlay.TheObjects[j]);
        outputSystemToBeSolved.TheObjects[indexEquation].AddMonomial(tempM);
        //outputSystemToBeSolved.ComputeDebugString();
      }
    }
  int oldSize=outputSystemToBeSolved.size;
  outputSystemToBeSolved.SetSize(oldSize+this->theWeyl.CartanSymmetric.NumRows);
  for(int i=oldSize; i<outputSystemToBeSolved.size; i++)
    outputSystemToBeSolved.TheObjects[i].Nullify((int)numberVariables);
  //outputSystemToBeSolved.ComputeDebugString();
  for (int i=0; i<rootsInPlay.size; i++)
  { assert(rootsInPlay.size==halfNumberVariables);
    this->GetConstantOrHElement(rootsInPlay.TheObjects[i], -rootsInPlay.TheObjects[i], tempRat, tempRoot);
    for (int j=0; j<this->theWeyl.CartanSymmetric.NumRows; j++)
    { tempM.init((int)numberVariables);
      tempM.degrees[i]=1;
      tempM.degrees[i+halfNumberVariables]=1;
      tempM.Coefficient= tempRoot.TheObjects[j];
      outputSystemToBeSolved.TheObjects[j+oldSize].AddMonomial(tempM);
    }
  }
  for (int i=0; i<this->theWeyl.CartanSymmetric.NumRows; i++)
    outputSystemToBeSolved.TheObjects[i+oldSize].AddConstant(targetH.TheObjects[i]*(-1));
  outputMatrixSystemToBeSolved.init(outputSystemToBeSolved.size, halfNumberVariables);
  outputSystemColumnVector.init(outputSystemToBeSolved.size, 1);
  outputMatrixSystemToBeSolved.NullifyAll();
  outputSystemColumnVector.NullifyAll();
  for (int i=0; i<outputSystemToBeSolved.size; i++)
    for (int j=0; j<outputSystemToBeSolved.TheObjects[i].size; j++)
    { int lowerIndex=-1; int higherIndex=-1;
      Monomial<Rational>& theMonomial= outputSystemToBeSolved.TheObjects[i].TheObjects[j];
      for (int k=0; k<numberVariables; k++)
        if (theMonomial.degrees[k]==1)
        { if (k<halfNumberVariables)
            lowerIndex=k;
          else
          { higherIndex=k;
            break;
          }
        }
      if (lowerIndex==-1)
        outputSystemColumnVector.elements[i][0]= theMonomial.Coefficient*(-1);
      else
        outputMatrixSystemToBeSolved.elements[i][lowerIndex]=theMonomial.Coefficient* inputFCoeffs.elements[0][higherIndex-halfNumberVariables];
    }
//  outputSystemToBeSolved.ComputeDebugString();
}

bool SltwoSubalgebras::ContainsSl2WithGivenH(root& theH, int* outputIndex)
{ if (outputIndex!=0)
    *outputIndex=-1;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].theH.Hcomponent==theH)
    { if (outputIndex!=0)
        *outputIndex=i;
      return true;
    }
  return false;
}

bool SltwoSubalgebras::ContainsSl2WithGivenHCharacteristic(root& theHCharacteristic, int* outputIndex)
{ if (outputIndex!=0)
    *outputIndex=-1;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].hCharacteristic==theHCharacteristic)
    { if (outputIndex!=0)
        *outputIndex=i;
      return true;
    }
  return false;
}

void slTwo::MakeReportPrecomputations(GlobalVariables& theGlobalVariables, SltwoSubalgebras& container, int indexInContainer, int indexMinimalContainingRegularSA, rootSubalgebra& MinimalContainingRegularSubalgebra)
{ int theDimension=this->owner->theWeyl.CartanSymmetric.NumRows;
  this->IndicesContainingRootSAs.size=0;
  roots tempRoots;
  tempRoots.CopyFromBase(MinimalContainingRegularSubalgebra.SimpleBasisK);
  this->owner->theWeyl.TransformToSimpleBasisGeneratorsWRTh(tempRoots, this->theH.Hcomponent);
  DynkinDiagramRootSubalgebra theDiagram;
  theDiagram.ComputeDiagramTypeKeepInput(tempRoots, this->owner->theWeyl);
  theDiagram.GetSimpleBasisInBourbakiOrder(tempRoots);
  this->IndicesContainingRootSAs.AddObjectOnTop(indexMinimalContainingRegularSA);
  tempRoots.MakeEiBasis(theDimension);
  this->owner->theWeyl.TransformToSimpleBasisGeneratorsWRTh(tempRoots, this->theH.Hcomponent);
  DynkinDiagramRootSubalgebra tempDiagram;
  tempDiagram.ComputeDiagramTypeKeepInput(tempRoots, this->owner->theWeyl);
  tempDiagram.GetSimpleBasisInBourbakiOrder(this->preferredAmbientSimpleBasis);
  this->hCharacteristic.SetSize(theDimension);
  for (int i=0; i<theDimension; i++)
    this->hCharacteristic.TheObjects[i]=this->owner->theWeyl.RootScalarCartanRoot(this->theH.Hcomponent, this->preferredAmbientSimpleBasis.TheObjects[i]);
  //this->hCharacteristic.ComputeDebugString();
  if (this->theE.NonZeroElements.MaxSize==this->owner->theWeyl.RootSystem.size && this->theF.NonZeroElements.MaxSize==this->owner->theWeyl.RootSystem.size && this->theH.NonZeroElements.MaxSize==this->owner->theWeyl.RootSystem.size)
  { this->owner->LieBracket(this->theE, this->theF, this->bufferEbracketF);
    this->owner->LieBracket(this->theH, this->theE, this->bufferHbracketE);
    this->owner->LieBracket(this->theH, this->theF, this->bufferHbracketF);
  }
  //theSl2.hCharacteristic.ComputeDebugString();
//  this->ComputeModuleDecomposition();
}

void WeylGroup::PerturbWeightToRegularWRTrootSystem(const root& inputH, root& output)
{ output.Assign(inputH);
  int indexFirstNonRegular;
  while(!this->IsRegular(output, &indexFirstNonRegular))
  { root& theBadRoot= this->RootSystem.TheObjects[indexFirstNonRegular];
    Rational maxMovement=0; Rational tempRat1, tempRat2, tempMaxMovement;
    for (int i=0; i<this->RootsOfBorel.size; i++)
    { this->RootScalarCartanRoot(theBadRoot, this->RootsOfBorel.TheObjects[i], tempRat1);
      this->RootScalarCartanRoot(output, this->RootsOfBorel.TheObjects[i], tempRat2);
      if ((!tempRat1.IsEqualToZero()) && (!tempRat2.IsEqualToZero()))
      { tempMaxMovement = tempRat2/tempRat1;
        tempMaxMovement.AssignAbsoluteValue();
        if ((tempMaxMovement< maxMovement) || maxMovement.IsEqualToZero())
          maxMovement = tempMaxMovement;
      }
    }
    int tempInt=2;
    if (this->RootScalarCartanRoot(theBadRoot, inputH).IsNegative())
      tempInt=-2;
    output+=theBadRoot*maxMovement/tempInt;
  }
}

bool WeylGroup::IsRegular(root& input, int* indexFirstPerpendicularRoot)
{ if (indexFirstPerpendicularRoot!=0)
    *indexFirstPerpendicularRoot=-1;
  for (int i=0; i<this->RootSystem.size; i++)
    if (this->RootScalarCartanRoot(input, this->RootSystem.TheObjects[i]).IsEqualToZero())
    { if (indexFirstPerpendicularRoot!=0)
        *indexFirstPerpendicularRoot=i;
      return false;
    }
  return true;
}

Rational DynkinDiagramRootSubalgebra::GetSizeCorrespondingWeylGroupByFormula()
{ Rational output=1;
  for (int i=0; i<this->SimpleBasesConnectedComponents.size; i++)
    output*=WeylGroup::GetSizeWeylByFormula(this->DynkinTypeStrings.TheObjects[i].at(1), this->SimpleBasesConnectedComponents.TheObjects[i].size);
  return output;
}

Rational WeylGroup::GetSizeWeylByFormula(char weylLetter, int theDim)
{ //Humphreys, Introduction to Lie algebras and representation theory(1980), page 66, Table 1
  Rational theOutput=1;
  if (weylLetter=='A')
    theOutput= Rational::Factorial(theDim+1);
  if (weylLetter=='B' || weylLetter=='C')
    theOutput= Rational::Factorial(theDim)*Rational::TwoToTheNth(theDim);
  if (weylLetter=='D')
    theOutput= Rational::Factorial(theDim)*Rational::TwoToTheNth(theDim-1);
  if (weylLetter=='E')
  { if (theDim==6)
      theOutput= 51840;
    if (theDim==7)
    { theOutput=1024;
      theOutput*=81*35;
    }
    if (theDim==8)
    { theOutput=1024*16;
      theOutput*=81*3;
      theOutput*=25*7;
    }
  }
  if (weylLetter=='F')
    theOutput=128*9;
  if (weylLetter=='G')
    theOutput=12;
  return theOutput;
}

void DynkinDiagramRootSubalgebra::GetSimpleBasisInBourbakiOrder(roots& output)
{ output.size=0;
  output.MakeActualSizeAtLeastExpandOnTop(this->RankTotal());
  for (int i=0; i<this->SimpleBasesConnectedComponents.size; i++)
    this->GetSimpleBasisInBourbakiOrderOneComponentAppend(output, i);
}

void DynkinDiagramRootSubalgebra::GetSimpleBasisInBourbakiOrderOneComponentAppend(roots& outputAppend, int index)
{ std::string& theString= this->DynkinTypeStrings.TheObjects[index];
  // the order implemented here I took from the atlas of lie groups (http://www.liegroups.org/dissemination/spherical/explorer/rootSystem.cgi)
  // which should be the Bourbaki order. The order is as follows:
  // type A all roots are from left to right (or the other way round, whichever is your orientation)
  // in type B first comes the long roots in the order they appear in the diagram;
  // in types C,
  // Types F and G there were some recent changes due to different order choice in different parts of the code.
  // The info for F and G needs to be updated!
  // in type D first comes the long string, with the end node with lowest index;
  // then come the two end one-root strings in any order.
  // in type E the order is as below
  //  2
  //13456(78)
  //(2 is connected to 4)
  //The format of this function is in accordance with WeylGroup::GetEpsilonMatrix
  assert(theString.size()>0);
  if (theString.at(1)=='A'|| theString.at(1)=='B' || theString.at(1)=='G')
    outputAppend.AddListOnTop(this->SimpleBasesConnectedComponents.TheObjects[index]);
  if (theString.at(1)=='C' || theString.at(1)=='F')
    for (int i=this->SimpleBasesConnectedComponents.TheObjects[index].size-1; i>=0; i--)
      outputAppend.AddObjectOnTop(this->SimpleBasesConnectedComponents.TheObjects[index].TheObjects[i]);
  if (theString.at(1)=='D')
  { int componentRank=this->SimpleBasesConnectedComponents.TheObjects[index].size;
    for (int i=componentRank-3; i>=0; i--)
      outputAppend.AddObjectOnTop(this->SimpleBasesConnectedComponents.TheObjects[index].TheObjects[i]);
    outputAppend.AddObjectOnTop(this->SimpleBasesConnectedComponents.TheObjects[index].TheObjects[componentRank-2]);
    outputAppend.AddObjectOnTop(this->SimpleBasesConnectedComponents.TheObjects[index].TheObjects[componentRank-1]);
  }
  if (theString.at(1)=='E')
  { int componentRank=this->SimpleBasesConnectedComponents.TheObjects[index].size;
    outputAppend.AddObjectOnTop(this->SimpleBasesConnectedComponents.TheObjects[index].TheObjects[componentRank-2]);
    outputAppend.AddObjectOnTop(this->SimpleBasesConnectedComponents.TheObjects[index].TheObjects[componentRank-1]);
    outputAppend.AddObjectOnTop(this->SimpleBasesConnectedComponents.TheObjects[index].TheObjects[componentRank-3]);
    for (int i=0; i<componentRank-3; i++)
      outputAppend.AddObjectOnTop(this->SimpleBasesConnectedComponents.TheObjects[index].TheObjects[i]);
  }
}

void DynkinDiagramRootSubalgebra::GetKillingFormMatrixUseBourbakiOrder(MatrixLargeRational& output, WeylGroup& theWeyl)
{ roots tempRoots;
  int theDimension= this->RankTotal();
  output.init(theDimension, theDimension);
  this->GetSimpleBasisInBourbakiOrder(tempRoots);
  for (int i=0; i<theDimension; i++)
    for (int j=0; j<theDimension; j++)
      output.elements[i][j]=theWeyl.RootScalarCartanRoot(tempRoots.TheObjects[i], tempRoots.TheObjects[j]);
}

void slTwo::ComputeModuleDecompositionAmbientLieAlgebra(GlobalVariables& theGlobalVariables)
{ this->ComputeModuleDecomposition(this->owner->theWeyl.RootsOfBorel, this->owner->theWeyl.CartanSymmetric.NumRows, this->highestWeights, this->multiplicitiesHighestWeights, this->weightSpaceDimensions, theGlobalVariables);
}

void slTwo::ComputeModuleDecompositionOfMinimalContainingRegularSAs(SltwoSubalgebras& owner, int IndexInOwner, GlobalVariables& theGlobalVariables)
{ this->MultiplicitiesDecompositionMinimalContainingRootSA.SetSize(this->IndicesMinimalContainingRootSA.size);
  this->HighestWeightsDecompositionMinimalContainingRootSA.SetSize(this->IndicesMinimalContainingRootSA.size);
  List<int> buffer;
  for (int i=0; i<this->IndicesMinimalContainingRootSA.size; i++)
  { rootSubalgebra& theSA= owner.theRootSAs.TheObjects[this->IndicesMinimalContainingRootSA.TheObjects[i]];
    this->ComputeModuleDecomposition(theSA.PositiveRootsK, theSA.SimpleBasisK.size, this->HighestWeightsDecompositionMinimalContainingRootSA.TheObjects[i], this->MultiplicitiesDecompositionMinimalContainingRootSA.TheObjects[i], buffer, theGlobalVariables);
  }
}

//The below code is related to sl(2) subalgebras of simple Lie algebras
void slTwo::ComputeModuleDecomposition(roots& positiveRootsContainingRegularSA, int dimensionContainingRegularSA, List<int>& outputHighestWeights, List<int>& outputMultiplicitiesHighestWeights, List<int>& outputWeightSpaceDimensions, GlobalVariables& theGlobalVariables)
{ int IndexZeroWeight=positiveRootsContainingRegularSA.size*2;
  outputWeightSpaceDimensions.initFillInObject(4*positiveRootsContainingRegularSA.size+1, 0);
  outputWeightSpaceDimensions.TheObjects[IndexZeroWeight]=dimensionContainingRegularSA;
  List<int> BufferHighestWeights;
  bool possible=true;
  Rational tempRat;
  roots tempRoots;
  positiveRootsContainingRegularSA.GetCoordsInBasis(this->preferredAmbientSimpleBasis, tempRoots, theGlobalVariables);
  for (int k=0; k<positiveRootsContainingRegularSA.size; k++)
  { root::RootScalarEuclideanRoot(this->hCharacteristic, tempRoots.TheObjects[k], tempRat);
    assert(tempRat.DenShort==1);
    if (tempRat.NumShort>positiveRootsContainingRegularSA.size*2)
    { possible=false;
      break;
    }
    outputWeightSpaceDimensions.TheObjects[IndexZeroWeight+tempRat.NumShort]++;
    outputWeightSpaceDimensions.TheObjects[IndexZeroWeight-tempRat.NumShort]++;
  }
  BufferHighestWeights.CopyFromBase(outputWeightSpaceDimensions);
  outputHighestWeights.MakeActualSizeAtLeastExpandOnTop(positiveRootsContainingRegularSA.size*2);
  outputMultiplicitiesHighestWeights.MakeActualSizeAtLeastExpandOnTop(positiveRootsContainingRegularSA.size*2);
  outputHighestWeights.size=0;
  outputMultiplicitiesHighestWeights.size=0;
//  this->hCharacteristic.ComputeDebugString();
  for (int j=BufferHighestWeights.size-1; j>=IndexZeroWeight; j--)
  { int topMult = BufferHighestWeights.TheObjects[j];
    if (topMult<0)
    { possible=false;
      break;
    }
    if (topMult>0)
    { outputHighestWeights.AddObjectOnTop(j-IndexZeroWeight);
      outputMultiplicitiesHighestWeights.AddObjectOnTop(topMult);
      if (j!=IndexZeroWeight)
        BufferHighestWeights.TheObjects[IndexZeroWeight*2-j]-=topMult;
      for (int k=j-2; k>=IndexZeroWeight; k-=2)
      { BufferHighestWeights.TheObjects[k]-=topMult;
        if (k!=IndexZeroWeight)
           BufferHighestWeights.TheObjects[IndexZeroWeight*2-k]-=topMult;
        assert(BufferHighestWeights.TheObjects[k]==BufferHighestWeights.TheObjects[IndexZeroWeight*2-k]);
        if(BufferHighestWeights.TheObjects[k]<0)
        { possible=false;
          break;
        }
      }
    }
  }
  assert(possible);
}

void SltwoSubalgebras::ElementToStringModuleDecompositionMinimalContainingRegularSAs(std::string& output, bool useLatex, bool useHtml)
{ std::string tempS; std::stringstream out;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToStringModuleDecompositionMinimalContainingRegularSAs(useLatex, useHtml, *this, tempS);
    out << tempS;
    if (useHtml)
      out << "\n<br>";
    out << "\n";
  }
  output=out.str();
}

void SltwoSubalgebras::ElementToStringNoGenerators(std::string& output, GlobalVariables& theGlobalVariables, WeylGroup& theWeyl, bool useLatex, bool useHtml, bool usePNG, std::string* physicalPath, std::string* htmlPathServer)
{ std::string tempS; std::stringstream out;
  std::string tooltipHchar="Let h be in the Cartan s.a. Let \\alpha_1, ..., \\alpha_n be simple roots w.r.t. h. Then the h-characteristic is the n-tuple (\\alpha_1(h), ..., \\alpha_n(h))";
  std::string tooltipVDecomposition= "The sl(2) submodules of g are parametrized by their highest weight w.r.t. h. V_l is l+1 dimensional";
  std::string tooltipContainingRegular="A regular semisimple subalgebra might contain an sl(2) such that the sl(2) has no centralizer in the regular semisimple subalgebra, but the regular semisimple subalgebra might fail to be minimal containing. This happens when another minimal containing regular semisimple subalgebra of equal rank nests as a root subalgebra in the containing SA. See Dynkin, Semisimple Lie subalgebras of semisimple Lie algebras, remark before Theorem 10.4.";
  std::string tooltipHvalue="The actual realization of h. The coordinates of h are given with respect to the fixed original simple basis. Note that the characteristic of h is given *with respect to another basis* (namely, with respect to an h-positive simple basis). I will fix this in the future (email me if you want that done sooner).";
  out << "Number of sl(2) subalgebras "<< this->size<<"\n";
  if (this->IndicesSl2decompositionFlas.size < this->size)
    usePNG = false;
  if(useHtml)
    out << "<br><br><table><tr><td style=\"padding-right:20px\">" << CGIspecificRoutines::ElementToStringTooltip("Characteristic", tooltipHchar)  << "</td><td align=\"center\" title=\"" << tooltipHvalue << "\"> h</td><td style=\"padding-left:20px\" title=\"" << tooltipVDecomposition << "\"> Decomposition of ambient Lie algebra</td> <td>Minimal containing regular semisimple SAs</td><td title=\"" << tooltipContainingRegular << "\">Containing regular semisimple SAs in which the sl(2) has no centralizer</td> </tr>";
  if (this->BadHCharacteristics.size>0)
  { if (useHtml)
      out << "<tr><td>Bad values of h</td><td>";
    this->BadHCharacteristics.ElementToString(tempS);
    out << tempS;
    if (useHtml)
      out << "</td></tr>";
  }
  for (int i=0; i<this->size; i++)
  { slTwo& theSl2= this->TheObjects[i];
    if (useHtml)
      out << "<tr><td style=\"padding-right:20px\"><a href=\"./sl2s.html#sl2index" << i << "\"title=\"" << tooltipHchar << "\" >";
    out << theSl2.hCharacteristic.ElementToString();
    if (useHtml)
      out << "</a></td><td title=\"" << tooltipHvalue << "\">";
    out << theSl2.theH.Hcomponent.ElementToString();
    if (useHtml)
      out << "</td><td style=\"padding-left:20px\" title=\"" << tooltipVDecomposition << "\">";
    if (useHtml && usePNG)
      out << "<img src=\"./fla" << this->IndicesSl2decompositionFlas.TheObjects[i]+1 << ".png\"></td><td>";
    else
    { theSl2.ElementToStringModuleDecomposition(useLatex, useHtml, tempS);
      out << tempS;
      if (useHtml)
        out << "</td><td>";
    }
    for (int j=0; j<theSl2.IndicesMinimalContainingRootSA.size; j++)
    { rootSubalgebra& currentSA= this->theRootSAs.TheObjects[theSl2.IndicesMinimalContainingRootSA.TheObjects[j]];
      CGIspecificRoutines::clearDollarSigns(currentSA.theDynkinDiagram.DebugString, tempS);
      out << "<a href=\"../rootHtml_rootSA" << theSl2.IndicesMinimalContainingRootSA.TheObjects[j] << ".html\">" << tempS << "</a>" << ";  ";
    }
    if (useHtml)
      out << "</td><td title=\"" << tooltipContainingRegular << "\">";
    for (int j=0; j<theSl2.IndicesContainingRootSAs.size; j++)
    { rootSubalgebra& currentSA= this->theRootSAs.TheObjects[theSl2.IndicesContainingRootSAs.TheObjects[j]];
      CGIspecificRoutines::clearDollarSigns(currentSA.theDynkinDiagram.DebugString, tempS);
      out << "<a href=\"../rootHtml_rootSA" << theSl2.IndicesContainingRootSAs.TheObjects[j] << ".html\">" << tempS << "</a>" << ";  ";
    }
    if (useHtml)
      out <<"</td></tr>\n";
  }
  if (useHtml)
    out << "</table><HR width=\"100%\">";
  output= out.str();
}

void SltwoSubalgebras::ElementToString(std::string& output, GlobalVariables& theGlobalVariables, WeylGroup& theWeyl, bool useLatex, bool useHtml, bool usePNG, std::string* physicalPath, std::string* htmlPathServer)
{ std::string tempS; std::stringstream out; std::stringstream body;
  PolynomialOutputFormat PolyFormatLocal;
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS, theGlobalVariables, *this, i, useLatex, useHtml, usePNG, physicalPath, htmlPathServer, PolyFormatLocal);
  //  body<< "Index "<< i<<": ";
    if(useHtml)
      body << "<br>";
    body << tempS;
    if(useHtml)
      body << "<HR width=\"100%\">";
  }
  if(useHtml)
    out << "<br>";
  this->ElementToStringNoGenerators(tempS, theGlobalVariables, theWeyl, useLatex, useHtml, usePNG, physicalPath, htmlPathServer);
  out << tempS;
  tempS = body.str();
  out << tempS;
  output = out.str();
  return;
}

void SltwoSubalgebras::ElementToHtml(GlobalVariables& theGlobalVariables, WeylGroup& theWeyl, bool usePNG, std::string& physicalPath, std::string& htmlPathServer)
{ std::string physicalPathSAs;
  std::string htmlPathServerSAs;
  physicalPathSAs= physicalPath;
  physicalPathSAs.append("../");
  htmlPathServerSAs= htmlPathServer;
  htmlPathServerSAs.append("../");
  std::string tempS;
  this->theRootSAs.ElementToHtml(tempS, physicalPathSAs, htmlPathServerSAs, this, theGlobalVariables);
  if(usePNG)
  { int numExpectedFiles= this->size*8;
    this->texFileNamesForPNG.MakeActualSizeAtLeastExpandOnTop(numExpectedFiles);
    this->texStringsEachFile.MakeActualSizeAtLeastExpandOnTop(numExpectedFiles);
    this->listSystemCommandsLatex.MakeActualSizeAtLeastExpandOnTop(numExpectedFiles);
    this->listSystemCommandsDVIPNG.MakeActualSizeAtLeastExpandOnTop(numExpectedFiles);
  }
  this->texFileNamesForPNG.size=0;
  this->texStringsEachFile.size=0;
  this->listSystemCommandsLatex.size=0;
  this->listSystemCommandsDVIPNG.size=0;
  std::stringstream out, outNotation;
  std::string fileName;
  std::fstream theFile, fileFlas;
  outNotation << "<a href=\"" << htmlPathServer << "StructureConstants.html\">Notation, structure constants and Weyl group info</a><br> <a href=\"../rootHtml.html\">Root subsystem table</a><br>";
  std::string notation= outNotation.str();
  this->ElementToString(tempS, theGlobalVariables, theWeyl, false, true, usePNG, &physicalPath, &htmlPathServer);
  out << tempS;
  if(usePNG)
  { fileName= physicalPath;
    fileName.append("sl2s.html");
    CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(theFile, fileName, false, true, false);
    tempS= out.str();
    theFile << "<HMTL><BODY>" << notation << "<a href=\"" << htmlPathServer << "sl2s_nopng.html\"> plain html for your copy+paste convenience</a><br>\n" <<tempS<<"</HTML></BODY>";
    theFile.close();
  }
  fileName= physicalPath;
  fileName.append("sl2s_nopng.html");
  this->ElementToString(tempS, theGlobalVariables, theWeyl, false, true, false, &physicalPath, &htmlPathServer);
  CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(theFile, fileName, false, true, false);
  theFile << "<HMTL><BODY>" << notation << "<a href=\"" << htmlPathServer << "sl2s.html\"> " << ".png rich html for your viewing pleasure</a><br>\n" << tempS << "</HTML></BODY>";
  theFile.close();
  fileName= physicalPath;
  fileName.append("StructureConstants.html");
  CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(theFile, fileName, false, true, false);
  this->owner.ElementToString(tempS, true, false, usePNG, theGlobalVariables, &physicalPath, &htmlPathServer, &this->texFileNamesForPNG, &this->texStringsEachFile);
  theFile << tempS;
  theFile.close();
  if (usePNG)
  { this->listSystemCommandsLatex.SetSize(this->texFileNamesForPNG.size);
    this->listSystemCommandsDVIPNG.SetSize(this->texFileNamesForPNG.size);
    for (int i=0; i<this->texFileNamesForPNG.size; i++)
    { CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(fileFlas, this->texFileNamesForPNG.TheObjects[i], false, true, false);
      fileFlas << "\\documentclass{article}\\begin{document}\\pagestyle{empty}\n" << this->texStringsEachFile.TheObjects[i] << "\n\\end{document}";
      std::stringstream tempStreamLatex, tempStreamPNG;
      tempStreamLatex << "latex " << " -output-directory=" << physicalPath << " " << this->texFileNamesForPNG.TheObjects[i];
      tempS= this->texFileNamesForPNG.TheObjects[i];
      tempS.resize(tempS.size()-4);
      tempStreamPNG << "dvipng " << tempS << ".dvi -o " << tempS << ".png -T tight";
      this->listSystemCommandsLatex.TheObjects[i]= tempStreamLatex.str();
      this->listSystemCommandsDVIPNG.TheObjects[i]=tempStreamPNG.str();
      fileFlas.close();
    }
  }
}

void ComputationSetup::CountNilradicals(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ rootSubalgebra tempSA;
  inputData.theRootSubalgebras.flagUseDynkinClassificationForIsomorphismComputation=true;
  inputData.theRootSubalgebras.flagUsingActionsNormalizerCentralizerNilradical=true;
  inputData.theRootSubalgebras.flagCountingNilradicalsOnlyNoComputation=true;
  inputData.theRootSubalgebras.UpperLimitNumElementsWeyl=0;
  inputData.theRootSubalgebras.GenerateAllReductiveRootSubalgebrasUpToIsomorphism(theGlobalVariables, inputData.WeylGroupLetter, inputData.WeylGroupIndex, true, true);
//  inputData.theRootSubalgebras.ComputeDebugString(true, false, true, 0, 0, theGlobalVariables);
  inputData.theRootSubalgebras.numNilradicalsBySA.initFillInObject(inputData.theRootSubalgebras.size, 0);
  inputData.theRootSubalgebras.ComputeAllRootSubalgebrasUpToIso(theGlobalVariables, 0, inputData.theRootSubalgebras.size-6);
  std::stringstream out;
  int total=0;
  for (int i=0; i<inputData.theRootSubalgebras.size-6; i++)
  { rootSubalgebra& currentSA= inputData.theRootSubalgebras.TheObjects[i];
    out << currentSA.theDynkinDiagram.DebugString << " & " << currentSA.theCentralizerDiagram.DebugString << " & " << inputData.theRootSubalgebras.numNilradicalsBySA.TheObjects[i] << " \\\\\n";
    total+=inputData.theRootSubalgebras.numNilradicalsBySA.TheObjects[i];
  }
  out << "Total: " << total << " nilradicals up to iso";
  std::string tempS;
  inputData.theRootSubalgebras.ElementToStringCentralizerIsomorphisms(tempS, true, false, 0, inputData.theRootSubalgebras.size-6, theGlobalVariables);
  theGlobalVariables.theIndicatorVariables.StatusString1=tempS;
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
//    (*this->theGlobalVariablesContainer->Default(), 0, this->theRootSubalgebras.size-1);
}

void rootSubalgebras::ElementToStringCentralizerIsomorphisms(std::string& output, bool useLatex, bool useHtml, int fromIndex, int NumToProcess, GlobalVariables& theGlobalVariables)
{ std::stringstream out; std::string tempS;
  //W'' stands for the graph isomorphisms of C(k_ss) extending to root system isomorphisms of the entire algebra.
  for (int i=fromIndex; i<NumToProcess; i++)
    this->GenerateKintersectBOuterIsos(this->TheObjects[i], theGlobalVariables);
  if (useLatex)
    out << "\\begin{tabular}{ccccc}$\\mathfrak{k}_{ss}$& $C(k_{ss})_{ss}$ & $\\#W''$ &$\\#W'''$&$\\#(W'''\\rtimes W'')$\\\\\\hline";
  if (useHtml)
    out << "<br><table><tr><td>k_{ss}</td><td></td><td>Weyl group of C(k_{ss})_{ss}</td><td>Outer automorphisms of C(k_{ss})_{ss}<td></tr>";
  roots emptyRoots;
  emptyRoots.size=0;
  for (int i=fromIndex; i<NumToProcess; i++)
  { rootSubalgebra& current= this->TheObjects[i];
    ReflectionSubgroupWeylGroup& theOuterIsos= this->CentralizerOuterIsomorphisms.TheObjects[i];
    theOuterIsos.ComputeSubGroupFromGeneratingReflections(emptyRoots, theOuterIsos.ExternalAutomorphisms, theGlobalVariables, 0, true);
    Rational numInnerIsos = current.theCentralizerDiagram.GetSizeCorrespondingWeylGroupByFormula();
    if (useHtml)
      out << "<td>";
    current.theDynkinDiagram.ElementToString(tempS, true);
    out << tempS;
    if (useHtml)
      out << "</td><td>";
    if (useLatex)
      out << " & ";
    current.theCentralizerDiagram.ElementToString(tempS, true);
    out << tempS;
    if (useHtml)
      out << "</td><td>";
    if (useLatex)
      out << " & ";
    out << theOuterIsos.size;
    if (useHtml)
      out << "</td><td>";
    if (useLatex)
      out << " & ";
    out << numInnerIsos.ElementToString();
    if (useHtml)
      out << "</td><td>";
    if (useLatex)
      out << " & ";
    out << (numInnerIsos*theOuterIsos.size).ElementToString();
    if (useHtml)
      out << "</td></tr>";
    if (useLatex)
      out << " \\\\\n";
  }
  if (useLatex)
    out << "\\end{tabular}";
  if(useHtml)
    out << "</table><br>";
  output= out.str();
}

bool IsRegularWRT(roots& input, root& h1, root& h2, WeylGroup& theWeyl)
{ for (int i=0; i<input.size; i++)
    if (theWeyl.RootScalarCartanRoot(h1, input.TheObjects[i]).IsEqualToZero() && theWeyl.RootScalarCartanRoot(h2, input.TheObjects[i]).IsEqualToZero())
      return false;
  return true;
}

void ComputationSetup::ExperimentWithH(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ SemisimpleLieAlgebra theG;
  SltwoSubalgebras tempSl2s;
  theG.FindSl2Subalgebras(tempSl2s, inputData.WeylGroupLetter, inputData.WeylGroupIndex, theGlobalVariables);
  roots h1s, h2s;
  for (int i=0; i<tempSl2s.size; i++)
    for (int j=i+1; j<tempSl2s.size; j++)
    { root& h1= tempSl2s.TheObjects[i].theH.Hcomponent;
      root& h2= tempSl2s.TheObjects[j].theH.Hcomponent;
      if (tempSl2s.theRootSAs.AmbientWeyl.RootScalarCartanRoot(h1, h2).IsEqualToZero())
        if (IsRegularWRT(tempSl2s.theRootSAs.AmbientWeyl.RootsOfBorel, h1, h2, tempSl2s.theRootSAs.AmbientWeyl))
        { h1s.AddObjectOnTop(h1);
          h2s.AddObjectOnTop(h2);
        }
    }
  std::stringstream out;
  tempSl2s.theRootSAs.AmbientWeyl.ProjectOnTwoPlane(h1s.TheObjects[0], h2s.TheObjects[0], theGlobalVariables);
  for (int i=0; i<h1s.size; i++)
    out << "h1: " << h1s.TheObjects[i].ElementToString() << " h2: " << h2s.TheObjects[i].ElementToString() << "\n\n";
  theGlobalVariables.theIndicatorVariables.StatusString1 = out.str();
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void WeylGroup::ProjectOnTwoPlane(root& orthonormalBasisVector1, root& orthonormalBasisVector2, GlobalVariables& theGlobalVariables)
{ for (int i=0; i<this->RootSystem.size; i++)
  { double x= this->RootScalarCartanRoot(orthonormalBasisVector1, this->RootSystem.TheObjects[i]).DoubleValue()*10;
    double y= this->RootScalarCartanRoot(orthonormalBasisVector2, this->RootSystem.TheObjects[i]).DoubleValue()*10;
    theGlobalVariables.theDrawingVariables.drawLineDirectly(0, 0, x, y, 0, 0);
  }
}

void DrawingVariables::drawLineDirectly(double X1, double Y1, double X2, double Y2, unsigned long thePenStyle, int ColorIndex)
{ if (this->theDrawLineFunction!=0)
    this->theDrawLineFunction(X1+ this->centerX, Y1+ this->centerY, X2+ this->centerX, Y2+ this->centerY, thePenStyle, ColorIndex);
}

void ComputationSetup::DyckPathPolytopeComputation(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ inputData.flagDyckPathComputationLoaded=inputData.thePartialFraction.theChambers.ReadFromFile("./DyckPathPolytope.txt", theGlobalVariables);
  inputData.thePartialFraction.theChambers.ComputeDebugString();
  assert(inputData.thePartialFraction.theChambers.ConsistencyCheck(false, theGlobalVariables));
  IrreducibleFiniteDimensionalModule theModule;
  QuasiPolynomialOld tempP;
  if (!inputData.flagDyckPathComputationLoaded)
    theModule.InitAndPrepareTheChambersForComputation(3, inputData.thePartialFraction.theChambers, theGlobalVariables);
  inputData.thePartialFraction.theChambers.flagMustStop=false;
  inputData.thePartialFraction.theChambers.flagIsRunning=true;
  inputData.thePartialFraction.theChambers.flagReachSafePointASAP=false;
  inputData.flagDyckPathComputationLoaded=true;
  inputData.thePartialFraction.LimitSplittingSteps=100000;
  inputData.thePartialFraction.flagUsingCheckSum=true;
  inputData.thePartialFraction.flagAnErrorHasOccurredTimeToPanic=true;
  inputData.thePartialFraction.theChambers.thePauseController.InitComputation();
  inputData.thePartialFraction.theChambers.theDirections.ComputeDebugString();
  theGlobalVariables.theIndicatorVariables.StatusString1=inputData.thePartialFraction.theChambers.theDirections.DebugString;
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.MakeReport();
  inputData.thePartialFraction.theChambers.flagUsingStartingConesSeparation=true;
  inputData.thePartialFraction.theChambers.SliceTheEuclideanSpace(theGlobalVariables, true);
  inputData.thePartialFraction.DoTheFullComputation(theGlobalVariables);
  inputData.thePartialFraction.ComputeDebugString(theGlobalVariables);
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.theIndicatorVariables.StatusString1= inputData.thePartialFraction.DebugString;
  theGlobalVariables.MakeReport();
}

void ComputationSetup::TestGraphicalOutputPolys(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ PolynomialRationalCoeff tempP;
  Rational tempRat1=-1;
  Rational tempRat2= 2;
  tempP.MakeNVarDegOnePoly(5, 0, 4, tempRat1, tempRat2);
  tempP.RaiseToPower(8, (Rational) 1);
  DrawElementInputOutput theDrawData;
  theDrawData.TopLeftCornerX=50;
  theDrawData.TopLeftCornerY=50;
  PolynomialOutputFormat PolyFormatLocal;
  tempP.DrawElement(theGlobalVariables, theDrawData, PolyFormatLocal);
}

void ComputationSetup::ComputeReductiveSAs(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ reductiveSubalgebras theRedSAs;
  theRedSAs.FindTheReductiveSubalgebras(inputData.WeylGroupLetter, inputData.WeylGroupIndex, theGlobalVariables);
}

void reductiveSubalgebras::FindTheReductiveSubalgebras(char WeylLetter, int WeylIndex, GlobalVariables& theGlobalVariables)
{ //this->theSl2s.owner.FindSl2Subalgebras(this->theSl2s, WeylLetter, WeylIndex, theGlobalVariables);
  this->theSl2s.owner.FindSl2Subalgebras(this->theSl2s, WeylLetter, WeylIndex, theGlobalVariables);
  this->theSl2s.ComputeModuleDecompositionsOfMinimalContainingRegularSAs(theGlobalVariables);
  this->GenerateModuleDecompositionsPrincipalSl2s(WeylIndex, theGlobalVariables);
  this->MatchActualSl2sFixedRootSAToPartitionSl2s(theGlobalVariables);
  this->MakeSelectionBasedOnPrincipalSl2s(theGlobalVariables);
  std::string tempS; std::stringstream out;
  //this->theSl2s.ComputeDebugString(theGlobalVariables, this->theSl2s.theRootSAs.AmbientWeyl, false, false);
//  theGlobalVariables.theIndicatorVariables.StatusString1= this->theSl2s.DebugString;
  this->ElementToStringCandidatePrincipalSl2s(false, true, tempS, theGlobalVariables);
  out << tempS;
//  this->theSl2s.ElementToStringModuleDecompositionMinimalContainingRegularSAs(tempS, false, true);
//  out << tempS;
  this->theSl2s.ElementToString(tempS, theGlobalVariables, this->theSl2s.theRootSAs.AmbientWeyl, false, true, false, 0, 0);
  out << tempS;
  theGlobalVariables.theIndicatorVariables.StatusString1.append(tempS);
  theGlobalVariables.theIndicatorVariables.StatusString1= out.str();
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.FeedIndicatorWindow(theGlobalVariables.theIndicatorVariables);
}

void reductiveSubalgebras::MakeSelectionBasedOnPrincipalSl2s(GlobalVariables& theGlobalVariables)
{ this->RemainingCandidates.init(this->theLetters.size);
  for (int i=0; i<this->theLetters.size; i++)
    if (this->IndicesMatchingActualSl2s.TheObjects[i].size>0)
    { SltwoSubalgebras& theCurrentAlgebrasSl2s= this->theCandidateSubAlgebras.TheObjects[i];
      SemisimpleLieAlgebra& theSSLieAlgebra= theCurrentAlgebrasSl2s.owner;
      theSSLieAlgebra.FindSl2Subalgebras(theCurrentAlgebrasSl2s, theGlobalVariables);
      bool DoesFit=true;
      for (int j=0; j<theCurrentAlgebrasSl2s.size; j++)
      { slTwo& currentSl2= theCurrentAlgebrasSl2s.TheObjects[j];
        bool currentSl2Fits=false;
        for (int k=0; k<this->theSl2s.size; k++)
        { slTwo& other= this->theSl2s.TheObjects[k];
          currentSl2Fits=currentSl2.ModuleDecompositionFitsInto(currentSl2.highestWeights, currentSl2.multiplicitiesHighestWeights, other.highestWeights, other.multiplicitiesHighestWeights);
          if (currentSl2Fits)
            break;
        }
        if (!currentSl2Fits)
        { DoesFit=false;
          break;
        }
      }
      if (DoesFit)
        this->RemainingCandidates.AddSelectionAppendNewIndex(i);
    }
}

void reductiveSubalgebras::GenerateModuleDecompositionsPrincipalSl2s(int theRank, GlobalVariables& theGlobalVariables)
{ this->EnumerateAllPossibleDynkinDiagramsOfRankUpTo(theRank);
  slTwo tempSl2;
  this->CandidatesPrincipalSl2ofSubalgebra.MakeActualSizeAtLeastExpandOnTop(this->theLetters.size);
  this->theCandidateSubAlgebras.SetSize(this->theLetters.size);
  for (int i=0; i<this->theLetters.size; i++)
  { this->theCandidateSubAlgebras.TheObjects[i].theRootSAs.AmbientWeyl.MakeFromDynkinType(this->theLetters.TheObjects[i], this->theRanks.TheObjects[i], &this->theMultiplicities.TheObjects[i]);
    this->theCandidateSubAlgebras.TheObjects[i].theRootSAs.AmbientWeyl.GenerateRootSystemFromKillingFormMatrix();
    this->theCandidateSubAlgebras.TheObjects[i].owner.theWeyl.Assign(this->theCandidateSubAlgebras.TheObjects[i].theRootSAs.AmbientWeyl);
    int theDimension = this->theCandidateSubAlgebras.TheObjects[i].theRootSAs.AmbientWeyl.CartanSymmetric.NumRows;
    tempSl2.hCharacteristic.initFillInObject(theDimension, 2);
    tempSl2.preferredAmbientSimpleBasis.MakeEiBasis(theDimension);
    tempSl2.owner = &this->theCandidateSubAlgebras.TheObjects[i].owner;
    tempSl2.ComputeModuleDecompositionAmbientLieAlgebra(theGlobalVariables);
    this->CandidatesPrincipalSl2ofSubalgebra.AddObjectOnTopHash(tempSl2);
  }
}

void reductiveSubalgebras::EnumerateAllPossibleDynkinDiagramsOfRankUpTo(int theRank)
{ this->GenerateAllPartitionsUpTo(theRank);
  this->theLetters.size=0;
  this->theMultiplicities.size=0;
  this->theRanks.size=0;
  List<int> ranksBuffer, multiplicitiesBuffer;
  List<char> lettersBuffer;
  for (int i=0; i<this->thePartitionMultiplicities.size; i++)
    this->GenerateAllDiagramsForPartitionRecursive(i, 0, ranksBuffer, multiplicitiesBuffer, lettersBuffer);
}

void reductiveSubalgebras::GenerateAllDiagramsForPartitionRecursive(int indexPartition, int indexInPartition, List<int>& ranksBuffer, List<int>& multiplicitiesBuffer, List<char>& lettersBuffer)
{ List<int>& partitionValues= this->thePartitionValues.TheObjects[indexPartition];
  List<int>& partitionMults= this->thePartitionMultiplicities.TheObjects[indexPartition];
  if (indexInPartition>= partitionValues.size)
  { this->theLetters.AddObjectOnTop(lettersBuffer);
    this->theMultiplicities.AddObjectOnTop(multiplicitiesBuffer);
    this->theRanks.AddObjectOnTop(ranksBuffer);
    return;
  }
  Selection DistributionBetweenTheFourLetters;
  int theMult = partitionMults.TheObjects[indexInPartition];
  int theRank = partitionValues.TheObjects[indexInPartition];
  int numLetters;
  List<char> lettersAvailable; lettersAvailable.SetSize(5);
  lettersAvailable.TheObjects[0]='A';
  lettersAvailable.TheObjects[1]='B';
  lettersAvailable.TheObjects[2]='C';
  lettersAvailable.TheObjects[3]='D';
  switch(theRank)
  { case 1: numLetters=1; break;
    case 2: numLetters=3; lettersAvailable.TheObjects[2]='G'; break;
    case 3: numLetters=3; break;
    case 4: numLetters=5; lettersAvailable.TheObjects[4]='F'; break;
    case 6: numLetters=5; lettersAvailable.TheObjects[4]='E'; break;
    case 7: numLetters=5; lettersAvailable.TheObjects[4]='E'; break;
    case 8: numLetters=5; lettersAvailable.TheObjects[4]='E'; break;
    default: numLetters=4; break;
  }
  int numBars=numLetters-1;
  DistributionBetweenTheFourLetters.init(numBars+theMult); //there are numLetters letters, therefore we need numLetters-1 barriers in numLetters-1+theMult cells to record a partition of mult into 7 letters.
  int numCycles= MathRoutines::NChooseK(DistributionBetweenTheFourLetters.MaxSize, numBars);
  int oldsize= ranksBuffer.size;
  for (int i=0; i<numCycles; i++)
  { DistributionBetweenTheFourLetters.incrementSelectionFixedCardinality(numBars);
    int startIndex=-1;
    int endIndex;
    for (int k=0; k< numLetters; k++)
    { if (k!=0)
        startIndex= DistributionBetweenTheFourLetters.elements[k-1];
      if (k!=numBars)
        endIndex= DistributionBetweenTheFourLetters.elements[k];
      else
        endIndex= DistributionBetweenTheFourLetters.MaxSize;
      int numIsotypic= endIndex-startIndex-1;
      if (numIsotypic!=0)
      { ranksBuffer.AddObjectOnTop(theRank);
        lettersBuffer.AddObjectOnTop(lettersAvailable.TheObjects[k]);
        multiplicitiesBuffer.AddObjectOnTop(numIsotypic);
      }
    }
    this->GenerateAllDiagramsForPartitionRecursive(indexPartition, indexInPartition+1, ranksBuffer, multiplicitiesBuffer, lettersBuffer);
    ranksBuffer.size=oldsize;
    multiplicitiesBuffer.size=oldsize;
    lettersBuffer.size=oldsize;
  }
}

void reductiveSubalgebras::MatchRealSl2sToPartitionSl2s()
{ this->IndicesMatchingSl2s.SetSize(this->theLetters.size);
  for (int i=0; i<this->CandidatesPrincipalSl2ofSubalgebra.size; i++)
  { this->IndicesMatchingSl2s.TheObjects[i].size=0;
    for (int j=0; j<this->theSl2s.size; j++)
      if (this->CandidatesPrincipalSl2ofSubalgebra.TheObjects[i].ModuleDecompositionFitsInto(this->theSl2s.TheObjects[j]))
        this->IndicesMatchingSl2s.TheObjects[i].AddObjectOnTop(j);
  }
}

void reductiveSubalgebras::MatchActualSl2sFixedRootSAToPartitionSl2s(GlobalVariables& theGlobalVariables)
{ this->theSl2s.ComputeModuleDecompositionsOfMinimalContainingRegularSAs(theGlobalVariables);
  List<int> tempL;
  this->IndicesMatchingActualSl2s.initFillInObject(this->theLetters.size, tempL);
  this->IndicesMatchingPartitionSl2s.initFillInObject(this->theSl2s.size, tempL);
  for (int i=0; i<this->theSl2s.size; i++)
  { slTwo& theSl2= this->theSl2s.TheObjects[i];
    for (int j=0; j<theSl2.IndicesMinimalContainingRootSA.size; j++)
      for (int k=0; k<this->CandidatesPrincipalSl2ofSubalgebra.size; k++)
      { slTwo& candidateSl2= this->CandidatesPrincipalSl2ofSubalgebra.TheObjects[k];
        if (theSl2.ModuleDecompositionFitsInto(candidateSl2.highestWeights, candidateSl2.multiplicitiesHighestWeights, theSl2.HighestWeightsDecompositionMinimalContainingRootSA.TheObjects[j], theSl2.MultiplicitiesDecompositionMinimalContainingRootSA.TheObjects[j]))
        { this->IndicesMatchingActualSl2s.TheObjects[k].AddObjectOnTop(i);
          this->IndicesMatchingPartitionSl2s.TheObjects[i].AddObjectOnTop(k);
        }
      }
  }
}

bool slTwo::ModuleDecompositionFitsInto(const slTwo& other)
{ return this->ModuleDecompositionFitsInto(this->highestWeights, this->multiplicitiesHighestWeights, other.highestWeights, other.multiplicitiesHighestWeights);
}

bool slTwo::ModuleDecompositionFitsInto(const List<int>& highestWeightsLeft, const List<int>& multiplicitiesHighestWeightsLeft, const List<int>& highestWeightsRight, const List<int>& multiplicitiesHighestWeightsRight)
{ for (int i=0; i<highestWeightsLeft.size; i++)
  { int theIndex= highestWeightsRight.IndexOfObject(highestWeightsLeft.TheObjects[i]);
    if (theIndex==-1)
      return false;
    else
      if (multiplicitiesHighestWeightsLeft.TheObjects[i]>multiplicitiesHighestWeightsRight.TheObjects[theIndex])
        return false;
  }
  return true;
}

void reductiveSubalgebras::GenerateAllPartitionsRecursive(int remainingToBePartitioned, int CurrentValue, List<int>& Multiplicities, List<int>& Values)
{ if (remainingToBePartitioned==0)
  { this->thePartitionMultiplicities.AddObjectOnTop(Multiplicities);
    this->thePartitionValues.AddObjectOnTop(Values);
    return;
  }
  int possibleMults=(remainingToBePartitioned/CurrentValue)+1;
  for(int i=0; i<possibleMults; i++)
  { if (i>0)
    { Multiplicities.AddObjectOnTop(i);
      Values.AddObjectOnTop(CurrentValue);
    }
    int newRemainder = remainingToBePartitioned - i*CurrentValue;
    int newCurrentValue = MathRoutines::Minimum(CurrentValue-1, newRemainder);
    if (newCurrentValue!=0 || newRemainder==0)
      this->GenerateAllPartitionsRecursive(newRemainder, newCurrentValue, Multiplicities, Values);
    if (i>0)
    { Multiplicities.size--;
      Values.size--;
    }
  }
}

void reductiveSubalgebras::GenerateAllPartitionsUpTo(int theRank)
{ this->thePartitionMultiplicities.size=0;
  this->thePartitionValues.size=0;
  for (int i=1; i<=theRank; i++)
    this->GenerateAllPartitionsDontInit(i);
}

void reductiveSubalgebras::GenerateAllPartitionsDontInit(int theRank)
{ int upperLimit= MathRoutines::TwoToTheNth(theRank);
  this->thePartitionMultiplicities.MakeActualSizeAtLeastExpandOnTop(upperLimit);
  this->thePartitionValues.MakeActualSizeAtLeastExpandOnTop(upperLimit);
  List<int> buffer1, buffer2;
  this->GenerateAllPartitionsRecursive(theRank, theRank, buffer1, buffer2);
}

void reductiveSubalgebras::ElementToStringDynkinType(int theIndex, bool useLatex, bool useHtml, std::string& output)
{ std::stringstream out;
  for (int j=0; j<this->theLetters.TheObjects[theIndex].size; j++)
  { int theMult= this->theMultiplicities.TheObjects[theIndex].TheObjects[j];
    int theRank= this->theRanks.TheObjects[theIndex].TheObjects[j];
    char theLetter= this->theLetters.TheObjects[theIndex].TheObjects[j];
    if (theMult!=1)
      out << theMult;
    out << theLetter << "_" << theRank << " ";
    if (j!=this->theLetters.TheObjects[theIndex].size-1)
      out << "+ ";
  }
  output=out.str();
}

void reductiveSubalgebras::ElementToStringCandidatePrincipalSl2s(bool useLatex, bool useHtml, std::string& output, GlobalVariables& theGlobalVariables)
{ std::stringstream out; std::string tempS;
  for (int i =0; i<this->thePartitionValues.size; i++)
  { for (int j=0; j< this->thePartitionValues.TheObjects[i].size; j++)
    { int mult= this->thePartitionMultiplicities.TheObjects[i].TheObjects[j];
      int val= this->thePartitionValues.TheObjects[i].TheObjects[j];
      if (mult!=1)
        out << mult << " x ";
      out << val << " ";
      if (j!=this->thePartitionValues.TheObjects[i].size-1)
        out << "+ ";
    }
    if (useHtml)
      out << "\n<br>";
    out << "\n";
  }
  for (int i=0; i<this->theLetters.size; i++)
  { this->ElementToStringDynkinType(i, useLatex, useHtml, tempS);
    out << tempS << "     Module decomposition: ";
    slTwo& theSl2= this->CandidatesPrincipalSl2ofSubalgebra.TheObjects[i];
    theSl2.ElementToStringModuleDecomposition(useLatex, useHtml, tempS);
    out << tempS;
    if (this->IndicesMatchingActualSl2s.size>0)
    { out << " Matching actual sl(2)'s: ";
      for (int j=0; j<this->IndicesMatchingActualSl2s.TheObjects[i].size; j++)
      { int tempI= this->IndicesMatchingActualSl2s.TheObjects[i].TheObjects[j];
        out << this->theSl2s.TheObjects[tempI].hCharacteristic.ElementToString() << ", ";
      }
    }
    if (useHtml)
      out << "\n<br>";
    out << "\n";
  }
  out << "Remaining candidates:\n";
  if (useHtml)
    out << "<br>\n";
  for (int i=0; i<this->theCandidateSubAlgebras.size; i++)
  { SltwoSubalgebras& currentSl2s= this->theCandidateSubAlgebras.TheObjects[i];
    if (currentSl2s.size>0)
    { this->ElementToStringDynkinType(i, useLatex, useHtml, tempS);
      out << tempS;
      if (this->RemainingCandidates.selected[i])
        out << " orbits fit\n";
      else
        out << " orbits do not fit, embedding impossible\n";
      if (useHtml)
        out << "<br>\n";
      currentSl2s.ElementToStringNoGenerators(tempS, theGlobalVariables, currentSl2s.theRootSAs.AmbientWeyl, useLatex, useHtml, false, 0, 0);
      out << tempS;
    }
  }
  output=out.str();
}

void WeylGroup::MakeFromDynkinType(List<char>& theLetters, List<int>& theRanks, List<int>* theMultiplicities)
{ WeylGroup tempW;
  this->CartanSymmetric.init(0, 0);
  for (int i=0; i<theLetters.size; i++)
  { tempW.MakeArbitrary(theLetters.TheObjects[i], theRanks.TheObjects[i]);
    int numSummands=1;
    if (theMultiplicities!=0)
      numSummands =theMultiplicities->TheObjects[i];
    for (int j=0; j<numSummands; j++)
      this->CartanSymmetric.DirectSumWith(tempW.CartanSymmetric, (Rational) 0);
  }
}

void CombinatorialChamberContainer::WriteToFile(std::fstream& output, GlobalVariables& theGlobalVariables)
{ this->LabelChamberIndicesProperly();
  output << "Num_pointers: " << this->size << "\n";
///////////////////////////////////////////////////
  output << "Dimension: " << this->AmbientDimension << "\n";
  output << "Using_separating_cones: " << this->flagUsingStartingConesSeparation << "\n";
  output << "CurrentIndex: " << this->theCurrentIndex << "\n";
  output << "Directions:\n";
  this->theDirections.WriteToFile(output, theGlobalVariables);
  output << "\nNext_index_to_slice: " << this->indexNextChamberToSlice << "\n";
  output << "\nLowestNonCheckedForGlueing: " << this->indexLowestNonCheckedForGlueing << "\n";
  output << "\nTotalGlued: " << this->NumTotalGlued << "\n";
  output << "FirstNonExploredIndex: " << this->FirstNonExploredIndex << "\n";
  this->TheGlobalConeNormals.WriteToFile(output, theGlobalVariables);
  output << "\n";
  this->startingCones.WriteToFile(output, theGlobalVariables);
  output << "\nTheFacets: ";
  this->theHyperplanes.WriteToFile(output);
////////////////////////////////////////////////////
  output << "\nPreferredNextChambers: " << this->PreferredNextChambers.size << " ";
  for (int i=0; i<this->PreferredNextChambers.size; i++)
    output << this->PreferredNextChambers.TheObjects[i] << " ";
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
    { output << "\nChamber:\n";
      this->TheObjects[i]->WriteToFile(output, theGlobalVariables);
    } else
      output << "Empty\n";
}

void CombinatorialChamberContainer::ReadFromFile(std::fstream& input, GlobalVariables& theGlobalVariables)
{ std::string tempS;
  input.seekg(0);
  this->KillAllElements();
  int tempI;
  input >> tempS >> tempI;
  this->initAndCreateNewObjects(tempI);
///////////////////////////////////////////////////
  input >> tempS >> this->AmbientDimension;
  input >> tempS >> this->flagUsingStartingConesSeparation;
  input >> tempS >> this->theCurrentIndex;
  input >> tempS;
  this->theDirections.ReadFromFile(input, theGlobalVariables);
  input >> tempS >> this->indexNextChamberToSlice;
  input >> tempS >> this->indexLowestNonCheckedForGlueing;
  input >> tempS >> this->NumTotalGlued;
  input >> tempS >> this->FirstNonExploredIndex;
  this->TheGlobalConeNormals.ReadFromFile(input, theGlobalVariables);
  this->startingCones.ReadFromFile(input, theGlobalVariables);
  input >> tempS;
  this->theHyperplanes.ReadFromFile(input);
////////////////////////////////////////////////////
  input >> tempS >> tempI;
  this->PreferredNextChambers.SetSize(tempI);
  for (int i=0; i<this->PreferredNextChambers.size; i++)
    input >> this->PreferredNextChambers.TheObjects[i];
  for (int i=0; i<this->size; i++)
  { input >> tempS;
    if (tempS=="Chamber:")
      this->TheObjects[i]->ReadFromFile(input, theGlobalVariables, *this);
    else
    { assert (tempS=="Empty");
      delete this->TheObjects[i];
      this->TheObjects[i]=0;
    }
    std::stringstream out;
    out << "reading chamber " << i+1 <<" out of " << this->size;
    theGlobalVariables.theIndicatorVariables.ProgressReportString1=out.str();
    theGlobalVariables.MakeReport();
  }
  this->flagIsRunning=false;
  this->flagMustStop=false;
  this->flagReachSafePointASAP=false;
}

void DrawOperations::drawLineBetweenTwoVectorsBuffer(root& vector1, root& vector2, unsigned long thePenStyle, int ColorIndex)
{ this->TypeNthDrawOperation.AddObjectOnTop(this->typeDrawLineBetweenTwoVectors);
  this->IndexNthDrawOperation.AddObjectOnTop(this->theDrawLineBetweenTwoRootsOperations.size);
  this->theDrawLineBetweenTwoRootsOperations.AddObjectOnTopCreateNew();
  this->theDrawLineBetweenTwoRootsOperations.LastObject()->init(vector1, vector2, thePenStyle, ColorIndex);
}

void DrawOperations::drawTextAtVectorBuffer(root& input, const std::string& inputText, int ColorIndex, int theFontSize, int theTextStyle)
{ this->TypeNthDrawOperation.AddObjectOnTop(this->typeDrawTextAtVector);
  this->IndexNthDrawOperation.AddObjectOnTop(this->theDrawTextAtVectorOperations.size);
  this->theDrawTextAtVectorOperations.AddObjectOnTopCreateNew();
  this->theDrawTextAtVectorOperations.LastObject()->init(input, inputText, ColorIndex, theFontSize, theTextStyle);
}

void DrawOperations::drawLineBuffer(double X1, double Y1, double X2, double Y2, unsigned long thePenStyle, int ColorIndex)
{ this->TypeNthDrawOperation.AddObjectOnTop(this->typeDrawLine);
  this->IndexNthDrawOperation.AddObjectOnTop(this->theDrawLineOperations.size);
  this->theDrawLineOperations.AddObjectOnTopCreateNew();
  this->theDrawLineOperations.LastObject()->init(X1, Y1, X2, Y2, thePenStyle, ColorIndex);
}

void DrawOperations::drawTextBuffer(double X1, double Y1, const std::string& inputText, int ColorIndex, int theFontSize, int theTextStyle)
{ this->TypeNthDrawOperation.AddObjectOnTop(this->typeDrawText);
  this->IndexNthDrawOperation.AddObjectOnTop(this->theDrawTextOperations.size);
  this->theDrawTextOperations.AddObjectOnTopCreateNew();
  this->theDrawTextOperations.LastObject()->init(X1, Y1, inputText, ColorIndex, theFontSize, theTextStyle);
}

void DrawingVariables::drawBuffer()
{ double x1, x2, y1, y2; int currentPenStyle, currentTextStyle;
  for (int i=0; i<this->theBuffer.IndexNthDrawOperation.size; i++)
    switch (this->theBuffer.TypeNthDrawOperation.TheObjects[i])
    { case DrawOperations::typeDrawText:
        if (this->theDrawTextFunction!=0)
        { DrawTextOperation& theDrawTextOp= this->theBuffer.theDrawTextOperations.TheObjects[this->theBuffer.IndexNthDrawOperation.TheObjects[i]];
          currentTextStyle=this->GetActualTextStyleFromFlagsAnd(theDrawTextOp.TextStyle);
          if (currentTextStyle==this->TextStyleInvisible)
            break;
          this->theDrawTextFunction(theDrawTextOp.X1, theDrawTextOp.Y1, theDrawTextOp.theText.c_str(), theDrawTextOp.theText.size(), theDrawTextOp.ColorIndex, theDrawTextOp.fontSize);
        }
        break;
      case DrawOperations::typeDrawLine:
        if (this->theDrawLineFunction!=0)
        { DrawLineOperation& theDrawLineOp= this->theBuffer.theDrawLineOperations.TheObjects[this->theBuffer.IndexNthDrawOperation.TheObjects[i]];
          currentPenStyle= this->GetActualPenStyleFromFlagsAnd(theDrawLineOp.thePenStyle);
          if (currentPenStyle==this->PenStyleInvisible)
            break;
          this->theDrawLineFunction(theDrawLineOp.X1, theDrawLineOp.Y1, theDrawLineOp.X2, theDrawLineOp.Y2, currentPenStyle, theDrawLineOp.ColorIndex);
        }
        break;
      case DrawOperations::typeDrawLineBetweenTwoVectors:
        if (this->theDrawLineFunction!=0)
        { DrawLineBetweenTwoRootsOperation& theDrawLineBnTwoOp= this->theBuffer.theDrawLineBetweenTwoRootsOperations.TheObjects[this->theBuffer.IndexNthDrawOperation.TheObjects[i]];
          currentPenStyle= this->GetActualPenStyleFromFlagsAnd(theDrawLineBnTwoOp.thePenStyle);
          if (currentPenStyle==this->PenStyleInvisible)
            break;
          this->GetCoordsForDrawing(*this, theDrawLineBnTwoOp.v1, x1, y1);
          this->GetCoordsForDrawing(*this, theDrawLineBnTwoOp.v2, x2, y2);
          this->theDrawLineFunction(x1, y1, x2, y2, currentPenStyle, theDrawLineBnTwoOp.ColorIndex);
        }
        break;
      case DrawOperations::typeDrawTextAtVector:
        if (this->theDrawTextFunction!=0)
        { DrawTextAtVectorOperation& theDrawTextOp= this->theBuffer.theDrawTextAtVectorOperations.TheObjects[this->theBuffer.IndexNthDrawOperation.TheObjects[i]];
          currentTextStyle= this->GetActualTextStyleFromFlagsAnd(theDrawTextOp.TextStyle);
          if (currentTextStyle==this->TextStyleInvisible)
            break;
          this->GetCoordsForDrawing(*this, theDrawTextOp.theVector, x1, y1);
          this->theDrawTextFunction(x1, y1, theDrawTextOp.theText.c_str(), theDrawTextOp.theText.size(), theDrawTextOp.ColorIndex, theDrawTextOp.fontSize);
        }
        break;
      default: break;
    }
}

int DrawingVariables::GetActualPenStyleFromFlagsAnd(int inputPenStyle)
{ if (inputPenStyle==this->PenStyleInvisible)
    return this->PenStyleInvisible;
  if (inputPenStyle== this->PenStyleDashed)
    return this->PenStyleDashed;
  if (inputPenStyle==this->PenStyleDotted)
    return this->PenStyleDotted;
  if (inputPenStyle==this->PenStyleNormal)
    return this->PenStyleNormal;
  if (!this->flagDrawingInvisibles)
    if (inputPenStyle == this->PenStyleLinkToOriginPermanentlyZeroChamber || inputPenStyle == this->PenStyleLinkToOriginZeroChamber || inputPenStyle == this->PenStyleZeroChamber || inputPenStyle == this->PenStylePermanentlyZeroChamber)
      return this->PenStyleInvisible;
  if (inputPenStyle==this->PenStyleLinkToOrigin || inputPenStyle==this->PenStyleLinkToOriginPermanentlyZeroChamber || inputPenStyle==this->PenStyleLinkToOriginZeroChamber)
  { if (this->flagDrawingLinkToOrigin)
      return this->PenStyleDashed;
    else
      return this->PenStyleInvisible;
  }
  if (inputPenStyle==this->PenStylePermanentlyZeroChamber || inputPenStyle==this->PenStyleZeroChamber)
    return this->PenStyleDotted;
  return this->PenStyleNormal;
}

int DrawingVariables::GetActualTextStyleFromFlagsAnd(int inputTextStyle)
{ if (inputTextStyle==this->TextStyleInvisible)
    return this->TextStyleInvisible;
  if (inputTextStyle==this->TextStyleNormal)
    return this->TextStyleNormal;
  if (!this->flagDrawChamberIndices && (inputTextStyle==this->TextStyleChamber || inputTextStyle==this->TextStylePermanentlyZeroChamber || inputTextStyle==this->TextStyleZeroChamber))
    return this->TextStyleInvisible;
  if (!this->flagDrawingInvisibles && (inputTextStyle==this->TextStylePermanentlyZeroChamber || inputTextStyle==this->TextStyleZeroChamber))
    return this->TextStyleInvisible;
  return this->TextStyleNormal;
}

void DrawingVariables::drawLineBuffer(double X1, double Y1, double X2, double Y2, unsigned long thePenStyle, int ColorIndex)
{ this->theBuffer.drawLineBuffer(X1, Y1, X2, Y2, thePenStyle, ColorIndex);
}

void DrawingVariables::drawTextBuffer(double X1, double Y1, const std::string& inputText, int color, std::fstream* LatexOutFile)
{ this->theBuffer.drawTextBuffer(X1, Y1, inputText, color, this->fontSizeNormal, this->TextStyleNormal);
}

void DrawingVariables::drawString(DrawElementInputOutput& theDrawData, const std::string& input, int theFontSize, int theTextStyle)
{ theDrawData.outputHeight=0; theDrawData.outputWidth=0;
  if (input=="")
    return;
  for (unsigned int i=0; i<input.size(); i++)
  { std::string tempS;
    tempS=input.at(i);
    this->theBuffer.drawTextBuffer(theDrawData.outputWidth+theDrawData.TopLeftCornerX, theDrawData.outputHeight+theDrawData.TopLeftCornerY, tempS, 0, theFontSize, theTextStyle);
    theDrawData.outputWidth+=(int)(((double) theFontSize)/1.15);
  }
}

void Rational::DrawElement(GlobalVariables& theGlobalVariables, DrawElementInputOutput& theDrawData)
{ std::string tempS;
  this->ElementToString(tempS);
  theGlobalVariables.theDrawingVariables.theBuffer.drawTextBuffer(theDrawData.TopLeftCornerX, theDrawData.TopLeftCornerY, tempS, 0, theGlobalVariables.theDrawingVariables.fontSizeNormal, theGlobalVariables.theDrawingVariables.TextStyleNormal);
  theDrawData.outputHeight=10;
  theDrawData.outputWidth=10*tempS.size();
}

void ComputationSetup::LProhibitingWeightsComputation(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ if (inputData.theRootSubalgebras.controllerLProhibitingRelations.IsRunningUnsafeDeprecatedDontUse())
    return;
  rootSubalgebras& theRootSAs= inputData.theRootSubalgebras;
  inputData.theRootSubalgebras.controllerLProhibitingRelations.InitComputation();
  rootSubalgebra tempSA;
  //most important flags
  inputData.theRootSubalgebras.flagUseDynkinClassificationForIsomorphismComputation=false;
  inputData.theRootSubalgebras.flagUsingActionsNormalizerCentralizerNilradical=true;
  inputData.theRootSubalgebras.flagComputeConeCondition=true;
  inputData.theRootSubalgebras.flagComputingLprohibitingWeights=true;
  inputData.theRootSubalgebras.flagLookingForMinimalRels=true;
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  inputData.theRootSubalgebras.theGoodRelations.flagIncludeCoordinateRepresentation=false;
  inputData.theRootSubalgebras.theBadRelations.flagIncludeCoordinateRepresentation=false;
  inputData.theRootSubalgebras.theMinRels.flagIncludeCoordinateRepresentation=false;
  inputData.theRootSubalgebras.theGoodRelations.flagIncludeSubalgebraDataInDebugString=false;
  inputData.theRootSubalgebras.theBadRelations.flagIncludeSubalgebraDataInDebugString=false;
  if (!inputData.theRootSubalgebras.flagNilradicalComputationInitialized)
    if (!inputData.theRootSubalgebras.ReadFromDefaultFileNilradicalGeneration(theGlobalVariables))
    { inputData.theRootSubalgebras.GenerateAllReductiveRootSubalgebrasUpToIsomorphism(theGlobalVariables, inputData.WeylGroupLetter, inputData.WeylGroupIndex, true, true);
      inputData.theRootSubalgebras.initForNilradicalGeneration();
    }
  inputData.theRootSubalgebras.ComputeLProhibitingRelations(theGlobalVariables);
  std::string stringConeConditionSatisfying;
  if (theRootSAs.flagStoringNilradicals)
    theRootSAs.ElementToStringConeConditionNotSatisfying(stringConeConditionSatisfying, false, theGlobalVariables);
  std::string tempS;
  inputData.theRootSubalgebras.ComputeDebugString(true, false, true, 0, 0, theGlobalVariables);
  inputData.theRootSubalgebras.ElementToStringCentralizerIsomorphisms(tempS, true, false, 0, inputData.theRootSubalgebras.size-1, theGlobalVariables);
  inputData.theRootSubalgebras.DebugString.append(tempS);
  inputData.theOutput.DebugString.append("\\documentclass{article}\n\\usepackage{amssymb}\n\\usepackage{longtable}\n");
  inputData.theOutput.DebugString.append("\\addtolength{\\hoffset}{-3.5cm}\\addtolength{\\textwidth}{7cm}");
  inputData.theOutput.DebugString.append("\\addtolength{\\voffset}{-3.5cm}\\addtolength{\\textheight}{7cm}");
  inputData.theOutput.DebugString.append("\\begin{document}~");
  std::stringstream out;
  if (theRootSAs.NumConeConditionHoldsBySSpart.size==theRootSAs.size)
    for (int i=0; i< theRootSAs.size; i++)
      out << theRootSAs.TheObjects[i].theDynkinDiagram.DebugString << " " << theRootSAs.NumConeConditionHoldsBySSpart.TheObjects[i] << ";   ";
  out << "\n\n\\noindent Number of different subalgebras up to $\\mathfrak{g}$-automorphism such that $\\mathfrak{n}\\cap C(\\mathfrak{k}_{ss})$ is a nilradical of a parabolic subalgebra of $\\mathfrak{k}$: " << inputData.theRootSubalgebras.NumSubalgebrasProcessed << "\n";
  out << "\n\n\\noindent Among them " << inputData.theRootSubalgebras.NumSubalgebrasProcessed - inputData.theRootSubalgebras.NumConeConditionFailures << " satisfy the cone condition and " << inputData.theRootSubalgebras.NumConeConditionFailures << " do not." ;
  out << "\n\n";
  out << stringConeConditionSatisfying << "\n\n";
  inputData.theRootSubalgebras.theBadRelations.ComputeDebugString(inputData.theRootSubalgebras, theGlobalVariables);
  inputData.theRootSubalgebras.theGoodRelations.ComputeDebugString(inputData.theRootSubalgebras, theGlobalVariables);
  //this->theRootSubalgebras.theMinRels.ComputeDebugString
  //  (this->theRootSubalgebras, *this->theGlobalVariablesContainer->Default());
  inputData.theOutput.DebugString.append(inputData.theRootSubalgebras.DebugString);
  inputData.theOutput.DebugString.append("\n\n\n");
  tempS = out.str();
  inputData.theOutput.DebugString.append(tempS);

  if (inputData.theRootSubalgebras.theGoodRelations.size!=0)
    inputData.theOutput.DebugString.append(inputData.theRootSubalgebras.theGoodRelations.DebugString);
  inputData.theOutput.DebugString.append("\n\n\n");
  if (inputData.theRootSubalgebras.theBadRelations.size>0)
  { inputData.theOutput.DebugString.append("The bad relations: \n\n");
    inputData.theOutput.DebugString.append(inputData.theRootSubalgebras.theBadRelations.DebugString);
  }
  if (inputData.theRootSubalgebras.flagLookingForMinimalRels)
  { inputData.theOutput.DebugString.append("\n\nMinimal relations: \n\n");
    inputData.theOutput.DebugString.append(inputData.theRootSubalgebras.theMinRels.DebugString);
  }
  inputData.theOutput.DebugString.append("\\end{document}");
  theGlobalVariables.theIndicatorVariables.StatusString1= inputData.theOutput.DebugString;
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.MakeReport();
  inputData.theRootSubalgebras.controllerLProhibitingRelations.ExitComputation();
}

bool rootSubalgebras::ReadFromDefaultFileNilradicalGeneration(GlobalVariables& theGlobalVariables)
{ std::fstream theFile;
  if (CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(theFile, "./theNilradicalsGenerator.txt", false, false, false))
  { theFile.seekg(0);
    this->ReadFromFileNilradicalGeneration(theFile, theGlobalVariables);
    return true;
  }
  return false;
}

void rootSubalgebras::WriteToDefaultFileNilradicalGeneration(GlobalVariables& theGlobalVariables)
{ std::fstream theFile;
  CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(theFile, "./theNilradicalsGenerator.txt", false, true, false);
  this->WriteToFileNilradicalGeneration(theFile, theGlobalVariables);
}

void rootSubalgebras::WriteToFileNilradicalGeneration(std::fstream& output, GlobalVariables& theGlobalVariables)
{ this->AmbientWeyl.WriteToFile(output);
  output << "Number_subalgebras: " << this->size << "\n";
  //////////////////////////////////////////////////////////////////////////////////////
  output << "Index_current_SA_nilradicals_generation: " << this->IndexCurrentSANilradicalsGeneration << "\n";
  output << "Num_SAs_to_be_processed: " << this->NumReductiveRootSAsToBeProcessedNilradicalsGeneration << "\n";
  output << "Parabolics_counter_nilradical_generation: " << this->parabolicsCounterNilradicalGeneration << "\n";
  output << "Num_SAs_processed: " << this->NumSubalgebrasProcessed << "\n";
  output << "Num_cone_condition_failures: " << this->NumConeConditionFailures << "\n";
  output << "Implied_selections: ";
  this->ImpiedSelectionsNilradical.WriteToFile(output);
  output << "Counters_nilradicals_generation: ";
  output << this->CountersNilradicalsGeneration;
  output << "\nRecursion_depth: " << this->RecursionDepthNilradicalsGeneration << "\n";
  ////////////////////////////////////////////////////////////////////////////////////////
  for (int  i=0; i<this->size; i++)
    this->TheObjects[i].WriteToFileNilradicalGeneration(output, theGlobalVariables, *this);
  this->theGoodRelations.WriteToFile(output, theGlobalVariables);
  this->theBadRelations.WriteToFile(output, theGlobalVariables);
}

void rootSubalgebras::ReadFromFileNilradicalGeneration(std::fstream& input, GlobalVariables& theGlobalVariables)
{ std::string tempS; int tempI;
  this->AmbientWeyl.ReadFromFile(input);
  this->AmbientWeyl.ComputeRho(true);
  input >> tempS >> tempI;
  assert(tempS=="Number_subalgebras:");
  this->SetSize(tempI);
  //////////////////////////////////////////////////////////////////////////////////////
  input >> tempS >> this->IndexCurrentSANilradicalsGeneration;
  input >> tempS >> this->NumReductiveRootSAsToBeProcessedNilradicalsGeneration;
  input >> tempS >> this->parabolicsCounterNilradicalGeneration;
  input >> tempS >> this->NumSubalgebrasProcessed;
  input >> tempS >> this->NumConeConditionFailures;
  input >> tempS;
  this->ImpiedSelectionsNilradical.ReadFromFile(input);
  input >> tempS;
  input >> this->CountersNilradicalsGeneration;
  input >> tempS >> this->RecursionDepthNilradicalsGeneration;
  /////////////////////////////////////////////////////////////////////////////////////
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].ReadFromFileNilradicalGeneration(input, theGlobalVariables, *this);
  this->theGoodRelations.ReadFromFile(input, theGlobalVariables, *this);
  this->theBadRelations.ReadFromFile(input, theGlobalVariables, *this);
  this->flagNilradicalComputationInitialized=true;
}

void rootSubalgebra::WriteToFileNilradicalGeneration(std::fstream& output, GlobalVariables& theGlobalVariables, rootSubalgebras& owner)
{ output << "Simple_basis_k: ";
  this->SimpleBasisK.WriteToFile(output, theGlobalVariables);
}

void rootSubalgebra::ReadFromFileNilradicalGeneration(std::fstream& input, GlobalVariables& theGlobalVariables, rootSubalgebras& owner)
{ std::string tempS;
  input >> tempS;
  assert(tempS=="Simple_basis_k:");
  this->SimpleBasisK.ReadFromFile(input, theGlobalVariables);
  this->genK.CopyFromBase(this->SimpleBasisK);
  this->AmbientWeyl.Assign(owner.AmbientWeyl);
  this->ComputeAll();
}

void rootSubalgebra::GeneratePossibleNilradicalsInit(List<Selection>& impliedSelections, int& parabolicsCounter)
{ impliedSelections.SetSize(this->kModules.size+1);
  parabolicsCounter=0;
}

void rootSubalgebra::GeneratePossibleNilradicals(Controller& PauseMutex, List<Selection>& impliedSelections, int& parabolicsCounter, GlobalVariables& theGlobalVariables, bool useParabolicsInNilradical, rootSubalgebras& owner, int indexInOwner)
{  //this->ComputeAll();
  this->GenerateKmodMultTable(this->theMultTable, this->theOppositeKmods, theGlobalVariables);
  if (this->flagAnErrorHasOccuredTimeToPanic)
    this->theMultTable.ComputeDebugString(*this);
  if (this->flagAnErrorHasOccuredTimeToPanic)
    this->ComputeDebugString(theGlobalVariables);
  this->NumTotalSubalgebras=0;
  Selection emptySel;
  emptySel.init(this->SimpleBasisCentralizerRoots.size);
  owner.ComputeActionNormalizerOfCentralizerIntersectNilradical(emptySel, *this, theGlobalVariables);
  int numCycles= MathRoutines::TwoToTheNth(this->SimpleBasisCentralizerRoots.size);
  theGlobalVariables.selApproveSelAgainstOneGenerator.init(this->kModules.size);
  List<Selection> StartingNilradicalsNoRepetition;
  StartingNilradicalsNoRepetition.MakeActualSizeAtLeastExpandOnTop(numCycles);
  Selection tempSel, ParabolicsGenerator;
  if (!owner.flagNilradicalComputationInitialized)
    owner.CountersNilradicalsGeneration.SetSize(this->kModules.size+1);
  if (owner.flagStoringNilradicals)
    owner.storedNilradicals.TheObjects[indexInOwner].size=0;
  roots tempRootsTest;
  if (useParabolicsInNilradical)
  { this->flagFirstRoundCounting=false;
    ParabolicsGenerator.init(this->SimpleBasisCentralizerRoots.size);
    for (int i=0; i<numCycles; i++, ParabolicsGenerator.incrementSelection())
    { tempSel.init(this->kModules.size);
      for (int j=0; j<this->CentralizerRoots.size; j++)
        if (this->rootIsInNilradicalParabolicCentralizer(ParabolicsGenerator, this->CentralizerRoots.TheObjects[j]))
          tempSel.AddSelectionAppendNewIndex(j);
      if (owner.flagUsingActionsNormalizerCentralizerNilradical)
        owner.RaiseSelectionUntilApproval(tempSel, theGlobalVariables);
      StartingNilradicalsNoRepetition.AddOnTopNoRepetition(tempSel);
      //StartingNilradicalsNoRepetition.AddObjectOnTop(tempSel);
    }

/*      tempRootsTest.size=0;
      std::string tempS; std::stringstream out;
      for (int s=0; s<impliedSelections.TheObjects[0].CardinalitySelection; s++)
        tempRootsTest.AddObjectOnTop(this->kModules.TheObjects[impliedSelections.TheObjects[0].elements[s]].TheObjects[0]);
      tempS=out.str();
      assert(this->RootsDefineASubalgebra(tempRootsTest));*/
    for (; parabolicsCounter<StartingNilradicalsNoRepetition.size; parabolicsCounter++, owner.flagNilradicalComputationInitialized=false)
    { if (!owner.flagNilradicalComputationInitialized)
      { impliedSelections.TheObjects[0].Assign(StartingNilradicalsNoRepetition.TheObjects[parabolicsCounter]);
        owner.RecursionDepthNilradicalsGeneration=0;
        owner.CountersNilradicalsGeneration.TheObjects[0]=this->CentralizerRoots.size;
      }
      this->GeneratePossibleNilradicalsRecursive(PauseMutex, theGlobalVariables, this->theMultTable, impliedSelections, this->theOppositeKmods, owner, indexInOwner);
    }
  }
  else
  { this->flagFirstRoundCounting=false;
    impliedSelections.TheObjects[0].init(this->kModules.size);
    owner.RecursionDepthNilradicalsGeneration=0;
    owner.CountersNilradicalsGeneration.TheObjects[0]=0;
    this->GeneratePossibleNilradicalsRecursive(PauseMutex, theGlobalVariables, this->theMultTable, impliedSelections, this->theOppositeKmods, owner, indexInOwner);
  }
}

void coneRelations::WriteToFile(std::fstream& output, GlobalVariables& theGlobalVariables)
{ output << "num_rels: " << this->size << "\n";
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].WriteToFile(output, theGlobalVariables);
}

void coneRelations::ReadFromFile(std::fstream& input, GlobalVariables& theGlobalVariables, rootSubalgebras& owner)
{ std::string tempS; int tempI;
  this->ClearTheObjects();
  input >> tempS >> tempI;
  coneRelation tempRel;
  for (int i=0; i<tempI; i++)
  { tempRel.ReadFromFile(input, theGlobalVariables, owner);
    this->AddRelationNoRepetition(tempRel, owner, tempRel.IndexOwnerRootSubalgebra);
  }
}

void coneRelation::WriteToFile(std::fstream& output, GlobalVariables& theGlobalVariables)
{ this->AlphaCoeffs.WriteToFile(output);
  this->Alphas.WriteToFile(output, theGlobalVariables);
  output << this->AlphaKComponents;
  this->BetaCoeffs.WriteToFile(output);
  this->Betas.WriteToFile(output, theGlobalVariables);
  output << this->BetaKComponents;
  output << "Index_owner_root_SA: " << this->IndexOwnerRootSubalgebra << " ";
}

void coneRelation::ReadFromFile(std::fstream& input, GlobalVariables& theGlobalVariables, rootSubalgebras& owner)
{ std::string tempS;
  this->AlphaCoeffs.ReadFromFile(input);
  this->Alphas.ReadFromFile(input, theGlobalVariables);
  input >> this->AlphaKComponents;
  this->BetaCoeffs.ReadFromFile(input);
  this->Betas.ReadFromFile(input, theGlobalVariables);
  input >> this->BetaKComponents;
  input >> tempS >> this->IndexOwnerRootSubalgebra;
  assert(tempS=="Index_owner_root_SA:");
  this->ComputeTheDiagramAndDiagramRelAndK(owner.TheObjects[this->IndexOwnerRootSubalgebra]);
  this->ComputeDebugString(owner, true, true);
}

void WeylGroup::WriteToFile(std::fstream& output)
{ output << "Weyl_group: ";
  output << this->WeylLetter << " " << this->CartanSymmetric.NumRows << "\n";
  output << "Long_root_length: ";
  this->LongRootLength.WriteToFile(output);
  output << "\n";
  this->CartanSymmetric.WriteToFile(output);
}

void WeylGroup::ReadFromFile(std::fstream& input)
{ std::string tempS; int tempI;
  input >> tempS;
  input >> this->WeylLetter >> tempI >> tempS;
  assert(tempS=="Long_root_length:");
  this->LongRootLength.ReadFromFile(input);
  this->CartanSymmetric.ReadFromFile(input);
}

bool CombinatorialChamber::ElementToString(std::string& output, CombinatorialChamberContainer& owner, bool useLatex, bool useHtml, PolynomialOutputFormat& PolyFormatLocal)
{ std::stringstream out;
  std::string tempS;
  //assert(this->ExternalWalls->size== this->ExternalWallsNormals.size);
  this->SortNormals();
  std::string endOfLine;
  endOfLine="\n";
  if (useLatex)
    endOfLine.assign("\\\\\n");
  if(useHtml)
    endOfLine.assign("\n<br>\n");
  this->ChamberNumberToString(tempS, owner);
  if(!useHtml)
    out << tempS << "\n";
  else
    out << "<a name=\"" << tempS << "\">" << tempS << "</a>";
  if (useLatex)
    out << endOfLine << "Projective representation\n\n";
  out << " index in owner: " << this->IndexInOwnerComplex << "\n";
  out << "Hash_id: " << this->GetHashFromSortedNormals() << "\n";
  this->ElementToInequalitiesString(tempS, owner, useLatex, useHtml, PolyFormatLocal);
  out << tempS;
  out << "Neighbors: ";
  for (int k=0; k<this->Externalwalls.size; k++)
  { int theWallIndex= this->IndicesCorrespondingNonSortedWalls.TheObjects[k];
    out << "wall " << k+1 << ": ";
    for (int j=0; j<this->Externalwalls.TheObjects[theWallIndex].NeighborsAlongWall.size; j++)
    { CombinatorialChamber* currentChamber = this->Externalwalls.TheObjects[theWallIndex].NeighborsAlongWall.TheObjects[j];
      if (currentChamber!=0)
      { currentChamber->ChamberNumberToString(tempS, owner);
        if (useHtml)
          out << "<a href=\"#" << tempS << "\">";
        out << tempS << ", ";
        if (useHtml)
          out << "</a>";
      }
    }
  }
  PolyFormatLocal.cutOffString=false;
  if (this->flagIncludeVerticesInDebugString)
  { out << endOfLine << "Vertices: ";
    for (int i=0; i<this->AllVertices.size; i++)
    { this->AllVertices.TheObjects[i].ElementToString(tempS);
      out << tempS << ", ";
    }
  }
  out << endOfLine;
  if (!owner.flagDrawingProjective)
  { if (useLatex)
    out << "Affine data" << endOfLine;
    out << "Affine walls: " << endOfLine;
    for (int i=0; i<this->affineExternalWalls.size; i++)
    { out << "wall" << i+1 << ": ";
      this->affineExternalWalls.TheObjects[i].ElementToString(tempS);
      out << tempS << endOfLine;
    }
    out << "Affine vertices (true): " << endOfLine;
    for (int i=0; i<affineVertices.size; i++)
    { if (i==this->NumTrueAffineVertices)
        out << "Affine vertices representing pt(s) at infty: " << endOfLine;
      this->affineVertices.TheObjects[i].ElementToString(tempS);
      out << tempS << endOfLine;
    }
  }
  output=out.str();
  return true;
}

void ComputationSetup::ChamberSlice(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ if (inputData.thePartialFraction.theChambers.thePauseController.IsRunningUnsafeDeprecatedDontUse())
    return;
  inputData.thePartialFraction.theChambers.thePauseController.InitComputation();
  inputData.thePartialFraction.theChambers.ReadFromDefaultFile(theGlobalVariables);
  inputData.thePartialFraction.theChambers.theDirections.ReverseOrderElements();
  root tempRoot;
  tempRoot.MakeZero(inputData.thePartialFraction.theChambers.AmbientDimension);
  theGlobalVariables.theDrawingVariables.theBuffer.init();
  if (inputData.flagChopFully)
    inputData.thePartialFraction.theChambers.SliceAndComputeDebugString(theGlobalVariables, inputData.thePartialFraction.theChambers.flagSpanTheEntireSpace);
  else if (inputData.flagChopOneDirection)
  { inputData.thePartialFraction.theChambers.SliceOneDirection(0, theGlobalVariables);
    inputData.thePartialFraction.theChambers.ComputeDebugString(false, false);
    inputData.thePartialFraction.theChambers.drawOutput(theGlobalVariables.theDrawingVariables, tempRoot, 0);
  } else
  { inputData.thePartialFraction.theChambers.OneSlice(0, theGlobalVariables);
    inputData.thePartialFraction.theChambers.ComputeDebugString(false, false);
    inputData.thePartialFraction.theChambers.drawOutput(theGlobalVariables.theDrawingVariables, tempRoot, 0);
  }
  if (inputData.thePartialFraction.theChambers.theCurrentIndex>= inputData.thePartialFraction.theChambers.theDirections.size)
  { inputData.thePartialFraction.theChambers.PurgeZeroPolyChambers(theGlobalVariables);
    inputData.thePartialFraction.theChambers.ComputeDebugString(false);
    theGlobalVariables.theDrawingVariables.theBuffer.init();
    inputData.thePartialFraction.theChambers.drawOutput(theGlobalVariables.theDrawingVariables, tempRoot, 0);
  }
  inputData.thePartialFraction.theChambers.thePauseController.ExitComputation();
}

void CombinatorialChamberContainer::SliceAndComputeDebugString(GlobalVariables& theGlobalVariables, bool SpanTheEntireSpace)
{ this->SliceTheEuclideanSpace(theGlobalVariables, SpanTheEntireSpace);
  this->QuickSortAscending();
  this->LabelChamberIndicesProperly();
  this->PurgeInternalWalls();
  this->ComputeDebugString(false);
  root tempRoot;
  theGlobalVariables.theDrawingVariables.theBuffer.init();
  tempRoot.MakeZero(this->AmbientDimension);
  this->drawOutput(theGlobalVariables.theDrawingVariables, tempRoot, 0);
}

void ComputationSetup::TestUnitCombinatorialChamberHelperFunction(std::stringstream& logstream, char WeylLetter, int Dimension, ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ std::string tempS;
  inputData.thePartialFraction.theChambers.flagUsingStartingConesSeparation=false;
  inputData.thePartialFraction.theChambers.SetupBorelAndSlice(WeylLetter, Dimension, false, theGlobalVariables, false);
  tempS= inputData.thePartialFraction.theChambers.DebugString;
  inputData.thePartialFraction.theChambers.SetupBorelAndSlice(WeylLetter, Dimension, true, theGlobalVariables, false);
  if (tempS!=inputData.thePartialFraction.theChambers.DebugString)
    logstream << WeylLetter << Dimension << " reverse order no span IS DIFFERENT FROM regular order no span !!! Total chambers: " << inputData.thePartialFraction.theChambers.size << "\n";
  else
    logstream << WeylLetter << Dimension << " reverse order no span same as regular order no span. Total chambers: " << inputData.thePartialFraction.theChambers.size <<"\n";
  inputData.thePartialFraction.theChambers.SetupBorelAndSlice(WeylLetter, Dimension, false, theGlobalVariables, true);
  inputData.thePartialFraction.theChambers.PurgeZeroPolyChambers(theGlobalVariables);
  inputData.thePartialFraction.theChambers.ComputeDebugString(false);
  if (tempS!=inputData.thePartialFraction.theChambers.DebugString)
    logstream << WeylLetter << Dimension << " span entire space regular order full span IS DIFFERENT FROM regular order no span!!! Total chambers: " << inputData.thePartialFraction.theChambers.size << "\n";
  else
    logstream << WeylLetter << Dimension << " span entire space regular order full span same as regular order no span. Total chambers: " << inputData.thePartialFraction.theChambers.size <<"\n";
  inputData.thePartialFraction.theChambers.SetupBorelAndSlice(WeylLetter, Dimension, true, theGlobalVariables, true);
  inputData.thePartialFraction.theChambers.PurgeZeroPolyChambers(theGlobalVariables);
  inputData.thePartialFraction.theChambers.ComputeDebugString(false);
  if (tempS!=inputData.thePartialFraction.theChambers.DebugString)
    logstream << WeylLetter << Dimension << " span entire space reverse order full span IS DIFFERENT FROM regular order no span !!! Total chambers: " << inputData.thePartialFraction.theChambers.size << "\n";
  else
    logstream << WeylLetter << Dimension << " span entire space reverse order full span same as regular order no span. Total chambers: " << inputData.thePartialFraction.theChambers.size <<"\n";

  inputData.thePartialFraction.theChambers.flagUsingStartingConesSeparation=true;

  inputData.thePartialFraction.theChambers.SetupBorelAndSlice(WeylLetter, Dimension, true, theGlobalVariables, false);
  if (tempS!=inputData.thePartialFraction.theChambers.DebugString)
    logstream << WeylLetter << Dimension << " reverse order no span with cone separation optimization IS DIFFERENT FROM regular order no span !!! Total chambers: " << inputData.thePartialFraction.theChambers.size << "\n";
  else
    logstream << WeylLetter << Dimension << " reverse order no span with cone separation optimization same as regular order no span. Total chambers: " << inputData.thePartialFraction.theChambers.size <<"\n";
  inputData.thePartialFraction.theChambers.SetupBorelAndSlice(WeylLetter, Dimension, true, theGlobalVariables, true);
  inputData.thePartialFraction.theChambers.PurgeZeroPolyChambers(theGlobalVariables);
  inputData.thePartialFraction.theChambers.ComputeDebugString(false);
  if (tempS!=inputData.thePartialFraction.theChambers.DebugString)
    logstream << WeylLetter << Dimension << " span entire space reverse order full span with cone separation optimization IS DIFFERENT FROM regular order no span !!! Total chambers: " << inputData.thePartialFraction.theChambers.size << "\n";
  else
    logstream << WeylLetter << Dimension << " span entire space reverse order full span with cone separation optimization same as regular order no span. Total chambers: " << inputData.thePartialFraction.theChambers.size <<"\n";

  theGlobalVariables.theIndicatorVariables.StatusString1= logstream.str();
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.MakeReport();
}

void ComputationSetup::TestUnitCombinatorialChambersChambers(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ std::stringstream out;
  inputData.TestUnitCombinatorialChamberHelperFunction(out, 'A', 2, inputData, theGlobalVariables);
  inputData.TestUnitCombinatorialChamberHelperFunction(out, 'A', 3, inputData, theGlobalVariables);
  inputData.TestUnitCombinatorialChamberHelperFunction(out, 'B', 2, inputData, theGlobalVariables);
  inputData.TestUnitCombinatorialChamberHelperFunction(out, 'B', 3, inputData, theGlobalVariables);
  inputData.TestUnitCombinatorialChamberHelperFunction(out, 'C', 3, inputData, theGlobalVariables);
  inputData.TestUnitCombinatorialChamberHelperFunction(out, 'A', 4, inputData, theGlobalVariables);
  inputData.TestUnitCombinatorialChamberHelperFunction(out, 'D', 4, inputData, theGlobalVariables);
  inputData.TestUnitCombinatorialChamberHelperFunction(out, 'B', 4, inputData, theGlobalVariables);
  inputData.TestUnitCombinatorialChamberHelperFunction(out, 'A', 5, inputData, theGlobalVariables);
}

int CombinatorialChamber::GetHashFromSortedNormals()
{ this->SortNormals();
  int result=0;
  int topBound= MathRoutines::Minimum(SomeRandomPrimesSize, this->ExternalwallsNormalsSorted.size);
  for (int i=0; i<topBound; i++)
    result+=SomeRandomPrimes[i]*this->ExternalwallsNormalsSorted.TheObjects[i].HashFunction();
  return result;
}

void CombinatorialChamber::SortNormals()
{ if (this->flagNormalsAreSorted)
    return;
  roots originalRoots;
  this->ExternalwallsNormalsSorted.SetSize(this->Externalwalls.size);
  originalRoots.SetSize(this->Externalwalls.size);
  this->IndicesCorrespondingNonSortedWalls.SetSize(this->Externalwalls.size);
  for (int i=0; i<this->Externalwalls.size; i++)
  { this->ExternalwallsNormalsSorted.TheObjects[i] = this->Externalwalls.TheObjects[i].normal;
    originalRoots.TheObjects[i] = this->Externalwalls.TheObjects[i].normal;
  }
  this->ExternalwallsNormalsSorted.QuickSortAscending();
  for (int i=0; i<this->ExternalwallsNormalsSorted.size; i++)
    this->IndicesCorrespondingNonSortedWalls.TheObjects[i]=originalRoots.IndexOfObject(this->ExternalwallsNormalsSorted.TheObjects[i]);
}

bool CombinatorialChamber::operator>(CombinatorialChamber& right)
{ //used to allow to sort lists of pointers including eventually zero pointers. This code might be changed in the future (although it seems safe and fine to me now).
  if (this==0)
    return false;
  if (!this->flagHasZeroPolynomiaL && right.flagHasZeroPolynomiaL)
    return true;
  if (this->flagHasZeroPolynomiaL && !right.flagHasZeroPolynomiaL)
    return false;
  if (this->Externalwalls.size> right.Externalwalls.size)
    return true;
  if (this->Externalwalls.size<right.Externalwalls.size)
    return false;
  this->SortNormals();
  right.SortNormals();
  for (int i=0; i<this->Externalwalls.size; i++)
  { if (this->ExternalwallsNormalsSorted.TheObjects[i] > right.ExternalwallsNormalsSorted.TheObjects[i])
      return true;
    if (right.ExternalwallsNormalsSorted.TheObjects[i] > this->ExternalwallsNormalsSorted.TheObjects[i])
      return false;
  }
  return false;
}

void CombinatorialChamber::ReplaceMeByAddExtraWallsToNewChamber(CombinatorialChamberContainer& owner, CombinatorialChamber* newChamber, List<int>& IndicesGluedChambers, roots& redundantNormals)
{ //owner.LabelChambersForDisplayAndGetNumVisibleChambers();
  //this->ComputeDebugString(owner);
  //newChamber->ComputeDebugString(owner);
  for (int i=0; i<this->Externalwalls.size; i++)
  { WallData& currentWall =  this->Externalwalls.TheObjects[i];
    if (!redundantNormals.ContainsObject(currentWall.normal))
    { int indexWallInNewChamber=newChamber->GetIndexWallWithNormal(currentWall.normal);
      if (indexWallInNewChamber==-1)
      { indexWallInNewChamber=newChamber->Externalwalls.size;
        newChamber->Externalwalls.AddObjectOnTopCreateNew();
        newChamber->Externalwalls.LastObject()->normal.Assign(currentWall.normal);
        newChamber->Externalwalls.LastObject()->NeighborsAlongWall.size=0;
        newChamber->Externalwalls.LastObject()->IndicesMirrorWalls.size=0;
      }
      WallData& WalllnNewChamber= newChamber->Externalwalls.TheObjects[indexWallInNewChamber];
      for (int j=0; j<currentWall.NeighborsAlongWall.size; j++)
      { CombinatorialChamber* other= currentWall.NeighborsAlongWall.TheObjects[j];
        WallData& otherWall = other->Externalwalls.TheObjects[currentWall.IndicesMirrorWalls.TheObjects[j]];
        otherWall.SubstituteNeighborOneAllowNeighborAppearingNotOnce(this, newChamber, indexWallInNewChamber);
        WalllnNewChamber.AddNeighbor(other, currentWall.IndicesMirrorWalls.TheObjects[j]);
        otherWall.RemoveNeighborExtraOcurrences(newChamber);
        WalllnNewChamber.RemoveNeighborExtraOcurrences(other);
        //other->ComputeDebugString(owner);
      }
    }
//    this->ComputeDebugString(owner);
//    newChamber->ComputeDebugString(owner);
  }
}

void partFractions::DoTheFullComputation(GlobalVariables& theGlobalVariables, roots& toBePartitioned)
{ if (toBePartitioned.size<1)
    return;
  this->AmbientDimension= toBePartitioned.TheObjects[0].size;
  this->theChambers.AmbientDimension= this->AmbientDimension;
  this->theChambers.theDirections.CopyFromBase(toBePartitioned);
  this->DoTheFullComputation(theGlobalVariables);
}

void partFractions::DoTheFullComputation(GlobalVariables& theGlobalVariables)
{ this->theChambers.thePauseController.InitComputation();
  this->theChambers.ReadFromDefaultFile(theGlobalVariables);
  this->theChambers.SliceTheEuclideanSpace(theGlobalVariables, false);
  this->theChambers.QuickSortAscending();
  this->theChambers.LabelChamberIndicesProperly();
  root tempRoot; tempRoot.MakeZero(this->AmbientDimension);
  tempRoot.MakeZero(this->AmbientDimension);
  this->theChambers.drawOutput(theGlobalVariables.theDrawingVariables, tempRoot, 0);
  this->theChambers.thePauseController.ExitComputation();
  this->initAndSplit(this->theChambers.theDirections, theGlobalVariables);
  QuasiPolynomialOld tempQP;
  for (int i=0; i<this->theChambers.size; i++)
    if (this->theChambers.TheObjects[i]!=0)
      this->partFractionsToPartitionFunctionAdaptedToRoot(tempQP, this->theChambers.TheObjects[i]->InternalPoint, false, false, theGlobalVariables, true);
}

bool CombinatorialChamber::GetSplittingFacet(root& output, CombinatorialChamberContainer& owner, GlobalVariables& theGlobalVariables)
{ root& currentDirection= owner.theDirections.TheObjects[owner.theCurrentIndex];
  bool tempBool;
  for (int i=0; i<this->Externalwalls.size; i++)
    if (this->Externalwalls.TheObjects[i].IsExternalWithRespectToDirection(currentDirection) && this->Externalwalls.TheObjects[i].EveryNeigborIsExplored(tempBool))
      for (int j=i+1; j<this->Externalwalls.size; j++)
        if (this->Externalwalls.TheObjects[j].IsExternalWithRespectToDirection(currentDirection) && this->Externalwalls.TheObjects[j].EveryNeigborIsExplored(tempBool))
          if (this->MakeFacetFromEdgeAndDirection(this->Externalwalls.TheObjects[i], this->Externalwalls.TheObjects[j], owner, currentDirection, owner.theDirections, owner.theCurrentIndex, output, theGlobalVariables))
            if (this->HasHPositiveAndHNegativeVertex(output))
              return true;
  return false;
}

bool CombinatorialChamber::HasHPositiveAndHNegativeVertex(root& h)
{ bool foundPositive=false; bool foundNegative=false;
  for (int j=0; j<this->AllVertices.size; j++)
  { if (!foundPositive)
      if (h.OurScalarProductIsPositive(this->AllVertices.TheObjects[j]))
        foundPositive=true;
      if (!foundNegative)
        if (h.OurScalarProductIsNegative(this->AllVertices.TheObjects[j]))
          foundNegative=true;
    if (foundNegative&& foundPositive)
      return true;
  }
  return false;
}

bool CombinatorialChamber::SliceInDirection(root& direction, roots& directions, int CurrentIndex, CombinatorialChamberContainer& output, hashedRoots& FacetOutput, GlobalVariables& theGlobalVariables)
{ if (!(this->Externalwalls.size>=output.AmbientDimension))
  { this->ComputeDebugString(output);
//    CombinatorialChamberContainer::TheBigDump<<this->DebugString;
  }
  assert(this->Externalwalls.size>=output.AmbientDimension);
  this->flagExplored=false;
  root KillerFacet;
  if (this->InternalWalls.size!=0)
  { if (this->SplitChamber(this->InternalWalls.TheObjects[0], output, direction, theGlobalVariables))
      return true;
    else
      this->InternalWalls.PopIndexSwapWithLast(0);
    return false;
  } else
    if (this->GetSplittingFacet(KillerFacet, output, theGlobalVariables))
      if (this->SplitChamber(KillerFacet, output, direction, theGlobalVariables))
        return true;
  this->ComputeDebugString(output);
  direction.ComputeDebugString();
  assert(this->TestPossibilityToSlice(direction, output));
  this->flagExplored=true;
  output.NumExplored++;
  if (this->flagHasZeroPolynomiaL && !this->flagPermanentlyZero)
    this->flagHasZeroPolynomiaL= !this->BordersViaExternalWRTDirectionNonZeroNeighbor(direction);
  return false;
}

void CombinatorialChamberContainer::initNextIndex()
{ this->PurgeZeroPointers();
  this->theCurrentIndex++;
  this->indexLowestNonCheckedForGlueing=0;
  this->NumTotalGlued=0;
  this->LabelAllUnexplored();
  if (this->theCurrentIndex<this->theDirections.size)
    this->ComputeNextIndexToSlice(this->theDirections.TheObjects[this->theCurrentIndex]);
}

void CombinatorialChamberContainer::OneSlice(root* theIndicatorRoot, GlobalVariables& theGlobalVariables)
{ //static int ProblemCounter=0;
  //ProblemCounter++;
  if (this->flagMustStop)
  { assert(this->ConsistencyCheck(true, theGlobalVariables));
    return;
  }
  if (this->theCurrentIndex==-1)
  { this->MakeStartingChambers(this->theDirections, theIndicatorRoot, theGlobalVariables);
  }
  else
  { if (this->theCurrentIndex<this->theDirections.size)
    { if(this->indexNextChamberToSlice!=-1)
      { if (this->TheObjects[this->indexNextChamberToSlice]!=0)
          if (this->TheObjects[this->indexNextChamberToSlice]->SliceInDirection(this->theDirections.TheObjects[this->theCurrentIndex], this->theDirections, this->theCurrentIndex, *this, this->theHyperplanes, theGlobalVariables))
          { assert(this->TheObjects[this->indexNextChamberToSlice]->HasNoNeighborsThatPointToThis());
            delete this->TheObjects[this->indexNextChamberToSlice];
  #ifdef CGIversionLimitRAMuse
    ParallelComputing::GlobalPointerCounter--;
    ParallelComputing::CheckPointerCounters();
  #endif
            this->TheObjects[this->indexNextChamberToSlice]=0;
          }
        if (this->theCurrentIndex<this->theDirections.size)
          this->ComputeNextIndexToSlice(this->theDirections.TheObjects[this->theCurrentIndex]);
      }
      else
      { this->PreferredNextChambers.size=0;
        if (this->theCurrentIndex<this->theDirections.size-1)
          this->indexLowestNonCheckedForGlueing=this->size;
        if (this->indexLowestNonCheckedForGlueing==0)
        { this->LabelChamberIndicesProperly();
          //if (this->flagMakeGrandMasterConsistencyCheck && this->theCurrentIndex==this->theDirections.size-1)
          //  this->GrandMasterConsistencyCheck(theGlobalVariables);
          assert(this->ConsistencyCheck(true, theGlobalVariables));
        }
        if (this->indexLowestNonCheckedForGlueing<this->size)
          this->GlueOverSubdividedChambersCheckLowestIndex(theGlobalVariables);
        else
        { this->initNextIndex();
          this->ConsistencyCheck(false, theGlobalVariables);
        }
      }
    }
    if (this->theCurrentIndex<this->theDirections.size)
      this->MakeReportOneSlice(theGlobalVariables, this->theCurrentIndex, this->theDirections.size, this->theDirections.TheObjects[this->theCurrentIndex]);
    //if (ProblemCounter>1024)
    //this->ComputeDebugString();
//    assert(this->ConsistencyCheck(false));
    //below follows the code to pause the computation
    this->thePauseController.SafePoint();
  }
}

bool CombinatorialChamber::GetNonSeparableChamberIndicesAppendList(CombinatorialChamberContainer& owner, List<int>& outputIndicesChambersToGlue, GlobalVariables& theGlobalVariables)
{ if (this->GetHashFromSortedNormals()==58238520)
    MathRoutines::KToTheNth(1,1);
  for (int i=0; i<this->Externalwalls.size; i++)
  { WallData& theWall= this->Externalwalls.TheObjects[i];
    for(int j=0; j<theWall.NeighborsAlongWall.size; j++)
      if (theWall.NeighborsAlongWall.TheObjects[j]!=0)
        if (!theWall.NeighborsAlongWall.TheObjects[j]->flagHasZeroPolynomiaL)
          if (theWall.NeighborsAlongWall.TheObjects[j]->IndexInOwnerComplex>=owner.indexLowestNonCheckedForGlueing)
            if (!outputIndicesChambersToGlue.ContainsObject(theWall.NeighborsAlongWall.TheObjects[j]->IndexInOwnerComplex))
              if (!this->IsSeparatedByStartingConesFrom(owner, *theWall.NeighborsAlongWall.TheObjects[j], theGlobalVariables))
              { outputIndicesChambersToGlue.AddObjectOnTop(theWall.NeighborsAlongWall.TheObjects[j]->IndexInOwnerComplex);
                theWall.NeighborsAlongWall.TheObjects[j]->GetNonSeparableChamberIndicesAppendList(owner, outputIndicesChambersToGlue, theGlobalVariables);
              }
  }
  return outputIndicesChambersToGlue.size>1;
}

bool CombinatorialChamberContainer::GrandMasterConsistencyCheck(GlobalVariables& theGlobalVariables)
{ roots OldVertices;
  roots tempRoots;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
    { CombinatorialChamber& theChamber = *this->TheObjects[i];
      OldVertices.CopyFromBase(this->TheObjects[i]->AllVertices);
      this->TheObjects[i]->ComputeVerticesFromNormals(*this, theGlobalVariables);
      OldVertices.intersectWith(this->TheObjects[i]->AllVertices, tempRoots);
      if (tempRoots.size!=OldVertices.size || OldVertices.size!=this->TheObjects[i]->AllVertices.size)
      { this->TheObjects[i]->ComputeDebugString(*this);
        assert(false);
        return false;
      }
      /////////////////////////check that for each chamber and each of the starting cone, either the chamber and the cone have zero measure intersection, or the chamber lies entirely in the cone
      for (int j=0; j<this->startingCones.size; j++)
      { if (!this->startingCones.TheObjects[j].IsInCone(theChamber.AllVertices))
          if (theChamber.ChambersHaveNonZeroMeasureIntersection(this->startingCones.TheObjects[j], theGlobalVariables))
          { theChamber.ComputeDebugString(*this);
            this->startingCones.TheObjects[j].ComputeDebugString();
            assert(false);
            return false;
          }
        std::stringstream out;
        out << "Checking consistency chamber " << i+1 << " out of " << this->size << " cone " << j+1 << " out of " << this->startingCones.size;
        theGlobalVariables.theIndicatorVariables.ProgressReportString1= out.str();
        theGlobalVariables.MakeReport();
      }
    }
  return true;
}

bool CombinatorialChamber::ChambersHaveNonZeroMeasureIntersection(roots& WallsOther, GlobalVariables& theGlobalVariables)
{ Selection VertexSelection;
  if (this->Externalwalls.size<1)
    return false;
  int theDimension = this->Externalwalls.TheObjects[0].normal.size;
  roots theWalls;
  this->GetWallNormals(theWalls);
  theWalls.AddRootSnoRepetition(WallsOther);
  int numCandidates = MathRoutines::NChooseK(theWalls.size, theDimension-1);
  root tempRoot; root newInternalPoint;
  newInternalPoint.MakeZero(theDimension);
  VertexSelection.init(theWalls.size);
  for (int i=0; i<numCandidates; VertexSelection.incrementSelectionFixedCardinality(theDimension-1), i++)
    if (theWalls.ComputeNormalFromSelection(tempRoot, VertexSelection, theGlobalVariables, theDimension))
      if (this->PlusMinusPointIsInChamberModifyInput(tempRoot))
        if (WallsOther.ElementsHaveNonNegativeScalarProduct(tempRoot))
        { newInternalPoint.Add(tempRoot);
          if (this->PointIsStrictlyInsideChamber(newInternalPoint) && WallsOther.ElementsHavePositiveScalarProduct(newInternalPoint))
            return true;
        }
  return false;
}

bool roots::ElementsHaveNonNegativeScalarProduct(const root& theRoot) const
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].OurScalarProductIsNegative(theRoot))
      return false;
  return true;
}

bool roots::ElementsHaveNonPositiveScalarProduct(const root& theRoot) const
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].OurScalarProductIsPositive(theRoot))
      return false;
  return true;
}

bool roots::ElementsHavePositiveScalarProduct(const root& theRoot) const
{ for (int i=0; i<this->size; i++)
    if (!this->TheObjects[i].OurScalarProductIsPositive(theRoot))
      return false;
  return true;
}

void ComputationSetup::ProverOpenAndGo(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ inputData.theProverFixedK.ReadFromFile(inputData.theProverFixedK.ProverFileName, theGlobalVariables);
  inputData.theProver.ReadFromFile(theGlobalVariables);
  inputData.theProver.TheFullRecursion(inputData.theProver.theWeylGroup, theGlobalVariables);
}

void CombinatorialChamberContainer::MakeStartingChambersDontSpanEntireSpace(roots& directions, root* theIndicatorRoot, GlobalVariables& theGlobalVariables)
{ this->initAndCreateNewObjects(1);
  CombinatorialChamber& theStartingChamber= *this->TheObjects[0];
  theStartingChamber.Externalwalls.SetSize(this->TheGlobalConeNormals.size);
  theStartingChamber.flagHasZeroPolynomiaL=false;
  theStartingChamber.flagPermanentlyZero=false;
  for (int i=0; i<this->TheGlobalConeNormals.size; i++)
    theStartingChamber.Externalwalls.TheObjects[i].normal.Assign(this->TheGlobalConeNormals.TheObjects[i]);
  this->StartingCrossSections.SetSize(1);
  theStartingChamber.IndexStartingCrossSectionNormal=0;
  this->TheGlobalConeNormals.average(this->StartingCrossSections.TheObjects[0].normal, this->AmbientDimension);
  this->StartingCrossSections.TheObjects[0].affinePoint.Assign(directions.TheObjects[0]);
  Selection tempSel;
  tempSel.init(this->TheGlobalConeNormals.size);
  roots tempRoots;
  root tempRoot;
  for (int i=0; i<directions.size; i++)
    if (this->TheGlobalConeNormals.PointIsAVertex(directions.TheObjects[i], theGlobalVariables))
      theStartingChamber.AllVertices.AddObjectOnTop(directions.TheObjects[i]);
  tempSel.init(this->AmbientDimension);
  tempRoots.CopyFromBase(this->theDirections);
  tempRoots.size=this->AmbientDimension;
  for (int i=0; i<this->AmbientDimension; i++)
  { tempRoots.ComputeNormalExcludingIndex(tempRoot, i, theGlobalVariables);
    tempRoot.ScaleToIntegralMinHeightFirstNonZeroCoordinatePositive();
    theStartingChamber.InternalWalls.AddObjectOnTop(tempRoot);
  }
  this->initNextIndex();
}

void CombinatorialChamberContainer::MakeStartingChambersSpanEntireSpace(roots& directions, root* theIndicatorRoot, GlobalVariables& theGlobalVariables)
{ Selection theSelection;
  theSelection.init(this->AmbientDimension);
  this->theHyperplanes.ClearTheObjects();
  this->theHyperplanes.MakeActualSizeAtLeastExpandOnTop(MathRoutines::NChooseK(directions.size, this->AmbientDimension-1));
  for(int i=0; i<this->AmbientDimension; i++)
  { roots TempRoots;
    root TempRoot;
    Rational tempRat;
    theSelection.incrementSelectionFixedCardinality(this->AmbientDimension-1);
    directions.SubSelection(theSelection, TempRoots);
    TempRoots.ComputeNormal(TempRoot);
    TempRoot.ScaleToIntegralMinHeightFirstNonZeroCoordinatePositive();
    this->theHyperplanes.AddObjectOnTopHash(TempRoot);
  }
  theSelection.initNoMemoryAllocation();
  int NumStartingChambers=MathRoutines::TwoToTheNth(this->AmbientDimension);
  this->initAndCreateNewObjects(NumStartingChambers);
  this->StartingCrossSections.SetSize(NumStartingChambers);
  for(int i=0; i<NumStartingChambers; i++)
  { int tempI= theSelection.SelectionToIndex();
    this->TheObjects[tempI]->Externalwalls.MakeActualSizeAtLeastExpandOnTop(this->AmbientDimension);
    for (int j=0; j<this->AmbientDimension; j++)
    { this->TheObjects[tempI]->AllVertices.AddRoot(directions.TheObjects[j]);
      if (theSelection.selected[j])
      { int tempI2;
        theSelection.selected[j]=false;
        tempI2=theSelection.SelectionToIndex();
        theSelection.selected[j]=true;
        CombinatorialChamber* plusOwner; CombinatorialChamber* minusOwner;
        if (this->theHyperplanes.TheObjects[this->AmbientDimension-j-1].OurScalarProductIsPositive(directions.TheObjects[j]))
        { plusOwner= this->TheObjects[tempI];
          minusOwner= this->TheObjects[tempI2];
        } else
        { minusOwner= this->TheObjects[tempI];
          plusOwner= this->TheObjects[tempI2];
        }
        this->TheObjects[tempI]->MakeNewMutualNeighbors(plusOwner, minusOwner, this->theHyperplanes.TheObjects[this->AmbientDimension-j-1]);
      } else
        this->TheObjects[tempI]->AllVertices.LastObject()->MinusRoot();
//      if (this->flagAnErrorHasOcurredTimeToPanic)
  //      this->ComputeDebugString();
    }
    root tempRoot;
    tempRoot.Assign(directions.TheObjects[0]);
    if (!theSelection.selected[0])
      tempRoot.MinusRoot();
    this->StartingCrossSections.TheObjects[tempI].affinePoint.Assign(tempRoot);
    theSelection.incrementSelection();
//    if (this->flagAnErrorHasOcurredTimeToPanic)
//      this->ComputeDebugString();
  }
  for(int i=0; i<NumStartingChambers; i++)
  { this->TheObjects[i]->IndexStartingCrossSectionNormal=i;
    root Accum;  Accum.MakeZero(this->AmbientDimension);
    for (int j=0; j<this->TheObjects[i]->Externalwalls.size; j++)
      Accum.Add(this->TheObjects[i]->Externalwalls.TheObjects[j].normal);
    this->StartingCrossSections.TheObjects[i].normal.Assign(Accum);
//    if (this->flagAnErrorHasOcurredTimeToPanic)
//      Accum.ComputeDebugString();
    assert(this->TheObjects[i]->ConsistencyCheck(this->AmbientDimension, false, *this, theGlobalVariables));
    if (this->TheGlobalConeNormals.IsSurelyOutsideCone(this->TheObjects[i]->AllVertices))
      this->TheObjects[i]->flagPermanentlyZero=true;
    this->TheObjects[i]->AllVertices.average(this->TheObjects[i]->InternalPoint, this->AmbientDimension);
  }
  this->TheObjects[NumStartingChambers-1]->flagHasZeroPolynomiaL=false;
  this->initNextIndex();
//  if (this->flagAnErrorHasOcurredTimeToPanic)
//    this->ComputeDebugString();
}

void CombinatorialChamberContainer::PurgeZeroPolyChambers(GlobalVariables& theGlobalVariables)
{ //this->ConsistencyCheck(false, theGlobalVariables);
  //this->WriteReportToFile("./Debug_A3_before_purge.html", false);
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
    { CombinatorialChamber& currentChamber= *this->TheObjects[i];
      if (currentChamber.flagHasZeroPolynomiaL || currentChamber.flagPermanentlyZero)
      { for (int j=0; j<currentChamber.Externalwalls.size; j++)
        { WallData& currentWall= currentChamber.Externalwalls.TheObjects[j];
          for (int k=0; k<currentWall.NeighborsAlongWall.size; k++)
            k-=currentWall.RemoveNeighborhoodBothSidesAllowRepetitionsReturnNeighborsDecrease(this->TheObjects[i], currentWall.NeighborsAlongWall.TheObjects[k]);
        }
      }
    }
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i]!=0)
    { CombinatorialChamber& currentChamber= *this->TheObjects[i];
      if (currentChamber.flagHasZeroPolynomiaL || currentChamber.flagPermanentlyZero)
      {
#ifdef CGIversionLimitRAMuse
  ParallelComputing::GlobalPointerCounter--;
  ParallelComputing::CheckPointerCounters();
#endif
        delete this->TheObjects[i];
        this->TheObjects[i]=0;
      }
    }
//  this->WriteReportToFile("./Debug_A3.html", false);
  //this->ConsistencyCheck(false, theGlobalVariables);
  this->PurgeZeroPointers();
  this->ConsistencyCheck(false, theGlobalVariables);
}

void rootSubalgebras::ElementToStringConeConditionNotSatisfying(std::string& output, bool includeMatrixForm, GlobalVariables& theGlobalVariables)
{ roots tempRoots, tempRoots2;
  std::stringstream out;
  std::stringstream out2;
  std::string tempS;
  int numNonSolvableNonReductive=0;
  if (this->AmbientWeyl.WeylLetter=='B')
    out << "$\\mathrm{so}(2n+1)$ is realized as a matrix Lie algebra as $\\left\\{\\left(\\begin{array}{c|c|c}A&\\begin{array}{c}v_1\\\\ \\vdots \\\\ v_n\\end{array} &C=-C^T \\\\\\hline \\begin{array}{ccc}w_1 &\\dots&  w_n\\end{array} &0& \\begin{array}{ccc}-v_n &\\dots&  -v_1\\end{array} \\\\\\hline D=-D^T&\\begin{array}{c}-w_n\\\\ \\vdots \\\\ -w_1\\end{array} & -A^T\\end{array}\\right)\\right\\}$.\n\n";
  if (this->AmbientWeyl.WeylLetter=='C')
    out << "$\\mathrm{sp}(2n)$ is realized as a matrix Lie algebra as $\\left\\{\\left(\\begin{array}{c|c}A& C \\\\\\hline D& -A^T\\end{array}\\right)| C=C^T, D=D^T\\right\\}.$";
  out << " In this realization, the Cartan subalgebra $\\mathfrak{h}$ can be chosen to consist of the diagonal matrices of the above form.\n\n";
  if (!includeMatrixForm)
  { out << "\n\\begin{longtable}{r|l}\n\\multicolumn{2}{c}{";
    if (this->AmbientWeyl.WeylLetter=='B')
      out << " $ \\mathfrak{g}\\simeq \\mathrm{so("<<this->AmbientWeyl.CartanSymmetric.NumRows*2+1 << ")}$";
    if (this->AmbientWeyl.WeylLetter=='C')
      out << " $\\mathfrak{g}\\simeq \\mathrm{sp("<<this->AmbientWeyl.CartanSymmetric.NumRows*2 << ")}$";
    out << "} \\\\\\hline";
  }
  for (int i=0; i<this->size-1; i++)
    if (this->storedNilradicals.TheObjects[i].size>0)
    { rootSubalgebra& currentRootSA=this->TheObjects[i];
      tempRoots.size=0;
      for (int j=0; j<currentRootSA.PositiveRootsK.size; j++)
      { tempRoots.AddObjectOnTop(currentRootSA.PositiveRootsK.TheObjects[j]);
        tempRoots.AddObjectOnTop(-currentRootSA.PositiveRootsK.TheObjects[j]);
      }
      if (includeMatrixForm)
        out << "\n\n\\noindent\\rule{\\textwidth}{1.5pt}\n\n";
      else
        out << "\\hline\\begin{tabular}{r}";
      out << "$\\Delta(\\mathfrak{k})$ is of type " << currentRootSA.theDynkinDiagram.DebugString << "; ";
      if (!includeMatrixForm)
        out <<"\\\\";
      currentRootSA.AmbientWeyl.GetEpsilonCoords(currentRootSA.PositiveRootsK, tempRoots2, theGlobalVariables);
      tempRoots2.ElementToStringEpsilonForm(tempS, true, false, false);
      out << " $\\Delta^+(\\mathfrak{k})=$ " << tempS;
      if (includeMatrixForm)
        out << "\n\n\\noindent\\rule{\\textwidth}{0.3pt}\n\n";
      else
        out << "\\end{tabular} &\n\\begin{tabular}{l}";
      int numNonReductiveCurrent=0;
      for (int j=0; j<this->storedNilradicals.TheObjects[i].size; j++)
      { List<int>& currentNilrad= this->storedNilradicals.TheObjects[i].TheObjects[j];
        if (currentNilrad.size>0)
        { numNonSolvableNonReductive++;
          numNonReductiveCurrent++;
          tempRoots.size= currentRootSA.PositiveRootsK.size*2;
          for(int k=0; k<currentNilrad.size; k++)
            tempRoots.AddListOnTop(currentRootSA.kModules.TheObjects[currentNilrad.TheObjects[k]]);
          this->ElementToStringRootSpaces(tempS, includeMatrixForm, tempRoots, theGlobalVariables);
          out << tempS << "\n";
          if (numNonReductiveCurrent%2==0)
          { out << "\n\n";
            if (!includeMatrixForm)
              out << "\\\\";
          }
        }
      }
      if (!includeMatrixForm)
        out << "\\end{tabular}\n\n\\\\";
    }
  if (!includeMatrixForm)
    out << "\n\\end{longtable}";
  out2 << "\n\nThe number of non-conjugate non-solvable non-reductive root subalgebras not satisfying the cone condition is: " << numNonSolvableNonReductive << "\n\n";
  tempS = out.str();
  out2 << tempS;
  output=out2.str();
}

void rootSubalgebras::ElementToStringRootSpaces(std::string& output, bool includeMatrixForm, roots& input, GlobalVariables& theGlobalVariables)
{ std::string tempS; std::stringstream out;
  roots epsCoords;
  Matrix<int> tempMat;
  int theDimension=this->AmbientWeyl.CartanSymmetric.NumRows;
  if (this->AmbientWeyl.WeylLetter=='B')
  { this->AmbientWeyl.GetEpsilonCoords(input, epsCoords, theGlobalVariables);
    tempMat.MakeIdMatrix(theDimension*2+1);
    tempMat.elements[theDimension][theDimension]=0;
    for (int i=0; i<epsCoords.size; i++)
    { bool isShort=false;
      int firstIndex=-1;
      int secondIndex=-1;
      bool firstSignIsPositive=true;
      bool secondSignIsPositive=true;
      root& currentRoot=epsCoords.TheObjects[i];
      epsCoords.ComputeDebugString();
      for (int j=0; j<theDimension; j++)
      { if (currentRoot.TheObjects[j]!=0)
        { isShort=!isShort;
          if(isShort)
          { if (currentRoot.TheObjects[j].IsPositive())
              firstSignIsPositive=true;
            else
              firstSignIsPositive=false;
            firstIndex=j;
          } else
          { if (currentRoot.TheObjects[j].IsPositive())
              secondSignIsPositive=true;
            else
              secondSignIsPositive=false;
            secondIndex=j;
          }
        }
      }
      if (!isShort)
      { bool signsAreDifferent=(firstSignIsPositive!=secondSignIsPositive);
        if (signsAreDifferent)
        { int positiveIndex, negativeIndex;
          if (firstSignIsPositive)
          { positiveIndex= firstIndex;
            negativeIndex=secondIndex;
          } else
          { positiveIndex= secondIndex;
            negativeIndex=firstIndex;
          }
          tempMat.elements[positiveIndex][negativeIndex]=1;
          tempMat.elements[theDimension+1+negativeIndex][theDimension+1+positiveIndex]=-1;
        } else
        { if (firstSignIsPositive)
          { tempMat.elements[firstIndex][secondIndex+theDimension+1]=1;
            tempMat.elements[secondIndex][firstIndex+theDimension+1]=-1;
          } else
          { tempMat.elements[theDimension+1+firstIndex][secondIndex]=1;
            tempMat.elements[theDimension+1+secondIndex][firstIndex]=-1;
          }
        }
      } else
      { if (firstSignIsPositive)
        { tempMat.elements[firstIndex][theDimension]=1;
          tempMat.elements[theDimension][theDimension+1+firstIndex]=-1;
        } else
        { tempMat.elements[theDimension][firstIndex]=1;
          tempMat.elements[firstIndex+1+theDimension][theDimension]=-1;
        }
      }
    }
  }
  if (this->AmbientWeyl.WeylLetter=='C')
  { this->AmbientWeyl.GetEpsilonCoords(input, epsCoords, theGlobalVariables);
    tempMat.MakeIdMatrix(theDimension*2);
    for (int i=0; i<epsCoords.size; i++)
    { bool isLong=false;
      int firstIndex=-1;
      int secondIndex=-1;
      bool firstSignIsPositive=true;
      bool secondSignIsPositive=true;
      root& currentRoot=epsCoords.TheObjects[i];
      epsCoords.ComputeDebugString();
      for (int j=0; j<theDimension; j++)
      { if (currentRoot.TheObjects[j]!=0)
        { isLong=!isLong;
          if(isLong)
          { if (currentRoot.TheObjects[j].IsPositive())
              firstSignIsPositive=true;
            else
              firstSignIsPositive=false;
            firstIndex=j;
          } else
          { if (currentRoot.TheObjects[j].IsPositive())
              secondSignIsPositive=true;
            else
              secondSignIsPositive=false;
            secondIndex=j;
          }
        }
      }
      if (!isLong)
      { bool signsAreDifferent=(firstSignIsPositive!=secondSignIsPositive);
        if (signsAreDifferent)
        { int positiveIndex=-1, negativeIndex=-1;
          if (firstSignIsPositive)
          { positiveIndex= firstIndex;
            negativeIndex=secondIndex;
          } else
          { positiveIndex= secondIndex;
            negativeIndex=firstIndex;
          }
          tempMat.elements[positiveIndex][negativeIndex]=1;
          tempMat.elements[theDimension+negativeIndex][theDimension+positiveIndex]=-1;
        } else
        { if (firstSignIsPositive)
          { tempMat.elements[firstIndex][secondIndex+theDimension]=1;
            tempMat.elements[secondIndex][firstIndex+theDimension]=1;
          } else
          { tempMat.elements[theDimension+firstIndex][secondIndex]=1;
            tempMat.elements[theDimension+secondIndex][firstIndex]=1;
          }
        }
      } else
      { if (firstSignIsPositive)
          tempMat.elements[firstIndex][theDimension+firstIndex]=1;
        else
          tempMat.elements[theDimension+firstIndex][firstIndex]=1;
      }
    }
  }
  if (includeMatrixForm)
    out << "\\begin{tabular}{cc} \\begin{tabular}{l}";
  out << "$\\Delta(\\mathfrak{n})=$";
  if (includeMatrixForm)
    out <<"\\\\";
  int numNilradicalRootSpaces=0;
  for (int i=0; i<epsCoords.size; i++)
  { root& currentRoot=epsCoords.TheObjects[i];
    currentRoot.ElementToStringEpsilonForm(tempS, true, false);
    if (!epsCoords.ContainsObject(-currentRoot))
    { out << tempS << ", ";
      numNilradicalRootSpaces++;
    }
    if (includeMatrixForm)
      if (numNilradicalRootSpaces%2==0 && numNilradicalRootSpaces!=0)
        out << "\\\\";
  }
  if (includeMatrixForm)
  { out << "\\end{tabular} & $\\mathfrak{l}=\\left(\\begin{array}{";
    for (int i=0; i<tempMat.NumCols; i++)
    { out << "c";
      if (this->AmbientWeyl.WeylLetter=='B' && (i==theDimension-1 || i==theDimension))
        out << "|";
    }
    out << "}";
    for (int i=0; i< tempMat.NumRows; i++)
    { if (this->AmbientWeyl.WeylLetter=='B' && (i==theDimension || i==theDimension+1))
        out << "\\hline";
      for (int j=0; j<tempMat.NumCols; j++)
      { if (tempMat.elements[i][j]!=0 && tempMat.elements[j][i]==0)
          out << "\\blacktriangle";
        if (tempMat.elements[i][j]!=0 && tempMat.elements[j][i]!=0)
        out << "\\bullet";
        if (j!=tempMat.NumCols-1)
          out << "&";
        else
          out << "\\\\";
      }
    }
    out << "\\end{array}\\right)$ \\end{tabular}  ";
  }
  output=out.str();
}

void ComputationSetup::G2InD4Experiment(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ std::stringstream out;
  out << "\\documentclass{article}\\begin{document}";
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  SemisimpleLieAlgebra theLie;
  theLie.ComputeChevalleyConstants('G',  2, theGlobalVariables);
  theLie.ComputeDebugString(false, true, theGlobalVariables);
  out << theLie.DebugString;
  theLie.theWeyl.ComputeWeylGroup(-1);
  root tempHW="(0,1)";
  tempHW.ComputeDebugString();
  roots tempRoots;
  theLie.CreateEmbeddingFromFDModuleHaving1dimWeightSpaces(tempHW, theGlobalVariables);
  std::string tempS;
  if (theLie.CheckClosedness(tempS, theGlobalVariables))
    out << "Lie bracket is good! ";
  else
    out << tempS;
  theLie.ElementToStringEmbedding(tempS);
  out << "\n\n\n" << tempS << "\n\n\n";
 // theLie.
  MatrixLargeRational theAuto;
  theLie.ComputeChevalleyConstants('D', 4, theGlobalVariables);
  theLie.ComputeOneAutomorphism(theGlobalVariables, theAuto, false );
  theAuto.ElementToString(tempS, false, true);
  out << tempS;
  MatrixLargeRational tempMat;
  tempMat.MakeIdMatrix(theAuto.NumRows);
  theAuto= theAuto-tempMat;
  theAuto.FindZeroEigenSpace(tempRoots, theGlobalVariables);
  tempMat.AssignRootsToRowsOfMatrix(tempRoots);
  tempMat.Transpose(theGlobalVariables);
  tempMat= theAuto*tempMat;
  tempMat.ElementToString(tempS, false, true);
  std::string tempS2;
  tempRoots.ElementToString(tempS2, true, false, true);
  out << "\n\n" << tempS2 << "\n\n" << tempS;
  out << "\\end{document}";
  theGlobalVariables.theIndicatorVariables.StatusString1=out.str();
  theGlobalVariables.MakeReport();
}

void MatrixLargeRational::FindZeroEigenSpace(roots& output, GlobalVariables& theGlobalVariables)
{ MatrixLargeRational tempMat;
  tempMat.Assign(*this);
  MatrixLargeRational emptyMat;
  Selection nonPivotPts;
  tempMat.GaussianEliminationByRows(tempMat, emptyMat, nonPivotPts);
  output.SetSize(nonPivotPts.CardinalitySelection);
  for (int i=0; i<nonPivotPts.CardinalitySelection; i++)
  { root& current= output.TheObjects[i];
    current.MakeZero(this->NumCols);
    int currentPivotIndex = nonPivotPts.elements[i];
    current.TheObjects[currentPivotIndex]=1;
    int rowCounter=0;
    for (int j=0; j<this->NumCols; j++)
      if (!nonPivotPts.selected[j])
      { current.TheObjects[j]=-tempMat.elements[rowCounter][currentPivotIndex];
        rowCounter++;
      }
  }
}

void ElementSimpleLieAlgebra::AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(int generatorIndex, const SemisimpleLieAlgebra& owner)
{ int numPosRoots=owner.theWeyl.RootsOfBorel.size;
  int theDimension=owner.theWeyl.CartanSymmetric.NumRows;
  this->Nullify(owner);
  if(generatorIndex< numPosRoots || generatorIndex>=numPosRoots+theDimension)
  { this->SetCoefficient(owner.theWeyl.RootSystem.TheObjects[owner.ChevalleyGeneratorIndexToRootIndex(generatorIndex)], 1, owner);
    return;
  }
  this->Hcomponent.MakeEi(theDimension, generatorIndex-numPosRoots);
}

void ElementSimpleLieAlgebra::AssignVectorRootSpacesFirstThenCartan(const root& input, SemisimpleLieAlgebra& owner)
{ this->Nullify(owner);
  for (int i=0; i<this->coeffsRootSpaces.size; i++)
    this->coeffsRootSpaces.TheObjects[i]=input.TheObjects[i];
  for (int i=0; i<this->Hcomponent.size; i++)
   this->Hcomponent.TheObjects[i]=input.TheObjects[i+this->coeffsRootSpaces.size];
  this->ComputeNonZeroElements();
}

void ElementSimpleLieAlgebra::AssignVectorNegRootSpacesCartanPosRootSpaces(const root& input, const SemisimpleLieAlgebra& owner)
{ this->AssignVectorNegRootSpacesCartanPosRootSpaces(input, owner.GetNumPosRoots()*2, owner.GetRank());
}

void ElementSimpleLieAlgebra::AssignVectorNegRootSpacesCartanPosRootSpaces
  (const root& input, int numRoots, int theAlgebraRank)
{ this->Nullify(numRoots, theAlgebraRank);
  int numPosRoots=numRoots/2;
  for (int i=0; i<numPosRoots; i++)
  { this->coeffsRootSpaces.TheObjects[-i+numRoots-1]=input.TheObjects[i];
    this->coeffsRootSpaces.TheObjects[i]=input.TheObjects[i+numPosRoots+theAlgebraRank];
  }
  this->Hcomponent.SetSize(theAlgebraRank);
  for (int i=0; i<this->Hcomponent.size; i++)
    this->Hcomponent.TheObjects[i]=input.TheObjects[i+numPosRoots];
  this->ComputeNonZeroElements();
}

void ElementSimpleLieAlgebra::ElementToVectorNegativeRootSpacesFirst(Vector<Rational>& output)const
{ output.MakeZero(this->coeffsRootSpaces.size+ this->Hcomponent.size, (Rational) 0);
  int numPosRoots=this->coeffsRootSpaces.size/2;
  for (int i=0; i<this->NonZeroElements.CardinalitySelection; i++)
  { int theIndex=this->NonZeroElements.elements[i];
    int targetIndex= (theIndex<numPosRoots) ? theIndex+numPosRoots+this->Hcomponent.size : -theIndex+2*numPosRoots-1;
    output.TheObjects[targetIndex]= this->coeffsRootSpaces.TheObjects[theIndex];
  }
  for (int i=0; i<this->Hcomponent.size; i++)
    output.TheObjects[i+numPosRoots]= this->Hcomponent.TheObjects[i];
}

void ElementSimpleLieAlgebra::ElementToVectorRootSpacesFirstThenCartan(root& output)
{ output.MakeZero(this->coeffsRootSpaces.size+ this->Hcomponent.size);
  for (int i=0; i<this->NonZeroElements.CardinalitySelection; i++)
  { int theIndex=this->NonZeroElements.elements[i];
    output.TheObjects[theIndex]= this->coeffsRootSpaces.TheObjects[theIndex];
  }
  for (int i=0; i<this->Hcomponent.size; i++)
    output.TheObjects[i+this->coeffsRootSpaces.size]= this->Hcomponent.TheObjects[i];
}

void SemisimpleLieAlgebra::ComputeOneAutomorphism(GlobalVariables& theGlobalVariables, MatrixLargeRational& outputAuto, bool useNegativeRootsFirst)
{ rootSubalgebra theRootSA;
  theRootSA.AmbientWeyl.Assign(this->theWeyl);
  int theDimension= this->theWeyl.CartanSymmetric.NumRows;
  theRootSA.genK.MakeEiBasis(theDimension);
  ReflectionSubgroupWeylGroup theAutos;
  theRootSA.GenerateAutomorphismsPreservingBorel(theGlobalVariables, theAutos);
  MatrixLargeRational mapOnRootSpaces;
  int theAutoIndex= theAutos.ExternalAutomorphisms.size>1? 1 : 0;
  /*if (this->theWeyl.WeylLetter=='D' && theDimension==4)
    theAutoIndex=2;
*/
  mapOnRootSpaces.AssignRootsToRowsOfMatrix(theAutos.ExternalAutomorphisms.TheObjects[theAutoIndex]);
  mapOnRootSpaces.Transpose(theGlobalVariables);
//  mapOnRootSpaces.ComputeDebugString();
//  MatrixLargeRational theDet=mapOnRootSpaces;
//  Rational tempRat;
//  theDet.ComputeDeterminantOverwriteMatrix(tempRat);
//  std::cout << " ... and the det is: " << tempRat.ElementToString();
  Selection NonExplored;
  int numRoots= this->theWeyl.RootSystem.size;
  NonExplored.init(numRoots);
  NonExplored.MakeFullSelection();
  root domainRoot, rangeRoot;
  this->ComputeChevalleyConstants(this->theWeyl, theGlobalVariables);
  List<ElementSimpleLieAlgebra> Domain, Range;
  Range.SetSize(numRoots+theDimension);
  Domain.SetSize(numRoots+theDimension);
  ElementSimpleLieAlgebra tempElt;
  for (int i=0; i<theDimension; i++)
  { domainRoot.MakeEi(theDimension, i);
    mapOnRootSpaces.ActOnAroot(domainRoot, rangeRoot);
    tempElt.Nullify(*this);
    tempElt.Hcomponent= domainRoot;
    Domain.TheObjects[numRoots+i]=tempElt;
    tempElt.Hcomponent= rangeRoot;
    Range.TheObjects[numRoots+i]=tempElt;
    for (int i=0; i<2; i++, domainRoot.MinusRoot(), rangeRoot.MinusRoot())
    { int theIndex= this->theWeyl.RootSystem.IndexOfObjectHash(rangeRoot);
      tempElt.Nullify(*this);
      tempElt.SetCoefficient(rangeRoot, Rational::TheRingUnit, *this);
      Range.TheObjects[theIndex]=tempElt;
      tempElt.Nullify(*this);
      tempElt.SetCoefficient(domainRoot, Rational::TheRingUnit, *this);
      Domain.TheObjects[theIndex]=tempElt;
      NonExplored.RemoveSelection(theIndex);
    }
  }
  root left, right;
  while(NonExplored.CardinalitySelection>0)
  { for (int i=0; i<NonExplored.CardinalitySelection; i++)
    { int theIndex = NonExplored.elements[i];
      root& current = this->theWeyl.RootSystem.TheObjects[theIndex];
      for (int j=0; j<theDimension; j++)
      { left.MakeEi(theDimension, j);
        for (int k=0; k<2; k++, left.MinusRoot())
        { right= current-left;
          if (this->theWeyl.IsARoot(right))
          { int leftIndex= this->theWeyl.RootSystem.IndexOfObjectHash(left);
            int rightIndex= this->theWeyl.RootSystem.IndexOfObjectHash(right);
            if (!NonExplored.selected[rightIndex])
            { ElementSimpleLieAlgebra& leftDomainElt=Domain.TheObjects[leftIndex];
              ElementSimpleLieAlgebra& rightDomainElt= Domain.TheObjects[rightIndex];
              this->LieBracket(leftDomainElt, rightDomainElt, Domain.TheObjects[theIndex]);
              ElementSimpleLieAlgebra& leftRangeElt=Range.TheObjects[leftIndex];
              ElementSimpleLieAlgebra& rightRangeElt= Range.TheObjects[rightIndex];
              this->LieBracket(leftRangeElt, rightRangeElt, Range.TheObjects[theIndex]);
              NonExplored.RemoveSelection(theIndex);
            }
          }
        }
      }
    }
  }
  roots vectorsLeft, vectorsRight;
  vectorsLeft.SetSize(Range.size);
  vectorsRight.SetSize(Range.size);
  if (!useNegativeRootsFirst)
    for (int i=0; i<Range.size; i++)
    { Range.TheObjects[i].ElementToVectorRootSpacesFirstThenCartan(vectorsRight.TheObjects[i]);
      Domain.TheObjects[i].ElementToVectorRootSpacesFirstThenCartan(vectorsLeft.TheObjects[i]);
    }
  else
    for (int i=0; i<Range.size; i++)
    { Range.TheObjects[i].ElementToVectorNegativeRootSpacesFirst(vectorsRight.TheObjects[i]);
      Domain.TheObjects[i].ElementToVectorNegativeRootSpacesFirst(vectorsLeft.TheObjects[i]);
    }
  outputAuto.MakeLinearOperatorFromDomainAndRange(vectorsLeft, vectorsRight, theGlobalVariables);
}

void MatrixLargeRational::MakeLinearOperatorFromDomainAndRange(roots& domain, roots& range, GlobalVariables& theGlobalVariables)
{ MatrixLargeRational A;
  MatrixLargeRational B;
  A.AssignRootsToRowsOfMatrix(domain);
  B.AssignRootsToRowsOfMatrix(range);
  A.Invert(theGlobalVariables);
  (*this)=A*B;
  this->Transpose(theGlobalVariables);
}

//void SemisimpleLieAlgebra::ComputeD

bool SemisimpleLieAlgebra::IsInTheWeightSupport(root& theWeight, root& highestWeight, GlobalVariables& theGlobalVariables)
{ root correspondingDominant= theWeight;
  this->theWeyl.RaiseToHighestWeight(correspondingDominant);

  root theDiff= highestWeight - correspondingDominant;
  correspondingDominant.ComputeDebugString();
  highestWeight.ComputeDebugString();
  theDiff.ComputeDebugString();
  if (!theDiff.IsPositiveOrZero())
    return false;
  return true;
}

bool WeylGroup::IsDominantWeight(root& theWeight)
{ int theDimension= this->CartanSymmetric.NumRows;
  root tempRoot;
  for (int i=0; i<theDimension; i++)
  { tempRoot.MakeEi(theDimension, i);
    if (this->RootScalarCartanRoot(tempRoot, theWeight)<0)
      return false;
  }
  return true;
}

void SemisimpleLieAlgebra::GenerateWeightSupport(root& theHighestWeight, roots& output, GlobalVariables& theGlobalVariables)
{ int indexFirstNonExplored=0;
  this->theWeyl.RaiseToHighestWeight(theHighestWeight);
  output.size=0;
  output.AddObjectOnTop(theHighestWeight);
  roots simpleBasis;
  int theDimension= this->theWeyl.CartanSymmetric.NumRows;
  simpleBasis.MakeEiBasis(theDimension);
  root current;
  while (indexFirstNonExplored<output.size)
  { for (int i=0; i<theDimension; i++)
    { current= output.TheObjects[indexFirstNonExplored]-simpleBasis.TheObjects[i];
      current.ComputeDebugString();
      if (this->IsInTheWeightSupport(current, theHighestWeight, theGlobalVariables))
        output.AddOnTopNoRepetition(current);
    }
    indexFirstNonExplored++;
  }
}

void WeylGroup::RaiseToHighestWeight(root& theWeight)
{ root correspondingDominant;
  for (int i=0; i<this->size; i++)
  { correspondingDominant= theWeight;
    this->ActOnRootByGroupElement(i, correspondingDominant, false, false);
    if (this->IsDominantWeight(correspondingDominant))
    { theWeight=correspondingDominant;
      break;
    }
  }
}

void SemisimpleLieAlgebra::CreateEmbeddingFromFDModuleHaving1dimWeightSpaces(root& theHighestWeight, GlobalVariables& theGlobalVariables)
{ /*roots weightSupport;
  this->GenerateWeightSupport(theHighestWeight, weightSupport, theGlobalVariables);
  int highestWeight, distanceToHW;
  this->EmbeddingsRootSpaces.SetSize(this->theWeyl.RootSystem.size);
  int theDimension= this->theWeyl.CartanSymmetric.NumRows;
  List<bool> Explored;
  Explored.initFillInObject(this->theWeyl.RootSystem.size, false);
  int numExplored=0;
  for (int i=0; i<this->theWeyl.RootSystem.size; i++)
  { root& current= this->theWeyl.RootSystem.TheObjects[i];
    if (current.SumCoordinates()==1 || current.SumCoordinates()==-1)
    { numExplored++;
      Explored.TheObjects[i]=true;
      MatrixLargeRational& currentMat= this->EmbeddingsRootSpaces.TheObjects[i];
      currentMat.init(weightSupport.size, weightSupport.size);
      currentMat.NullifyAll();
      for (int j=0; j<weightSupport.size; j++)
      { int indexTarget= weightSupport.IndexOfObject(current+weightSupport.TheObjects[j]);
        if (indexTarget!=-1)
        { highestWeight = -1+ this->GetLengthStringAlongAlphaThroughBeta(current, weightSupport.TheObjects[j], distanceToHW, weightSupport);
          if (current.IsNegativeOrZero())
            currentMat.elements[indexTarget][j]=1;
          else
            currentMat.elements[indexTarget][j]=(highestWeight-distanceToHW+1)*distanceToHW;
        }
      }
    }
  }
  roots simpleBasis;
  simpleBasis.MakeEiBasis(theDimension);
  while (numExplored<this->theWeyl.RootSystem.size)
  { for (int i=0; i<this->theWeyl.RootSystem.size; i++)
      if (Explored.TheObjects[i])
        for (int j=0; j<this->theWeyl.RootSystem.size; j++)
          if (Explored.TheObjects[j])
          { root tempRoot= this->theWeyl.RootSystem.TheObjects[i]+this->theWeyl.RootSystem.TheObjects[j];
            if (this->theWeyl.IsARoot(tempRoot))
            { int index= this->theWeyl.RootSystem.IndexOfObjectHash(tempRoot);
              if (!Explored.TheObjects[index])
              { Explored.TheObjects[index]=true;
                numExplored++;
                this->EmbeddingsRootSpaces.TheObjects[index]= this->EmbeddingsRootSpaces.TheObjects[i];
                this->EmbeddingsRootSpaces.TheObjects[index].LieBracketWith(this->EmbeddingsRootSpaces.TheObjects[j]);
              }
            }
          }
  }
  this->EmbeddingsCartan.SetSize(theDimension);
  for (int i=0; i<theDimension; i++)
  { MatrixLargeRational& current= this->EmbeddingsCartan.TheObjects[i];
    current.init(weightSupport.size, weightSupport.size);
    current.NullifyAll();
    root tempRoot;
    tempRoot.MakeEi(theDimension, i);
    for (int j=0; j<weightSupport.size; j++)
      current.elements[j][j]=this->theWeyl.RootScalarCartanRoot(tempRoot, weightSupport.TheObjects[j]);
  }*/
}

int SemisimpleLieAlgebra::GetLengthStringAlongAlphaThroughBeta(root& alpha, root& beta, int& distanceToHighestWeight, roots& weightSupport)
{ root tempRoot=beta;
  for (int i=0; ; i++)
  { tempRoot+= alpha;
    if (!weightSupport.ContainsObject(tempRoot))
    { distanceToHighestWeight=i;
      break;
    }
  }
  for (int i=0; ; i++)
  { tempRoot-= alpha;
    if (!weightSupport.ContainsObject(tempRoot))
      return i;
  }
//  assert(false);
//  return -1;
}

void SemisimpleLieAlgebra::ElementToStringEmbedding(std::string& output)
{ /*std::stringstream out;
  std::string tempS;
  for (int i=0; i<this->EmbeddingsRootSpaces.size; i++)
  { MatrixLargeRational& theMat = this->EmbeddingsRootSpaces.TheObjects[i];
    theMat.ElementToString(tempS, false, true);
    out << " $g^{\\alpha_{" << i+1 << "}}\\mapsto$ " << tempS << " \n\n";
  }
  for (int i=0; i<this->EmbeddingsCartan.size; i++)
  { MatrixLargeRational& theMat = this->EmbeddingsCartan.TheObjects[i];
    theMat.ElementToString(tempS, false, true);
    out << " $h_{" << i+1 << "}\\mapsto$ " << tempS << " \n\n";
  }
  output = out.str();*/
}

void MatrixLargeRational::LieBracketWith(MatrixLargeRational& right)
{ MatrixLargeRational tempMat, tempMat2, tempMat3;
  tempMat2=((*this)*right );
  tempMat2.ComputeDebugString();
  tempMat3= (right*(*this));
  tempMat3.ComputeDebugString();
  tempMat=tempMat2-tempMat3;
  tempMat.ComputeDebugString();
  this->Assign(tempMat);
}

bool roots::LinSpanContainsRoot(root& input, GlobalVariables& theGlobalVariables)
{ roots tempRoots;
  tempRoots.CopyFromBase(*this);
  tempRoots.AddObjectOnTop(input);
  this->ComputeDebugString();
  tempRoots.ComputeDebugString();
  input.ComputeDebugString();
  return this->GetRankOfSpanOfElements(theGlobalVariables)==tempRoots.GetRankOfSpanOfElements(theGlobalVariables);
}

bool SemisimpleLieAlgebra::CheckClosedness(std::string& output, GlobalVariables& theGlobalVariables)
{ /*List<MatrixLargeRational> tempElts;
  tempElts.size=0;
  tempElts.AddListOnTop(this->EmbeddingsCartan);
  tempElts.AddListOnTop(this->EmbeddingsRootSpaces);
  roots tempRoots;
  tempRoots.SetSize(tempElts.size);
  for (int i=0; i<tempElts.size; i++)
    tempElts.TheObjects[i].MatrixToRoot(tempRoots.TheObjects[i]);
  MatrixLargeRational tempMat;
  for (int i=0; i<tempElts.size; i++)
    for (int j=0; j<tempElts.size; j++)
    { tempMat= tempElts.TheObjects[i];
      tempMat.ComputeDebugString();
      tempElts.TheObjects[j].ComputeDebugString();
      tempMat.LieBracketWith(tempElts.TheObjects[j]);
      tempMat.ComputeDebugString();
      root tempRoot;
      tempMat.MatrixToRoot(tempRoot);
      bool isGood=tempRoots.LinSpanContainsRoot(tempRoot, theGlobalVariables);
      if (!isGood)
      { std::stringstream out;
        std::string tempS1, tempS2, tempS3;
        tempMat.ElementToString(tempS1, false, true);
        tempElts.TheObjects[i].ElementToString(tempS2, false, true);
        tempElts.TheObjects[j].ElementToString(tempS3, false, true);
        out << "First bad: " << tempS1 << "=[" << tempS2 << "," << tempS3 << "]";
        output=out.str();
        return false;
      }
    }*/
  return true;
}

void MatrixLargeRational::MatrixToRoot(root& output)
{ output.SetSize(this->NumRows*this->NumCols);
  for (int i=0; i<this->NumRows; i++)
    for (int j=0; j<this->NumCols; j++)
      output.TheObjects[i*this->NumRows+j]=this->elements[i][j];
}

void rootSubalgebra::GenerateAutomorphismsPreservingBorel(GlobalVariables& theGlobalVariables, ReflectionSubgroupWeylGroup& outputAutomorphisms)
{ this->ComputeAll();
  this->GenerateIsomorphismsPreservingBorel(*this, theGlobalVariables, &outputAutomorphisms, false);
}

void LatticeRoot::DuflosComputation(List<char>& WeylLetters, List<int>& ranks, std::string& output, GlobalVariables& theGlobalVariables)
{ std::stringstream body, tables;
  std::string tempBody, tempTable;
  tables << "\\documentclass{article}\n\\usepackage{amssymb}\n\\begin{document}\n";
  for (int i=0; i<WeylLetters.size; i++)
  { this->DuflosComputationOneSA(WeylLetters.TheObjects[i], ranks.TheObjects[i], tempTable, tempBody, theGlobalVariables);
    tables << tempTable << "\n\n";
    body << tempBody;
  }
  tables << body.str();
  tables << "\n\\end{document}";
  output = tables.str();
}

void LatticeRoot::DuflosComputationOneSA(char WeylLetter, int rank, std::string& outputTable, std::string& outputBody, GlobalVariables& theGlobalVariables)
{ std::stringstream out;
  std::stringstream niceTable;
  rootSubalgebras theRootSubalgebras;
  theRootSubalgebras.GenerateAllReductiveRootSubalgebrasUpToIsomorphism(theGlobalVariables, WeylLetter, rank, true, true);
  WeylGroup& theWeyl= theRootSubalgebras.AmbientWeyl;
  int theDimension= theWeyl.CartanSymmetric.NumRows;
  niceTable << "\\begin{tabular}{cc}\n\\multicolumn{2}{c}{Root system $\\Delta$ of type" << theRootSubalgebras.TheObjects[0].theDynkinDiagram.DebugString << "} \\\\\\hline\n Dynkin type subsystem $\\Delta'$ & Structure of $\\Lambda(\\Delta)/\\Lambda(\\Delta')$\\\\\\hline\n";
  out << "\n\nRoot system of " << theRootSubalgebras.TheObjects[0].theDynkinDiagram.DebugString << ":\n\n";
  roots tempRoots;
  tempRoots.CopyFromBase(theWeyl.RootSystem);
  out << tempRoots.ElementToString() << "\n\n";
  for (int i=1; i<theRootSubalgebras.size; i++)
  { rootSubalgebra& currentSA=theRootSubalgebras.TheObjects[i];
    if (currentSA.SimpleBasisK.size==theDimension)
    { this->LatticeBasis= currentSA.SimpleBasisK;
      this->GetZnModLatticeRepresentativesRootCase(theWeyl, this->RepresentativesQuotient, theGlobalVariables);
      //std::string tempS;
      out << "\n\nType subsystem: " << currentSA.theDynkinDiagram.DebugString << "\n\n Cardinality quotient: " << this->RepresentativesQuotient.size;
      out << "\n\nSimple basis root subsystem: " << currentSA.SimpleBasisK.ElementToString();
      out << "\n\nRepresentatives elements in quotient: " << this->RepresentativesQuotient.ElementToString();
      std::string tempS;
      List<int> list1, list2;
      this->GetStructureQuotientRootCase(currentSA.AmbientWeyl, tempS, list1, list2, theGlobalVariables);
      out << "\n\nStructure: " << tempS;
      niceTable << currentSA.theDynkinDiagram.DebugString << " & " << tempS << " \\\\\n";
    }
  }
  niceTable << "\\end{tabular}";
  outputTable = niceTable.str();
  outputBody = out.str();
}

void ComputationSetup::DuflosComputation(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ std::string tempS;
  LatticeRoot tempLattice;
  List<char> WeylLetters;
  List<int> ranks;
 /* WeylLetters.AddObjectOnTop('E');
  ranks.AddObjectOnTop(8);
*/
  WeylLetters.AddObjectOnTop('G');
  ranks.AddObjectOnTop(2);
  WeylLetters.AddObjectOnTop('D');
  ranks.AddObjectOnTop(4);
  WeylLetters.AddObjectOnTop('F');
  ranks.AddObjectOnTop(4);
  WeylLetters.AddObjectOnTop('E');
  ranks.AddObjectOnTop(6);
  WeylLetters.AddObjectOnTop('E');
  ranks.AddObjectOnTop(7);
  WeylLetters.AddObjectOnTop('E');
  ranks.AddObjectOnTop(8);
  tempLattice.DuflosComputation(WeylLetters, ranks, tempS, theGlobalVariables);
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.theIndicatorVariables.StatusString1=tempS;
  theGlobalVariables.MakeReport();
}

bool LatticeRoot::IsInLattice(const root& input)
{ roots tempRoots;
  tempRoots = this->LatticeBasis;
  int theDimension = this->LatticeBasis.size;
  tempRoots.AddObjectOnTop(input);
  MatrixLargeRational tempMat;
  tempRoots.GetLinearDependence(tempMat);
  Rational coeffInFrontOfInput= tempMat.elements[theDimension][0];
  tempMat.ComputeDebugString();
  tempRoots.ComputeDebugString();
  if (coeffInFrontOfInput==0)
    return false;
  for (int i=0; i<theDimension; i++)
    if (!(tempMat.elements[i][0]/coeffInFrontOfInput).IsInteger())
      return false;
  return true;
}

void LatticeRoot::GetZnModLatticeRepresentatives(WeylGroup* theWeyl, roots& representativesOutput, GlobalVariables& theGlobalVariables)
{ int theDimension= this->LatticeBasis.size;
  if (theDimension<1)
    return;
  if (theDimension!=this->LatticeBasis.TheObjects[0].size)
    return;
  if (theDimension!=this->LatticeBasis.GetRankOfSpanOfElements(theGlobalVariables))
    return;
  representativesOutput.size=0;
  root tempRoot;
  for (int i=0; i<theDimension; i++)
  { tempRoot.MakeEi(theDimension, i);
    if (!this->ContainsConjugacyClassRepresentedBy(representativesOutput, tempRoot))
      representativesOutput.AddObjectOnTop(tempRoot);
  }
  for (int lowestNonExploredIndex=0; lowestNonExploredIndex<representativesOutput.size; lowestNonExploredIndex++)
  { //root& current= representativesOutput.TheObjects[lowestNonExploredIndex];
    for (int k=0; k<=lowestNonExploredIndex; k++)
    { tempRoot= representativesOutput.TheObjects[lowestNonExploredIndex]+representativesOutput.TheObjects[k];
      if (!this->ContainsConjugacyClassRepresentedBy(representativesOutput, tempRoot))
      { if (theWeyl!=0)
          for (int l=0; l<theWeyl->RootSystem.size; l++)
          { if (this->IsInLattice(tempRoot- theWeyl->RootSystem.TheObjects[l]))
            { representativesOutput.AddObjectOnTop(theWeyl->RootSystem.TheObjects[l]);
              break;
            }
          }
        else
          representativesOutput.AddObjectOnTop(tempRoot);
      }
    }
  }
}

bool LatticeRoot::ContainsConjugacyClassRepresentedBy(roots& representatives, root& input)
{ for (int i=0; i<representatives.size; i++)
    if (this->IsInLattice(representatives.TheObjects[i]-input))
      return true;
  return false;
}

void LatticeRoot::GetStructureQuotientRootCase(WeylGroup& theWeyl, std::string& output, List<int>& outputIndices, List<int>& outputMults, GlobalVariables& theGlobalVariables)
{ LatticeRoot tempLattice;
  std::stringstream out;
  tempLattice.LatticeBasis=this->LatticeBasis;
  tempLattice.GetZnModLatticeRepresentativesRootCase(theWeyl, theGlobalVariables);
  int maxRank=0;
  rootSubalgebra tempSA;
  tempSA.AmbientWeyl.Assign(theWeyl);
  tempSA.genK=tempLattice.LatticeBasis;
  tempSA.ComputeAll();
  outputIndices.size=0;
  outputMults.size=0;
  out << "$";
  for (int indexMaxRank=tempLattice.GetIndexFirstElementOfMaxRank(maxRank); maxRank>1; indexMaxRank=tempLattice.GetIndexFirstElementOfMaxRank(maxRank))
  { if (outputIndices.size>0)
      out << "+";
    if (outputIndices.ContainsObject(maxRank))
      outputMults.TheObjects[outputIndices.IndexOfObject(maxRank)]++;
    else
    { outputIndices.AddObjectOnTop(maxRank);
      outputMults.AddObjectOnTop(1);
    }
    out << "\\mathbb{Z}_{" << maxRank << "}";
    tempSA.genK.AddObjectOnTop(tempLattice.RepresentativesQuotient.TheObjects[indexMaxRank]);
    tempSA.ComputeAllButAmbientWeyl();
    tempLattice.LatticeBasis= tempSA.SimpleBasisK;
    tempLattice.GetZnModLatticeRepresentativesRootCase(theWeyl, theGlobalVariables);
  }
  out << "$";
  output=out.str();
}

int LatticeRoot::GetIndexFirstElementOfMaxRank(int& outputRank)
{ int result=-1;
  outputRank=0;
  for (int i=0; i<this->RepresentativesQuotient.size; i++)
    if (outputRank< this->GetRankElementRepresentedBy(this->RepresentativesQuotient.TheObjects[i]))
    { outputRank=this->GetRankElementRepresentedBy(this->RepresentativesQuotient.TheObjects[i]);
      result=i;
    }
  return result;
}

int LatticeRoot::GetRankElementRepresentedBy(root& elementRepresentative)
{ root tempRoot;
  tempRoot.MakeZero(elementRepresentative.size);
  for (int result=1; ; result++)
  { tempRoot+=elementRepresentative;
    if (this->IsInLattice(tempRoot))
      return result;
  }
//  assert(false);
//  return -1;
}

ElementUniversalEnveloping Parser::ParseAndCompute(const std::string& input, GlobalVariables& theGlobalVariables)
{ this->Parse(input);
  this->Evaluate(theGlobalVariables);
  this->theValue.UEElement.GetElement().Simplify();
  return this->theValue.UEElement.GetElement();
}

void Parser::ParseEvaluateAndSimplifyPart1(const std::string& input, GlobalVariables& theGlobalVariables)
{ this->theHmm.theRange.ComputeChevalleyConstants(this->DefaultWeylLetter, this->DefaultWeylRank, theGlobalVariables);
  this->Parse(input);
  this->ComputeDebugString(theGlobalVariables);
}

std::string Parser::ParseEvaluateAndSimplifyPart2(const std::string& input, GlobalVariables& theGlobalVariables)
{ this->Evaluate(theGlobalVariables);
  if (!this->theValue.UEElement.IsZeroPointer())
    this->theValue.UEElement.GetElement().Simplify();
  if(!this->theValue.UEElement.IsZeroPointer())
    this->theValue.UEElementOrdered.GetElement().Simplify(&theGlobalVariables);
  std::stringstream out;
  out << "<DIV class=\"math\" scale=\"50\">\\begin{eqnarray*}&&" << this->StringBeingParsed << "\\end{eqnarray*} = </div>" << this->theValue.ElementToStringValueAndType(true);
  return out.str();
}

std::string Parser::ParseEvaluateAndSimplify(const std::string& input, GlobalVariables& theGlobalVariables)
{ this->ParseEvaluateAndSimplifyPart1(input, theGlobalVariables);
  return this->ParseEvaluateAndSimplifyPart2(input, theGlobalVariables);
}

int DebugCounter=-1;

void Parser::ParserInit(const std::string& input)
{ this->TokenStack.MakeActualSizeAtLeastExpandOnTop(input.size());
  this->ValueStack.MakeActualSizeAtLeastExpandOnTop(input.size());
  this->MakeActualSizeAtLeastExpandOnTop(input.size());
  this->TokenStack.size=0;
  this->ValueStack.size=0;
  this->TokenBuffer.size=0;
  this->ValueBuffer.size=0;
  this->size=0;
  this->NumVariables=0;
  this->SystemCommands.size=0;
  std::string buffer;
  int theLength=(signed) input.size();
  char LookAheadChar;
  for (int i=0; i<theLength; i++)
  { buffer.push_back(input[i]);
    if (i<theLength-1)
      LookAheadChar=input[i+1];
    else
      LookAheadChar=' ';
    if (this->IsAWordSeparatingCharacter(buffer[0]) || this->IsAWordSeparatingCharacter(LookAheadChar))
    { this->LookUpInDictionaryAndAdd(buffer);
      buffer="";
    }
  }
  this->ValueStack.size=0;
  this->TokenStack.size=0;
  this->ValueStack.MakeActualSizeAtLeastExpandOnTop(this->ValueBuffer.size);
  this->TokenStack.MakeActualSizeAtLeastExpandOnTop(this->TokenBuffer.size);
  this->StringBeingParsed=input;
  for (int i=0; i<this->numEmptyTokensAtBeginning; i++)
  { this->TokenStack.AddObjectOnTop(this->tokenEmpty);
    this->ValueStack.AddObjectOnTop(0);
  }
}

bool Parser::IsAWordSeparatingCharacter(char c)
{ switch (c)
  { case '0': return true;
    case '1': return true;
    case '2': return true;
    case '3': return true;
    case '4': return true;
    case '5': return true;
    case '6': return true;
    case '7': return true;
    case '8': return true;
    case '9': return true;
    case '*': return true;
    case '}': return true;
    case '{': return true;
    case '[': return true;
    case ']': return true;
    case '(': return true;
    case ',': return true;
    case ')': return true;
    case '^': return true;
    case '+': return true;
    case '-': return true;
    case '_': return true;
    case '/': return true;
    case ' ': return true;
    case ';': return true;
    case ':': return true;
    default: return false;
  }
//  return false;
}

void Parser::Parse(const std::string& input)
{ this->ParserInit(input);
  this->ParseNoInit(0, this->TokenBuffer.size-1);
  this->ComputeNumberOfVariablesAndAdjustNodes();
}

void Parser::ParseNoInit(int indexFrom, int indexTo)
{ if (indexFrom<0 || indexTo>= this->TokenBuffer.size)
    return;
  for (int i=indexFrom; i<=indexTo; i++)
  { this->ValueStack.AddObjectOnTop(this->ValueBuffer.TheObjects[i]);
    this->TokenStack.AddObjectOnTop(this->TokenBuffer.TheObjects[i]);
    int lookAheadToken=this->tokenEnd;
    if (i<this->TokenBuffer.size-1)
      lookAheadToken=this->TokenBuffer.TheObjects[i+1];
    while(this->ApplyRules(lookAheadToken))
    {}
  }
}

bool Parser::TokenProhibitsUnaryMinus(int theToken)
{ if (theToken==this->tokenExpression)
    return true;
  return false;
}

bool Parser::lookAheadTokenProhibitsPlus(int theToken)
{ if (theToken==this->tokenEnd)
    return false;
  if (theToken==this->tokenPlus)
    return false;
  if (theToken==this->tokenMinus)
    return false;
  if (theToken==this->tokenCloseBracket)
    return false;
  if (theToken==this->tokenCloseLieBracket)
    return false;
  if (theToken==this->tokenCloseCurlyBracket)
    return false;
  if (theToken==this->tokenComma)
    return false;
  if (theToken==this->tokenColon)
    return false;
//  if (theToken==this->tokenExpression)
//    return true;
//  if (theToken==this->tokenUnderscore)
//    return true;
  return true;
}

bool Parser::lookAheadTokenProhibitsTimes(int theToken)
{ if (theToken==this->tokenPower)
    return true;
  if (theToken==this->tokenUnderscore)
    return true;
  return false;
}

bool Parser::ApplyRules(int lookAheadToken)
{ if (this->TokenStack.size<=this->numEmptyTokensAtBeginning)
    return false;
  int tokenLast=*this->TokenStack.LastObject();
  int tokenSecondToLast= this->TokenStack.TheObjects[this->TokenStack.size-2];
  int tokenThirdToLast=this->TokenStack.TheObjects[this->TokenStack.size-3];
  int tokenFourthToLast=this->TokenStack.TheObjects[this->TokenStack.size-4];
  int tokenFifthToLast=this->TokenStack.TheObjects[this->TokenStack.size-5];
//  int tokenSixthToLast=this->TokenStack.TheObjects[this->TokenStack.size-6];
  if (tokenLast==this->tokenEmpty)
  { this->PopTokenAndValueStacksLast();
    return true;
  }
  if (tokenLast==this->tokenCloseCurlyBracket && tokenThirdToLast==this->tokenOpenCurlyBracket && tokenSecondToLast==this->tokenExpression)
  { this->PopTokenAndValueStacksLast();
    this->PopTokenAndValueStacksShiftDown(this->TokenStack.size-2);
    return true;
  }
  if (tokenLast==this->tokenExpression && tokenSecondToLast==this->tokenMap && lookAheadToken!=this->tokenUnderscore)
  { this->AddMapOnTop();
    return true;
  }
  if (tokenLast== this->tokenFunctionNoArgument)
  { this->ExtendOnTop(1);
    this->LastObject()->Operation=this->tokenFunction;
    this->LastObject()->intValue=*this->ValueStack.LastObject();
    *this->TokenStack.LastObject()=this->tokenExpression;
    *this->ValueStack.LastObject()=this->size-1;
    return true;
  }
  if (tokenSecondToLast==this->tokenFunction && tokenLast==this->tokenExpression)
  { this->AddFunctionOnTop();
    return true;
  }
  if (tokenLast==this->tokenExpression && tokenSecondToLast==this->tokenMinus && !this->TokenProhibitsUnaryMinus(tokenThirdToLast) && !this->lookAheadTokenProhibitsPlus(lookAheadToken))
  { this->AddUnaryMinusOnTop();
    return true;
  }
  if (tokenLast==this->tokenCloseBracket && tokenSecondToLast==this->tokenExpression && tokenThirdToLast==this->tokenOpenBracket)
  { this->PopTokenAndValueStacksLast();
    this->PopTokenAndValueStacksShiftDown(this->TokenStack.size-2);
    return true;
  }
  if (tokenSecondToLast==this->tokenMapsTo && tokenLast==this->tokenExpression && tokenThirdToLast==this->tokenExpression && this->lookAheadTokenAllowsMapsTo(lookAheadToken))
  { this->AddEOEonTop();
    return true;
  }
  if (tokenLast== this->tokenCloseLieBracket && tokenSecondToLast==this->tokenExpression && tokenThirdToLast==this->tokenComma && tokenFourthToLast==this->tokenExpression && tokenFifthToLast==this->tokenOpenLieBracket)
   { this->AddXECEXOnTop(this->tokenLieBracket);
    return true;
  }
  if (tokenLast==this->tokenCloseLieBracket && tokenSecondToLast==this->tokenExpression && tokenThirdToLast==this->tokenOpenLieBracket && tokenFourthToLast==this->tokenExpression)
  { this->AddEXEXonTop(this->tokenDereferenceArray);
    return true;
  }
  if (tokenLast==this->tokenDigit)
  { *this->TokenStack.LastObject()=this->tokenInteger;
    if (tokenSecondToLast!=this->tokenInteger)
      this->LargeIntegerReader=*this->ValueStack.LastObject();
    else
      this->MergeLastTwoIntegers();
    return true;
  }
  if (tokenLast==this->tokenInteger && lookAheadToken!=this->tokenDigit)
  { this->AddIntegerOnTopConvertToExpression();
    return true;
  }
  if (tokenLast==this->tokenPartialDerivative || tokenLast==this->tokenG || tokenLast==this->tokenF || tokenLast==this->tokenX || tokenLast==this->tokenH || tokenLast== this->tokenC || tokenLast==this->tokenVariable)
  { this->AddLetterExpressionOnTop();
    return true;
  }
  if (tokenSecondToLast==this->tokenUnderscore && tokenLast==this->tokenExpression && tokenThirdToLast==this->tokenExpression && tokenFourthToLast!=this->tokenUnderscore)
  { this->AddEOEonTop();
    return true;
  }
  if (tokenLast==this->tokenExpression && tokenSecondToLast== this->tokenPower && tokenThirdToLast==this->tokenExpression)
  { this->AddEOEonTop();
    return true;
  }
  if (tokenLast==this->tokenExpression && tokenSecondToLast== this->tokenDivide && tokenThirdToLast==this->tokenExpression && !this->lookAheadTokenProhibitsTimes(lookAheadToken))
  { this->AddEOEonTop();
    return true;
  }
  if (tokenLast==this->tokenExpression && tokenThirdToLast==this->tokenExpression && tokenSecondToLast==tokenTimes && !this->lookAheadTokenProhibitsTimes(lookAheadToken))
  { this->AddEOEonTop();
    return true;
  }
  if (tokenLast==this->tokenExpression && tokenSecondToLast==this->tokenExpression && !this->lookAheadTokenProhibitsTimes(lookAheadToken))
  { this->AddImpiedTimesOnTop();
    return true;
  }
  if (tokenSecondToLast==this->tokenPlus && tokenLast==this->tokenExpression && tokenThirdToLast==this->tokenExpression && !this->lookAheadTokenProhibitsPlus(lookAheadToken))
  { this->AddEOEonTop();
    return true;
  }
  if (tokenSecondToLast==this->tokenMinus && tokenLast==this->tokenExpression && tokenThirdToLast==this->tokenExpression && !this->lookAheadTokenProhibitsPlus(lookAheadToken))
  { this->AddEOEonTop();
    return true;
  }
  int rootDim;
  if (this->StackTopIsARoot(rootDim))
  { this->AddXECdotsCEX(rootDim, this->tokenArraY);
    return true;
  }
  if (this->StackTopIsDelimiter1ECdotsCEDelimiter2EDelimiter3(rootDim, this->tokenOpenBracket, this->tokenColon, this->tokenCloseBracket))
  { this->AddXECdotsCEXEX(rootDim, this->tokenColon);
    return true;
  }
  return false;
}

void Parser::DecreaseStackSetExpressionLastNode(int Decrease)
{ this->TokenStack.size-=Decrease;
  this->ValueStack.size-=Decrease;
  *this->TokenStack.LastObject()=this->tokenExpression;
  *this->ValueStack.LastObject()=this->size-1;
}

void Parser::MergeLastTwoIntegers()
{ this->LargeIntegerReader=this->LargeIntegerReader*10+(*this->ValueStack.LastObject());
  this->PopTokenAndValueStacksLast();
}

void Parser::AddLetterExpressionOnTop()
{ this->ExtendOnTop(1);
  this->LastObject()->Clear();
  this->LastObject()->Operation=*this->TokenStack.LastObject();
  this->DecreaseStackSetExpressionLastNode(0);
}

void Parser::AddIntegerOnTopConvertToExpression()
{ this->ExtendOnTop(1);
  this->LastObject()->rationalValue=this->LargeIntegerReader;
  this->LastObject()->Operation=this->tokenInteger;
  this->DecreaseStackSetExpressionLastNode(0);
}

void Parser::AddFunctionOnTop()
{ /*if (this->LastObject()->Operation!=this->tokenRoot)
  { this->ExtendOnTop(1);
    this->LastObject()->Operation=this->tokenRoot;
    this->Own(this->size-1, this->ValueStack.TheObjects[this->ValueStack.size-1]);
    this->DecreaseStackSetExpressionLastNode(0);
  }*/
  this->ExtendOnTop(1);
  this->LastObject()->Operation=this->TokenStack.TheObjects[this->TokenStack.size-2];
  this->LastObject()->intValue=this->ValueStack.TheObjects[this->ValueStack.size-2];
  this->Own(this->size-1, this->ValueStack.TheObjects[this->ValueStack.size-1]);
  this->DecreaseStackSetExpressionLastNode(1);
}

void Parser::AddEXEXonTop(int theOperation)
{ this->ExtendOnTop(1);
  this->LastObject()->Operation=theOperation;
  this->Own(this->size-1, this->ValueStack.TheObjects[this->ValueStack.size-4], this->ValueStack.TheObjects[this->ValueStack.size-2]);
  this->DecreaseStackSetExpressionLastNode(3);
}

void Parser::AddEOEonTop()
{ this->ExtendOnTop(1);
  ParserNode* theNode=this->LastObject();
  theNode->Operation=this->TokenStack.TheObjects[this->TokenStack.size-2];
  this->Own(this->size-1, this->ValueStack.TheObjects[this->ValueStack.size-3], this->ValueStack.TheObjects[this->ValueStack.size-1]);
  this->DecreaseStackSetExpressionLastNode(2);
}

void Parser::AddUnaryMinusOnTop()
{ this->ExtendOnTop(1);
  ParserNode* theNode=this->LastObject();
  theNode->Operation=this->tokenMinusUnary;
  this->Own(this->size-1, this->ValueStack.TheObjects[this->ValueStack.size-1]);
  this->DecreaseStackSetExpressionLastNode(1);
}

void Parser::AddMapOnTop()
{ this->ExtendOnTop(1);
  ParserNode* theNode=this->LastObject();
  theNode->Operation=this->tokenMap;
  this->Own(this->size-1, this->ValueStack.TheObjects[this->ValueStack.size-1]);
  this->DecreaseStackSetExpressionLastNode(1);
}

void Parser::AddImpiedTimesOnTop()
{ this->ExtendOnTop(1);
  ParserNode* theNode=this->LastObject();
  theNode->Operation=this->tokenTimes;
  this->Own(this->size-1, this->ValueStack.TheObjects[this->ValueStack.size-2], this->ValueStack.TheObjects[this->ValueStack.size-1]);
  this->DecreaseStackSetExpressionLastNode(1);
}

void Parser::AddXECEXOnTop(int theOperation)
{ this->ExtendOnTop(1);
  this->LastObject()->Operation=theOperation;
  this->Own(this->size-1, this->ValueStack.TheObjects[this->ValueStack.size-4], this->ValueStack.TheObjects[this->ValueStack.size-2]);
  this->DecreaseStackSetExpressionLastNode(4);
}

void Parser::ParseAndCompute(const std::string& input, std::string& output, GlobalVariables& theGlobalVariables)
{ std::stringstream out; std::string tempS;
  this->Parse(input);
  out << "\\begin{eqnarray*}&&" << input << " = \\\\\n";
  this->Evaluate(theGlobalVariables);
//  this->WeylAlgebraValue.ElementToString(tempS, false, true, false);
  out << tempS;
  out << "\\end{eqnarray*}";
  output=out.str();
}

void Parser::Own(int indexParent, int indexChild1)
{ ParserNode* theNode= &this->TheObjects[indexParent];
  theNode->children.SetSize(1);
  theNode->children.TheObjects[0]=indexChild1;
  this->TheObjects[indexChild1].indexParentNode= indexParent;
}

void Parser::Own(int indexParent, int indexChild1, int indexChild2)
{ ParserNode* theNode= & this->TheObjects[indexParent];
  theNode->children.SetSize(2);
  theNode->children.TheObjects[0]=indexChild1;
  theNode->children.TheObjects[1]=indexChild2;
  this->TheObjects[indexChild1].indexParentNode= indexParent;
  this->TheObjects[indexChild2].indexParentNode= indexParent;
}

void Parser::Evaluate(GlobalVariables& theGlobalVariables)
{ if (this->TokenStack.size== this->numEmptyTokensAtBeginning+1)
    if (*this->TokenStack.LastObject()==this->tokenExpression)
    { this->TheObjects[this->ValueStack.TheObjects[this->numEmptyTokensAtBeginning]].Evaluate(theGlobalVariables);
//      this->WeylAlgebraValue.Assign(this->TheObjects[this->ValueStack.TheObjects[this->numEmptyTokensAtBeginning]].WeylAlgebraElement);
//      this->LieAlgebraValue= this->TheObjects[this->ValueStack.TheObjects[this->numEmptyTokensAtBeginning]].LieAlgebraElement;
      this->theValue=this->TheObjects[this->ValueStack.TheObjects[this->numEmptyTokensAtBeginning]];
    }
  if (this->TokenStack.size>this->numEmptyTokensAtBeginning+1)
    this->theValue.SetError(ParserNode::errorBadSyntax);
//  this->WeylAlgebraValue.ComputeDebugString(false, false);
}

void Parser::ExtendOnTop(int numNew)
{ this->SetSize(this->size+numNew);
  for (int i=0; i<numNew; i++)
  { this->TheObjects[this->size-1-i].owner=this;
    this->TheObjects[this->size-1-i].Clear();
    this->TheObjects[this->size-1-i].indexInOwner=this->size-1-i;
  }
}

void ParserNode::Evaluate(GlobalVariables& theGlobalVariables)
{ //this->UEElement.ComputeDebugString();
  this->Evaluated=true;
  for (int i=0; i<this->children.size; i++)
  { if (this->Operation==Parser::tokenMap)
      this->ContextLieAlgebra=&this->owner->theHmm.theDomain;
    this->owner->TheObjects[this->children.TheObjects[i]].ContextLieAlgebra=this->ContextLieAlgebra;
    this->owner->TheObjects[this->children.TheObjects[i]].Evaluate(theGlobalVariables);
    if (this->owner->TheObjects[this->children.TheObjects[i]].ExpressionType==this->typeError)
    { this->CopyError(this->owner->TheObjects[this->children.TheObjects[i]]);
      return;
    }
  }
  switch (this->Operation)
  { case Parser::tokenPlus: this->EvaluatePlus(theGlobalVariables); break;
    case Parser::tokenMinus: this->EvaluateMinus(theGlobalVariables); break;
    case Parser::tokenMinusUnary: this->EvaluateMinusUnary(theGlobalVariables); break;
    case Parser::tokenTimes: this->EvaluateTimes(theGlobalVariables); break;
    case Parser::tokenG: break;
    case Parser::tokenH: break;
    case Parser::tokenF: break;
    case Parser::tokenVariable: break;
    case Parser::tokenPartialDerivative: break;
    case Parser::tokenX: break;
    case Parser::tokenC: this->ExpressionType=this->typeUEelement; this->UEElement.GetElement().MakeCasimir(*this->ContextLieAlgebra, this->owner->NumVariables, theGlobalVariables); break;
    case Parser::tokenDivide: this->EvaluateDivide(theGlobalVariables); break;
    case Parser::tokenUnderscore: this->EvaluateUnderscore(theGlobalVariables); break;
    case Parser::tokenInteger: this->EvaluateInteger(theGlobalVariables); break;
    case Parser::tokenLieBracket: this->EvaluateLieBracket(theGlobalVariables); break;
    case Parser::tokenPower: this->EvaluateThePower(theGlobalVariables); break;
    case Parser::tokenMap: this->EvaluateEmbedding(theGlobalVariables); break;
    case Parser::tokenFunction: this->EvaluateFunction(theGlobalVariables); break;
    case Parser::tokenArraY: this->array.GetElement().CopyFromBase(this->children); this->ExpressionType=this->typeArray; break;
    case Parser::tokenMapsTo: this->EvaluateSubstitution(theGlobalVariables); break;
    case Parser::tokenColon: this->EvaluateApplySubstitution(theGlobalVariables); break;
    case Parser::tokenDereferenceArray: this->EvaluateDereferenceArray(theGlobalVariables); break;
    default: this->SetError(this->errorUnknownOperation); return;
  }
}

void ParserNode::EvaluateInteger(GlobalVariables& theGlobalVariables)
{ if (this->rationalValue.Extended!=0)
    this->ExpressionType=this->typeRational;
  else
  { this->ExpressionType= this->typeIntegerOrIndex;
    this->intValue= this->rationalValue.NumShort;
  }
}

void ParserNode::EvaluateThePower(GlobalVariables& theGlobalVariables)
{ this->ExpressionType=this->typeError;
  if (this->children.size!=2 || !this->AllChildrenAreOfDefinedNonErrorType())
  { this->SetError(this->errorOperationByUndefinedOrErrorType);
    return;
  }
  ParserNode& leftNode=this->owner->TheObjects[this->children.TheObjects[0]];
  ParserNode& rightNode=this->owner->TheObjects[this->children.TheObjects[1]];
  if (rightNode.ExpressionType!=this->typeIntegerOrIndex)
  { if ((rightNode.ExpressionType==this->typeRational || rightNode.ExpressionType==this->typePoly) && leftNode.ExpressionType==this->typeUEelement)
      if (leftNode.UEElement.GetElement().IsAPowerOfASingleGenerator())
        { rightNode.ConvertToType(this->typePoly, theGlobalVariables);
          leftNode.UEElement.GetElement().SetNumVariables(this->owner->NumVariables);
          MonomialUniversalEnveloping tempMon;
          tempMon.operator=(leftNode.UEElement.GetElement().TheObjects[0]);
          tempMon.Powers.TheObjects[0].MultiplyBy(rightNode.polyValue.GetElement());
          this->UEElement.GetElement().Nullify(*this->ContextLieAlgebra);
          this->UEElement.GetElement().AddMonomial(tempMon);
          this->ExpressionType=this->typeUEelement;
          return;
        }
     if ((rightNode.ExpressionType==this->typeRational || rightNode.ExpressionType==this->typePoly) && leftNode.ExpressionType==this->typeUEElementOrdered)
      if (leftNode.UEElementOrdered.GetElement().IsAPowerOfASingleGenerator())
        { rightNode.ConvertToType(this->typePoly, theGlobalVariables);
          leftNode.UEElementOrdered.GetElement().SetNumVariables(this->owner->NumVariables);
          MonomialUniversalEnvelopingOrdered<PolynomialRationalCoeff> tempMon;
          tempMon.operator=(leftNode.UEElementOrdered.GetElement().TheObjects[0]);
          tempMon.Powers.TheObjects[0].MultiplyBy(rightNode.polyValue.GetElement());
          this->UEElementOrdered.GetElement().Nullify(this->owner->testAlgebra);
          this->UEElementOrdered.GetElement().AddMonomial(tempMon);
          this->ExpressionType=this->typeUEElementOrdered;
          return;
        }
    this->SetError(this->errorDunnoHowToDoOperation);
    return;
  }
  int thePower= rightNode.intValue;
  PolynomialRationalCoeff PolyOne;
  PolyOne.MakeNVarConst(this->owner->NumVariables, (Rational) 1);
  switch(leftNode.ExpressionType)
  { case ParserNode::typeIntegerOrIndex:
      this->rationalValue=leftNode.intValue;
      this->rationalValue.RaiseToPower(thePower);
      this->ExpressionType=this->typeRational;
      break;
    case ParserNode::typeRational:
      this->rationalValue=leftNode.rationalValue;
      this->rationalValue.RaiseToPower(thePower);
      this->ExpressionType=this->typeRational;
      break;
    case ParserNode::typePoly:
      this->polyValue.GetElement()=leftNode.polyValue.GetElement();
      this->polyValue.GetElement().RaiseToPower(thePower, (Rational) 1);
      this->ExpressionType=this->typePoly;
      break;
    case ParserNode::typeRationalFunction:
      this->ratFunction.GetElement()=leftNode.ratFunction.GetElementConst();
      this->ratFunction.GetElement().RaiseToPower(thePower);
      this->ExpressionType=this->typeRationalFunction;
      break;
    case ParserNode::typeUEelement:
      this->UEElement.GetElement()=leftNode.UEElement.GetElement();
      this->UEElement.GetElement().RaiseToPower(thePower);
      this->ExpressionType=this->typeUEelement;
    break;
    case ParserNode::typeUEElementOrdered:
      this->UEElementOrdered.GetElement()=leftNode.UEElementOrdered.GetElement();
      this->UEElementOrdered.GetElement().RaiseToPower(thePower, PolyOne);
      this->ExpressionType=this->typeUEElementOrdered;
    break;
    case ParserNode::typeWeylAlgebraElement:
      this->WeylAlgebraElement.GetElement()=leftNode.WeylAlgebraElement.GetElement();
      this->WeylAlgebraElement.GetElement().RaiseToPower(thePower);
      this->ExpressionType=this->typeWeylAlgebraElement;
    break;
    default: this->SetError(this->errorDunnoHowToDoOperation); return;
  }
}

void ParserNode::EvaluateUnderscore(GlobalVariables& theGlobalVariables)
{ this->ExpressionType=this->typeError;
  if (this->children.size!=2)
  { this->SetError(this->errorProgramming);
    return;
  }
  ParserNode& leftNode=this->owner->TheObjects[this->children.TheObjects[0]];
  ParserNode& rightNode=this->owner->TheObjects[this->children.TheObjects[1]];
  if (rightNode.ExpressionType!=this->typeIntegerOrIndex)
  { this->SetError(this->errorBadIndex);
    return;
  }
  int theIndex= rightNode.intValue;
  int theDimension= this->ContextLieAlgebra->theWeyl.CartanSymmetric.NumRows;
  if (leftNode.Operation==Parser::tokenH)
  { theIndex--;
    if (theIndex>=theDimension || theIndex<0)
    { this->SetError(this->errorBadIndex);
      return;
    }
    root tempRoot;
    tempRoot.MakeEi(theDimension, theIndex);
    this->UEElement.GetElement().AssignElementCartan(tempRoot, this->owner->NumVariables, *this->ContextLieAlgebra);
    this->ExpressionType=this->typeUEelement;
    return;
  }
  if (leftNode.Operation==Parser::tokenG)
  { theIndex=this->ContextLieAlgebra->DisplayIndexToRootIndex(theIndex);
    theIndex=this->ContextLieAlgebra->RootIndexOrderAsInRootSystemToGeneratorIndexNegativeRootsThenCartanThenPositive(theIndex);
    if (theIndex<0 || theIndex>this->ContextLieAlgebra->theWeyl.RootSystem.size+theDimension)
    { this->SetError(this->errorBadIndex);
      return;
    }
    this->UEElement.GetElement().MakeOneGeneratorCoeffOne(theIndex, this->owner->NumVariables, *this->ContextLieAlgebra);
    this->ExpressionType=this->typeUEelement;
    return;
  }
  if (leftNode.Operation==Parser::tokenPartialDerivative)
  { theIndex--;
    if (theIndex<0 || theIndex>1000)
    { this->SetError(this->errorBadIndex);
      return;
    }
    this->owner->NumVariables=MathRoutines::Maximum(theIndex+1, this->owner->NumVariables);
    this->WeylAlgebraElement.GetElement().Makedi(theIndex, this->owner->NumVariables);
    this->ExpressionType=this->typeWeylAlgebraElement;
  }
  if (leftNode.Operation==Parser::tokenF)
  { if (theIndex>0 && theIndex<=this->ContextLieAlgebra->GetNumPosRoots())
      theIndex+= this->ContextLieAlgebra->GetNumPosRoots()+this->ContextLieAlgebra->GetRank()-1;
    else if (theIndex<=0)
      theIndex+= this->ContextLieAlgebra->GetNumPosRoots();
    else
      theIndex--;
    if (theIndex<0 || theIndex>this->ContextLieAlgebra->theWeyl.RootSystem.size+this->ContextLieAlgebra->GetRank())
    { this->SetError(this->errorBadIndex);
      return;
    }
    PolynomialRationalCoeff polyOne;
    polyOne.MakeNVarConst(this->owner->NumVariables, (Rational) 1);
    this->UEElementOrdered.GetElement().MakeOneGenerator(theIndex, polyOne, this->owner->testAlgebra, &theGlobalVariables);
    this->ExpressionType=this->typeUEElementOrdered;
    return;
  }
  if (leftNode.Operation==Parser::tokenX)
    leftNode.Operation=Parser::tokenVariable;
  if (leftNode.Operation==Parser::tokenVariable)
  { if (theIndex<1 || theIndex>1000)
    { this->SetError(this->errorBadIndex);
      return;
    }
    this->owner->NumVariables=MathRoutines::Maximum(theIndex, this->owner->NumVariables);
    this->polyValue.GetElement().MakeMonomialOneLetter((int)this->owner->NumVariables, theIndex-1, 1, (Rational) 1);
    this->ExpressionType=this->typePoly;
    return;
  }
}

bool ParserNode::ConvertChildrenToType(int theType, GlobalVariables& theGlobalVariables)
{ for (int i=0; i<this->children.size; i++)
    if (!this->owner->TheObjects[this->children.TheObjects[i]].ConvertToType(theType, theGlobalVariables))
      return false;
  return true;
}

void ParserNode::InitForAddition(GlobalVariables* theContext)
{ this->intValue=0;
  this->rationalValue.MakeZero();
  if (this->ExpressionType==this->typePoly)
    this->polyValue.GetElement().Nullify((int)this->owner->NumVariables);
  if (this->ExpressionType==this->typeUEelement)
    this->UEElement.GetElement().Nullify(*this->ContextLieAlgebra);
  if (this->ExpressionType==this->typeUEElementOrdered)
    this->UEElementOrdered.GetElement().Nullify(this->owner->testAlgebra);
  if (this->ExpressionType==this->typeWeylAlgebraElement)
    this->WeylAlgebraElement.GetElement().Nullify(this->owner->NumVariables);
  if (this->ExpressionType==this->typeRationalFunction)
    this->ratFunction.GetElement().Nullify(this->owner->NumVariables, theContext);
}

void ParserNode::InitForMultiplication(GlobalVariables* theContext)
{ this->intValue=1;
  this->rationalValue=1;
  if(this->ExpressionType==this->typePoly)
    this->polyValue.GetElement().MakeNVarConst((int)this->owner->NumVariables, (Rational)1);
  if(this->ExpressionType==this->typeUEelement)
    this->UEElement.GetElement().AssignInt(1, this->owner->NumVariables, *this->ContextLieAlgebra);
  if(this->ExpressionType==this->typeUEElementOrdered)
  { PolynomialRationalCoeff PolyOne;
    PolyOne.MakeNVarConst(this->owner->NumVariables, (Rational) 1);
    this->UEElementOrdered.GetElement().MakeConst(PolyOne, this->owner->testAlgebra);
  }
  if(this->ExpressionType==this->typeWeylAlgebraElement)
    this->WeylAlgebraElement.GetElement().MakeConst(this->owner->NumVariables, (Rational) 1);
  if (this->ExpressionType==this->typeRationalFunction)
    this->ratFunction.GetElement().MakeNVarConst(this->owner->NumVariables, (Rational) 1, theContext);
}

int ParserNode::GetStrongestExpressionChildrenConvertChildrenIfNeeded(GlobalVariables& theGlobalVariables)
{ int result=this->typeUndefined;
  for (int i=0; i<this->children.size; i++)
  { int childExpressionType=this->owner->TheObjects[this->children.TheObjects[i]].ExpressionType;
    if (childExpressionType>result)
      result=childExpressionType;
  }
  for (int i=0; i<this->children.size; i++)
    if(!this->owner->TheObjects[this->children.TheObjects[i]].ConvertToType(result, theGlobalVariables))
    { this->SetError(this->owner->TheObjects[this->children.TheObjects[i]].ErrorType);
      return this->typeError;
    }
  return result;
}

void ParserNode::ConvertChildrenAndMyselfToStrongestExpressionChildren(GlobalVariables& theGlobalVariables)
{ this->ExpressionType=this->GetStrongestExpressionChildrenConvertChildrenIfNeeded(theGlobalVariables);
}

void ParserNode::EvaluateMinus(GlobalVariables& theGlobalVariables)
{ if (!this->AllChildrenAreOfDefinedNonErrorType())
  { this->ExpressionType=this->typeError;
    return;
  }
  this->ConvertChildrenAndMyselfToStrongestExpressionChildren(theGlobalVariables);
  this->InitForAddition(&theGlobalVariables);
  for (int i=0; i<this->children.size; i++)
  { ParserNode& currentChild=this->owner->TheObjects[this->children.TheObjects[i]];
    switch (this->ExpressionType)
    { case ParserNode::typeIntegerOrIndex: if (i==0) this->intValue+=currentChild.intValue; else this->intValue-=currentChild.intValue; break;
      case ParserNode::typeRational: if (i==0) this->rationalValue+=currentChild.rationalValue; else this->rationalValue-=currentChild.rationalValue; break;
      case ParserNode::typePoly: if(i==0) this->polyValue.GetElement().AddPolynomial(currentChild.polyValue.GetElement()); else this->polyValue.GetElement().Subtract(currentChild.polyValue.GetElement()); break;
      case ParserNode::typeRationalFunction: if(i==0) this->ratFunction.GetElement()+=(currentChild.ratFunction.GetElement()); else this->ratFunction.GetElement()-=(currentChild.ratFunction.GetElement()); break;
      case ParserNode::typeUEelement: if (i==0) this->UEElement.GetElement()+=currentChild.UEElement.GetElement(); else this->UEElement.GetElement()-=currentChild.UEElement.GetElement(); break;
      case ParserNode::typeUEElementOrdered: if (i==0) this->UEElementOrdered.GetElement()+=currentChild.UEElementOrdered.GetElement(); else this->UEElementOrdered.GetElement()-=currentChild.UEElementOrdered.GetElement(); break;
      case ParserNode::typeWeylAlgebraElement: if (i==0) this->WeylAlgebraElement.GetElement()+=currentChild.WeylAlgebraElement.GetElement(); else this->WeylAlgebraElement.GetElement()-=currentChild.WeylAlgebraElement.GetElement(); break;
      default: this->ExpressionType=this->typeError; return;
    }
  }
}

void ParserNode::EvaluateMinusUnary(GlobalVariables& theGlobalVariables)
{ if (!this->AllChildrenAreOfDefinedNonErrorType())
  { this->ExpressionType=this->typeError;
    return;
  }
  this->ConvertChildrenAndMyselfToStrongestExpressionChildren(theGlobalVariables);
  this->InitForAddition(&theGlobalVariables);
  ParserNode& currentChild=this->owner->TheObjects[this->children.TheObjects[0]];
  switch (this->ExpressionType)
  { case ParserNode::typeIntegerOrIndex: this->intValue-=currentChild.intValue; break;
    case ParserNode::typeRational: this->rationalValue-=currentChild.rationalValue; break;
    case ParserNode::typePoly: this->polyValue.GetElement().Subtract(currentChild.polyValue.GetElement()); break;
    case ParserNode::typeUEelement: this->UEElement.GetElement()-=currentChild.UEElement.GetElement(); break;
    case ParserNode::typeUEElementOrdered: this->UEElementOrdered.GetElement()-=currentChild.UEElementOrdered.GetElement(); break;
    case ParserNode::typeWeylAlgebraElement: this->WeylAlgebraElement.GetElement()-=currentChild.WeylAlgebraElement.GetElement(); break;
    default: this->ExpressionType=this->typeError; return;
  }
}

void ParserNode::ReduceRatFunction()
{ if (this->ExpressionType!=this->typeRationalFunction)
    return;
  this->ratFunction.GetElement().ReduceMemory();
  switch (this->ratFunction.GetElement().expressionType)
  { case RationalFunction::typeRational:
      this->rationalValue= this->ratFunction.GetElement().ratValue;
      this->ExpressionType=this->typeRational;
      break;
    case RationalFunction::typePoly:
      this->polyValue.GetElement().operator=(this->ratFunction.GetElement().Numerator.GetElement());
      this->ExpressionType=this->typePoly;
      break;
  }
}

bool ParserNode::OneChildrenOrMoreAreOfType(int theType)
{ for (int i=0; i<this->children.size; i++)
    if (this->owner->TheObjects[this->children.TheObjects[i]].ExpressionType==theType)
      return true;
  return false;
}

bool ParserNode::AllChildrenAreOfDefinedNonErrorType()
{ for (int i=0; i<this->children.size; i++)
    if (this->owner->TheObjects[this->children.TheObjects[i]].ExpressionType==this->typeError || this->owner->TheObjects[this->children.TheObjects[i]].ExpressionType==this->typeUndefined)
      return false;
  return true;
}

void ParserNode::EvaluateSecretSauce(GlobalVariables& theGlobalVariables)
{ EigenVectorComputation theComp;
  this->outputString=theComp.ComputeAndReturnStringNonOrdered(theGlobalVariables, *this->owner);
  this->ExpressionType=this->typeString;
}

void ParserNode::EvaluatePrintEmbedding(GlobalVariables& theGlobalVariables)
{ SSalgebraModule theModule;
  std::stringstream out;
  theModule.InduceFromEmbedding(out, this->owner->theHmm, theGlobalVariables);
  for (int i=0; i<theModule.actionsNegativeRootSpacesCartanPositiveRootspaces.size; i++)
  { out << "<br><div class=\"math\">" << theModule.actionsNegativeRootSpacesCartanPositiveRootspaces.TheObjects[i].ElementToString(false, true) << "</div>";
  }
  this->outputString=out.str();
  this->ExpressionType=this->typeString;
}

void ParserNode::EvaluateSecretSauceOrdered(GlobalVariables& theGlobalVariables)
{ EigenVectorComputation theComp;
  //Note: the ComputeAndReturnStringOrdered following code might relocate the *this object
  //Until I think of a more conceptual solution I shall use the below safe but rather ugly workaround
  int indexInOwneR=this->indexInOwner;
  Parser* theOwner=this->owner;
  std::string buffer=theComp.ComputeAndReturnStringOrdered(theGlobalVariables, *this->owner, indexInOwneR);
  theOwner->TheObjects[indexInOwneR].outputString=buffer;
  theOwner->TheObjects[indexInOwneR].ExpressionType=ParserNode::typeArray;
  theOwner->TheObjects[indexInOwneR].array.GetElement();
}

void ParserNode::EvaluateLieBracket(GlobalVariables& theGlobalVariables)
{ if (this->children.size!=2 || !this->AllChildrenAreOfDefinedNonErrorType())
  { this->ExpressionType=this->typeError;
    return;
  }
  this->ExpressionType=this->typeUEelement;
  if (this->OneChildrenOrMoreAreOfType(this->typeWeylAlgebraElement))
  { this->ExpressionType=this->typeWeylAlgebraElement;
    if (this->OneChildrenOrMoreAreOfType(this->typeUEelement) || this->OneChildrenOrMoreAreOfType(this->typeUEElementOrdered))
    { this->SetError(this->errorMultiplicationByNonAllowedTypes);
      return;
    }
  }
  if (this->OneChildrenOrMoreAreOfType(this->typeUEElementOrdered) && !this->OneChildrenOrMoreAreOfType(this->typeUEelement))
    this->ExpressionType= this->typeUEElementOrdered;
  for (int i=0; i<this->children.size; i++)
    if(!this->owner->TheObjects[this->children.TheObjects[i]].ConvertToType(this->ExpressionType, theGlobalVariables))
    { this->SetError(this->errorDunnoHowToDoOperation);
      return;
    }
  if (this->ExpressionType==this->typeUEelement)
  { ElementUniversalEnveloping& left= this->owner->TheObjects[this->children.TheObjects[0]].UEElement.GetElement();
    ElementUniversalEnveloping& right= this->owner->TheObjects[this->children.TheObjects[1]].UEElement.GetElement();
    left.LieBracketOnTheRight(right, this->UEElement.GetElement());
  } else if (this->ExpressionType==this->typeUEElementOrdered)
  { ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff>& left=this->owner->TheObjects[this->children.TheObjects[0]].UEElementOrdered.GetElement();
    ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff>& right= this->owner->TheObjects[this->children.TheObjects[1]].UEElementOrdered.GetElement();
    left.LieBracketOnTheRight(right, this->UEElementOrdered.GetElement());
    this->UEElementOrdered.GetElement().Simplify(&theGlobalVariables);
  } else if (this->ExpressionType==this->typeWeylAlgebraElement)
  { ElementWeylAlgebra& left=this->owner->TheObjects[this->children.TheObjects[0]].WeylAlgebraElement.GetElement();
    ElementWeylAlgebra& right= this->owner->TheObjects[this->children.TheObjects[1]].WeylAlgebraElement.GetElement();
    this->WeylAlgebraElement.GetElement().Assign(left);
    this->WeylAlgebraElement.GetElement().LieBracketOnTheRight(right, theGlobalVariables);
  } else
    this->SetError(this->errorProgramming);
}

void ParserNode::EvaluateEmbedding(GlobalVariables& theGlobalVariables)
{ if (!this->children.size==1)
  { this->SetError(this->errorProgramming);
    return;
  }
  ParserNode& child= this->owner->TheObjects[this->children.TheObjects[0]];
  if (child.ExpressionType!=this->typeUEelement)
  { this->SetError(this->errorOperationByUndefinedOrErrorType);
    return;
  }
  if (! this->owner->theHmm.ApplyHomomorphism(child.UEElement.GetElement(), this->UEElement.GetElement(), theGlobalVariables))
  { this->SetError(this->errorBadIndex);
    return;
  }
  this->ExpressionType=this->typeUEelement;
}

void ParserNode::EvaluateGCDorLCM(GlobalVariables& theGlobalVariables)
{ if (!this->AllChildrenAreOfDefinedNonErrorType())
  { this->SetError(this->errorOperationByUndefinedOrErrorType);
    return;
  }
  if (this->children.size!=1)
  { this->SetError(this->errorProgramming);
    return;
  }
  ParserNode& theRootNode= this->owner->TheObjects[this->children.TheObjects[0]];
  List<int>& theTrueChildren= theRootNode.children;
  if (theRootNode.ExpressionType!=this->typeArray)
  { this->SetError(this->errorBadOrNoArgument);
    return;
  }
  if (theTrueChildren.size!=2)
  { this->SetError(this->errorWrongNumberOfArguments);
    return;
  }
  this->ExpressionType=theRootNode.GetStrongestExpressionChildrenConvertChildrenIfNeeded(theGlobalVariables);
  if (this->ExpressionType==this->typeError)
    return;
  ParserNode& leftNode=this->owner->TheObjects[theTrueChildren.TheObjects[0]];
  ParserNode& rightNode=this->owner->TheObjects[theTrueChildren.TheObjects[1]];
  LargeIntUnsigned tempUI1, tempUI2, tempUI3;
  LargeInt tempInt=0;
  Rational tempRat;
  int tempI2;
  int theFunction=this->intValue;
  switch(leftNode.ExpressionType)
  { case ParserNode::typeIntegerOrIndex:
      if (leftNode.intValue==0 || rightNode.intValue==0)
      { this->SetError(this->errorDivisionByZero);
        return;
      }
      if (theFunction==Parser::functionGCD)
      { this->intValue= Rational::gcd(leftNode.intValue, rightNode.intValue);
        this->ExpressionType=this->typeIntegerOrIndex;
      } else
      { tempRat=leftNode.intValue;
        tempRat.MultiplyByInt(rightNode.intValue);
        tempI2=Rational::gcd(leftNode.intValue, rightNode.intValue);
        tempRat.DivideByInteger(tempI2);
        if (tempRat.IsSmallInteger())
        { this->intValue=tempRat.NumShort;
          this->ExpressionType=this->typeIntegerOrIndex;
        } else
        { this->rationalValue=tempRat;
          this->ExpressionType=this->typeRational;
        }
      }
      break;
    case ParserNode::typeRational:
      if (!leftNode.rationalValue.IsInteger() && !rightNode.rationalValue.IsInteger())
        this->SetError(this->errorDunnoHowToDoOperation);
      else
      { leftNode.rationalValue.GetNumUnsigned(tempUI1);
        rightNode.rationalValue.GetNumUnsigned(tempUI2);
        if (theFunction==Parser::functionGCD)
          LargeIntUnsigned::gcd(tempUI1, tempUI2, tempUI3);
        else
          LargeIntUnsigned::lcm(tempUI1, tempUI2, tempUI3);
        tempInt.AddLargeIntUnsigned(tempUI3);
        this->rationalValue.AssignLargeInteger(tempInt);
        this->ExpressionType=this->typeRational;
      }
      break;
    case ParserNode::typePoly:
      if (leftNode.polyValue.GetElement().IsEqualToZero() || rightNode.polyValue.GetElement().IsEqualToZero())
      { this->SetError(this->errorDivisionByZero);
        return;
      }
      if (theFunction==Parser::functionGCD)
        RationalFunction::gcd(leftNode.polyValue.GetElement(), rightNode.polyValue.GetElement(), this->polyValue.GetElement(), &theGlobalVariables);
      else
        RationalFunction::lcm(leftNode.polyValue.GetElement(), rightNode.polyValue.GetElement(), this->polyValue.GetElement());
      this->ExpressionType=this->typePoly;
      break;
    case ParserNode::typeUEelement:
      this->SetError(errorDunnoHowToDoOperation);
    break;
    default: this->SetError(this->errorDunnoHowToDoOperation); return;
  }
}

ParserNode::ParserNode()
{ this->owner=0;
  this->Clear();
}

void Parser::ElementToString(std::string& output, bool useHtml, GlobalVariables& theGlobalVariables)
{ std::stringstream out; std::string tempS;
  out << "String: " << this->StringBeingParsed << "\n";
  if (useHtml)
    out << "<br>";
  out << "Tokens: ";
  for (int i=0; i<this->TokenBuffer.size; i++)
    this->TokenToStringStream(out, this->TokenBuffer.TheObjects[i]);
  out << "\nToken stack: ";
  for (int i=this->numEmptyTokensAtBeginning; i<this->TokenStack.size; i++)
    this->TokenToStringStream(out, this->TokenStack.TheObjects[i]);
  if (useHtml)
    out << "<br>";
  out << "\nValue stack: ";
  for (int i=this->numEmptyTokensAtBeginning; i<this->ValueStack.size; i++)
    out << this->ValueStack.TheObjects[i] << ", ";
  if (useHtml)
    out << "<br>";
  out << "\nElements:\n";
  if (useHtml)
    out << "<br>";
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].ElementToString(tempS);
    out << " Index: " << i << " " << tempS << ";\n";
    if (useHtml)
      out << "<br>";
  }
  if (useHtml)
    out << "<br><br>";
  out << "\n\nValue: " << this->theValue.ElementToStringValueAndType(false);

//  this->WeylAlgebraValue.ComputeDebugString(false, false);
//  this->LieAlgebraValue.ComputeDebugString(this->theLieAlgebra, false, false);
//  out << "\n\nWeyl algebra value: " << this->WeylAlgebraValue.DebugString;
//  out << "\nLie algebra value: " << this->LieAlgebraValue.DebugString;
  if (!useHtml)
  { out << "\nAmbient Lie algebra details:\n";
    out << this->theHmm.theRange.ElementToStringLieBracketPairing();
  }
  output=out.str();
}

void Parser::TokenToStringStream(std::stringstream& out, int theToken)
{ //out << theToken << " ";
  switch(theToken)
  { case Parser::tokenX: out << "x"; break;
    case Parser::tokenDigit: out << "D"; break;
    case Parser::tokenPlus: out << "+"; break;
    case Parser::tokenUnderscore: out << "_"; break;
    case Parser::tokenEmpty: out << " "; break;
    case Parser::tokenExpression: out << "E"; break;
    case Parser::tokenOpenLieBracket: out << "["; break;
    case Parser::tokenCloseLieBracket: out << "]"; break;
    case Parser::tokenLieBracket: out << "[, ]"; break;
    case Parser::tokenComma: out << ", "; break;
    case Parser::tokenOpenCurlyBracket: out << "{"; break;
    case Parser::tokenCloseCurlyBracket: out << "}"; break;
    case Parser::tokenOpenBracket: out << "("; break;
    case Parser::tokenCloseBracket: out << ")"; break;
    case Parser::tokenPartialDerivative: out << "d"; break;
    case Parser::tokenTimes: out << "*"; break;
    case Parser::tokenMinus: out << "-"; break;
    case Parser::tokenG : out << "g"; break;
    case Parser::tokenInteger: out << "Integer"; break;
    case Parser::tokenDivide: out << "/"; break;
    case Parser::tokenH: out << "h"; break;
    case Parser::tokenPower: out << "^"; break;
    case Parser::tokenC: out << "c"; break;
    case Parser::tokenMap: out << "i"; break;
    case Parser::tokenMinusUnary: out << "-"; break;
    case Parser::tokenVariable: out << "n"; break;
    case Parser::tokenArraY: out << "array"; break;
    case Parser::tokenDereferenceArray: out << "deref[]"; break;
    case Parser::tokenMapsTo: out << "->"; break;
    case Parser::tokenFunction: out << "function"; break;
    case Parser::tokenEndStatement: out << ";"; break;
    case Parser::tokenColon: out << ":"; break;
//    case Parser::tokenSubstitution: out << "Substitution: "; break;
    case Parser::tokenFunctionNoArgument: out << "functionNoArgument"; break;
    case Parser::tokenF: out << "f"; break;
    default: out << "?"; break;
  }
}

void Parser::Clear()
{ this->theValue.Clear();
  this->theValue.UEElement.GetElement().Nullify(this->theHmm.theRange);
  this->TokenStack.size=0;
  this->ValueStack.size=0;
}

void Parser::ComputeNumberOfVariablesAndAdjustNodes()
{ this->NumVariables=0;
  for(int i=0; i<this->size; i++)
    if (this->NumVariables< this->TheObjects[i].WeylAlgebraElement.GetElement().NumVariables)
      this->NumVariables=this->TheObjects[i].WeylAlgebraElement.GetElement().NumVariables;
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].WeylAlgebraElement.GetElement().SetNumVariablesPreserveExistingOnes(this->NumVariables);
}

std::string ParserNode::ElementToStringErrorCode(bool useHtml)
{ std::stringstream out;
  switch (this->ErrorType)
  { case ParserNode::errorBadIndex: out << "error: bad index"; break;
    case ParserNode::errorDimensionProblem: out << "error with dimension and/or number of arguments"; break;
    case ParserNode::errorBadOrNoArgument: out << "error: bad or no argument"; break;
    case ParserNode::errorBadSyntax: out << "error: bad syntax."; break;
    case ParserNode::errorDunnoHowToDoOperation: out << "error: my master hasn't taught me how to do this operation (maybe he doesn't know how either)"; break;
    case ParserNode::errorDivisionByZero: out << "error: division by zero"; break;
    case ParserNode::errorDivisionByNonAllowedType: out << "error: division of/by non-allowed type"; break;
    case ParserNode::errorMultiplicationByNonAllowedTypes: out << "error: multiplication by non-allowed types"; break;
    case ParserNode::errorNoError: out << "error: error type claims no error, but expression type claims error. Slap the programmer."; break;
    case ParserNode::errorOperationByUndefinedOrErrorType: out << "error: operation with an undefined type"; break;
    case ParserNode::errorProgramming: out << "error: there has been some programming mistake (it's not your expression's fault). Slap the programmer!"; break;
    case ParserNode::errorUnknownOperation: out << "error: unknown operation. The lazy programmer has added the operation to the dictionary, but hasn't implemented it yet. Lazy programmers deserve no salary. "; break;
    case ParserNode::errorImplicitRequirementNotSatisfied: out << "Error: an implicit requirement for the funciton input has not been satisfied."; break;
    default: out << "Non-documented error. Lazy programmers deserve no salaries.";
  }
  return out.str();
}

void ParserNode::ElementToString(std::string& output)
{ std::stringstream out; std::string tempS;
  owner->TokenToStringStream(out, this->Operation);
  if (this->children.size>0)
  { out << " Its children are: ";
    for (int i=0; i<this->children.size; i++)
      out << this->children.TheObjects[i] << ", ";
  }
  PolynomialOutputFormat PolyFormatLocal;
  out << this->ElementToStringValueAndType(false);
  output=out.str();
}

bool HomomorphismSemisimpleLieAlgebra::ComputeHomomorphismFromImagesSimpleChevalleyGenerators(GlobalVariables& theGlobalVariables)
{ int theDomainDimension= this->theDomain.theWeyl.CartanSymmetric.NumRows;
  Selection NonExplored;
  int numRoots= this->theDomain.theWeyl.RootSystem.size;
  NonExplored.init(numRoots);
  NonExplored.MakeFullSelection();
  root domainRoot, rangeRoot;
  this->theDomain.ComputeChevalleyConstants(this->theDomain.theWeyl, theGlobalVariables);
  this->theRange.ComputeChevalleyConstants(this->theRange.theWeyl, theGlobalVariables);
  List<ElementSimpleLieAlgebra> tempDomain, tempRange;
  tempDomain.SetSize(numRoots+theDomainDimension);
  tempRange.SetSize(numRoots+theDomainDimension);
  root tempRoot;
  for (int i=0; i<theDomainDimension; i++)
  { tempRoot.MakeEi(theDomainDimension, i);
    for (int j=0; j<2; j++, tempRoot.MinusRoot())
    { int index= this->theDomain.theWeyl.RootSystem.IndexOfObjectHash(tempRoot);
      tempDomain.TheObjects[index].Nullify(this->theDomain);
      tempDomain.TheObjects[index].SetCoefficient(tempRoot, 1, this->theDomain);
      tempRange.TheObjects[index] = this->imagesSimpleChevalleyGenerators.TheObjects[i+j*theDomainDimension];
      NonExplored.RemoveSelection(index);
//      std::cout <<"<br>" << tempDomain.TheObjects[index].ElementToStringNegativeRootSpacesFirst(false, true, this->theDomain);
//      std::cout <<"->" << tempRange.TheObjects[index].ElementToStringNegativeRootSpacesFirst(false, true, this->theRange);
    }
  }
//  std::cout << this->ElementToString(theGlobalVariables) << "<br>";
  ElementSimpleLieAlgebra tempElt;
  root right;
  while (NonExplored.CardinalitySelection>0)
  { for (int i=0; i<NonExplored.CardinalitySelection; i++)
    { int theIndex = NonExplored.elements[i];
      root& current = this->theDomain.theWeyl.RootSystem.TheObjects[theIndex];
      for (int j=0; j<NonExplored.MaxSize; j++)
        if (!NonExplored.selected[j])
        { root& left= this->theDomain.theWeyl.RootSystem.TheObjects[j];
          right= current-left;
//          left.ComputeDebugString(); right.ComputeDebugString(); current.ComputeDebugString();
          if (this->theDomain.theWeyl.IsARoot(right))
          { int leftIndex= this->theDomain.theWeyl.RootSystem.IndexOfObjectHash(left);
            int rightIndex= this->theDomain.theWeyl.RootSystem.IndexOfObjectHash(right);
            if (!NonExplored.selected[rightIndex])
            { ElementSimpleLieAlgebra& leftDomainElt=tempDomain.TheObjects[leftIndex];
              ElementSimpleLieAlgebra& rightDomainElt= tempDomain.TheObjects[rightIndex];
              this->theDomain.LieBracket(leftDomainElt, rightDomainElt, tempDomain.TheObjects[theIndex]);
              ElementSimpleLieAlgebra& leftRangeElt=tempRange.TheObjects[leftIndex];
              ElementSimpleLieAlgebra& rightRangeElt= tempRange.TheObjects[rightIndex];
              this->theRange.LieBracket(leftRangeElt, rightRangeElt, tempRange.TheObjects[theIndex]);
              NonExplored.RemoveSelection(theIndex);
              break;
            }
          }
        }
    }
  }
  for (int i=0; i<theDomainDimension; i++)
  { tempRoot.MakeEi(theDomainDimension, i);
    int leftIndex= this->theDomain.theWeyl.RootSystem.IndexOfObjectHash(tempRoot);
    int rightIndex= this->theDomain.theWeyl.RootSystem.IndexOfObjectHash(-tempRoot);
    this->theDomain.LieBracket(tempDomain.TheObjects[leftIndex], tempDomain.TheObjects[rightIndex], tempDomain.TheObjects[numRoots+i]);
    this->theRange.LieBracket(tempRange.TheObjects[leftIndex], tempRange.TheObjects[rightIndex], tempRange.TheObjects[numRoots+i]);
  }
  roots vectorsLeft, vectorsRight;
  vectorsLeft.SetSize(tempDomain.size);
  vectorsRight.SetSize(tempDomain.size);
  for (int i=0; i<tempRange.size; i++)
  { tempDomain.TheObjects[i].ElementToVectorRootSpacesFirstThenCartan(vectorsLeft.TheObjects[i]);
    tempRange.TheObjects[i].ElementToVectorRootSpacesFirstThenCartan(vectorsRight.TheObjects[i]);
  }
  MatrixLargeRational tempMat;
  tempMat.MakeLinearOperatorFromDomainAndRange(vectorsLeft, vectorsRight, theGlobalVariables);
  root imageRoot;
  this->domainAllChevalleyGenerators.SetSize(tempDomain.size);
  this->imagesAllChevalleyGenerators.SetSize(tempDomain.size);
  for (int i=0; i<this->theDomain.theWeyl.RootSystem.size; i++)
  { tempElt.Nullify(this->theDomain);
    tempElt.SetCoefficient(this->theDomain.theWeyl.RootSystem.TheObjects[i], 1, this->theDomain);
    this->domainAllChevalleyGenerators.TheObjects[this->theDomain.RootIndexOrderAsInRootSystemToGeneratorIndexNegativeRootsThenCartanThenPositive(i)]=tempElt;
  }
//  std::cout << "Domain type:" << this->theDomain.theWeyl.WeylLetter;
//  std::cout <<  tempMat.ElementToString( true, false);
  for (int i=0; i<theDomainDimension; i++)
  { tempElt.Nullify(this->theDomain);
    tempElt.Hcomponent.MakeEi(theDomainDimension, i);
    this->domainAllChevalleyGenerators.TheObjects[this->theDomain.CartanIndexToChevalleyGeneratorIndex(i)]=tempElt;
  }
  for (int i=0; i<this->imagesAllChevalleyGenerators.size; i++)
  { this->domainAllChevalleyGenerators.TheObjects[i].ElementToVectorRootSpacesFirstThenCartan(tempRoot);
    tempMat.ActOnAroot(tempRoot, imageRoot);
    this->imagesAllChevalleyGenerators.TheObjects[i].AssignVectorRootSpacesFirstThenCartan(imageRoot, this->theRange);
//    std::cout << this->domainAllChevalleyGenerators.TheObjects[i].ElementToStringNegativeRootSpacesFirst(false, true, this->theDomain);
//    std::cout << "->" << this->imagesAllChevalleyGenerators.TheObjects[i].ElementToStringNegativeRootSpacesFirst(false, true, this->theRange);
//    std::cout << "<br>";
  }
  return true;
}

void HomomorphismSemisimpleLieAlgebra::ProjectOntoSmallCartan(roots& input, roots& output, GlobalVariables& theGlobalVariables)
{ output.SetSize(input.size);
  for (int i=0; i<input.size; i++)
    this->ProjectOntoSmallCartan(input.TheObjects[i], output.TheObjects[i], theGlobalVariables);
}

void HomomorphismSemisimpleLieAlgebra::ProjectOntoSmallCartan(root& input, root& output, GlobalVariables& theGlobalVariables)
{ MatrixLargeRational invertedSmallCartan;
  invertedSmallCartan=this->theDomain.theWeyl.CartanSymmetric;
  invertedSmallCartan.Invert(theGlobalVariables);
  int theSmallDimension=this->theDomain.theWeyl.CartanSymmetric.NumRows;
  output.MakeZero(theSmallDimension);
  for (int i=0; i<theSmallDimension; i++)
    output.TheObjects[i]= this->theRange.theWeyl.RootScalarCartanRoot(this->imagesAllChevalleyGenerators.TheObjects[this->theDomain.theWeyl.RootsOfBorel.size+i].Hcomponent, input);
  invertedSmallCartan.ActOnAroot(output, output);
}

bool HomomorphismSemisimpleLieAlgebra::ApplyHomomorphism(MonomialUniversalEnveloping& input, ElementUniversalEnveloping& output, GlobalVariables& theGlobalVariables)
{ ElementUniversalEnveloping tempElt;
  output.Nullify(this->theRange);
  output.MakeConst(input.Coefficient, this->theRange);
  for (int i=0; i<input.generatorsIndices.size; i++)
  { if (input.generatorsIndices.TheObjects[i]>=this->imagesAllChevalleyGenerators.size)
      return false;
    tempElt.AssignElementLieAlgebra(this->imagesAllChevalleyGenerators.TheObjects[input.generatorsIndices.TheObjects[i]], input.Coefficient.NumVars, this->theRange);
    PolynomialRationalCoeff& thePower=input.Powers.TheObjects[i];
    if (thePower.TotalDegree()>0)
      return false;
    int theIntegralPower=thePower.TheObjects[0].Coefficient.NumShort;
    for (int j=0; j<theIntegralPower; j++)
      output*=tempElt;
  }
  return true;
}

bool HomomorphismSemisimpleLieAlgebra::ApplyHomomorphism(ElementUniversalEnveloping& input, ElementUniversalEnveloping& output, GlobalVariables& theGlobalVariables)
{ assert(&output!=&input);
  output.Nullify(this->theRange);
  ElementUniversalEnveloping tempElt;
  for (int i=0; i<input.size; i++)
  { if(!this->ApplyHomomorphism(input.TheObjects[i], tempElt, theGlobalVariables))
      return false;
    output+=tempElt;
  }
  return true;
}

void HomomorphismSemisimpleLieAlgebra::MakeGinGWithId(char theWeylLetter, int theWeylDim, GlobalVariables& theGlobalVariables)
{ this->theDomain.ComputeChevalleyConstants(theWeylLetter, theWeylDim, theGlobalVariables);
  this->theRange.ComputeChevalleyConstants(theWeylLetter, theWeylDim, theGlobalVariables);
  int numPosRoots=this->theDomain.theWeyl.RootsOfBorel.size;
  this->imagesAllChevalleyGenerators.SetSize(numPosRoots*2+theWeylDim);
  this->domainAllChevalleyGenerators.SetSize(numPosRoots*2+theWeylDim);
  this->imagesSimpleChevalleyGenerators.SetSize(theWeylDim*2);
  for (int i=0; i<2*numPosRoots+theWeylDim; i++)
  { ElementSimpleLieAlgebra& tempElt1=this->imagesAllChevalleyGenerators.TheObjects[i];
    ElementSimpleLieAlgebra& tempElt2=this->domainAllChevalleyGenerators.TheObjects[i];
    tempElt2.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(i, this->theDomain);
    tempElt1.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(i, this->theRange);
  }
  for (int i=0; i<theWeylDim; i++)
  { ElementSimpleLieAlgebra& tempElt1=this->imagesSimpleChevalleyGenerators.TheObjects[i];
    tempElt1.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(i, this->theRange);
    ElementSimpleLieAlgebra& tempElt2=this->imagesSimpleChevalleyGenerators.TheObjects[theWeylDim+i];
    tempElt2.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(i+numPosRoots, this->theRange);
  }
//  std::cout << this->ElementToString(theGlobalVariables);
}

void HomomorphismSemisimpleLieAlgebra::MakeG2InB3(Parser& owner, GlobalVariables& theGlobalVariables)
{ owner.DefaultWeylLetter='B';
  owner.DefaultWeylRank=3;
  owner.theHmm.theRange.ComputeChevalleyConstants(owner.DefaultWeylLetter, owner.DefaultWeylRank, theGlobalVariables);
  this->theDomain.ComputeChevalleyConstants('G', 2, theGlobalVariables);
  this->theRange.ComputeChevalleyConstants('B', 3, theGlobalVariables);
  this->imagesSimpleChevalleyGenerators.SetSize(4);
  (owner.ParseAndCompute("g_2", theGlobalVariables)).ConvertToLieAlgebraElementIfPossible(this->imagesSimpleChevalleyGenerators.TheObjects[0]);
  (owner.ParseAndCompute("g_1+g_3", theGlobalVariables)).ConvertToLieAlgebraElementIfPossible(this->imagesSimpleChevalleyGenerators.TheObjects[1]);
  (owner.ParseAndCompute("g_{-2}", theGlobalVariables)).ConvertToLieAlgebraElementIfPossible(this->imagesSimpleChevalleyGenerators.TheObjects[2]);
  (owner.ParseAndCompute("g_{-1}+g_{-3}", theGlobalVariables)).ConvertToLieAlgebraElementIfPossible(this->imagesSimpleChevalleyGenerators.TheObjects[3]);
  this->ComputeHomomorphismFromImagesSimpleChevalleyGenerators(theGlobalVariables);
  owner.Clear();
  this->GetRestrictionAmbientRootSystemToTheSmallerCartanSA(this->RestrictedRootSystem, theGlobalVariables);
  //this->ComputeDebugString(true, theGlobalVariables);
  //std::cout << this->DebugString;
  //if (this->CheckClosednessLieBracket(theGlobalVariables))
  //{ std::cout <<"good good good good!!!!";
  //}
}

void HomomorphismSemisimpleLieAlgebra::ElementToString(std::string& output, bool useHtml, GlobalVariables& theGlobalVariables)
{ std::stringstream out;
  std::string tempS, tempS2;
  if (this->CheckClosednessLieBracket(theGlobalVariables))
    out << "Lie bracket closes, everything is good!";
  else
    out << "The Lie bracket is BAD BAD BAD!";
  if (useHtml)
    out << "<br>";
  out << "Images simple Chevalley generators:\n\n";
  if (useHtml)
    out << "<br>";
  for (int i=0; i<this->imagesSimpleChevalleyGenerators.size; i++)
  { this->imagesSimpleChevalleyGenerators.TheObjects[i].ElementToString(tempS, false, false);
    out << tempS << "\n\n";
    if (useHtml)
      out << "<br>";
  }
  out << "Maps of Chevalley generators:\n\n";
  for (int i=0; i<this->domainAllChevalleyGenerators.size; i++)
  { this->imagesAllChevalleyGenerators.TheObjects[i].ElementToString(tempS, false, false);
    this->domainAllChevalleyGenerators.TheObjects[i].ElementToString(tempS2, false, false);
    out << tempS2 << " \\mapsto " << tempS << "\n\n";
    if  (useHtml)
      out << "<br>";
  }
  output=out.str();
}

void ParserNode::EvaluateFunction(GlobalVariables& theGlobalVariables)
{ switch(this->intValue)
  { case Parser::functionGCD: this->EvaluateGCDorLCM(theGlobalVariables); break;
    case Parser::functionLCM: this->EvaluateGCDorLCM(theGlobalVariables); break;
    case Parser::functionEigen: this->EvaluateEigen(theGlobalVariables); break;
    case Parser::functionSlTwoInSlN: this->EvaluateSlTwoInSlN(theGlobalVariables); break;
    case Parser::functionEigenOrdered: this->EvaluateEigenOrdered(theGlobalVariables); break;
    case Parser::functionSecretSauce: this->EvaluateSecretSauce(theGlobalVariables); break;
    case Parser::functionSecretSauceOrdered: this->EvaluateSecretSauceOrdered(theGlobalVariables); break;
    case Parser::functionWeylDimFormula: this->EvaluateWeylDimFormula(theGlobalVariables); break;
    case Parser::functionOuterAutos: this->EvaluateOuterAutos(theGlobalVariables); break;
    case Parser::functionMod: this->EvaluateModVermaRelations(theGlobalVariables); break;
    case Parser::functionInvariants: this->EvaluateInvariants(theGlobalVariables); break;
    case Parser::functionPrintDecomposition: this->EvaluatePrintDecomposition(theGlobalVariables); break;
    case Parser::functionEmbedding: this->EvaluatePrintEmbedding(theGlobalVariables); break;
    case Parser::functionPrintRootSystem: this->EvaluatePrintRootSystem(theGlobalVariables); break;
    case Parser::functionOrder: this->EvaluateOrder(theGlobalVariables); break;
    case Parser::functionActByWeyl: this->EvaluateWeylAction(theGlobalVariables); break;
    case Parser::functionActByAffineWeyl: this->EvaluateWeylRhoAction(theGlobalVariables); break;
    case Parser::functionPrintWeylGroup: this->EvaluatePrintWeyl(theGlobalVariables); break;
    case Parser::functionChamberParam: this->EvaluateChamberParam(theGlobalVariables); break;
    case Parser::functionCone: this->EvaluateCone(theGlobalVariables); break;
    case Parser::functionMaximumLFoverCone: this->EvaluateMaxLFOverCone(theGlobalVariables); break;
    case Parser::functionLattice: this->EvaluateLattice(theGlobalVariables); break;
    case Parser::functionGetAllRepresentatives: this->EvaluateGetAllRepresentatives(theGlobalVariables); break;
    case Parser::functionInvertLattice: this->EvaluateInvertLattice(theGlobalVariables); break;
   default: this->SetError(this->errorUnknownOperation); break;
  }
}

void ParserNode::EvaluateOrder(GlobalVariables& theGlobalVariables)
{ if (this->children.size!=1)
  { this->SetError(this->errorBadOrNoArgument);
    return;
  }
  ParserNode& theArgument=this->owner->TheObjects[this->children.TheObjects[0]];
  if (!theArgument.ConvertToType(this->typeUEElementOrdered, theGlobalVariables))
  { this->SetError(this->errorConversionError);
    return;
  }
  this->UEElementOrdered.GetElement()=theArgument.UEElementOrdered.GetElement();
  this->ExpressionType=this->typeUEElementOrdered;
}

void ParserNode::EvaluatePrintDecomposition(GlobalVariables& theGlobalVariables)
{ SSalgebraModule theModule;
  std::stringstream out, out2;
  theModule.InduceFromEmbedding(out2, this->owner->theHmm, theGlobalVariables);
  out << out2.str();
  this->outputString=out.str();
  this->ExpressionType=this->typeString;
}

void ParserNode::EvaluatePrintWeyl(GlobalVariables& theGlobalVariables)
{ std::stringstream out;
  WeylGroup& theWeyl=this->owner->theHmm.theRange.theWeyl;
  theWeyl.ComputeWeylGroup(51840);
  out << "<br>Symmetric Cartan matrix in Bourbaki order:<br><div class=\"math\">" << this->owner->theHmm.theRange.theWeyl.CartanSymmetric.ElementToString(false, true) << "</div>Root system:";
  out << "<br>Size of Weyl group by formula: " << theWeyl.GetSizeWeylByFormula(theWeyl.WeylLetter, theWeyl.GetDim()).ElementToString();
  out << "<br>Explicitly computed elements: " << theWeyl.size;
  out << "<br>Each element is parametrized by a list of simple reflections. <br>For example an element parametrized by 1,2 corresponds to the element <span class=\"math\">s_{\\alpha_1}s_{\\alpha_2}</span>,";
  out << " where <span class=\"math\">s_{\\beta}</span> is the reflection with respect to <span class=\"math\">\\beta</span> and <span class=\"math\">\\alpha_i</span> is the i^th simple root";
  for (int i=0; i<theWeyl.size; i++)
  { ElementWeylGroup& current=theWeyl.TheObjects[i];
    out << "<br>";
    if (current.size==0)
      out << "id";
    else
      for (int j=0; j<current.size; j++)
        out << current.TheObjects[j]+1 << ",";
  }
  this->outputString=out.str();
  this->ExpressionType=this->typeString;
}

void ParserNode::EvaluatePrintRootSystem(GlobalVariables& theGlobalVariables)
{ std::stringstream out;
  out << "<br>Symmetric Cartan matrix in Bourbaki order:<br><div class=\"math\">" << this->owner->theHmm.theRange.theWeyl.CartanSymmetric.ElementToString(false, true) << "</div>Root system:";
  for (int i=0; i<this->owner->theHmm.theRange.theWeyl.RootSystem.size; i++)
  { root& current=this->owner->theHmm.theRange.theWeyl.RootSystem.TheObjects[i];
    out << "<br>" << current.ElementToString();
  }
  this->outputString=out.str();
  this->ExpressionType=this->typeString;
}

void ParserNode::EvaluateInvariants(GlobalVariables& theGlobalVariables)
{ if (this->owner->DefaultWeylLetter!='B' && this->owner->DefaultWeylRank!=3)
  { this->SetError(this->errorUnknownOperation);
    return;
  }
  if (this->children.size!=1)
  { this->SetError(this->errorBadOrNoArgument);
    return;
  }
  ParserNode& theArgument=this->owner->TheObjects[this->children.TheObjects[0]];
  if (theArgument.ExpressionType!=this->typeIntegerOrIndex)
  { this->SetError(this->errorBadOrNoArgument);
    return;
  }
  if (theArgument.intValue<0)
  { this->SetError(this->errorBadOrNoArgument);
    return;
  }
  std::stringstream out;
  SSalgebraModule theModule;
  theModule.InduceFromEmbedding(out, this->owner->theHmm, theGlobalVariables);
  theModule.ComputeInvariantsOfDegree(theArgument.intValue, out, theGlobalVariables);
  this->ExpressionType=this->typePoly;
  if (theModule.invariantsFound.size>0)
    this->polyValue.GetElement().operator=(theModule.invariantsFound.TheObjects[0]);
  this->outputString=out.str();
}

void ParserNode::EvaluateModVermaRelations(GlobalVariables& theGlobalVariables)
{ if (this->children.size!=1)
  { this->SetError(this->errorBadOrNoArgument);
    return;
  }
  ParserNode& theArgument=this->owner->TheObjects[this->children.TheObjects[0]];
  if (!this->ConvertChildrenToType(this->typeUEelement, theGlobalVariables))
  { this->SetError(this->errorBadOrNoArgument);
    return;
  }
  this->UEElement.GetElement()=theArgument.UEElement.GetElement();
  this->outputString.append(this->UEElement.GetElement().ElementToString(true));
  this->UEElement.GetElement().Simplify();
  this->UEElement.GetElement().ModOutVermaRelations();
  this->ExpressionType=this->typeUEelement;
}

class slTwoInSlN;

void ParserNode::EvaluateOuterAutos(GlobalVariables& theGlobalVariables)
{ MatrixLargeRational tempMat;
  std::stringstream out;
  this->ExpressionType=this->typeString;
  this->owner->theHmm.theRange.ComputeOneAutomorphism(theGlobalVariables, tempMat, true);
  MatrixLargeRational tempMat2=tempMat;
  Rational tempRat;
  tempMat2.ComputeDeterminantOverwriteMatrix(tempRat);
  out << "<br>one outer automorphism of the Lie algebra is realized as the following matrix. <br> The coordinates of the matrix are given in the ordered basis ";
  out << " <div class=\"math\" scale=\"50\"> g_{-n}, \\dots, g_{-1}, h_1,\\dots, h_k, g_1,\\dots, g_n</div> where the generators are as in the table on the right.<br> Its determinant is \n" << tempRat.ElementToString();
  out << "<div class=\"math\" scale=\"50\">" << tempMat.ElementToString(false, true) << "</div>";
  this->outputString=out.str();
}

void ParserNode::EvaluateWeylDimFormula(GlobalVariables& theGlobalVariables)
{ List<int> argumentList;
  HomomorphismSemisimpleLieAlgebra& theHmm= this->owner->theHmm;
  bool tempBool=this->ExtractArgumentList(argumentList);
  if (!tempBool || argumentList.size!=theHmm.theRange.GetRank())
  { this->SetError(this->errorBadOrNoArgument);
    return;
  }
  root theWeight;
  int theDimension=argumentList.size;
  theWeight.SetSize(theDimension);
  for (int i=0; i<theDimension ; i++)
  { ParserNode& current= this->owner->TheObjects[argumentList.TheObjects[i]];
    if (!current.ConvertToType(this->typeRational, theGlobalVariables))
    { this->SetError(this->errorBadOrNoArgument);
      return;
    }
    theWeight.TheObjects[i]=current.rationalValue;
  }
  this->rationalValue= theHmm.theRange.theWeyl.WeylDimFormula(theWeight, theGlobalVariables);
  this->ExpressionType=this->typeRational;
}

void ParserNode::EvaluateEigenOrdered(GlobalVariables& theGlobalVariables)
{ if (this->children.size!=1)
  { this->SetError(this->errorProgramming);
    return;
  }
  ParserNode& theArgument=this->owner->TheObjects[this->children.TheObjects[0]];
  int theDimension= theArgument.children.size;
  HomomorphismSemisimpleLieAlgebra& theHmm= this->owner->theHmm;
  if (theArgument.GetStrongestExpressionChildrenConvertChildrenIfNeeded(theGlobalVariables)!=this->typeIntegerOrIndex || theDimension!=theHmm.theDomain.theWeyl.CartanSymmetric.NumRows)
  { this->SetError(this->errorBadOrNoArgument);
    return;
  }
  List<ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff> > theList;
  root theWeight;
  theWeight.SetSize(theDimension);
  for (int i=0; i<theDimension; i++)
  { ParserNode& current= this->owner->TheObjects[theArgument.children.TheObjects[i]];
    theWeight.TheObjects[i]=current.intValue;
  }
  EigenVectorComputation theEigenComputation;
  this->outputString=theEigenComputation.ComputeEigenVectorsOfWeightConventionOrdered(this->owner->theHmm, this->owner->testAlgebra, theList, theWeight, theGlobalVariables);
  this->ExpressionType=this->typeString;
}

void ParserNode::EvaluateEigen(GlobalVariables& theGlobalVariables)
{ if (this->children.size!=1)
  { this->SetError(this->errorProgramming);
    return;
  }
  ParserNode& theArgument=this->owner->TheObjects[this->children.TheObjects[0]];
  int theDimension= theArgument.children.size;
  HomomorphismSemisimpleLieAlgebra& theHmm= this->owner->theHmm;
  if (theArgument.GetStrongestExpressionChildrenConvertChildrenIfNeeded(theGlobalVariables)!=this->typeIntegerOrIndex || theDimension!=theHmm.theDomain.theWeyl.CartanSymmetric.NumRows)
  { this->SetError(this->errorBadOrNoArgument);
    return;
  }
  List<ElementUniversalEnveloping> theList;
  root theWeight;
  theWeight.SetSize(theDimension);
  for (int i=0; i<theDimension; i++)
  { ParserNode& current= this->owner->TheObjects[theArgument.children.TheObjects[i]];
    theWeight.TheObjects[i]=current.intValue;
  }
  EigenVectorComputation theEigenComputation;
  this->outputString=theEigenComputation.ComputeEigenVectorsOfWeight(this->owner->theHmm, this->owner->testAlgebra, theList, theWeight, theGlobalVariables);
  this->ExpressionType=this->typeString;
}

bool Parser::LookUpInDictionaryAndAdd(std::string& input)
{ switch (input.at(0))
  { case '0': this->TokenBuffer.AddObjectOnTop(Parser::tokenDigit); this->ValueBuffer.AddObjectOnTop(0); return true;
    case '1': this->TokenBuffer.AddObjectOnTop(Parser::tokenDigit); this->ValueBuffer.AddObjectOnTop(1); return true;
    case '2': this->TokenBuffer.AddObjectOnTop(Parser::tokenDigit); this->ValueBuffer.AddObjectOnTop(2); return true;
    case '3': this->TokenBuffer.AddObjectOnTop(Parser::tokenDigit); this->ValueBuffer.AddObjectOnTop(3); return true;
    case '4': this->TokenBuffer.AddObjectOnTop(Parser::tokenDigit); this->ValueBuffer.AddObjectOnTop(4); return true;
    case '5': this->TokenBuffer.AddObjectOnTop(Parser::tokenDigit); this->ValueBuffer.AddObjectOnTop(5); return true;
    case '6': this->TokenBuffer.AddObjectOnTop(Parser::tokenDigit); this->ValueBuffer.AddObjectOnTop(6); return true;
    case '7': this->TokenBuffer.AddObjectOnTop(Parser::tokenDigit); this->ValueBuffer.AddObjectOnTop(7); return true;
    case '8': this->TokenBuffer.AddObjectOnTop(Parser::tokenDigit); this->ValueBuffer.AddObjectOnTop(8); return true;
    case '9': this->TokenBuffer.AddObjectOnTop(Parser::tokenDigit); this->ValueBuffer.AddObjectOnTop(9); return true;
    case '*': this->TokenBuffer.AddObjectOnTop(Parser::tokenTimes); this->ValueBuffer.AddObjectOnTop(9); return true;
    case '}': this->TokenBuffer.AddObjectOnTop(Parser::tokenCloseCurlyBracket); this->ValueBuffer.AddObjectOnTop(0); return true;
    case '{': this->TokenBuffer.AddObjectOnTop(Parser::tokenOpenCurlyBracket); this->ValueBuffer.AddObjectOnTop(0); return true;
    case '[': this->TokenBuffer.AddObjectOnTop(Parser::tokenOpenLieBracket); this->ValueBuffer.AddObjectOnTop(0); return true;
    case ']': this->TokenBuffer.AddObjectOnTop(Parser::tokenCloseLieBracket); this->ValueBuffer.AddObjectOnTop(0); return true;
    case '(': this->TokenBuffer.AddObjectOnTop(Parser::tokenOpenBracket); this->ValueBuffer.AddObjectOnTop(0); return true;
    case ',': this->TokenBuffer.AddObjectOnTop(Parser::tokenComma); this->ValueBuffer.AddObjectOnTop(0); return true;
    case ')': this->TokenBuffer.AddObjectOnTop(Parser::tokenCloseBracket); this->ValueBuffer.AddObjectOnTop(0); return true;
    case '^': this->TokenBuffer.AddObjectOnTop(Parser::tokenPower); this->ValueBuffer.AddObjectOnTop(0); return true;
    case '+': this->TokenBuffer.AddObjectOnTop(Parser::tokenPlus); this->ValueBuffer.AddObjectOnTop(0); return true;
    case '-': this->TokenBuffer.AddObjectOnTop(Parser::tokenMinus); this->ValueBuffer.AddObjectOnTop(0); return true;
    case '_': this->TokenBuffer.AddObjectOnTop(Parser::tokenUnderscore); this->ValueBuffer.AddObjectOnTop(0); return true;
    case ';': this->TokenBuffer.AddObjectOnTop(Parser::tokenEndStatement); this->ValueBuffer.AddObjectOnTop(0); return true;
    case ':': this->TokenBuffer.AddObjectOnTop(Parser::tokenColon); this->ValueBuffer.AddObjectOnTop(0); return true;
    case '/': this->TokenBuffer.AddObjectOnTop(Parser::tokenDivide); this->ValueBuffer.AddObjectOnTop(0); return true;
    default: break;
  }
  if (input=="x")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenX);
    this->ValueBuffer.AddObjectOnTop(0);
    return true;
  }
  if (input=="d")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenPartialDerivative);
    this->ValueBuffer.AddObjectOnTop(0);
    return true;
  }
  if (input=="\\partial")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenPartialDerivative);
    this->ValueBuffer.AddObjectOnTop(0);
    return true;
  }
  if (input=="g")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenG);
    this->ValueBuffer.AddObjectOnTop(0);
    return true;
  }
  if (input=="f")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenF);
    this->ValueBuffer.AddObjectOnTop(0);
    return true;
  }
  if (input =="h")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenH);
    this->ValueBuffer.AddObjectOnTop(0);
    return true;
  }
  if (input=="c")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenC);
    this->ValueBuffer.AddObjectOnTop(0);
    return true;
  }
  if (input =="i")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenMap);
    this->ValueBuffer.AddObjectOnTop(0);
    return true;
  }
  if (input=="n")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenVariable);
    this->ValueBuffer.AddObjectOnTop(0);
    return true;
  }
  if (input=="gcd")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(this->functionGCD);
    return true;
  }
  if (input=="lcm")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(this->functionLCM);
    return true;
  }
  if (input=="eigen")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(this->functionEigen);
    return true;
  }
  if (input=="printEmbedding")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunctionNoArgument);
    this->ValueBuffer.AddObjectOnTop(this->functionEmbedding);
    return true;
  }
  if (input=="GetAllRepresentatives")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(this->functionGetAllRepresentatives);
    return true;
  }
  if (input=="actByWeylAffine")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(this->functionActByAffineWeyl);
    return true;
  }
  if (input=="InvertLattice")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(this->functionInvertLattice);
    return true;
  }
  if (input=="actByWeyl")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(this->functionActByWeyl);
    return true;
  }
  if (input=="printDecomposition")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunctionNoArgument);
    this->ValueBuffer.AddObjectOnTop(this->functionPrintDecomposition);
    return true;
  }
  if (input=="Lattice")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(this->functionLattice);
    return true;
  }
  if (input=="printWeylGroup")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunctionNoArgument);
    this->ValueBuffer.AddObjectOnTop(this->functionPrintWeylGroup);
    return true;
  }
  if (input=="printRootSystem")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunctionNoArgument);
    this->ValueBuffer.AddObjectOnTop(this->functionPrintRootSystem);
    return true;
  }
  if (input=="eigenOrdered")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(this->functionEigenOrdered);
    return true;
  }
  if (input=="\\mapsto")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenMapsTo);
    this->ValueBuffer.AddObjectOnTop(0);
    return true;
  }
  if (input=="combinatorialChamberParam")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(this->functionChamberParam);
    return true;
  }
  if (input =="secretSauce")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunctionNoArgument);
    this->ValueBuffer.AddObjectOnTop(this->functionSecretSauce);
    return true;
  }
  if (input=="secretSauceOrdered")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunctionNoArgument);
    this->ValueBuffer.AddObjectOnTop(this->functionSecretSauceOrdered);
    return true;
  }
  if (input=="dim")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(this->functionWeylDimFormula);
    return true;
  }
  if (input=="order")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(this->functionOrder);
    return true;
  }
  if (input=="outerAuto")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunctionNoArgument);
    this->ValueBuffer.AddObjectOnTop(Parser::functionOuterAutos);
    return true;
  }
  if (input=="mod")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(Parser::functionMod);
    return true;
  }
  if (input=="invariant")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(Parser::functionInvariants);
    return true;
  }
  if (input=="maximumLinearFunctionOverCone")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(Parser::functionMaximumLFoverCone);
    return true;
  }
  if (input=="Cone")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(Parser::functionCone);
    return true;
  }
  if (input=="slTwoInSlN")
  { this->TokenBuffer.AddObjectOnTop(Parser::tokenFunction);
    this->ValueBuffer.AddObjectOnTop(Parser::functionSlTwoInSlN);
    return true;
  }
  return false;
}

void HomomorphismSemisimpleLieAlgebra::GetRestrictionAmbientRootSystemToTheSmallerCartanSA(roots& output, GlobalVariables& theGlobalVariables)
{ List<root>& theRootSystem= this->theRange.theWeyl.RootSystem;
  int rankSA=this->theDomain.theWeyl.CartanSymmetric.NumRows;
  MatrixLargeRational tempMat;
  tempMat.Assign(this->theDomain.theWeyl.CartanSymmetric);
  tempMat.Invert(theGlobalVariables);
  int numPosRootsDomain=this->theDomain.theWeyl.RootsOfBorel.size;
  output.SetSize(theRootSystem.size);
  root theScalarProducts;
  theScalarProducts.SetSize(rankSA);
//  tempMat.ComputeDebugString(true, false);
//  std::cout << tempMat.DebugString << "<br>";
  for (int i=0; i<theRootSystem.size; i++)
  { for (int j=0; j<rankSA; j++)
    { ElementSimpleLieAlgebra& currentH=this->imagesAllChevalleyGenerators.TheObjects[j+numPosRootsDomain];
      theScalarProducts.TheObjects[j]=this->theRange.theWeyl.RootScalarCartanRoot(currentH.Hcomponent, theRootSystem.TheObjects[i]);
    }
    tempMat.ActOnAroot(theScalarProducts, output.TheObjects[i]);
  }
}

bool HomomorphismSemisimpleLieAlgebra::CheckClosednessLieBracket(GlobalVariables& theGlobalVariables)
{ ElementSimpleLieAlgebra tempElt;
  roots tempRoots; root tempRoot;
  tempRoots.SetSize(this->imagesAllChevalleyGenerators.size);
  for (int i=0; i<tempRoots.size; i++)
    this->imagesAllChevalleyGenerators.TheObjects[i].ElementToVectorRootSpacesFirstThenCartan(tempRoots.TheObjects[i]);
  for (int i=0; i<this->imagesAllChevalleyGenerators.size; i++)
    for (int j=0; j<this->imagesAllChevalleyGenerators.size; j++)
    { this->theRange.LieBracket(this->imagesAllChevalleyGenerators.TheObjects[i], this->imagesAllChevalleyGenerators.TheObjects[j], tempElt);
      tempElt.ElementToVectorRootSpacesFirstThenCartan(tempRoot);
      if(!tempRoots.LinSpanContainsRoot(tempRoot, theGlobalVariables))
        return false;
    }
  return true;
}

void MonomialUniversalEnveloping::SimplifyAccumulateInOutputNoOutputInit(ElementUniversalEnveloping& output)
{ int IndexlowestNonSimplified=0;
  ElementUniversalEnveloping buffer2;
  MonomialUniversalEnveloping tempMon;
  //simplified order is descending order
  while (IndexlowestNonSimplified<output.size)
  { bool reductionOccurred=false;
    if (output.TheObjects[IndexlowestNonSimplified].Coefficient.IsEqualToZero())
      reductionOccurred=true;
    else
      for (int i=0; i<output.TheObjects[IndexlowestNonSimplified].generatorsIndices.size-1; i++)
        if (!this->owner->AreOrderedProperly(output.TheObjects[IndexlowestNonSimplified].generatorsIndices.TheObjects[i], output.TheObjects[IndexlowestNonSimplified].generatorsIndices.TheObjects[i+1]))
        { if (output.TheObjects[IndexlowestNonSimplified].SwitchConsecutiveIndicesIfTheyCommute(i, tempMon))
          { output.AddMonomialNoCleanUpZeroCoeff(tempMon);
            tempMon.ComputeDebugString();
            reductionOccurred=true;
            break;
          }
          if (this->CommutingRightIndexAroundLeftIndexAllowed(output.TheObjects[IndexlowestNonSimplified].Powers.TheObjects[i], output.TheObjects[IndexlowestNonSimplified].generatorsIndices.TheObjects[i], output.TheObjects[IndexlowestNonSimplified].Powers.TheObjects[i+1], output.TheObjects[IndexlowestNonSimplified].generatorsIndices.TheObjects[i+1]))
          { output.TheObjects[IndexlowestNonSimplified].CommuteConsecutiveIndicesRightIndexAroundLeft(i, buffer2);
            for (int j=0; j<buffer2.size; j++)
              output.AddMonomialNoCleanUpZeroCoeff(buffer2.TheObjects[j]);
            output.ComputeDebugString();
            reductionOccurred=true;
            break;
          }
          if (this->CommutingLeftIndexAroundRightIndexAllowed(output.TheObjects[IndexlowestNonSimplified].Powers.TheObjects[i], output.TheObjects[IndexlowestNonSimplified].generatorsIndices.TheObjects[i], output.TheObjects[IndexlowestNonSimplified].Powers.TheObjects[i+1], output.TheObjects[IndexlowestNonSimplified].generatorsIndices.TheObjects[i+1]))
          { output.TheObjects[IndexlowestNonSimplified].CommuteConsecutiveIndicesLeftIndexAroundRight(i, buffer2);
            for (int j=0; j<buffer2.size; j++)
              output.AddMonomialNoCleanUpZeroCoeff(buffer2.TheObjects[j]);
            output.ComputeDebugString();
            reductionOccurred=true;
            break;
          }
        }
    if (reductionOccurred)
      output.PopIndexSwapWithLastHash(IndexlowestNonSimplified);
    else
      IndexlowestNonSimplified++;
    output.ComputeDebugString();
  }
  output.CleanUpZeroCoeff();
}

bool MonomialUniversalEnveloping::CommutingLeftIndexAroundRightIndexAllowed(PolynomialRationalCoeff& theLeftPower, int leftGeneratorIndex, PolynomialRationalCoeff& theRightPower, int rightGeneratorIndex)
{ if (theLeftPower.TotalDegree()==0)
  { if(theRightPower.TotalDegree()==0)
      return true;
    int numPosRoots=this->owner->theWeyl.RootsOfBorel.size;
    int theDimension= this->owner->theWeyl.CartanSymmetric.NumRows;
    if(rightGeneratorIndex>= numPosRoots && rightGeneratorIndex<numPosRoots+theDimension)
    { if (this->owner->theLiebracketPairingCoefficients.elements[leftGeneratorIndex][rightGeneratorIndex].IsEqualToZero())
        return true;
      else
        return false;
    } else
      return true;
  }
  return false;
}

bool MonomialUniversalEnveloping::SwitchConsecutiveIndicesIfTheyCommute(int theLeftIndex, MonomialUniversalEnveloping& output)
{ if (theLeftIndex>= this->generatorsIndices.size-1)
    return false;
  int leftGenerator=this->generatorsIndices.TheObjects[theLeftIndex];
  int rightGenerator=this->generatorsIndices.TheObjects[theLeftIndex+1];
  if (this->owner->OppositeRootSpaces.TheObjects[leftGenerator]==rightGenerator)
    return false;
  if (this->owner->theLiebracketPairingCoefficients.elements[leftGenerator][rightGenerator].IsEqualToZero())
  { this->ComputeDebugString();
    output.generatorsIndices.MakeActualSizeAtLeastExpandOnTop(this->generatorsIndices.size);
    output.Powers.MakeActualSizeAtLeastExpandOnTop(this->generatorsIndices.size);
    output.Nullify(this->Coefficient.NumVars, *this->owner);
    output.Coefficient=this->Coefficient;
    output.ComputeDebugString();
    for (int i=0; i<theLeftIndex; i++)
      output.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[i], this->Powers.TheObjects[i]);
    output.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[theLeftIndex+1], this->Powers.TheObjects[theLeftIndex+1]);
    output.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[theLeftIndex], this->Powers.TheObjects[theLeftIndex]);
    for (int i=theLeftIndex+2; i<this->generatorsIndices.size; i++)
      output.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[i], this->Powers.TheObjects[i]);
    return true;
  }
  return false;
}

bool MonomialUniversalEnveloping::CommutingRightIndexAroundLeftIndexAllowed(PolynomialRationalCoeff& theLeftPower, int leftGeneratorIndex, PolynomialRationalCoeff& theRightPower, int rightGeneratorIndex)
{ return this->CommutingLeftIndexAroundRightIndexAllowed(theRightPower, rightGeneratorIndex, theLeftPower, leftGeneratorIndex);
}

void MonomialUniversalEnveloping::Simplify(ElementUniversalEnveloping& output)
{ output.Nullify(*this->owner);
  output.AddObjectOnTopHash(*this);
  this->SimplifyAccumulateInOutputNoOutputInit(output);
}

void MonomialUniversalEnveloping::MultiplyByNoSimplify(const MonomialUniversalEnveloping& other)
{ this->generatorsIndices.MakeActualSizeAtLeastExpandOnTop(other.generatorsIndices.size+this->generatorsIndices.size);
  this->Powers.MakeActualSizeAtLeastExpandOnTop(other.generatorsIndices.size+this->generatorsIndices.size);
  this->Coefficient.MultiplyBy(other.Coefficient);
  if (other.generatorsIndices.size==0)
    return;
  int firstIndex=other.generatorsIndices.TheObjects[0];
  int i=0;
  if (this->generatorsIndices.size>0)
    if (firstIndex==(*this->generatorsIndices.LastObject()))
    { *this->Powers.LastObject()+=other.Powers.TheObjects[0];
      i=1;
    }
  for (; i<other.generatorsIndices.size; i++)
  { this->Powers.AddObjectOnTop(other.Powers.TheObjects[i]);
    this->generatorsIndices.AddObjectOnTop(other.generatorsIndices.TheObjects[i]);
  }
}

void MonomialUniversalEnveloping::CommuteConsecutiveIndicesRightIndexAroundLeft(int theIndeX, ElementUniversalEnveloping& output)
{ if (theIndeX==this->generatorsIndices.size-1)
    return;
  output.Nullify(*this->owner);
  MonomialUniversalEnveloping tempMon;
  tempMon.Nullify(this->Coefficient.NumVars, *this->owner);
  tempMon.Powers.MakeActualSizeAtLeastExpandOnTop(this->generatorsIndices.size+2);
  tempMon.generatorsIndices.MakeActualSizeAtLeastExpandOnTop(this->generatorsIndices.size+2);
  tempMon.Powers.size=0;
  tempMon.generatorsIndices.size=0;
  int rightGeneratorIndeX= this->generatorsIndices.TheObjects[theIndeX+1];
  int leftGeneratorIndeX=this->generatorsIndices.TheObjects[theIndeX];
  PolynomialRationalCoeff theRightPoweR, theLeftPoweR;
  theRightPoweR= this->Powers.TheObjects[theIndeX+1];
  theLeftPoweR= this->Powers.TheObjects[theIndeX];
  theRightPoweR-=1;
  int powerDroP=0;
  PolynomialRationalCoeff acquiredCoefficienT, polyOne;
  acquiredCoefficienT.Assign(this->Coefficient);
  for (int i=0; i<theIndeX; i++)
    tempMon.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[i], this->Powers.TheObjects[i]);
  MonomialUniversalEnveloping startMon;
  startMon=tempMon;
  ElementSimpleLieAlgebra adResulT, tempElT, tempLefttElt;
  adResulT.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(rightGeneratorIndeX, *this->owner);
  tempLefttElt.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(leftGeneratorIndeX, *this->owner);
  //tempLefttElt.ComputeDebugString(*this->owner, false, false);
  polyOne.MakeNVarConst(this->Coefficient.NumVars, (Rational) 1);
  do
  { //acquiredCoefficienT.ComputeDebugString();
    //theRightPoweR.ComputeDebugString();
    //theLeftPoweR.ComputeDebugString();
    //adResulT.ComputeDebugString(*this->owner, false, false);
    //tempMon.ComputeDebugString();
    if (adResulT.NonZeroElements.CardinalitySelection>0)
    { int theNewGeneratorIndex= this->owner->RootIndexOrderAsInRootSystemToGeneratorIndexNegativeRootsThenCartanThenPositive(adResulT.NonZeroElements.elements[0]);
      tempMon.Coefficient=acquiredCoefficienT;
      tempMon.Coefficient.TimesConstant(adResulT.coeffsRootSpaces.TheObjects[adResulT.NonZeroElements.elements[0]]);
      tempMon.MultiplyByGeneratorPowerOnTheRight(theNewGeneratorIndex, polyOne);
      tempMon.MultiplyByGeneratorPowerOnTheRight(leftGeneratorIndeX, theLeftPoweR);
      tempMon.MultiplyByGeneratorPowerOnTheRight(rightGeneratorIndeX, theRightPoweR);
      for (int i=theIndeX+2; i<this->generatorsIndices.size; i++)
        tempMon.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[i], this->Powers.TheObjects[i]);
      //tempMon.ComputeDebugString();
      output.AddObjectOnTopHash(tempMon);
    } else
    { int theDimension=this->owner->theWeyl.CartanSymmetric.NumRows;
      int numPosRoots= this->owner->theWeyl.RootsOfBorel.size;
      for (int i=0; i<theDimension; i++)
        if (!adResulT.Hcomponent.TheObjects[i].IsEqualToZero())
        { tempMon=startMon;
          tempMon.Coefficient=acquiredCoefficienT;
          tempMon.Coefficient.TimesConstant(adResulT.Hcomponent.TheObjects[i]);
          tempMon.MultiplyByGeneratorPowerOnTheRight(i+numPosRoots, polyOne);
          tempMon.MultiplyByGeneratorPowerOnTheRight(leftGeneratorIndeX, theLeftPoweR);
          tempMon.MultiplyByGeneratorPowerOnTheRight(rightGeneratorIndeX, theRightPoweR);
          for (int i=theIndeX+2; i<this->generatorsIndices.size; i++)
            tempMon.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[i], this->Powers.TheObjects[i]);
          //tempMon.ComputeDebugString();
          output.AddObjectOnTopHash(tempMon);
        }
    }
    acquiredCoefficienT.MultiplyBy(theLeftPoweR);
    theLeftPoweR-=1;
    tempMon=startMon;
    this->owner->LieBracket(tempLefttElt, adResulT, tempElT);
    adResulT=tempElT;
    powerDroP++;
    acquiredCoefficienT.DivByInteger(powerDroP);
    //adResulT.ComputeDebugString(*this->owner, false, false);
  }while(!adResulT.IsEqualToZero() && !acquiredCoefficienT.IsEqualToZero());
}

void MonomialUniversalEnveloping::CommuteConsecutiveIndicesLeftIndexAroundRight(int theIndeX, ElementUniversalEnveloping& output)
{ if (theIndeX==this->generatorsIndices.size-1)
    return;
  output.Nullify(*this->owner);
  MonomialUniversalEnveloping tempMon;
  tempMon.Nullify(this->Coefficient.NumVars, *this->owner);
  tempMon.Powers.MakeActualSizeAtLeastExpandOnTop(this->generatorsIndices.size+2);
  tempMon.generatorsIndices.MakeActualSizeAtLeastExpandOnTop(this->generatorsIndices.size+2);
  tempMon.Powers.size=0;
  tempMon.generatorsIndices.size=0;
  int rightGeneratorIndex= this->generatorsIndices.TheObjects[theIndeX+1];
  int leftGeneratorIndex=this->generatorsIndices.TheObjects[theIndeX];
  PolynomialRationalCoeff theRightPower, theLeftPower;
  theRightPower= this->Powers.TheObjects[theIndeX+1];
  theLeftPower= this->Powers.TheObjects[theIndeX];
  theLeftPower-=1;
  int powerDrop=0;
  PolynomialRationalCoeff acquiredCoefficient, polyOne;
  acquiredCoefficient.Assign(this->Coefficient);
  for (int i=0; i<theIndeX; i++)
    tempMon.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[i], this->Powers.TheObjects[i]);
  tempMon.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[theIndeX], theLeftPower);
  MonomialUniversalEnveloping startMon, tempMon2;
  startMon=tempMon;
  ElementSimpleLieAlgebra adResult, tempElt, tempRightElt;
  adResult.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(leftGeneratorIndex, *this->owner);
  tempRightElt.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(rightGeneratorIndex, *this->owner);
//  tempRightElt.ComputeDebugString(*this->owner, false, false);
  polyOne.MakeNVarConst(this->Coefficient.NumVars, (Rational) 1);
  do
  { //acquiredCoefficient.ComputeDebugString();
    //theRightPower.ComputeDebugString();
    //adResult.ComputeDebugString(*this->owner, false, false);
    //tempMon.ComputeDebugString();
    tempMon.MultiplyByGeneratorPowerOnTheRight(rightGeneratorIndex, theRightPower);
    //tempMon.ComputeDebugString();
    if (adResult.NonZeroElements.CardinalitySelection>0)
    { int theNewGeneratorIndex= this->owner->RootIndexOrderAsInRootSystemToGeneratorIndexNegativeRootsThenCartanThenPositive(adResult.NonZeroElements.elements[0]);
      tempMon.Coefficient=acquiredCoefficient;
      tempMon.Coefficient.TimesConstant(adResult.coeffsRootSpaces.TheObjects[adResult.NonZeroElements.elements[0]]);
      tempMon.MultiplyByGeneratorPowerOnTheRight(theNewGeneratorIndex, polyOne);
      for (int i=theIndeX+2; i<this->generatorsIndices.size; i++)
        tempMon.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[i], this->Powers.TheObjects[i]);
      //tempMon.ComputeDebugString();
      output.AddObjectOnTopHash(tempMon);
    } else
    { int theDimension=this->owner->theWeyl.CartanSymmetric.NumRows;
      int numPosRoots= this->owner->theWeyl.RootsOfBorel.size;
      tempMon.Coefficient=acquiredCoefficient;
      tempMon2=tempMon;
      for (int i=0; i<theDimension; i++)
        if (!adResult.Hcomponent.TheObjects[i].IsEqualToZero())
        { tempMon=tempMon2;
          tempMon.Coefficient.TimesConstant(adResult.Hcomponent.TheObjects[i]);
          tempMon.MultiplyByGeneratorPowerOnTheRight(i+numPosRoots, polyOne);
          for (int i=theIndeX+2; i<this->generatorsIndices.size; i++)
            tempMon.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[i], this->Powers.TheObjects[i]);
          //tempMon.ComputeDebugString();
          output.AddObjectOnTopHash(tempMon);
        }
    }
    acquiredCoefficient.MultiplyBy(theRightPower);
    theRightPower-=1;
    tempMon=startMon;
    this->owner->LieBracket(adResult, tempRightElt, tempElt);
    adResult=tempElt;
    powerDrop++;
    acquiredCoefficient.DivByInteger(powerDrop);
    //adResult.ComputeDebugString(*this->owner, false, false);
  }while(!adResult.IsEqualToZero() && !acquiredCoefficient.IsEqualToZero());
}

void MonomialUniversalEnveloping::MultiplyByGeneratorPowerOnTheRight(int theGeneratorIndex, int thePower)
{ if (thePower==0)
    return;
  PolynomialRationalCoeff tempP;
  tempP.MakeNVarConst(this->Coefficient.NumVars, thePower);
  this->MultiplyByGeneratorPowerOnTheRight(theGeneratorIndex, tempP);
}

void MonomialUniversalEnveloping::MultiplyByGeneratorPowerOnTheRight(int theGeneratorIndex, const PolynomialRationalCoeff& thePower)
{ if (thePower.IsEqualToZero())
    return;
  if (this->generatorsIndices.size>0)
    if (*this->generatorsIndices.LastObject()==theGeneratorIndex)
    { this->Powers.LastObject()->AddPolynomial(thePower);
      return;
    }
  this->Powers.AddObjectOnTop(thePower);
  this->generatorsIndices.AddObjectOnTop(theGeneratorIndex);
}

void ElementUniversalEnveloping::AddMonomialNoCleanUpZeroCoeff(const MonomialUniversalEnveloping& input)
{ int theIndex= this->IndexOfObjectHash(input);
  if (theIndex==-1)
    this->AddObjectOnTopHash(input);
  else
    this->TheObjects[theIndex].Coefficient+=input.Coefficient;
}

void ElementUniversalEnveloping::Simplify()
{ ElementUniversalEnveloping buffer;
  ElementUniversalEnveloping output;
  //this->ComputeDebugString();
  output.Nullify(*this->owner);
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].Simplify(buffer);
    output+=buffer;
    //output.ComputeDebugString();
  }
  *this=output;
}

void ElementUniversalEnveloping::LieBracketOnTheRight(const ElementUniversalEnveloping& right, ElementUniversalEnveloping& output)
{ ElementUniversalEnveloping tempElt, tempElt2;
  tempElt=*this;
  tempElt*=right;
  tempElt2=right;
  tempElt2*=*this;
  output=tempElt;
  output-=tempElt2;
}

void ElementUniversalEnveloping::AddMonomial(const MonomialUniversalEnveloping& input)
{ int theIndex= this->IndexOfObjectHash(input);
  if (theIndex==-1)
    this->AddObjectOnTopHash(input);
  else
  { this->TheObjects[theIndex].Coefficient+=input.Coefficient;
    if (this->TheObjects[theIndex].Coefficient.IsEqualToZero())
      this->PopIndexSwapWithLastHash(theIndex);
  }
}

void ElementUniversalEnveloping::CleanUpZeroCoeff()
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].Coefficient.IsEqualToZero())
    { this->PopIndexSwapWithLastHash(i);
      i--;
    }
}

void ElementUniversalEnveloping::MakeOneGeneratorCoeffOne(int theIndex, int numVars, SemisimpleLieAlgebra& theOwner)
{ this->Nullify(theOwner);
  MonomialUniversalEnveloping tempMon;
  tempMon.Nullify(numVars, theOwner);
  tempMon.Coefficient.MakeNVarConst((int)numVars, (Rational) 1);
  tempMon.MultiplyByGeneratorPowerOnTheRight(theIndex, tempMon.Coefficient);
  this->AddObjectOnTopHash(tempMon);
}

bool ElementUniversalEnveloping::ConvertToLieAlgebraElementIfPossible(ElementSimpleLieAlgebra& output)const
{ output.Nullify(*this->owner);
  int numPosRoots=this->owner->theWeyl.RootsOfBorel.size;
  Rational tempRat=0;
  PolynomialRationalCoeff tempP;
  for (int i=0; i<this->size; i++)
  { MonomialUniversalEnveloping& tempMon= this->TheObjects[i];
    tempMon.GetDegree(tempP);
    if (!tempP.IsEqualToOne())
      return false;
    if (tempMon.Coefficient.TotalDegree()>0)
      return false;
    if (tempMon.Coefficient.size>0)
      tempRat=tempMon.Coefficient.TheObjects[0].Coefficient;
    else
      tempRat=0;
    int theGeneratorIndex=tempMon.generatorsIndices.TheObjects[0];
    int correspondingRootIndex=this->owner->ChevalleyGeneratorIndexToRootIndex(theGeneratorIndex);
    if(correspondingRootIndex<0)
    { theGeneratorIndex-=numPosRoots;
      output.Hcomponent.TheObjects[theGeneratorIndex]=tempRat;
    } else
      output.SetCoefficient(this->owner->theWeyl.RootSystem.TheObjects[correspondingRootIndex], tempRat, *this->owner);
  }
  return true;
}

void ElementUniversalEnveloping::AssignElementLieAlgebra(const ElementSimpleLieAlgebra& input, int numVars, SemisimpleLieAlgebra& theOwner)
{ this->Nullify(theOwner);
  this->AssignElementCartan(input.Hcomponent, numVars, theOwner);
  MonomialUniversalEnveloping tempMon;
  tempMon.Nullify(numVars, theOwner);
  tempMon.generatorsIndices.SetSize(1);
  tempMon.Powers.SetSize(1);
  tempMon.Powers.TheObjects[0].MakeNVarConst((int)numVars, 1);
  for (int i=0; i<input.NonZeroElements.CardinalitySelection; i++)
  { int theIndex=input.NonZeroElements.elements[i];
    int theGeneratorIndex=theOwner.RootIndexOrderAsInRootSystemToGeneratorIndexNegativeRootsThenCartanThenPositive(theIndex);
    tempMon.Coefficient.MakeNVarConst((int)numVars, input.coeffsRootSpaces.TheObjects[theIndex]);
    tempMon.generatorsIndices.TheObjects[0]=theGeneratorIndex;
    this->AddObjectOnTopHash(tempMon);
  }
}

void ElementUniversalEnveloping::ModOutVermaRelations(bool SubHighestWeightWithZeroes)
{ MonomialUniversalEnveloping tempMon;
  ElementUniversalEnveloping output;
  output.Nullify(*this->owner);
  for (int i=0; i<this->size; i++)
  { tempMon= this->TheObjects[i];
    tempMon.ModOutVermaRelations(SubHighestWeightWithZeroes);
    output.AddMonomial(tempMon);
  }
  this->operator=(output);
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::ModOutVermaRelations
  (bool SubHighestWeightWithZeroes, const PolynomialsRationalCoeff& highestWeightSub, GlobalVariables* theContext, const CoefficientType& theRingUnit)
{ MonomialUniversalEnvelopingOrdered<CoefficientType> tempMon;
  ElementUniversalEnvelopingOrdered<CoefficientType> output;
  output.Nullify(*this->owner);
  for (int i=0; i<this->size; i++)
  { tempMon= this->TheObjects[i];
    tempMon.ComputeDebugString();
    tempMon.ModOutVermaRelations(SubHighestWeightWithZeroes, highestWeightSub, theContext, theRingUnit);
    tempMon.ComputeDebugString();
    output.AddMonomial(tempMon);
  }
  this->operator=(output);
}

void ElementUniversalEnveloping::GetCoordinateFormOfSpanOfElements
  (int numVars, List<ElementUniversalEnveloping>& theElements, List<rootPoly>& outputCoordinates, ElementUniversalEnveloping& outputCorrespondingMonomials, GlobalVariables& theGlobalVariables)
{ if (theElements.size==0)
    return;
  outputCorrespondingMonomials.Nullify(*theElements.TheObjects[0].owner);
  MonomialUniversalEnveloping tempMon;
  for (int i=0; i<theElements.size; i++)
    for (int j=0; j<theElements.TheObjects[i].size; j++)
      outputCorrespondingMonomials.AddObjectOnTopNoRepetitionOfObjectHash(theElements.TheObjects[i].TheObjects[j]);
  outputCoordinates.SetSize(theElements.size);
  PolynomialRationalCoeff ZeroPoly;
  ZeroPoly.Nullify((int)numVars);
  for (int i=0; i<theElements.size; i++)
  { rootPoly& current=outputCoordinates.TheObjects[i];
    current.initFillInObject(outputCorrespondingMonomials.size, ZeroPoly);
    ElementUniversalEnveloping& currentElt=theElements.TheObjects[i];
    for (int j=0; j<currentElt.size; j++)
    { MonomialUniversalEnveloping& currentMon=currentElt.TheObjects[j];
      current.TheObjects[outputCorrespondingMonomials.IndexOfObjectHash(currentMon)]=currentMon.Coefficient;
    }
  }
}

void ElementUniversalEnveloping::AssignElementCartan(const root& input, int numVars, SemisimpleLieAlgebra& theOwner)
{ MonomialUniversalEnveloping tempMon;
  this->Nullify(theOwner);
  tempMon.Nullify(numVars, theOwner);
  int theDimension= theOwner.theWeyl.CartanSymmetric.NumRows;
  int numPosRoots=theOwner.theWeyl.RootsOfBorel.size;
  tempMon.generatorsIndices.SetSize(1);
  tempMon.Powers.SetSize(1);
  for (int i=0; i<theDimension; i++)
    if (!input.TheObjects[i].IsEqualToZero())
    { (*tempMon.generatorsIndices.LastObject())=i+numPosRoots;
      tempMon.Powers.LastObject()->MakeNVarConst((int)numVars, 1);
      tempMon.Coefficient.MakeNVarConst((int)numVars, input.TheObjects[i]);
      this->AddObjectOnTopHash(tempMon);
    }
}

void ElementUniversalEnveloping::ElementToString(std::string& output, bool useLatex)
{ std::stringstream out;
  std::string tempS;
  if (this->size==0)
    out << "0";
  int IndexCharAtLastLineBreak=0;
  for (int i=0; i<this->size; i++)
  { MonomialUniversalEnveloping& current=this->TheObjects[i];
    tempS=current.ElementToString(false);
    if (i!=0)
      if (tempS.size()>0)
        if (tempS[0]!='-')
          out << '+';
    out << tempS;
    if (((int)out.tellp())- IndexCharAtLastLineBreak> 150)
    { IndexCharAtLastLineBreak=out.tellp();
      out << "\\\\&&";
    }
  }
  output=out.str();
}

void MonomialUniversalEnveloping::SetNumVariables(int newNumVars)
{ if (this->Coefficient.NumVars==newNumVars)
    return;
  this->Coefficient.SetNumVariablesSubDeletedVarsByOne((int)newNumVars);
  for(int i=0; i<this->generatorsIndices.size; i++)
    this->Powers.TheObjects[i].SetNumVariablesSubDeletedVarsByOne((int)newNumVars);
}

std::string MonomialUniversalEnveloping::ElementToString(bool useLatex)
{ std::stringstream out;
  std::string tempS;
  PolynomialOutputFormat PolyFormatLocal;
  if (this->owner==0)
    return "faulty monomial non-initialized owner. Slap the programmer.";
  if (this->Coefficient.IsEqualToZero())
    tempS="0";
  else
    tempS = this->Coefficient.ElementToString(PolyFormatLocal);
  if (this->generatorsIndices.size>0)
  { if (tempS=="1")
      tempS="";
    if (tempS=="-1")
      tempS="-";
  }
  if (this->Coefficient.size>1)
    out << "(" << tempS << ")";
  else
    out << tempS;
  for (int i=0; i<this->generatorsIndices.size; i++)
  { PolynomialRationalCoeff& thePower=this->Powers.TheObjects[i];
    int theIndex=this->generatorsIndices.TheObjects[i];
    tempS=this->owner->GetLetterFromGeneratorIndex(theIndex, useLatex);
    //if (thePower>1)
    //  out << "(";
    out << tempS;
    if (!thePower.IsEqualToOne())
    { out << "^";
     // if (useLatex)
      out << "{";
      out << thePower.ElementToString(PolyFormatLocal);
      //if (useLatex)
      out << "}";
    }
    //if (thePower>1)
    //  out << ")";
  }
  return out.str();
}

void MonomialUniversalEnveloping::ModOutVermaRelations(bool SubHighestWeightWithZeroes)
{ int numPosRoots=this->owner->theWeyl.RootsOfBorel.size;
  int theDimension=this->owner->theWeyl.CartanSymmetric.NumRows;
  int theNumVars=this->Coefficient.NumVars;
  this->ComputeDebugString();
  if (theNumVars<theDimension && !SubHighestWeightWithZeroes)
  { this->SetNumVariables(theDimension);
    theNumVars=theDimension;
  }
  for (int i=this->generatorsIndices.size-1; i>=0; i--)
  { int IndexCurrentGenerator=this->owner->ChevalleyGeneratorIndexToRootIndex(generatorsIndices.TheObjects[i]);
    //ChevalleyGeneratorToRootIndex returns a negative value if the generator is an element of the Cartan
    if (IndexCurrentGenerator<numPosRoots && IndexCurrentGenerator>=0)
    { this->Nullify(theNumVars, *this->owner);
      return;
    }
    if (IndexCurrentGenerator>=numPosRoots)
      return;
    if (IndexCurrentGenerator<0)
    { if (this->Powers.TheObjects[i].TotalDegree()!=0)
        return;
      if (SubHighestWeightWithZeroes)
      { this->Nullify(theNumVars, *this->owner);
        return;
      }
      int theDegree = this->Powers.TheObjects[i].TheObjects[0].Coefficient.NumShort;
      PolynomialRationalCoeff tempP;
      root tempRoot;
      tempRoot.MakeEi(theNumVars, this->owner->ChevalleyGeneratorIndexToElementCartanIndex(this->generatorsIndices.TheObjects[i]));
      tempP.MakeLinPolyFromRoot(tempRoot);
      if (theDegree!=1)
        tempP.RaiseToPower(theDegree, (Rational) 1);
      this->Coefficient.MultiplyBy(tempP);
      this->generatorsIndices.size--;
      this->Powers.size--;
    }
  }
}

template <class CoefficientType>
void MonomialUniversalEnvelopingOrdered<CoefficientType>::ModOutVermaRelations
  (bool SubHighestWeightWithZeroes, const PolynomialsRationalCoeff& highestWeightSub, GlobalVariables* theContext, const CoefficientType& theRingUnit)
{ int numPosRoots=this->owner->theOwner.GetNumPosRoots();
  int theDimension=this->owner->theOwner.GetRank();
  int theNumVars=this->Coefficient.NumVars;
  //this->ComputeDebugString();
  if (theNumVars<theDimension && !SubHighestWeightWithZeroes)
  { this->SetNumVariables(theDimension);
    theNumVars=theDimension;
  }
  for (int i=this->generatorsIndices.size-1; i>=0; i--)
  { int IndexCurrentGenerator=this->generatorsIndices.TheObjects[i];
    if (IndexCurrentGenerator>=numPosRoots+theDimension)
    { this->Nullify(theNumVars, *this->owner, theContext);
      return;
    }
    if (IndexCurrentGenerator<numPosRoots)
      return;
    if (IndexCurrentGenerator>=numPosRoots &&  IndexCurrentGenerator<numPosRoots+theDimension)
    { int theDegree;
      if (!this->Powers.TheObjects[i].IsSmallInteger(theDegree))
        return;
      if (SubHighestWeightWithZeroes)
      { this->Nullify(theNumVars, *this->owner, theContext);
        return;
      }
      PolynomialRationalCoeff tempP;
      root tempRoot;
      tempRoot.MakeZero(theNumVars);
      for (int i=0; i<this->owner->theOrder.TheObjects[IndexCurrentGenerator].Hcomponent.size; i++)
        tempRoot.TheObjects[i]=this->owner->theOrder.TheObjects[IndexCurrentGenerator].Hcomponent.TheObjects[i];
      tempP.MakeLinPolyFromRoot(tempRoot);
      tempP.Substitution(highestWeightSub, theNumVars, (Rational) 1);
      tempP.RaiseToPower(theDegree, (Rational) 1);
      tempP.ComputeDebugString();
      this->owner->theOrder.TheObjects[IndexCurrentGenerator].Hcomponent.ComputeDebugString();
      assert(this->Coefficient.checkConsistency());
      this->Coefficient.operator*=(tempP);
      assert(this->Coefficient.checkConsistency());
      this->generatorsIndices.size--;
      this->Powers.size--;
    }
  }
}

void MonomialUniversalEnveloping::Nullify(int numVars, SemisimpleLieAlgebra& theOwner)
{ this->Coefficient.Nullify((int)numVars);
  this->owner=&theOwner;
  this->generatorsIndices.size=0;
  this->Powers.size=0;
}

int MonomialUniversalEnveloping::HashFunction() const
{ int top=MathRoutines::Minimum(SomeRandomPrimesSize, this->generatorsIndices.size);
  int result=0;
  for (int i=0; i<top; i++)
    result+=SomeRandomPrimes[i]*this->generatorsIndices.TheObjects[i];
  return result;
}

void ParserNode::Clear()
{ this->indexParentNode=-1;
  this->indexInOwner=-1;
  this->intValue=0;
  this->ErrorType=this->errorNoError;
  this->Operation= Parser::tokenEmpty;
  this->Evaluated=false;
  this->ExpressionType=this->typeUndefined;
  this->children.size=0;
  this->rationalValue.MakeZero();
  if (this->owner!=0)
    this->ContextLieAlgebra=&this->owner->theHmm.theRange;
}

std::string SemisimpleLieAlgebra::GetLetterFromGeneratorIndex(int theIndex, bool useLatex)
{ int numPosRoots= this->theWeyl.RootsOfBorel.size;
  int rank= this->theWeyl.CartanSymmetric.NumRows;
  std::stringstream out;
  if (theIndex<numPosRoots || theIndex>= numPosRoots+rank)
  { out << "g";
    if (useLatex)
      out << "^{\\alpha_{" << this->ChevalleyGeneratorIndexToRootIndex(theIndex)+1 << "}}";
    else
      out << "_{" << this->ChevalleyGeneratorIndexToDisplayIndex(theIndex) << "}";
  } else
  { out << "h";
    if (useLatex)
      out << "_{\\alpha_{" << theIndex-numPosRoots+1 << "}}";
    else
      out << "_{" << theIndex-numPosRoots+1 << "}";
  }
  return out.str();
}

bool SemisimpleLieAlgebra::AreOrderedProperly(int leftIndex, int rightIndex)
{ return leftIndex<=rightIndex;
}

int SemisimpleLieAlgebra::DisplayIndexToRootIndex(int theIndex)
{ int numPosRoots=this->theWeyl.RootsOfBorel.size;
  if (theIndex<0)
    return -theIndex+numPosRoots-1;
  return theIndex-1;
}

int SemisimpleLieAlgebra::RootIndexToDisplayIndexNegativeSpacesFirstThenCartan(int theIndex)const
{ int numPosRoots=this->theWeyl.RootsOfBorel.size;
  //int theDimension= this->theWeyl.CartanSymmetric.NumRows;
  if (theIndex>=numPosRoots)
    return -theIndex+numPosRoots-1;
  if (theIndex<numPosRoots)
    return theIndex+1;
  return -10000;
}

int SemisimpleLieAlgebra::RootIndexOrderAsInRootSystemToGeneratorIndexNegativeRootsThenCartanThenPositive(int theIndex)const
{ if (theIndex<0  || theIndex>=this->theWeyl.RootSystem.size)
    return -1;
  int theDimension=this->theWeyl.CartanSymmetric.NumRows;
  int numPosRoots=this->theWeyl.RootsOfBorel.size;
  if (theIndex<numPosRoots)
    return theIndex+theDimension+numPosRoots;
  if (theIndex>=numPosRoots)
    return numPosRoots*2-1-theIndex;
  return -1;
}

int SemisimpleLieAlgebra::ChevalleyGeneratorIndexToRootIndex(int theIndex)const
{ int numPosRoots=this->theWeyl.RootsOfBorel.size;
  int theDimension=this->theWeyl.CartanSymmetric.NumRows;
  if (theIndex<numPosRoots)
    return -theIndex-1+2*numPosRoots;
  //returns a negative number if the generator is an element of the Cartan subalgebra
  return theIndex-theDimension-numPosRoots;
}

std::string SemisimpleLieAlgebra::ElementToStringLieBracketPairing()
{ std::stringstream out;
  std::string tempS;
  out << "<br>\nThe generator indices:<br>\n ";
  for (int i=0; i<this->theLiebracketPairingIndices.NumRows; i++)
  { for (int j=0; j<this->theLiebracketPairingIndices.NumCols; j++)
      out << this->theLiebracketPairingIndices.elements[i][j] << ", ";
    out << "<br>\n";
  }
  this->theLiebracketPairingCoefficients.ElementToString(tempS);
  out << "<br>\nThe coefficients:\n" << tempS;
  return out.str();
}

void ElementUniversalEnveloping::MakeConst(const Rational& coeff, int numVars, SemisimpleLieAlgebra& theOwner)
{ MonomialUniversalEnveloping tempMon;
  this->Nullify(theOwner);
  PolynomialRationalCoeff tempP;
  tempP.MakeNVarConst((int)numVars, coeff);
  tempMon.MakeConst(tempP, theOwner);
  this->AddMonomialNoCleanUpZeroCoeff(tempMon);
  this->CleanUpZeroCoeff();
}

void ElementUniversalEnveloping::Nullify(SemisimpleLieAlgebra& theOwner)
{ this->ClearTheObjects();
  this->owner=&theOwner;
}

void ElementUniversalEnveloping::operator+=(const ElementUniversalEnveloping& other)
{ this->MakeActualSizeAtLeastExpandOnTop(other.size);
  for (int i=0; i<other.size; i++)
    this->AddMonomialNoCleanUpZeroCoeff(other.TheObjects[i]);
  this->CleanUpZeroCoeff();
}

void ElementUniversalEnveloping::operator-=(const ElementUniversalEnveloping& other)
{ this->MakeActualSizeAtLeastExpandOnTop(other.size);
  MonomialUniversalEnveloping tempMon;
  for (int i=0; i<other.size; i++)
  { tempMon=other.TheObjects[i];
    tempMon.Coefficient.TimesConstant(-1);
    this->AddMonomialNoCleanUpZeroCoeff(tempMon);
  }
  this->CleanUpZeroCoeff();
}

void ElementUniversalEnveloping::operator/=(const Rational& other)
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].Coefficient.DivByRational(other);
}

void ElementUniversalEnveloping::operator*=(const PolynomialRationalCoeff& other)
{ if (other.IsEqualToZero())
  { this->Nullify(*this->owner);
    return;
  }
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].Coefficient.MultiplyBy(other);
}

void ElementUniversalEnveloping::operator*=(const Rational& other)
{ if (other.IsEqualToZero())
  { this->Nullify(*this->owner);
    return;
  }
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].Coefficient.TimesConstant(other);
}

void ElementUniversalEnveloping::operator*=(const ElementUniversalEnveloping& other)
{ this->MakeActualSizeAtLeastExpandOnTop(other.size*this->size);
  ElementUniversalEnveloping output;
  output.Nullify(*this->owner);
  MonomialUniversalEnveloping tempMon;
  int sizeOriginal=0;
  PolynomialRationalCoeff powerOriginal, CoeffOriginal;
  for (int i=0; i<this->size; i++)
  { tempMon=this->TheObjects[i];
    sizeOriginal=tempMon.generatorsIndices.size;
    if (sizeOriginal>0)
      powerOriginal=*tempMon.Powers.LastObject();
    CoeffOriginal.Assign(tempMon.Coefficient);
    for(int j=0; j<other.size; j++)
    { tempMon.generatorsIndices.size=sizeOriginal;
      tempMon.Powers.size=sizeOriginal;
      if (sizeOriginal>0)
        *tempMon.Powers.LastObject()=powerOriginal;
      tempMon.Coefficient.Assign(CoeffOriginal);
      tempMon.MultiplyByNoSimplify(other.TheObjects[j]);
      //tempMon.ComputeDebugString();
      output.AddMonomialNoCleanUpZeroCoeff(tempMon);
    }
  }
  *this=output;
}

void ElementUniversalEnveloping::SetNumVariables(int newNumVars)
{ //this->ComputeDebugString();
  if (this->size==0)
    return;
  int currentNumVars=this->TheObjects[0].Coefficient.NumVars;
  if (currentNumVars==newNumVars)
    return;
  ElementUniversalEnveloping Accum;
  Accum.Nullify(*this->owner);
  MonomialUniversalEnveloping tempMon;
  for (int i=0; i<this->size; i++)
  { tempMon=this->TheObjects[i];
    tempMon.SetNumVariables(newNumVars);
    Accum.AddMonomial(tempMon);
  }
//  Accum.ComputeDebugString();
  this->operator=(Accum);
 // this->ComputeDebugString();
}

void ElementUniversalEnveloping::RaiseToPower(int thePower)
{ ElementUniversalEnveloping buffer;
  buffer=*this;
  if (this->size==0)
    return;
  this->MakeConst(1, this->TheObjects[0].Coefficient.NumVars, *this->owner);
  for (int i=0; i<thePower; i++)
    this->operator*=(buffer);
}

void ElementUniversalEnveloping::MakeCasimir(SemisimpleLieAlgebra& theOwner, int numVars, GlobalVariables& theGlobalVariables)
{ std::stringstream out;
  this->Nullify(theOwner);
  WeylGroup& theWeyl= this->owner->theWeyl;
  int theDimension=theWeyl.CartanSymmetric.NumRows;
  root tempRoot1, tempRoot2;
  MatrixLargeRational killingForm;
  killingForm.init(theDimension, theDimension);
  for (int i=0; i<theDimension; i++)
  { tempRoot1.MakeEi(theDimension, i);
    for (int j=0; j<theDimension; j++)
    { killingForm.elements[i][j]=0;
      tempRoot2.MakeEi(theDimension, j);
      for (int k=0; k<theWeyl.RootSystem.size; k++)
        killingForm.elements[i][j]+= theWeyl.RootScalarCartanRoot(tempRoot1, theWeyl.RootSystem.TheObjects[k])* theWeyl.RootScalarCartanRoot(tempRoot2, theWeyl.RootSystem.TheObjects[k]);
    }
  }
  killingForm.Invert(theGlobalVariables);
  killingForm.ComputeDebugString();
  out << killingForm.DebugString;
  ElementUniversalEnveloping tempElt1, tempElt2;
  for (int i=0; i<theDimension; i++)
  { tempRoot1.MakeEi(theDimension, i);
    killingForm.ActOnAroot(tempRoot1, tempRoot2);
    tempElt1.AssignElementCartan(tempRoot1, numVars, theOwner);
    tempElt2.AssignElementCartan(tempRoot2, numVars, theOwner);
    tempElt1*=tempElt2;
    *this+=tempElt1;
  }
  Rational tempRat;
  root theSum;
  for (int i=0; i<theWeyl.RootSystem.size; i++)
  { tempRat=0;
    root& theRoot=theWeyl.RootSystem.TheObjects[i];
    int indexOfOpposite=theWeyl.RootSystem.IndexOfObjectHash(-theRoot);
    root& theOpposite= theWeyl.RootSystem.TheObjects[indexOfOpposite];
    for (int j=0; j<theWeyl.RootSystem.size; j++)
    { root& current=theWeyl.RootSystem.TheObjects[j];
      if (current==theOpposite)
        tempRat+=2;
      else
      { int indexOfSum=theWeyl.RootSystem.IndexOfObjectHash(current+theRoot);
        if (indexOfSum!=-1)
          tempRat+=(theOwner.ChevalleyConstants.elements[i][j]*theOwner.ChevalleyConstants.elements[indexOfOpposite][indexOfSum]);
      }
    }
    tempRat+=2;
    tempRat= 1/tempRat;
    tempElt2.MakeOneGeneratorCoeffOne(theOpposite, numVars, theOwner);
    tempElt1.MakeOneGeneratorCoeffOne(theRoot, numVars, theOwner);
    tempElt2*=tempElt1;
    tempElt2*=tempRat;
    *this+=tempElt2;
  }
  this->ComputeDebugString();
  out << "\n" << this->DebugString;
  this->DebugString=out.str();
/*  for (int i=0; i<theDimension; i++)
  { tempRoot.MakeEi(theDimension, i);
    if (!length1Explored)
    { length1= theWeyl.RootScalarCartanRoot(tempRoot, tempRoot);
      length1Explored=true;
      coefficient1=0;
      for (int j=0; j<theWeyl.RootsOfBorel.size; j++)
      { coefficient1+=theWeyl.RootScalarCartanRoot(tempRoot, theWeyl.RootsOfBorel.TheObjects[j])*theWeyl.RootScalarCartanRoot(tempRoot, theWeyl.RootsOfBorel.TheObjects[j]);
        coef
      }
    }
  }*/
}

void ComputationSetup::ExperimentSSsubalgebras(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ SemisimpleSubalgebras theComputation;
  theComputation.FindHCandidates(inputData.WeylGroupLetter, inputData.WeylGroupIndex, theGlobalVariables);
}

void ComputationSetup::TestParser(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ std::string inputString;
  std::stringstream out;
  SemisimpleLieAlgebra theLieAlgebra;
  theLieAlgebra.ComputeChevalleyConstants('A', 1, theGlobalVariables);
  theLieAlgebra.ComputeDebugString(false, false, theGlobalVariables);
  ElementUniversalEnveloping theElt;
  theElt.MakeCasimir(theLieAlgebra, 1, theGlobalVariables);
  out << theElt.DebugString << "\n\n";
  out << theLieAlgebra.DebugString;
  theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
  theGlobalVariables.theIndicatorVariables.StatusString1 = out.str();
  theGlobalVariables.MakeReport();
}

void CGIspecificRoutines::MakeSureWeylGroupIsSane(char& theWeylLetter, int& theRank)
{ if (theWeylLetter=='a') theWeylLetter='A';
  if (theWeylLetter=='b') theWeylLetter='B';
  if (theWeylLetter=='c') theWeylLetter='C';
  if (theWeylLetter=='d') theWeylLetter='D';
  if (theWeylLetter=='e') theWeylLetter='E';
  if (theWeylLetter=='f') theWeylLetter='F';
  if (theWeylLetter=='g') theWeylLetter='G';
  if (!(theWeylLetter=='A' || theWeylLetter=='B' || theWeylLetter=='C' || theWeylLetter=='D' || theWeylLetter=='E' || theWeylLetter=='F' || theWeylLetter=='G'))
      theWeylLetter='A';
  if (theRank>8 || theRank<1)
    theRank=1;
}

void SemisimpleLieAlgebra::ElementToStringNegativeRootSpacesFirst(std::string& output, bool useHtml, bool useLatex, bool usePNG, GlobalVariables& theGlobalVariables)
{ std::stringstream out;
  std::string tempS;
  root tempRoot;
  std::string beginMath;
  std::string endMath;
  if (!usePNG)
  { beginMath="<DIV class=\"math\" scale=\"50\">\\begin{array}{";
    endMath="\\end{array}</DIV>";
  } else
  { beginMath="\\begin{tabular}{";
    endMath="\\end{tabular}";
  }
  int numRoots=this->theWeyl.RootSystem.size;
  int numPosRoots=this->theWeyl.RootsOfBorel.size;
  int theDimension = this->theWeyl.CartanSymmetric.NumRows;
  ElementSimpleLieAlgebra tempElt1, tempElt2, tempElt3;
//  out << beginMath << "\\begin{array}{ccc}a& a&a\\\\a&a&a\\end{array}";
  if (usePNG)
  { out << "\\begin{tabular}{cc}";
    out << "\\hline generator &corresponding root space\\\\\\hline";
    for (int i=0; i<numRoots+theDimension; i++)
    { if (i==numPosRoots)
      { out << "\\hline\\begin{tabular}{c}$h_i$:=$[g_{i},g_{-i}]$\\\\$h_i$ is dual to the i$^{th}$ root\\end{tabular} & 0 \\\\\\hline";
//        out << "  \\\\\\hline";
        //out << "\\hline generator & corresponding root space\\\\\\hline";
        i+=theDimension;
      }
      out << "$" << this->GetLetterFromGeneratorIndex(i, false) << "$&";
      int tempI=this->ChevalleyGeneratorIndexToRootIndex(i);
      out << this->theWeyl.RootSystem.TheObjects[tempI].ElementToString() << "\\\\";
    }
    out << "\\end{tabular}";
  }
  out << beginMath;
//  ElementUniversalEnveloping tempSSElt1, tempSSElt2, tempSSElt3;
  for (int i=0; i<numRoots+theDimension+1; i++)
    out << "c";
  out << "}";
  std::string tempHeader=out.str();
  if(usePNG)
    out << "$";
  out << "[\\bullet, \\bullet]\n";
  if(usePNG)
    out << "$";
  for (int i=0; i<numRoots+theDimension; i++)
  { tempElt1.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(i, *this);
    tempS=tempElt1.ElementToStringNegativeRootSpacesFirst(true, false, *this);
    out << " & ";
    if(usePNG)
      out << "$";
    out << tempS;
    if(usePNG)
      out << "$";
  }
  out << "\\\\\n";
  Rational tempRat;
  for (int i=0; i<numRoots+theDimension; i++)
  { tempElt1.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(i,*this);
    tempS=tempElt1.ElementToStringNegativeRootSpacesFirst(true, false, *this);
    if(usePNG)
      out << "$";
    out << tempS;
    if(usePNG)
      out << "$";
    for (int j=0; j<numRoots+theDimension; j++)
    { tempElt2.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(j, *this);
      this->LieBracket(tempElt1, tempElt2, tempElt3);
      tempS=tempElt3.ElementToStringNegativeRootSpacesFirst(true, false, *this);
      out << "& ";
      if(usePNG)
        out << "$";
      out << tempS;
      if(usePNG)
        out << "$";
    }
    out << "\\\\\n";
    //the below is a hack to avoid a latex crash due to memory overuse
    //if (usePNG && i%130==129)
    //  out << "\\end{tabular}\n\n\n" << tempHeader;
  }
  out << endMath;
  output=out.str();
}

void CGIspecificRoutines::ReplaceEqualitiesAndAmpersantsBySpaces(std::string& inputOutput)
{ for (int i=0; i<(signed)inputOutput.size(); i++)
    if (inputOutput[i]=='=' || inputOutput[i]=='&')
      inputOutput[i]=' ';
}

void VectorPartition::ComputeAllPartitions()
{ List<int> currentPartition;
  currentPartition.initFillInObject(PartitioningRoots.size, 0);
  this->thePartitions.size=0;
  this->ComputeAllPartitionsRecursive(0, currentPartition, -1, theRoot);
}

void VectorPartition::ComputeAllPartitionsRecursive(int currentIndex, List<int>& CurrentPartition, int UpperBoundEachIndex, root& toBePartitioned)
{ if (currentIndex>=this->PartitioningRoots.size)
    return;
  root currentRoot=toBePartitioned;
  while (currentRoot.IsPositiveOrZero() && (CurrentPartition.TheObjects[currentIndex]<=UpperBoundEachIndex || UpperBoundEachIndex==-1))
  { if (currentRoot.IsEqualToZero())
      this->thePartitions.AddObjectOnTop(CurrentPartition);
    else
    { this->ComputeAllPartitionsRecursive(currentIndex+1, CurrentPartition , UpperBoundEachIndex, currentRoot);
      for (int i=currentIndex+1; i<CurrentPartition.size; i++)
        CurrentPartition.TheObjects[i]=0;
    }
    currentRoot.Subtract(this->PartitioningRoots.TheObjects[currentIndex]);
    CurrentPartition.TheObjects[currentIndex]++;
  }
}

std::string VectorPartition::ElementToString(bool useHtml)
{ std::stringstream out;
  out << this->theRoot.ElementToString() << "\n\n";
  if (useHtml)
    out << "<br>";
  for (int i=0; i<this->thePartitions.size; i++)
  { bool found=false;
    out << "=";
    for (int j=0; j<this->thePartitions.TheObjects[i].size; j++)
    { int theCoefficient=thePartitions.TheObjects[i].TheObjects[j];
      if (theCoefficient!=0)
      { if(found)
          out << "+";
        found=true;
        if (theCoefficient>1)
          out << theCoefficient;
        out << this->PartitioningRoots.TheObjects[j].ElementToString();
      }
    }
    out << "\n\n";
    if (useHtml)
      out << "<br>\n";
  }
  return out.str();
}


std::string rootPoly::ElementToString()
{ std::stringstream out;
  PolynomialOutputFormat PolyFormatLocal;
  out << "(";
  for (int i=0; i<this->size; i++)
  { out << this->TheObjects[i].ElementToString(PolyFormatLocal);
    if (i<this->size-1)
      out << ",";
  }
  out << ")";
  return out.str();
}

std::string RationalFunction::ElementToString(bool useLatex, bool breakLinesLatex)const
{ std::stringstream out;
  if (this->expressionType==this->typeRational)
  { out << this->ratValue.ElementToString();
    return out.str();
  }
  PolynomialOutputFormat PolyFormatLocal;
  bool hasDenominator=(this->expressionType==this->typeRationalFunction);
  if (hasDenominator && useLatex)
    out << "\\frac{";
  out << this->Numerator.GetElementConst().ElementToString(breakLinesLatex, PolyFormatLocal);
  if (hasDenominator)
  { if (useLatex)
      out << "}{";
    out << this->Denominator.GetElementConst().ElementToString(breakLinesLatex, PolyFormatLocal);
    if (useLatex)
      out << "}";
  }
  return out.str();
}

void RationalFunction::RemainderDivisionWithRespectToBasis(PolynomialRationalCoeff& input, List<PolynomialRationalCoeff>& theBasis, PolynomialRationalCoeff& outputRemainder, PolynomialRationalCoeff& buffer1, PolynomialRationalCoeff& buffer2, Monomial<Rational>& bufferMon1)
{ assert(&outputRemainder!=&input);
  PolynomialRationalCoeff* currentRemainder=&input;
  PolynomialRationalCoeff* nextRemainder=&buffer1;
  for (int i=0; i<theBasis.size; i++)
  { RationalFunction::RemainderDivision(*currentRemainder, theBasis.TheObjects[i], *nextRemainder, buffer2, bufferMon1);
    MathRoutines::swap(currentRemainder, nextRemainder);
    if (currentRemainder->IsEqualToZero())
      break;
  }
  if (currentRemainder!=&outputRemainder)
    outputRemainder.Assign(*currentRemainder);
}

void RationalFunction::RemainderDivision(PolynomialRationalCoeff& input, PolynomialRationalCoeff& divisor, PolynomialRationalCoeff& outputRemainder, PolynomialRationalCoeff& buffer, Monomial<Rational>& bufferMon1)
{ assert(&input!=&outputRemainder);
  outputRemainder.Assign(input);
  int divisorHighest=divisor.GetIndexMaxMonomialLexicographicLastVariableStrongest();
  Monomial<Rational>& highestMonDivisor=divisor.TheObjects[divisorHighest];
  int remainderHighest=-1;
  int theNumVars=input.NumVars;
  bufferMon1.init((int)theNumVars);
  assert(input.NumVars==theNumVars);
  assert(divisor.NumVars==theNumVars);
  for(;;)
  { if (outputRemainder.size==0)
      return;
    remainderHighest=  outputRemainder.GetIndexMaxMonomialLexicographicLastVariableStrongest();
    Monomial<Rational>& highestMonRemainder=outputRemainder.TheObjects[remainderHighest];
    /*outputRemainder.ComputeDebugString();
    highestMonRemainder.ComputeDebugString();
    highestMonDivisor.ComputeDebugString();*/
    for (int i=0; i<theNumVars; i++)
    { if (highestMonRemainder.degrees[i]<highestMonDivisor.degrees[i])
        return;
      bufferMon1.degrees[i]=highestMonRemainder.degrees[i]-highestMonDivisor.degrees[i];
    }
    bufferMon1.Coefficient=highestMonRemainder.Coefficient/highestMonDivisor.Coefficient;
    divisor.MultiplyByMonomial(bufferMon1, buffer);
/*    outputRemainder.ComputeDebugString();
    tempP.ComputeDebugString();
    highestMonRemainder.ComputeDebugString();
    tempMon.ComputeDebugString();
    highestMonDivisor.ComputeDebugString();*/
    outputRemainder.Subtract(buffer);/*
    outputRemainder.ComputeDebugString();*/
  }
}

void RationalFunction::TransformToGroebnerBasis(List<PolynomialRationalCoeff>& theBasis, PolynomialRationalCoeff& buffer1, PolynomialRationalCoeff& buffer2, PolynomialRationalCoeff& buffer3, PolynomialRationalCoeff& buffer4, Monomial<Rational>& bufferMon1, Monomial<Rational>& bufferMon2)
{ PolynomialRationalCoeff& tempP=buffer1;
  PolynomialRationalCoeff& Spoly=buffer2;
  Monomial<Rational>& leftShift=bufferMon1;
  Monomial<Rational>& rightShift=bufferMon2;
  int theNumVars=theBasis.TheObjects[0].NumVars;
  leftShift.init((int)theNumVars);
  rightShift.init((int)theNumVars);
 // std::string tempS;
  for (int lowestNonExplored=0; lowestNonExplored< theBasis.size; lowestNonExplored++)
  { //warning! currentPoly may expire if theBasis.TheObjects changes size
//    PolynomialRationalCoeff& currentPoly=;
    for (int j=0; j<theBasis.size; j++)
    { PolynomialRationalCoeff& currentLeft= theBasis.TheObjects[lowestNonExplored];
      PolynomialRationalCoeff& currentRight= theBasis.TheObjects[j];
      Monomial<Rational>& leftHighestMon=currentLeft.TheObjects[currentLeft.GetIndexMaxMonomialLexicographicLastVariableStrongest()];
      Monomial<Rational>& rightHighestMon=currentRight.TheObjects[currentRight.GetIndexMaxMonomialLexicographicLastVariableStrongest()];
      //leftHighestMon.ComputeDebugString();
      //rightHighestMon.ComputeDebugString();
      //currentRight.ComputeDebugString();
      //currentLeft.ComputeDebugString();
      leftShift.Coefficient=-rightHighestMon.Coefficient;
      rightShift.Coefficient=leftHighestMon.Coefficient;
      for (int k=0; k<leftHighestMon.NumVariables; k++)
        if (leftHighestMon.degrees[k]>rightHighestMon.degrees[k])
        { rightShift.degrees[k]=leftHighestMon.degrees[k]-rightHighestMon.degrees[k];
          leftShift.degrees[k]=0;
        }
        else
        { leftShift.degrees[k]=rightHighestMon.degrees[k]-leftHighestMon.degrees[k];
          rightShift.degrees[k]=0;
        }
      currentLeft.MultiplyByMonomial(leftShift, tempP);
      currentRight.MultiplyByMonomial(rightShift, Spoly);
      Spoly.AddPolynomial(tempP);
      //Spoly.ComputeDebugString();
//      theBasis.ElementToStringGeneric(tempS);
      RationalFunction::RemainderDivisionWithRespectToBasis(Spoly, theBasis, tempP, buffer3, buffer4, bufferMon1);

      //tempP.ComputeDebugString();
      if (!tempP.IsEqualToZero())
      { tempP.ScaleToIntegralNoGCDCoeffs();
        theBasis.AddObjectOnTop(tempP);
//        std::cout << "<br> new element found: " << tempP.ElementToString();
      }
    }
  }
//  std::cout << "<br> ... and the basis before reduction is: <br>";
//  for (int i=0; i<theBasis.size; i++)
//    std::cout << theBasis.TheObjects[i].ElementToString() << ", ";
  RationalFunction::ReduceGroebnerBasis(theBasis, buffer1);

}

void RationalFunction::ReduceGroebnerBasis(List<PolynomialRationalCoeff>& theBasis, PolynomialRationalCoeff& buffer1)
{ PolynomialRationalCoeff& LeadingCoeffs=buffer1;
  LeadingCoeffs.MakeActualSizeAtLeastExpandOnTop(theBasis.size);
  LeadingCoeffs.ClearTheObjects();
  List<Monomial<Rational> > tempList;
//  std::cout << "<br> ... and the leading coefficients are: <br>";
  for (int i=0; i<theBasis.size; i++)
  { PolynomialRationalCoeff& current=theBasis.TheObjects[i];
    LeadingCoeffs.AddObjectOnTopHash(current.TheObjects[current.GetIndexMaxMonomialLexicographicLastVariableStrongest()]);
    LeadingCoeffs.LastObject()->Coefficient=1;
//    LeadingCoeffs.LastObject()->ComputeDebugString();
//    std::cout << LeadingCoeffs.LastObject()->DebugString << ", ";
  }
  tempList.CopyFromBase(LeadingCoeffs);
  tempList.QuickSortAscending();
//  std::cout << "<br><br> and the sorted leading monomials are: ";
//  for (int i=0; i<theBasis.size; i++)
//  { tempList.TheObjects[i].ComputeDebugString();
//    std::cout << tempList.TheObjects[i].DebugString << ", ";
//  }
  for (int i=0; i<LeadingCoeffs.size; i++)
  { Monomial<Rational>& currentMon=LeadingCoeffs.TheObjects[i];
    for (int j=0; j<LeadingCoeffs.size; j++)
      if (i!=j)
        if (currentMon.IsDivisibleBy(LeadingCoeffs.TheObjects[j]))
        { LeadingCoeffs.PopIndexSwapWithLastHash(i);
          theBasis.PopIndexSwapWithLast(i);
          i--;
          break;
        }
  }
}

void RationalFunction::gcd(const PolynomialRationalCoeff& left, const PolynomialRationalCoeff& right, PolynomialRationalCoeff& output, PolynomialRationalCoeff& buffer1, PolynomialRationalCoeff& buffer2, PolynomialRationalCoeff& buffer3, PolynomialRationalCoeff& buffer4, PolynomialRationalCoeff& buffer5, Monomial<Rational>& bufferMon1, Monomial<Rational>& bufferMon2, List<PolynomialRationalCoeff>& bufferList)
{ RationalFunction::lcm(left, right, buffer4, buffer1, buffer2, buffer3, buffer5, bufferMon1, bufferMon2, bufferList);
  left.MultiplyBy(right, buffer2, buffer1, bufferMon1);
//  std::cout << "<br>the product: " << buffer2.DebugString << " and the gcd: " << buffer4.DebugString << "<br>";
  buffer2.DivideBy(buffer4, output, buffer3);
}

void RationalFunction::lcm(const PolynomialRationalCoeff& left, const PolynomialRationalCoeff& right, PolynomialRationalCoeff& output, PolynomialRationalCoeff& buffer1, PolynomialRationalCoeff& buffer2, PolynomialRationalCoeff& buffer3, PolynomialRationalCoeff& buffer4, Monomial<Rational>& bufferMon1, Monomial<Rational>& bufferMon2, List<PolynomialRationalCoeff>& bufferList)
{ PolynomialRationalCoeff& leftTemp=buffer1;
  PolynomialRationalCoeff& rightTemp=buffer2;
  PolynomialRationalCoeff& tempP=buffer3;
  List<PolynomialRationalCoeff>& tempList=bufferList;
  leftTemp.Assign(left);
  rightTemp.Assign(right);
  assert(left.NumVars==right.NumVars);
  int theNumVars=left.NumVars;
  leftTemp.SetNumVariablesSubDeletedVarsByOne((int)theNumVars+1);
  rightTemp.SetNumVariablesSubDeletedVarsByOne((int)theNumVars+1);
  leftTemp.ScaleToIntegralNoGCDCoeffs();
  rightTemp.ScaleToIntegralNoGCDCoeffs();
  tempP.MakeMonomialOneLetter((int)theNumVars+1,(int) theNumVars, 1, (Rational) 1);
  leftTemp.MultiplyBy(tempP);
  tempP.TimesConstant((Rational)-1);
  tempP.AddConstant((Rational) 1);
  rightTemp.MultiplyBy(tempP);
  tempList.size=0;
  tempList.AddObjectOnTop(leftTemp);
  tempList.AddObjectOnTop(rightTemp);
//  std::cout << "<br>In the beginning: <br>";
//  for (int i=0; i<tempList.size; i++)
//  { std::cout << "the groebner basis element with index " << i << " is " << tempList.TheObjects[i].ElementToString() << "<br>\n";
//  }
  RationalFunction::TransformToGroebnerBasis(tempList, buffer1, buffer2, buffer3, buffer4, bufferMon1, bufferMon2);
//  std::cout << "<br><br> ... and the basis is: <br>";
//  for (int i=0; i<tempList.size; i++)
//  { std::cout << tempList.TheObjects[i].ElementToString() << "<br>\n";
//  }
  for(int i=0; i<tempList.size; i++)
  { PolynomialRationalCoeff& current=tempList.TheObjects[i];
    Monomial<Rational>& currentMon= current.TheObjects[current.GetIndexMaxMonomialLexicographicLastVariableStrongest()];
    currentMon.ComputeDebugString();
    if (currentMon.degrees[theNumVars]==0)
    { output=current;
//      std::cout << "<br> the highest mon is: " << currentMon.DebugString << "<br>";
      output.SetNumVariablesSubDeletedVarsByOne((int)theNumVars);
      return;
    }
  }
  output.Nullify((int)theNumVars);
}

std::string rootRationalFunction::ElementToString()
{ std::stringstream out;
  out << "(";
  for (int i=0; i<this->size; i++)
  { out << this->TheObjects[i].ElementToString(true, false);
    if (i!=this->size-1)
      out << ",";
  }
  out << ")";
  return out.str();
}

void RationalFunction::operator*=(const PolynomialRationalCoeff& other)
{ if (other.IsEqualToZero())
  { this->Nullify(this->NumVars, this->context);
    return;
  }
  if (this->expressionType== this->typeRational)
    this->ConvertToType(this->typePoly);
  if (this->expressionType==this->typePoly)
  { this->Numerator.GetElement()*=other;
    this->ReduceMemory();
    return;
  }
  PolynomialRationalCoeff theGCD, theResult, tempP;
  if (this->context!=0)
  { std::stringstream out;
    out << "Multiplying " << this->ElementToString() << " by " << other.ElementToString();
    this->context->theIndicatorVariables.StatusString1NeedsRefresh=true;
    this->context->theIndicatorVariables.StatusString1=out.str();
    this->context->MakeReport();
  }
  RationalFunction::gcd(this->Denominator.GetElement(), other, theGCD, this->context);
  this->Numerator.GetElement()*=other;
  this->Numerator.GetElement().DivideBy(theGCD, theResult, tempP);
  //theGCD.ComputeDebugString();
  //theResult.ComputeDebugString();
  //tempP.ComputeDebugString();
  assert(tempP.IsEqualToZero());
  this->Numerator.GetElement()=theResult;
  this->Denominator.GetElement().DivideBy(theGCD, theResult, tempP);
  //theGCD.ComputeDebugString();
  //theResult.ComputeDebugString();
  tempP.ComputeDebugString();
  assert(tempP.IsEqualToZero());
  this->Denominator.GetElement()=theResult;
  this->ReduceMemory();
  this->SimplifyLeadingCoefficientOnly();
  if (this->context!=0)
  { std::stringstream out;
    out << "Multiplying " << this->ElementToString() << " by " << other.ElementToString();
    out << " and the result is:\n" << this->ElementToString();
    this->context->theIndicatorVariables.StatusString1NeedsRefresh=true;
    this->context->theIndicatorVariables.StatusString1=out.str();
    this->context->MakeReport();
  }
//  this->ComputeDebugString();
}

void RationalFunction::operator*=(const Rational& other)
{ assert(this->checkConsistency());
  if (other.IsEqualToZero())
  { this->Nullify(this->NumVars, this->context);
    return;
  }
  switch(this->expressionType)
  { case RationalFunction::typeRational: this->ratValue*=other; return;
    case RationalFunction::typePoly: this->Numerator.GetElement().TimesConstant(other); return;
    case RationalFunction::typeRationalFunction: this->Numerator.GetElement().TimesConstant(other); this->SimplifyLeadingCoefficientOnly(); return;
  }
}

void RationalFunction::operator*=(const RationalFunction& other)
{ assert(this->NumVars==other.NumVars);
  assert(this->checkConsistency());
  assert(other.checkConsistency());
  assert(this!=&other);
  if (other.context!=0)
    this->context=other.context;
  if (other.IsEqualToZero() || this->IsEqualToZero())
  { this->Nullify(this->NumVars, this->context);
    return;
  }
  if (other.expressionType==this->typeRational)
  { this->operator*=(other.ratValue);
    return;
  }
  if (other.expressionType==this->typePoly)
  { this->operator*=(other.Numerator.GetElementConst());
    return;
  }
  if (this->expressionType ==this->typeRational)
  { Rational tempRat;
    tempRat=this->ratValue;
    this->operator=(other);
    this->operator*=(tempRat);
    return;
  }
  if (this->expressionType==this->typePoly)
  { PolynomialRationalCoeff tempP;
    tempP=this->Numerator.GetElement();
    this->operator=(other);
    this->operator*=(tempP);
    return;
  }
  PolynomialRationalCoeff theGCD1, theGCD2, tempP1, tempP2;
  //this->ComputeDebugString();
//  RationalFunction tempde_Bugger;
//  tempde_Bugger=other;
//  tempde_Bugger.ComputeDebugString();
  if (this->context!=0)
  { std::stringstream out;
    out << "Multiplying " << this->ElementToString() << " by " << other.ElementToString();
    this->context->theIndicatorVariables.StatusString1NeedsRefresh=true;
    this->context->theIndicatorVariables.StatusString1=out.str();
    this->context->MakeReport();
  }
  RationalFunction::gcd(other.Denominator.GetElementConst(), this->Numerator.GetElement(), theGCD1, this->context);
  RationalFunction::gcd(this->Denominator.GetElement(), other.Numerator.GetElementConst(), theGCD2, this->context);
  this->Numerator.GetElement().DivideBy(theGCD1, tempP1, tempP2);
  this->Numerator.GetElement()=tempP1;
  assert(tempP2.IsEqualToZero());
  other.Denominator.GetElementConst().DivideBy(theGCD1, tempP1, tempP2);
  assert(tempP2.IsEqualToZero());
  this->Denominator.GetElement()*=tempP1;
  this->Denominator.GetElement().DivideBy(theGCD2, tempP1, tempP2);
  assert(tempP2.IsEqualToZero());
  this->Denominator.GetElement()=tempP1;
  other.Numerator.GetElementConst().DivideBy(theGCD2, tempP1, tempP2);
  assert(tempP2.IsEqualToZero());
  this->Numerator.GetElement().MultiplyBy(tempP1);
  this->ReduceMemory();
  this->SimplifyLeadingCoefficientOnly();
  if (this->context!=0)
  { std::stringstream out;
    out << "Multiplying " << this->ElementToString() << " by " << other.ElementToString();
    out << " and the result is:\n" << this->ElementToString();
    this->context->theIndicatorVariables.StatusString1NeedsRefresh=true;
    this->context->theIndicatorVariables.StatusString1=out.str();
    this->context->MakeReport();
  }
}

void RationalFunction::Simplify()
{ if (this->expressionType==this->typeRationalFunction)
    if(!this->Numerator.GetElement().IsEqualToZero())
    { PolynomialRationalCoeff theGCD, tempP, tempP2;
      this->gcd(this->Numerator.GetElement(), this->Denominator.GetElement(), theGCD, this->context);
      this->Numerator.GetElement().DivideBy(theGCD, tempP, tempP2);
      this->Numerator.GetElement().Assign(tempP);
      this->Denominator.GetElement().DivideBy(theGCD, tempP, tempP2);
      this->Denominator.GetElement().Assign(tempP);
    }
  this->ReduceMemory();
  this->SimplifyLeadingCoefficientOnly();
}

void RationalFunction::SimplifyLeadingCoefficientOnly()
{ if (this->expressionType!=this->typeRationalFunction)
    return;
  Rational tempRat= this->Denominator.GetElement().TheObjects[this->Denominator.GetElement().GetIndexMaxMonomialTotalDegThenLexicographic()].Coefficient;
  tempRat.Invert();
  this->Denominator.GetElement().TimesConstant(tempRat);
  this->Numerator.GetElement().TimesConstant(tempRat);
}

Rational PolynomialRationalCoeff::FindGCDCoefficientNumerators()
{ if (this->size==0)
    return (Rational) 1;
  Rational result; LargeIntUnsigned Accum, tempUI;
  this->TheObjects[0].Coefficient.GetNumUnsigned(Accum);
  for (int i=1; i<this->size; i++)
  { this->TheObjects[i].Coefficient.GetNumUnsigned(tempUI);
    LargeIntUnsigned::gcd(Accum, tempUI, Accum);
  }
  LargeInt tempInt;
  tempInt.AssignLargeIntUnsigned(Accum);
  result.AssignLargeInteger(tempInt);
  if (this->size>0)
  { if (this->TheObjects[0].Coefficient.IsNegative())
      result.Minus();
  }
  return result;
}

Rational PolynomialRationalCoeff::FindGCDCoefficientDenominators()
{ if (this->size==0)
    return (Rational) 1;
  Rational result; LargeIntUnsigned Accum, tempUI;
  this->TheObjects[0].Coefficient.GetDen(Accum);
  for (int i=1; i<this->size; i++)
  { this->TheObjects[i].Coefficient.GetDen(tempUI);
    LargeIntUnsigned::gcd(Accum, tempUI, Accum);
  }
  LargeInt tempInt;
  tempInt.AssignLargeIntUnsigned(Accum);
  result.AssignLargeInteger(tempInt);
  return result;
}

void PolynomialRationalCoeff::ScaleToIntegralNoGCDCoeffs()
{ if(this->size==0)
    return;
  int indexHighestMon=0;
  LargeIntUnsigned tempInt1, tempInt2, accumNum, accumDen;
  accumDen.MakeOne();
  this->TheObjects[0].Coefficient.GetNumUnsigned(accumNum);
  for (int i=0; i<this->size; i++)
  { if (this->TheObjects[i].IsGEQLexicographicLastVariableStrongest(this->TheObjects[indexHighestMon]))
      indexHighestMon=i;
    Rational& tempRat=this->TheObjects[i].Coefficient;
    tempRat.GetDen(tempInt1);
    tempRat.GetNumUnsigned(tempInt2);
    LargeIntUnsigned::lcm(tempInt1, accumDen, accumDen);
    LargeIntUnsigned::gcd(tempInt2, accumNum, accumNum);
  }
  Rational theMultiple;
  theMultiple.MakeOne();
  if (this->TheObjects[indexHighestMon].Coefficient.IsNegative())
    theMultiple.MakeMOne();
  theMultiple.MultiplyByLargeIntUnsigned(accumDen);
  Rational tempRat2;
  LargeInt tempInt3;
  tempInt3.AssignLargeIntUnsigned(accumNum);
  tempRat2.AssignLargeInteger(tempInt3);
  theMultiple.DivideBy(tempRat2);
  this->TimesConstant(theMultiple);
}

template <class ElementLeft, class ElementRight, class CoefficientType>
class TensorProductElement;
template <class ElementLeft, class ElementRight, class CoefficientType>
class TensorProductSpaceAndElements;

template <class ElementLeft, class ElementRight, class CoefficientType>
class TensorProductSpace
{
public:
  List<ElementLeft> leftSpaceBasis;
  List<ElementRight> rightSpaceBasis;
  roots leftWeights;
  roots rightWeights;
  CoefficientType theRingZerO;
  CoefficientType theRingUniT;
  std::string ElementToString();
  bool GetInternalRepresentationFromVectorLeft
  (const ElementLeft& input, Polynomial<CoefficientType>& output, GlobalVariables& theGlobalVariables)const
  ;
  void GetInternalRepresentationFromVectorRight
  (const ElementRight& input, Polynomial<CoefficientType>& output, GlobalVariables& theGlobalVariables)const
  ;
  void GetInternalRepresentationFromLeftAndRight
  (const ElementLeft& leftInput, const ElementRight& rightInput, Polynomial<CoefficientType>& output, GlobalVariables& theGlobalVariables)const
  { Polynomial<CoefficientType> tempP;
    this->GetInternalRepresentationFromVectorLeft(leftInput, tempP, theGlobalVariables);
    this->GetInternalRepresentationFromVectorRight(rightInput, output, theGlobalVariables);
    output.MultiplyBy(tempP);
  }
  void GetEltFromIndex(int theIndex, TensorProductElement<ElementLeft, ElementRight, CoefficientType>& output, GlobalVariables& theGlobalVariables)
  { int leftIndex=theIndex/this->rightSpaceBasis.size;
    int rightIndex=theIndex% this->rightSpaceBasis.size;
    output.SetTensorProduct(this->leftSpaceBasis.TheObjects[leftIndex], this->rightSpaceBasis.TheObjects[rightIndex], *this, theGlobalVariables);
  }
  void GetLeftAndRightIndexFromMonomial(const Monomial<CoefficientType>& input, int& leftIndex, int& rightIndex)
  { for (int i=0; i<this->leftSpaceBasis.size; i++)
      if (input.degrees[i]==1)
      { leftIndex=i;
        break;
      }
    for (int i=0; i<this->rightSpaceBasis.size; i++)
      if (input.degrees[i+this->leftSpaceBasis.size]==1)
      { rightIndex=i;
        return;
      }
  }
  int GetIndexFromMonomial(const Monomial<CoefficientType>& input)
  { int leftIndex=-1; int rightIndex=-1;
    this->GetLeftAndRightIndexFromMonomial(input, leftIndex, rightIndex);
    assert(rightIndex!=-1 && leftIndex!=-1);
    return leftIndex*this->rightSpaceBasis.size+rightIndex;
  }
  void GetComponentsFromInternalRepresentation
  (const Monomial<CoefficientType>& input, ElementLeft& leftOutput, ElementRight& rightOutput)
  ;
};

template <class ElementLeft, class ElementRight, class CoefficientType>
class TensorProductElement
{
  //Format.
  //Let the owner TensorProductSpace be of the form V_1 \otimes V_2.
  //Then the internalRepresentation is a second degree homogeneous polynomial of dim V_1 +dim V_2 variables.
  //A monomial from the internalRepresentation must be of the form (coefficient)*x_i*x_j, where i<dim V_1 and j>=dim V_1.
  //Then the monomial (coefficient)*x_i*x_j, corresponds to the tensor product (coefficient)v_i\otimes v_k, where k=j-dim V_1,
  // v_i corresponds to the i^th member of TensorProductSpace::leftSpaceBasis and v_k correponds to the k^th member of TensorProductSpace::rightSpaceBasis
  friend class TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>;
  Polynomial<CoefficientType> internalRepresentation;
public:
  std::string DebugString;
  void ComputeDebugString(){this->DebugString=this->ElementToString();}
  std::string ElementToString();
  std::string ElementToString
  (TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& owner)
  ;
  void SetTensorProduct
  (const  ElementLeft& leftVector, const  ElementRight& rightVector, const TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& owner, GlobalVariables& theGlobalVariables)
  ;
  void SetTensorProductBasisElement
  (int leftIndex, int rightIndex, const TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& owner, GlobalVariables& theGlobalVariables)
  ;
  void ActOnMe
  (const ElementSimpleLieAlgebra& theElt, TensorProductElement<ElementLeft, ElementRight, CoefficientType>& output,
   TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& theStartingSpace,
   TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& theTargetSpace,
   SemisimpleLieAlgebra& theAlgebra, GlobalVariables& theGlobalVariables)
  ;
  void ActOnMe
  (Polynomials<CoefficientType>& theSub, TensorProductElement<ElementLeft, ElementRight, CoefficientType>& output, const CoefficientType& theRingUnit)
  { this->internalRepresentation.Substitution(theSub, output.internalRepresentation, this->internalRepresentation.NumVars, theRingUnit);
  }
  void ActOnMe
  (Polynomials<CoefficientType>& theSub, const CoefficientType& theRingUnit)
  { this->internalRepresentation.Substitution(theSub, this->internalRepresentation.NumVars, theRingUnit);
  }
  void ElementToVector
  (Vector<CoefficientType>& output, TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& owner, GlobalVariables& theGlobalVariables)const
  ;
  void AssignVector
  (Vector<CoefficientType>& input, TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& owner, GlobalVariables& theGlobalVariables)
  ;
  void Nullify(TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& owner){ this->internalRepresentation.Nullify(owner.leftSpaceBasis.size+owner.rightSpaceBasis.size);}
  void operator+=(const TensorProductElement& other){ this->internalRepresentation+=other.internalRepresentation; }
  void operator/=(const CoefficientType& theCoeff){ this->internalRepresentation/=theCoeff; }
  void operator-=(const TensorProductElement& other){ this->internalRepresentation.Subtract(other.internalRepresentation); }
  bool IsEqualToZero()const{return this->internalRepresentation.IsEqualToZero();}
};

template <class ElementLeft, class ElementRight, class CoefficientType>
class TensorProductSpaceAndElements: public List<TensorProductElement<ElementLeft, ElementRight, CoefficientType> >
{
  public:
  TensorProductSpace<ElementLeft, ElementRight, CoefficientType> theTargetSpace, theStartingSpace;
  List<Polynomials<CoefficientType> > simplePositiveGeneratorsActions;
  List<Polynomials<CoefficientType> > simpleNegativeGeneratorsActions;
  std::string DebugString;
  std::string ElementToString();
  TensorProductElement<ElementLeft, ElementRight, CoefficientType> theSeedVector;
  root theRightLowestWeight;
  static bool flagAnErrorHasOccurredTimeToPanic;
  void ComputeDebugString(){this->DebugString=this->ElementToString();}
  void initTheSpacesForAdjointAction
    (List<ElementSimpleLieAlgebra>& theElementsActing,
     SemisimpleLieAlgebra& theAlgebra,
     List<ElementLeft>& theLeftElts,
     List<ElementRight>& theRightElts,
     const ElementLeft& leftZero,
     const ElementRight& rightZero,
     const CoefficientType& theRingZero,
     const CoefficientType& theRingUnit,
     GlobalVariables& theGlobalVariables)
     ;
  std::string ExtractHighestWeightsCorrespondingToMaxVermaSummands
    (root& input, roots& outputVectors, List<MatrixLargeRational>& simplePosGenerators, List<MatrixLargeRational>& simpleNegGenerators,
     GlobalVariables& theGlobalVariables)
;
  std::string ExtractHighestWeightVectorsFromVector
( TensorProductElement<ElementLeft, ElementRight, CoefficientType>& input, List<TensorProductElement<ElementLeft, ElementRight, CoefficientType> >& outputVectors,
  GlobalVariables& theGlobalVariables, const CoefficientType& theRingUnit)
  ;
  void ClimbDownFromHighestWeightAlongSl2String
  (TensorProductElement<ElementLeft, ElementRight, CoefficientType>& input,
   TensorProductElement<ElementLeft, ElementRight, CoefficientType>& output,
    CoefficientType& outputCoeff,
    Polynomials<CoefficientType>& posGenerator,
    Polynomials<CoefficientType>& negGenerator, int generatorPower, const CoefficientType& theRingUnit)
  ;
  void ClimbDownFromVectorAccordingToSequence
  (TensorProductElement<ElementLeft, ElementRight, CoefficientType>& input,
   TensorProductElement<ElementLeft, ElementRight, CoefficientType>& outputLastNonZero, CoefficientType& outputCoeff,
   List<int>& inputGeneratorSequence, List<int>& inputGeneratorPowers, GlobalVariables& theGlobalVariables, const CoefficientType& theRingUnit)
  ;
  void ClimbUpFromVector
  (TensorProductElement<ElementLeft, ElementRight, CoefficientType>& input,
   TensorProductElement<ElementLeft, ElementRight, CoefficientType>& output,
   List<int>& outputGeneratorSequence, List<int>& outputGeneratorPowers, GlobalVariables& theGlobalVariables)
  ;

  void initTheSpacesSl2StringVersion
  ( List<ElementSimpleLieAlgebra>& theSimplePosElts,  List<ElementSimpleLieAlgebra>& theSimpleNegElts, SemisimpleLieAlgebra& theAlgebra,
    const ElementLeft& leftZero, const ElementRight& rightZero, const CoefficientType& theRingUnit, const CoefficientType& theRingZero,
    GlobalVariables& theGlobalVariables)
     ;
  void GetRootForm(roots& output, GlobalVariables& theGlobalVariables);
  bool FindEigenVectorsWithRespectTo
  (List<ElementSimpleLieAlgebra>& theElementsActing,  List<ElementLeft>& theLeftElts, List<ElementRight>& theRightElts,
   SemisimpleLieAlgebra& theAlgebra, TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>& output,
   const ElementLeft& leftZero, const ElementRight& rightZero,
   const CoefficientType& theRingUnit, const CoefficientType& theRingZero,
   GlobalVariables& theGlobalVariables)
  ;
  bool FindEigenVectorsWithRespectToSl2StringVersion
  (List<ElementSimpleLieAlgebra>& theSimplePosElts,  List<ElementSimpleLieAlgebra>& theSimpleNegElts,
   SemisimpleLieAlgebra& theAlgebra, TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>& output,
   const ElementLeft& leftZero, const ElementRight& rightZero,
   const CoefficientType& theRingUnit, const CoefficientType& theRingZero,
   GlobalVariables& theGlobalVariables)
  ;
  void PrepareTheMatrix
  (List<ElementSimpleLieAlgebra>& theElementsActing, SemisimpleLieAlgebra& theAlgebra, Matrix<CoefficientType>& output, GlobalVariables& theGlobalVariables)
  ;
};

template < > int List<TensorProductElement<ElementVermaModuleOrdered<RationalFunction>, ElementSimpleLieAlgebra, RationalFunction> >::ListActualSizeIncrement=10;

template <class ElementLeft, class ElementRight, class CoefficientType>
bool TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>::flagAnErrorHasOccurredTimeToPanic=false;

class TranslationFunctorGmodKVermaModule
{
public:
  List<TensorProductSpaceAndElements<ElementVermaModuleOrdered<RationalFunction>, ElementSimpleLieAlgebra, RationalFunction> > theElements;
  List<TensorProductSpaceAndElements<ElementVermaModuleOrdered<RationalFunction>, ElementSimpleLieAlgebra, RationalFunction> > theEigenVectors;
  TensorProductSpaceAndElements<ElementVermaModuleOrdered<RationalFunction>, ElementSimpleLieAlgebra, RationalFunction> theSpace;
  List<TensorProductElement<ElementVermaModuleOrdered<RationalFunction>, ElementSimpleLieAlgebra, RationalFunction> >  theOutput;
  roots theModuleWeightsShifted;
  roots theModuleWeightsNonShifted;
  List<ElementSimpleLieAlgebra> ElementsOfKofNegativeWeights;
  List<ElementVermaModuleOrdered<RationalFunction> > leftComponents;
  List<ElementSimpleLieAlgebra> rightComponents;
  List<List<ElementVermaModuleOrdered<RationalFunction> > > theLeftComponentsByWeight;
  List<List<ElementSimpleLieAlgebra> > theRightComponentsByWeight;
  VectorPartition theVectorPartition;
  PolynomialsRationalCoeff HighestWeightSub;
  std::string RunTheComputationSl2StringVersion
  (Parser& theParser, GlobalVariables& theGlobalVariables, EigenVectorComputation& owner)
  ;

  std::string RunTheComputation
  (Parser& theParser, GlobalVariables& theGlobalVariables, EigenVectorComputation& owner)
  ;
  std::string initTheWeights
    (Parser& theParser, GlobalVariables& theGlobalVariables)
  ;

  std::string initTheCandidateMonomials
    (Parser& theParser, GlobalVariables& theGlobalVariables)
  ;
  std::string initTheCandidateMonomialsSl2StringVersion
    (Parser& theParser, GlobalVariables& theGlobalVariables)
  ;
  std::string GetLeftAndRightFromVP
  (int indexTotalWeight, int indexRightWeight, VectorPartition& theVP, Parser& theParser, GlobalVariables& theGlobalVariables)
 ;
  std::string GetLeftFromVP
  ( VectorPartition& theVP, Parser& theParser, GlobalVariables& theGlobalVariables)
 ;
};


template<class CoefficientType>
class GeneralizedVermaModuleData
{
  public:
  List<ElementSimpleLieAlgebra> theFDspace;
  SemisimpleLieAlgebraOrdered theOwner;
  PolynomialsRationalCoeff VermaHighestWeighSub;
  //The order of the below is chosen so that the opposite generator of posGenerators.TheObjects[i] is negGenerators.TheObjects[i]
  List<ElementSimpleLieAlgebra> posGenerators, negGenerators;
  CoefficientType theRingUnit;
  CoefficientType theRingZero;
  void init(Parser& input, GlobalVariables* theContext)
  { RationalFunction RFOne, RFZero;
    RFOne.MakeNVarConst(input.theHmm.theRange.GetRank(), (Rational) 1, theContext);
    RFZero.Nullify(input.theHmm.theRange.GetRank(), theContext);
    this->theRingUnit=RFOne;
    this->theRingZero=RFZero;
    this->posGenerators.size=0; this->negGenerators.size=0;
    int domainRank=input.theHmm.theDomain.GetRank();
    int numDomainPosRoots=input.theHmm.theDomain.GetNumPosRoots();
    for (int i=0; i<domainRank; i++)
    { this->posGenerators.AddObjectOnTop(input.theHmm.imagesAllChevalleyGenerators.TheObjects
        [domainRank+numDomainPosRoots+i]);
      this->negGenerators.AddObjectOnTop(input.theHmm.imagesAllChevalleyGenerators.TheObjects
        [numDomainPosRoots-i-1]);
    }
    this->theOwner=input.testAlgebra;
    this->theFDspace=input.theHmm.GmodK;
  }
};

template<class CoefficientType>
class ElementGeneralizedVerma
{
  public:
  std::string DebugString;
  std::string ElementToString(){ return this->ElementToString(true, false, true);}
  std::string ElementToString
  (bool displayLeftComponenetsOnTheRight, bool useOtimes, bool useFs)
;
  void ComputeDebugString(){this->DebugString=this->ElementToString();}
  GeneralizedVermaModuleData<CoefficientType>* theOwner;
  List<ElementVermaModuleOrdered<CoefficientType> > leftComponents;
  ElementGeneralizedVerma(){this->theOwner=0;}
  std::string ExtractHighestWeightVectors
  (Parser& theParser, List<ElementGeneralizedVerma<CoefficientType> >& outputVectors,
    GlobalVariables& theGlobalVariables)
;
  void Nullify
  (GeneralizedVermaModuleData<CoefficientType>& owner)
    ;
  void AssignDefaultGeneratorIndex
  (int theIndex, GeneralizedVermaModuleData<CoefficientType>& owner, GlobalVariables* theContext)
  { this->Nullify(owner);
    ElementVermaModuleOrdered<CoefficientType>& currentElt=this->leftComponents.TheObjects[theIndex];
    ElementVermaModuleOrdered<CoefficientType> zeroVermaElt;
    zeroVermaElt.Nullify(this->theOwner->theOwner, this->theOwner->VermaHighestWeighSub);
    ElementUniversalEnvelopingOrdered<CoefficientType> tempElt;
    tempElt.MakeConst(this->theOwner->theRingUnit, this->theOwner->theOwner);
    currentElt.AssignElementUniversalEnvelopingOrderedTimesHighestWeightVector(tempElt, zeroVermaElt, theContext, this->theOwner->theRingUnit);
    currentElt.theSub=this->theOwner->VermaHighestWeighSub;
  }
  std::string GetStringFormGmodKindex(int theIndex);
  void ActOnMe
  (const ElementSimpleLieAlgebra& theElt, ElementGeneralizedVerma<CoefficientType>& output, GlobalVariables* theContext)
;
  bool ActOnMe
  (const ElementUniversalEnvelopingOrdered<CoefficientType>& theElt, ElementGeneralizedVerma<CoefficientType>& output, GlobalVariables* theContext)
;
  void ActOnMe(const ElementSimpleLieAlgebra& theElt, GlobalVariables* theContext) {ElementGeneralizedVerma<CoefficientType> output; this->ActOnMe(theElt, output, theContext); this->operator=(output);};

  void ClimbDownFromHighestWeightAlongSl2String
(ElementGeneralizedVerma<CoefficientType>& input,
   ElementGeneralizedVerma<CoefficientType>& output,
    CoefficientType& outputCoeff,
   const ElementSimpleLieAlgebra& posGenerator, const ElementSimpleLieAlgebra& negGenerator,
     int generatorPower, GlobalVariables& theGlobalVariables)
  ;
  void ClimbDownFromVectorAccordingToSequence
  (ElementGeneralizedVerma<CoefficientType>& input,
   ElementGeneralizedVerma<CoefficientType>& outputLastNonZero, CoefficientType& outputCoeff,
   List<int>& inputGeneratorSequence, List<int>& inputGeneratorPowers, GlobalVariables& theGlobalVariables)
  ;
  void ClimbUpFromVector
  (ElementGeneralizedVerma<CoefficientType>& input,
   ElementGeneralizedVerma<CoefficientType>& outputLastNonZero,
   List<int>& outputGeneratorSequence, List<int>& outputGeneratorPowers, GlobalVariables& theGlobalVariables)
  ;
  void operator=(const ElementGeneralizedVerma<CoefficientType>& other)
  { this->leftComponents=other.leftComponents;
    this->theOwner=other.theOwner;
  }
  bool IsEqualToZero()const
  { for (int i=0; i<this->leftComponents.size; i++)
      if (!this->leftComponents.TheObjects[i].IsEqualToZero())
        return false;
    return true;
  }
  void operator/=(const CoefficientType& theConst)
  { for (int i=0; i<this->leftComponents.size; i++)
      this->leftComponents.TheObjects[i]/=theConst;
  }
  void operator*=(const CoefficientType& theConst)
  { for (int i=0; i<this->leftComponents.size; i++)
      this->leftComponents.TheObjects[i]*=theConst;
  }
  void operator-=(const ElementGeneralizedVerma<CoefficientType>& other)
  { for (int i=0; i<this->leftComponents.size; i++)
      this->leftComponents.TheObjects[i]-=other.leftComponents.TheObjects[i];
  }
  void operator+=(const ElementGeneralizedVerma<CoefficientType>& other)
  { for (int i=0; i<this->leftComponents.size; i++)
      this->leftComponents.TheObjects[i]+=other.leftComponents.TheObjects[i];
  }
  bool IsProportionalTo(const ElementGeneralizedVerma<CoefficientType>& other, CoefficientType& outputTimesMeEqualsInput)const
  { assert(this->leftComponents.size==other.leftComponents.size);
    if (this->IsEqualToZero())
    { if (other.IsEqualToZero())
      { outputTimesMeEqualsInput=this->theOwner->theRingZero;
        return true;
      }
      return false;
    }
    for (int i=0; i<this->leftComponents.size; i++)
      if (!this->leftComponents.TheObjects[i].IsEqualToZero())
      { if (!this->leftComponents.TheObjects[i].IsProportionalTo(other.leftComponents.TheObjects[i], outputTimesMeEqualsInput, this->theOwner->theRingZero))
          return false;
        else
          break;
      }
    ElementGeneralizedVerma<CoefficientType> tempElt;
    tempElt=*this;
    tempElt*=outputTimesMeEqualsInput;
    tempElt-=other;
    return tempElt.IsEqualToZero();
  }
  void ClearDenominators
  (CoefficientType& outputWasMultipliedByThis)
  ;
};

template < > int List<ElementGeneralizedVerma<RationalFunction> >::ListActualSizeIncrement=10;

std::string EigenVectorComputation::ComputeAndReturnStringOrdered
(GlobalVariables& theGlobalVariables, Parser& theParser, int NodeIndex)
{ std::stringstream out;
//  TranslationFunctorGmodKVermaModule theTranslationFunctor;
//  out << theTranslationFunctor.RunTheComputationSl2StringVersion(theParser, theGlobalVariables, *this);
  roots theAlgebraWeights;
  theParser.theHmm.GetWeightsGmodK(this->theModuleWeightsShifted, theGlobalVariables);
  theParser.theHmm.GetWeightsK(theAlgebraWeights, theGlobalVariables);
  GeneralizedVermaModuleData<RationalFunction> theData;
  ElementGeneralizedVerma<RationalFunction> startingElement;
  this->PrepareCartanSub(theParser.testAlgebra, theData.VermaHighestWeighSub, theGlobalVariables);
  theData.init(theParser, &theGlobalVariables);
//  startingElement.AssignDefaultGeneratorIndex(0, theData, &theGlobalVariables);
  startingElement.AssignDefaultGeneratorIndex(0, theData, &theGlobalVariables);
  List<ElementGeneralizedVerma<RationalFunction> > theEigenVectors;
  out << "<br>the starting element is: " << startingElement.ElementToString();
  out << startingElement.ExtractHighestWeightVectors(theParser, theEigenVectors, theGlobalVariables);
  return out.str();
  ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff> theElt, tempElt1, tempElt2;
  PolynomialOutputFormat PolyFormatLocal;
  //this->MakeGenericMonomialBranchingCandidate(theParser.theHmm, theElt, theGlobalVariables);
  this->MakeGenericVermaElementOrdered(theElt, theParser.testAlgebra);
  int theDomainRank=theParser.theHmm.theDomain.theWeyl.CartanSymmetric.NumRows;
  int theRangeRank=theParser.theHmm.theRange.theWeyl.CartanSymmetric.NumRows;
//  int numDomainPosRoots= theParser.theHmm.theDomain.theWeyl.RootsOfBorel.size;
  int numRangePosRoots= theParser.theHmm.theRange.theWeyl.RootsOfBorel.size;
  //int dimQuotient=numRangePosRoots-theParser.theHmm.theDomain.theWeyl.RootsOfBorel.size;
  this->theSystem.init(0,0);
  this->theOperators.size=0;
  this->theExponentShifts.size=0;
  theParser.TheObjects[NodeIndex].ExpressionType=ParserNode::typeArray;
  PolynomialRationalCoeff polyOne, polyZero;
  polyOne.MakeNVarConst(theRangeRank+numRangePosRoots, (Rational) 1);
  polyZero.Nullify(theRangeRank+numRangePosRoots);
  for (int i=0; i<theDomainRank; i++)
  { tempElt1.AssignElementLieAlgebra(theParser.theHmm.imagesSimpleChevalleyGenerators.TheObjects[i], polyOne, polyZero, theParser.testAlgebra);
    tempElt1.LieBracketOnTheRight(theElt, tempElt2);
    tempElt2.Simplify(&theGlobalVariables);
    std::cout << "<br>" << tempElt1.ElementToString();
    out << "<div class=\"math\" scale=\"50\">\\begin{eqnarray*}&&";
    out << "[" << tempElt1.ElementToString(true, PolyFormatLocal) << "," << theElt.ElementToString(true, PolyFormatLocal) << "]=" << tempElt2.ElementToString(true, PolyFormatLocal);
    out << "\\end{eqnarray*}</div>";
    std::cout << "<br>" << tempElt2.ElementToString();
    tempElt2.ModOutVermaRelationS(&theGlobalVariables, polyOne);
    out << "mod Verma rels:";
    out << "<div class=\"math\" scale=\"50\">\\begin{eqnarray*}&&";
    out << tempElt2.ElementToString(true, PolyFormatLocal);
    out << "\\end{eqnarray*}</div>";
    this->DetermineEquationsFromResultLieBracketEquationsPerTargetOrdered(theParser, NodeIndex, theElt, tempElt2, out, theGlobalVariables);
    theParser.ExtendOnTop(1);
    ParserNode& currentOutputNode=*theParser.LastObject();
    currentOutputNode.ExpressionType=ParserNode::typeWeylAlgebraElement;
    currentOutputNode.WeylAlgebraElement.GetElement().Assign(this->theOperators.TheObjects[i]);
    theParser.TheObjects[NodeIndex].array.GetElement().AddObjectOnTop(theParser.size-1);
  }
  this->theExponentShiftsTargetPerSimpleGenerator.CollectionToRoots(this->theExponentShifts);
  out << "<br><br> And the total rank is: " << this->theExponentShifts.GetRankOfSpanOfElements(theGlobalVariables);
  out << "<div class=\"math\" scale=\"50\">" << this->theSystem.ElementToString(false, true) << "</div>";
  theParser.NumVariables=theRangeRank+numRangePosRoots;
//  out << this->CrunchTheOperators(theGlobalVariables, theParser);
  for (int i=0; i<theParser.testAlgebra.theOrder.size; i++)
  { out << "<br>f_{" << i-theParser.testAlgebra.theOwner.GetNumPosRoots()-theParser.testAlgebra.theOwner.GetRank();
    out << "} = " << theParser.testAlgebra.theOrder.TheObjects[i].ElementToStringNegativeRootSpacesFirst(true, false, theParser.theHmm.theRange);
  }
  return out.str();
}

std::string EigenVectorComputation::ComputeAndReturnStringNonOrdered
(GlobalVariables& theGlobalVariables, Parser& theParser)
{ std::stringstream out;
  ElementUniversalEnveloping theElt, tempElt1, tempElt2;
  //this->MakeGenericMonomialBranchingCandidate(theParser.theHmm, theElt, theGlobalVariables);
  this->MakeGenericVermaElement(theElt, theParser.theHmm.theRange);
  int theDomainRank=theParser.theHmm.theDomain.theWeyl.CartanSymmetric.NumRows;
  int theRangeRank=theParser.theHmm.theRange.theWeyl.CartanSymmetric.NumRows;
//  int numDomainPosRoots= theParser.theHmm.theDomain.theWeyl.RootsOfBorel.size;
  int numRangePosRoots= theParser.theHmm.theRange.theWeyl.RootsOfBorel.size;
  //int dimQuotient=numRangePosRoots-theParser.theHmm.theDomain.theWeyl.RootsOfBorel.size;
  this->theSystem.init(0,0);
  this->theOperators.size=0;
  this->theExponentShifts.size=0;
  for (int i=0; i<theDomainRank; i++)
  { tempElt1.AssignElementLieAlgebra(theParser.theHmm.imagesSimpleChevalleyGenerators.TheObjects[i], theRangeRank+numRangePosRoots, theParser.theHmm.theRange);
    tempElt1.LieBracketOnTheRight(theElt, tempElt2);
    tempElt2.Simplify();
    out << "<div class=\"math\" scale=\"50\">\\begin{eqnarray*}&&";
    out << "[" << tempElt1.ElementToString(true) << "," << theElt.ElementToString(true) << "]=" << tempElt2.ElementToString(true);
    out << "\\end{eqnarray*}</div>";
    tempElt2.ModOutVermaRelations();
    out << "mod Verma rels:";
    out << "<div class=\"math\" scale=\"50\">\\begin{eqnarray*}&&";
    out << tempElt2.ElementToString(true);
    out << "\\end{eqnarray*}</div>";
    this->DetermineEquationsFromResultLieBracketEquationsPerTarget(theParser, theElt, tempElt2, out, theGlobalVariables);
  }
  out << "<div class=\"math\" scale=\"50\">" << this->theSystem.ElementToString(false, true) << "</div>";
  theParser.NumVariables=numRangePosRoots+theRangeRank;
  return out.str();
}

void RootIndexToPoly(int theIndex, SemisimpleLieAlgebra& theAlgebra, PolynomialRationalCoeff& output)
{ int theRank=theAlgebra.theWeyl.CartanSymmetric.NumRows;
  int numPosRoots=theAlgebra.theWeyl.RootsOfBorel.size;
  output.MakeNVarDegOnePoly((int)(theRank+numPosRoots), theIndex+theRank, (Rational) 1);
}

void EigenVectorComputation::DetermineEquationsFromResultLieBracketEquationsPerTarget(Parser& theParser, ElementUniversalEnveloping& theStartingGeneric, ElementUniversalEnveloping& theElt, std::stringstream& out, GlobalVariables& theGlobalVariables)
{ int theRangeRank=theParser.theHmm.theRange.theWeyl.CartanSymmetric.NumRows;
  int numRangePosRoots= theParser.theHmm.theRange.theWeyl.RootsOfBorel.size;
//  int dimQuotient=theParser.theHmm.theRange.theWeyl.RootsOfBorel.size- theParser.theHmm.theDomain.theWeyl.RootsOfBorel.size;
  int numCoeffVars=theRangeRank+numRangePosRoots;
  PolynomialRationalCoeff theDiffPoly;
  PolynomialOutputFormat PolyFormatLocal;
  MonomialUniversalEnveloping& originalMon= theStartingGeneric.TheObjects[0];
  this->theExponentShiftsTargetPerSimpleGenerator.SetSize(this->theExponentShiftsTargetPerSimpleGenerator.size+1);
  roots& currentTargetShifts =*this->theExponentShiftsTargetPerSimpleGenerator.LastObject();
  currentTargetShifts.SetSize(theElt.size);
  ElementWeylAlgebra tempWeyl;
  this->theOperators.SetSize(this->theOperators.size+1);
  ElementWeylAlgebra& currentOperator = *this->theOperators.LastObject();
  currentOperator.Nullify(numCoeffVars);
  for (int i=0; i<theElt.size; i++)
  { MonomialUniversalEnveloping& theMon= theElt.TheObjects[i];
    out << "<br>\nDifference in monomial index " << i << ": ";
    root& currentShift= currentTargetShifts.TheObjects[i];
    currentShift.MakeZero(numRangePosRoots);
    for (int j=0; j<numRangePosRoots; j++)
    { theDiffPoly = originalMon.Powers.TheObjects[j] - theMon.Powers.TheObjects[j];
      out << theDiffPoly.ElementToString(PolyFormatLocal) << " ";
      if (theDiffPoly.size>1)
        currentShift.TheObjects[j]=-10000;
      if (theDiffPoly.size==0)
        currentShift.TheObjects[j]=0;
      if (theDiffPoly.size==1)
        currentShift.TheObjects[j]=-theDiffPoly.TheObjects[0].Coefficient;
    }
    this->GetDiffOperatorFromShiftAndCoefficient(theMon.Coefficient, currentShift, tempWeyl, theGlobalVariables);
    currentOperator.Add(tempWeyl);
  }
  out << "<br>... and the operator is... <div class=\"math\" scale=\"50\"> \\begin{eqnarray*}&&" << currentOperator.ElementToString(true) << "\\end{eqnarray*}</div>";
  root tempRoot;
  RationalFunction ZeroRF;//, RFOne;
  ZeroRF.MakeNVarConst(numCoeffVars, (Rational) 0, &theGlobalVariables);
 // RFOne.MakeNVarConst(numCoeffVars, (Rational) 1, &theGlobalVariables);
  tempRoot.MakeZero(numRangePosRoots);
  if(this->theExponentShifts.AddOnTopNoRepetition(tempRoot))
    this->theSystem.Resize(this->theSystem.NumRows, this->theSystem.NumCols+1, true, &ZeroRF);
  int indexMainMon=this->theExponentShifts.IndexOfObject(tempRoot);
  PolynomialsRationalCoeff theSub;
  PolynomialRationalCoeff tempP;
  for (int i=0; i<theElt.size; i++)
  { int indexCurrentRow=this->theSystem.NumRows;
    this->theSystem.Resize(this->theSystem.NumRows+1, this->theSystem.NumCols, true, &ZeroRF);
    this->theSystem.elements[indexCurrentRow][indexMainMon]=theElt.TheObjects[i].Coefficient;
    for (int j=0; j<theElt.size; j++)
      if (i!=j)
      { theSub.MakeIdSubstitution(numCoeffVars, (Rational) 1);
        tempRoot= currentTargetShifts.TheObjects[i]-currentTargetShifts.TheObjects[j];
        for (int k=0; k<tempRoot.size; k++)
          theSub.TheObjects[k+theRangeRank].AddConstant(tempRoot.TheObjects[k]);
        int theVarIndex = this->theExponentShifts.IndexOfObject(tempRoot);
        if (theVarIndex<0)
        { theVarIndex=this->theExponentShifts.size;
          this->theExponentShifts.AddObjectOnTop(tempRoot);
          this->theSystem.Resize(this->theSystem.NumRows, this->theExponentShifts.size, true, &ZeroRF);
          out << "<br>Shift of monomial in play: " << tempRoot.ElementToString();
        }
        tempP=theElt.TheObjects[j].Coefficient;
        theSub.ComputeDebugString();
        tempP.ComputeDebugString();
        tempP.Substitution(theSub, numCoeffVars, (Rational) 1);
        tempP.ComputeDebugString();
        this->theSystem.elements[indexCurrentRow][theVarIndex]=tempP;
      }
  }
}

void EigenVectorComputation::DetermineEquationsFromResultLieBracketEquationsPerTargetOrdered
  (Parser& theParser, int nodeIndex, ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff>& theStartingGeneric, ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff>& theElt, std::stringstream& out, GlobalVariables& theGlobalVariables)
{ int theRangeRank=theParser.theHmm.theRange.theWeyl.CartanSymmetric.NumRows;
  int numRangePosRoots= theParser.theHmm.theRange.theWeyl.RootsOfBorel.size;
//  int dimQuotient=theParser.theHmm.theRange.theWeyl.RootsOfBorel.size- theParser.theHmm.theDomain.theWeyl.RootsOfBorel.size;
  int numCoeffVars=theRangeRank+numRangePosRoots;
  PolynomialRationalCoeff theDiffPoly;
  MonomialUniversalEnvelopingOrdered<PolynomialRationalCoeff>& originalMon= theStartingGeneric.TheObjects[0];
  this->theExponentShiftsTargetPerSimpleGenerator.SetSize(this->theExponentShiftsTargetPerSimpleGenerator.size+1);
  roots& currentTargetShifts =*this->theExponentShiftsTargetPerSimpleGenerator.LastObject();
  currentTargetShifts.SetSize(theElt.size);
  ElementWeylAlgebra tempWeyl;
  this->theOperators.SetSize(this->theOperators.size+1);
  ElementWeylAlgebra& currentOperator = *this->theOperators.LastObject();
  currentOperator.Nullify(numCoeffVars);
  PolynomialOutputFormat PolyFormatLocal;
  for (int i=0; i<theElt.size; i++)
  { MonomialUniversalEnvelopingOrdered<PolynomialRationalCoeff>& theMon= theElt.TheObjects[i];
    out << "<br>\nDifference in monomial index " << i << ": ";
    root& currentShift= currentTargetShifts.TheObjects[i];
    currentShift.MakeZero(numRangePosRoots);
    for (int j=0; j<numRangePosRoots; j++)
    { theDiffPoly = originalMon.Powers.TheObjects[j] - theMon.Powers.TheObjects[j];
      out << theDiffPoly.ElementToString(PolyFormatLocal) << " ";
      if (theDiffPoly.size>1)
        currentShift.TheObjects[j]=-10000;
      if (theDiffPoly.size==0)
        currentShift.TheObjects[j]=0;
      if (theDiffPoly.size==1)
        currentShift.TheObjects[j]=-theDiffPoly.TheObjects[0].Coefficient;
    }
    this->GetDiffOperatorFromShiftAndCoefficient(theMon.Coefficient, currentShift, tempWeyl, theGlobalVariables);
    currentOperator.Add(tempWeyl);
  }
  out << "<br>and the rank is: " << currentTargetShifts.GetRankOfSpanOfElements(theGlobalVariables);
  Selection tempSel;
  if (this->AreUnimodular(currentTargetShifts, tempSel, theGlobalVariables))
  { roots tempRoots, tempRoots2;
    currentTargetShifts.SubSelection(tempSel, tempRoots);
    out << "<br> one unimodular basis: " << tempRoots.ElementToString(false, true, false);
    currentTargetShifts.GetCoordsInBasis(tempRoots, tempRoots2, theGlobalVariables);
    out << "<br> in the above unimodular basis the coordinates are:<br> " << tempRoots2.ElementToString(false, true, true);
  }
  out << "<br>... and the operator is... <div class=\"math\" scale=\"50\"> \\begin{eqnarray*}&&" << currentOperator.ElementToString(true) << "\\end{eqnarray*}</div>";
  GeneralizedPolynomialRational tempGP;
  GeneralizedMonomialRational tempGM;
  tempGM.MakeGenericMon(numRangePosRoots+theRangeRank, theRangeRank);
  out << "<br>...and the generic monomial is: " << tempGM.ElementToString(PolyFormatLocal);
  this->WeylElementActsOnGeneralizedMonomial(currentOperator, tempGM, tempGP);
  out << "<br> ...and the action on the generic monomial is: <div class=\"math\">\\begin{eqnarray*}&&" << tempGP.ElementToString(PolyFormatLocal) << "\\end{eqnarray*}</div>";

  /*root tempRoot;
  RationalFunction ZeroRF;
  ZeroRF.MakeNVarConst(numCoeffVars, (Rational) 0);
  tempRoot.MakeZero(numRangePosRoots);
  if(this->theExponentShifts.AddOnTopNoRepetition(tempRoot))
    this->theSystem.Resize(this->theSystem.NumRows, this->theSystem.NumCols+1, true, &ZeroRF);
  int indexMainMon=this->theExponentShifts.IndexOfObject(tempRoot);
  PolynomialsRationalCoeff theSub;
  PolynomialRationalCoeff tempP;
  for (int i=0; i<theElt.size; i++)
  { int indexCurrentRow=this->theSystem.NumRows;
    this->theSystem.Resize(this->theSystem.NumRows+1, this->theSystem.NumCols, true, &ZeroRF);
    this->theSystem.elements[indexCurrentRow][indexMainMon]=theElt.TheObjects[i].Coefficient;
    for (int j=0; j<theElt.size; j++)
      if (i!=j)
      { theSub.MakeIdSubstitution(numCoeffVars, (Rational) 1);
        tempRoot= currentTargetShifts.TheObjects[i]-currentTargetShifts.TheObjects[j];
        for (int k=0; k<tempRoot.size; k++)
          theSub.TheObjects[k+theRangeRank].AddConstant(tempRoot.TheObjects[k]);
        int theVarIndex = this->theExponentShifts.IndexOfObject(tempRoot);
        if (theVarIndex<0)
        { theVarIndex=this->theExponentShifts.size;
          this->theExponentShifts.AddObjectOnTop(tempRoot);
          this->theSystem.Resize(this->theSystem.NumRows, this->theExponentShifts.size, true, &ZeroRF);
          out << "<br>Shift of monomial in play: " << tempRoot.ElementToString();
        }
        tempP=theElt.TheObjects[j].Coefficient;
        theSub.ComputeDebugString();
        tempP.ComputeDebugString();
        tempP.Substitution(theSub, numCoeffVars);
        tempP.ComputeDebugString();
        this->theSystem.elements[indexCurrentRow][theVarIndex]=tempP;
      }
  }*/
}

void EigenVectorComputation::MakeGenericMonomialBranchingCandidate(HomomorphismSemisimpleLieAlgebra& theHmm, ElementUniversalEnveloping& theElt, GlobalVariables& theGlobalVariables)
{ int RangeRank=theHmm.theRange.theWeyl.CartanSymmetric.NumRows;
  int numPosRootsRange=theHmm.theRange.theWeyl.RootsOfBorel.size;
  int dimPosPartQuotient=numPosRootsRange- theHmm.theDomain.theWeyl.RootsOfBorel.size;
  theElt.Nullify(theHmm.theRange);
  MonomialUniversalEnveloping tempMon;
  PolynomialRationalCoeff tempP;
  tempP.MakeNVarConst((int) RangeRank+dimPosPartQuotient, (Rational) 1);
  tempMon.MakeConst(tempP, theHmm.theRange);
  roots selectedRootSpaces;
  //int indexFirstPosRootDomain=theHmm.theDomain.theWeyl.RootsOfBorel.size+ theHmm.theDomain.theWeyl.CartanSymmetric.NumRows;
  selectedRootSpaces.MakeActualSizeAtLeastExpandOnTop(theHmm.theDomain.theWeyl.RootsOfBorel.size);
  root tempRoot;
  for (int i=0; i<theHmm.theDomain.theWeyl.RootsOfBorel.size; i++)
  { ElementSimpleLieAlgebra& tempElt= theHmm.imagesAllChevalleyGenerators.TheObjects[i];
    tempElt.ElementToVectorRootSpacesFirstThenCartan(tempRoot);
    selectedRootSpaces.AddObjectOnTop(tempRoot);
    //std::cout << "<br>" << tempElt.ElementToStringNegativeRootSpacesFirst(false, false, theHmm.theRange);
  }
  ElementSimpleLieAlgebra tempElt2;
  int numFound=0;
  for (int i=0; i<numPosRootsRange; i++)
  { tempElt2.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(i, theHmm.theRange);
    tempElt2.ElementToVectorRootSpacesFirstThenCartan(tempRoot);
    selectedRootSpaces.AddObjectOnTop(tempRoot);
    if (selectedRootSpaces.GetRankOfSpanOfElements(theGlobalVariables)==selectedRootSpaces.size)
    { tempP.MakeNVarDegOnePoly(RangeRank+dimPosPartQuotient, RangeRank+numFound, (Rational) 1);
      numFound++;
      tempMon.MultiplyByGeneratorPowerOnTheRight(i, tempP);
      //std::cout << "<br>" << tempElt2.ElementToStringNegativeRootSpacesFirst(false, false, theHmm.theRange);
    } else
      selectedRootSpaces.PopLastObject();
  }
  theElt.AddMonomial(tempMon);
}

void EigenVectorComputation::MakeGenericVermaElement(ElementUniversalEnveloping& theElt, SemisimpleLieAlgebra& owner)
{ theElt.owner=&owner;
  int numPosRoots= owner.theWeyl.RootsOfBorel.size;
  int theRank=owner.theWeyl.CartanSymmetric.NumRows;
  theElt.Nullify(owner);
  MonomialUniversalEnveloping tempMon;
  PolynomialRationalCoeff tempP;
  tempP.MakeNVarConst((int) theRank+numPosRoots, (Rational) 1);
  tempMon.MakeConst(tempP, owner);
  for (int i=0; i<numPosRoots; i++)
  { tempP.MakeNVarDegOnePoly(theRank+numPosRoots, theRank+i, (Rational) 1);
    tempMon.MultiplyByGeneratorPowerOnTheRight(i, tempP);
  }
  theElt.AddMonomial(tempMon);
}

void EigenVectorComputation::MakeGenericVermaElementOrdered(ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff>& theElt, SemisimpleLieAlgebraOrdered& owner)
{ int numPosRoots= owner.theOwner.theWeyl.RootsOfBorel.size;
  int theRank=owner.theOwner.GetRank();
  theElt.Nullify(owner);
  MonomialUniversalEnvelopingOrdered<PolynomialRationalCoeff> tempMon;
  PolynomialRationalCoeff tempP;
  tempP.MakeNVarConst((int) theRank+numPosRoots, (Rational) 1);
  tempMon.MakeConst(tempP, owner);
  for (int i=0; i<numPosRoots; i++)
  { tempP.MakeNVarDegOnePoly(theRank+numPosRoots, theRank+i, (Rational) 1);
    tempMon.MultiplyByGeneratorPowerOnTheRight(i, tempP);
  }
  theElt.AddMonomial(tempMon);
}


Rational WeylGroup::WeylDimFormula(root& theWeightInFundamentalBasis, GlobalVariables& theGlobalVariables)
{ root theWeightInSimpleBasis=theWeightInFundamentalBasis;
  MatrixLargeRational invertedCartan;
  for (int i=0; i<this->CartanSymmetric.NumRows; i++)
    theWeightInSimpleBasis.TheObjects[i]/=2/this->CartanSymmetric.elements[i][i];
  invertedCartan=this->CartanSymmetric;
  invertedCartan.Invert(theGlobalVariables);
  invertedCartan.ActOnAroot(theWeightInSimpleBasis, theWeightInSimpleBasis);
  Rational Result=1;
  for (int i=0; i<this->RootsOfBorel.size; i++)
  { Result.MultiplyBy(this->RootScalarCartanRoot(theWeightInSimpleBasis+this->rho, this->RootsOfBorel.TheObjects[i]));
    Result/=this->RootScalarCartanRoot(this->rho, this->RootsOfBorel.TheObjects[i]);
  }
  return Result;
}

std::string SemisimpleSubalgebras::ElementToString()
{ std::stringstream out; std::string tempS;
  this->theHcandidates.ElementToStringGeneric(tempS);
  out << tempS;
  return out.str();
}

void SemisimpleSubalgebras::FindHCandidates(char WeylLetter, int WeylDim, GlobalVariables& theGlobalVariables)
{ roots emptyStart;
//  List<List<root> >::ListActualSizeIncrement=10000;
  this->theAlgebra.FindSl2Subalgebras(this->theSl2s, WeylLetter, WeylDim, theGlobalVariables);
  this->theHcandidates.size=0;
  this->theHcandidates.AddObjectOnTop(emptyStart);
  for (this->indexLowestUnexplored=0; this->indexLowestUnexplored<this->theHcandidates.size; this->indexLowestUnexplored++)
    this->FindHCandidatesWithOneExtraHContaining(this->theHcandidates.TheObjects[this->indexLowestUnexplored], theGlobalVariables);
  this->ComputeDebugString();
  theGlobalVariables.theIndicatorVariables.StatusString1.append(this->DebugString);
  theGlobalVariables.MakeReport();
}

void  SemisimpleSubalgebras::FindHCandidatesWithOneExtraHContaining(roots& inpuT, GlobalVariables& theGlobalVariables)
{ int theDimension= this->theAlgebra.theWeyl.CartanSymmetric.NumRows;
  SelectionWithMaxMultiplicity theSel;
  theSel.initMaxMultiplicity(theDimension, 2);
  int theCounter=MathRoutines::KToTheNth(3, theDimension);
  root theRoot;
  WeylGroup& theWeyl=this->theAlgebra.theWeyl;
  MatrixLargeRational invertedCartan=this->theAlgebra.theWeyl.CartanSymmetric;
  invertedCartan.Invert(theGlobalVariables);
  roots tempRoots;
  tempRoots=inpuT;
  roots inputCopy;
  inputCopy=inpuT;
  for (int i=0; i<theCounter; i++, theSel.IncrementSubset())
  { //slTwo& currentSl2=this->theSl2s.TheObjects[i];
    theRoot=theSel;
    invertedCartan.ActOnAroot(theRoot, theRoot);
    bool isGood=true;
    if (!inputCopy.LinSpanContainsRoot(theRoot, theGlobalVariables))
    { for (int j=0; j<inputCopy.size; j++)
        if (theWeyl.RootScalarCartanRoot(inputCopy.TheObjects[j], theRoot).IsPositive())
        { isGood=false;
          break;
        }
      if (isGood)
      { tempRoots= inputCopy;
        tempRoots.AddObjectOnTop(theRoot);
        for (int k=tempRoots.size-1; k>0; k--)
          if (tempRoots.TheObjects[k]< tempRoots.TheObjects[k-1])
            tempRoots.SwapTwoIndices(k, k-1);
        this->theHcandidates.AddOnTopNoRepetition(tempRoots);
        //this->th
      }
      std::stringstream out;
      out << "index lowest non explored: " << this->indexLowestUnexplored+1 << " Total number found: " << this->theHcandidates.size;
      theGlobalVariables.theIndicatorVariables.StatusString1=out.str();
      theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
      theGlobalVariables.MakeReport();
    }
  }
}

void EigenVectorComputation::GetDiffOperatorFromShiftAndCoefficient
(PolynomialRationalCoeff& theCoeff, root& theShift, ElementWeylAlgebra& output, GlobalVariables& theGlobalVariables)
{ PolynomialRationalCoeff AccumDiffPart, tempP, tempP2, AccumPolyPart;
  Monomial<Rational> currentMon;
  int dimCartan=theCoeff.NumVars- theShift.size;
  AccumDiffPart.MakeNVarConst(theCoeff.NumVars, (Rational) 1);
  AccumPolyPart.MakeNVarConst(theCoeff.NumVars, (Rational) 1);
  output.MakeConst(theCoeff.NumVars, (Rational) 1);
  ElementWeylAlgebra tempW;
  PolynomialOutputFormat PolyFormatLocal;
  for (int i=0; i<theShift.size; i++)
    if (theShift.TheObjects[i].NumShort<0)
      for (int j=0; j<-theShift.TheObjects[i].NumShort; j++)
      { tempP.MakeNVarDegOnePoly(theCoeff.NumVars, i+dimCartan, (Rational) 1, (Rational) -j);
        AccumDiffPart.MultiplyBy(tempP);
        tempW.Makedi(i+dimCartan, theCoeff.NumVars);
        output.MultiplyOnTheRight(tempW);
      }
    else if (theShift.TheObjects[i].NumShort>0)
    { tempP.MakeMonomialOneLetter(theCoeff.NumVars, i+dimCartan, theShift.TheObjects[i].NumShort, (Rational) 1);
      AccumPolyPart.MultiplyBy(tempP);
    }
  std::cout << "<br>" << theCoeff.ElementToString(false, PolyFormatLocal) << "  " << theShift.ElementToString() << ": " << AccumDiffPart.ElementToString(false, PolyFormatLocal);
  theCoeff.DivideBy(AccumDiffPart, tempP, tempP2);
  if (!tempP2.IsEqualToZero())
    std::cout << "  problem problem problem!!!!";
  else
  { tempW.AssignPolynomial(tempP);
    output.MultiplyOnTheLeft(tempW, theGlobalVariables);
  }
  std::cout << " poly part: " << AccumPolyPart.ElementToString(false, PolyFormatLocal);
  tempW.AssignPolynomial(AccumPolyPart);
  output.MultiplyOnTheLeft(tempW, theGlobalVariables);
  //std::cout << "<div class=\"math\" scale=\"50\">"  << output.ElementToString(true) << "</div>";
  //while(!remainingCoeff.IsEqualToZero())
  //{ currentMon=remainingCoeff.TheObjects[remainingCoeff.GetIndexMaxMonomialTotalDegThenLexicographic()];

    //remainingCoeff.AddMonomial(
  //}
}

void SSalgebraModule::InduceFromEmbedding(std::stringstream& out, HomomorphismSemisimpleLieAlgebra& theHmm, GlobalVariables& theGlobalVariables)
{ this->theAlgebra.Assign(theHmm.theDomain);
  this->ambientAlgebrA.Assign(theHmm.theRange);
  int theDomainRank=this->theAlgebra.theWeyl.CartanSymmetric.NumRows;
  int numPosRootsDomain=this->theAlgebra.theWeyl.RootsOfBorel.size;
  int numGeneratorsDomain= theDomainRank+numPosRootsDomain*2;
  int numGeneratorsRange= theHmm.theRange.theWeyl.CartanSymmetric.NumRows+ theHmm.theRange.theWeyl.RootsOfBorel.size*2;
  List<ElementSimpleLieAlgebra> posGenerators, negGenerators, allSimpleGenerators;
  posGenerators.SetSize(theDomainRank);
  negGenerators.SetSize(theDomainRank);
  allSimpleGenerators.SetSize(theDomainRank*2);
  this->moduleElementsEmbedded.size=0;
  theHmm.GmodK.size=0;
  for (int i=0; i<theDomainRank; i++)
  { posGenerators.TheObjects[i] =theHmm.imagesAllChevalleyGenerators.TheObjects[numPosRootsDomain+theDomainRank+i];
    negGenerators.TheObjects[i] =theHmm.imagesAllChevalleyGenerators.TheObjects[numPosRootsDomain-1-i];
    allSimpleGenerators.TheObjects[i]=posGenerators.TheObjects[i];
    allSimpleGenerators.TheObjects[i+theDomainRank]=negGenerators.TheObjects[i];
  }
  List<MatrixLargeRational> negGeneratorsMatForm, posGeneratorsMatForm, allSimpleGeneratorsMatForm;
  this->ConvertElementsToAdMatrixFormNegativeRootSpacesFirst(negGenerators, theHmm.theRange, negGeneratorsMatForm);
  this->ConvertElementsToAdMatrixFormNegativeRootSpacesFirst(posGenerators, theHmm.theRange, posGeneratorsMatForm);
  this->ConvertElementsToAdMatrixFormNegativeRootSpacesFirst(allSimpleGenerators, theHmm.theRange, allSimpleGeneratorsMatForm);
  rootsCollection theModules;
  roots newlyFoundStartingVectors, BasisAllFoundElements, BasisNewlyFoundElements;
  root currentElementRootForm, oneRootFromDomainAlgebra;
  ElementSimpleLieAlgebra currentElt;
  int IndexFirstModuleNotEqualToDomain=-1;
  theHmm.imagesAllChevalleyGenerators.TheObjects[0].ElementToVectorNegativeRootSpacesFirst(oneRootFromDomainAlgebra);
  this->moduleElementsEmbedded.MakeActualSizeAtLeastExpandOnTop(numGeneratorsRange);
  this->moduleElementsEmbedded.size=0;
  for (int i=0; i<numGeneratorsRange; i++)
  { currentElt.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(i, theHmm.theRange);
    currentElt.ElementToVectorNegativeRootSpacesFirst(currentElementRootForm);
    if (!BasisAllFoundElements.LinSpanContainsRoot(currentElementRootForm, theGlobalVariables))
    { this->ExtractHighestWeightVectorsFromVector(currentElementRootForm, newlyFoundStartingVectors, posGeneratorsMatForm, negGeneratorsMatForm);
      for (int j=0; j<newlyFoundStartingVectors.size; j++)
        if (!BasisAllFoundElements.LinSpanContainsRoot(newlyFoundStartingVectors.TheObjects[j], theGlobalVariables))
        { currentElt.AssignVectorNegRootSpacesCartanPosRootSpaces(newlyFoundStartingVectors.TheObjects[j], theHmm.theRange);
          out << "<br><br> starting vector: " << currentElt.ElementToStringNegativeRootSpacesFirst(false, false, theHmm.theRange);
          this->GenerateSubmoduleFromRootNegativeRootSpacesFirst(newlyFoundStartingVectors.TheObjects[j], BasisNewlyFoundElements, allSimpleGeneratorsMatForm, theGlobalVariables);
          theModules.AddObjectOnTop(BasisNewlyFoundElements);
          BasisAllFoundElements.AddListOnTop(BasisNewlyFoundElements);
          if (!theModules.LastObject()->LinSpanContainsRoot(oneRootFromDomainAlgebra, theGlobalVariables))
          { for (int k=0; k<BasisNewlyFoundElements.size; k++)
            { this->moduleElementsEmbedded.SetSize(this->moduleElementsEmbedded.size+1);
              this->moduleElementsEmbedded.LastObject()->AssignVectorNegRootSpacesCartanPosRootSpaces(BasisNewlyFoundElements.TheObjects[k], theHmm.theRange);
              theHmm.GmodK.AddObjectOnTop(*this->moduleElementsEmbedded.LastObject());
              //std::cout << "<br> Just added to g mod k: " << theHmm.GmodK.LastObject()->ElementToStringNegativeRootSpacesFirst(true, false, theHmm.theRange);
            }
            if (IndexFirstModuleNotEqualToDomain==-1)
              IndexFirstModuleNotEqualToDomain=theModules.size-1;
          } else
          { out << "<br>Basis of the subalgebra:<br><table>";
            for (int k=0; k<theHmm.imagesAllChevalleyGenerators.size; k++)
            { std::stringstream displayString;
              if (k>= theHmm.theDomain.GetNumPosRoots()+theHmm.theDomain.GetRank())
                displayString << "f_{" << k+(-theHmm.theDomain.GetNumGenerators()+1+theHmm.theRange.GetNumPosRoots()) << "}=";
              if (k< theHmm.theDomain.GetNumPosRoots()+theHmm.theDomain.GetRank() && k>=theHmm.theDomain.GetNumPosRoots())
                displayString << "f_{0," << k-theHmm.theDomain.GetNumPosRoots() << "}=f_{" << k+theHmm.theRange.GetNumPosRoots()+1-theHmm.theDomain.GetNumPosRoots() << "}=";
              if (k< theHmm.theDomain.GetNumPosRoots())
                displayString << "f_{" << -theHmm.theRange.GetNumPosRoots()+k<< "}=";
              out << "<tr><td>" << displayString.str() << "</td><td>" << theHmm.imagesAllChevalleyGenerators.TheObjects[k].ElementToStringNegativeRootSpacesFirst(false, false, theHmm.theRange) << "</td></tr>";
            }
            out << "</table>";
          }
        }
    }
    if (BasisAllFoundElements.size==numGeneratorsRange)
      break;
  }
  out << "<br>basis of generated module:<br><table> ";
  for (int k=0; k<theHmm.GmodK.size; k++)
  { std::stringstream displayString;
    if (k==theHmm.GmodK.size/2)
      displayString << "f_{0," << theHmm.theRange.GetRank() << "}=f_{" << theHmm.theRange.GetNumPosRoots()+theHmm.theRange.GetRank() << "}=";
    if (k>theHmm.GmodK.size/2)
      displayString << "f_{" << k-theHmm.GmodK.size/2 << "}=";
    if (k<theHmm.GmodK.size/2)
      displayString << "f_{" << k-theHmm.GmodK.size/2 << "}=";
    out << "<tr><td>" << displayString.str() <<"</td><td>" << theHmm.GmodK.TheObjects[k].ElementToStringNegativeRootSpacesFirst(false, false, theHmm.theRange) << "</td></tr>" ;
  }
  out << "</table>";
  roots theAlgebra;
  roots& theModule= theModules.TheObjects[IndexFirstModuleNotEqualToDomain];
  this->actionsNegativeRootSpacesCartanPositiveRootspaces.SetSize(numGeneratorsDomain);
  ElementSimpleLieAlgebra tempElt;
  for (int j=0; j<numGeneratorsDomain; j++)
  { MatrixLargeRational& theMat=this->actionsNegativeRootSpacesCartanPositiveRootspaces.TheObjects[j];
    ElementSimpleLieAlgebra& currentGenerator=theHmm.imagesAllChevalleyGenerators.TheObjects[j];
    this->ComputeAdMatrixFromModule(currentGenerator, theModule, theHmm.theRange, theMat, theGlobalVariables);
    out << "<br> <div class=\"math\" scale=\"50\">" << currentGenerator.ElementToStringNegativeRootSpacesFirst(false, false, theHmm.theRange) << "\\to" << theMat.ElementToString(false, true) <<"</div>";
  }
}

void SSalgebraModule::ComputeAdMatrixFromModule
  (ElementSimpleLieAlgebra& theElt, roots& theModule, const SemisimpleLieAlgebra& ambientLieAlgebra, MatrixLargeRational& output,
   GlobalVariables& theGlobalVariables)
{ ElementSimpleLieAlgebra tempElt1, tempElt2;
  root tempRoot1, tempRoot2;
  output.init(theModule.size, theModule.size);
  for (int i=0; i<theModule.size; i++)
  { tempElt1.AssignVectorNegRootSpacesCartanPosRootSpaces(theModule.TheObjects[i], ambientLieAlgebra);
    ambientLieAlgebra.LieBracket(theElt, tempElt1, tempElt2);
    tempElt2.ElementToVectorNegativeRootSpacesFirst(tempRoot1);
    //theModule.ComputeDebugString();
    //tempRoot1.ComputeDebugString();
    assert(theModule.LinSpanContainsRoot(tempRoot1, theGlobalVariables));
    tempRoot1.GetCoordsInBasis(theModule, tempRoot2, theGlobalVariables);
    for (int j=0; j<theModule.size; j++)
      output.elements[j][i]=tempRoot2.TheObjects[j];
  }
}

void SSalgebraModule::GenerateSubmoduleFromRootNegativeRootSpacesFirst
  (root& input, roots& output, List<MatrixLargeRational>& allSimpleGenerators, GlobalVariables& theGlobalVariables)
{ output.size=0;
  output.AddObjectOnTop(input);
  root tempRoot;
  for (int lowestNonExplored=0; lowestNonExplored<output.size; lowestNonExplored++)
    for (int i=0; i<allSimpleGenerators.size; i++)
    { allSimpleGenerators.TheObjects[i].ActOnAroot(output.TheObjects[lowestNonExplored], tempRoot);
      output.AddObjectOnTop(tempRoot);
      if (output.GetRankOfSpanOfElements(theGlobalVariables)<output.size)
        output.PopLastObject();
    }
}

void SSalgebraModule::ExtractHighestWeightVectorsFromVector
  (root& input, roots& outputVectors, List<MatrixLargeRational>& simplePosGenerators, List<MatrixLargeRational>& simpleNegGenerators)
{ //Index ordering of sipleNegGenerators:
  //if simplePosGenerators.TheObjects[i] is a positive root space then its opposite root space should be
  //simpleNegGenerators.TheObjects[i]
  outputVectors.size=0;
  root remainderRoot=input;
  root componentRoot;
  root tempRoot;
  Rational theCoeff;
  List<int> GeneratorSequence;
  List<int> GeneratorPowers;
  while(!remainderRoot.IsEqualToZero())
  { this->ClimbUpFromVector(remainderRoot, tempRoot, simplePosGenerators, GeneratorSequence, GeneratorPowers);
    this->ClimbDownFromVectorAccordingToSequence(tempRoot, componentRoot, theCoeff, simplePosGenerators, simpleNegGenerators, GeneratorSequence, GeneratorPowers);
    assert(!theCoeff.IsEqualToZero());
    outputVectors.AddObjectOnTop(componentRoot/theCoeff);
    remainderRoot-=*outputVectors.LastObject();
  }
}

void SSalgebraModule::ClimbDownFromVectorAccordingToSequence
  (root& input, root& output, Rational& outputCoeff, List<MatrixLargeRational>& simplePosGenerators, List<MatrixLargeRational>& SimpleNegGenerators,
   List<int>& inputGeneratorSequence, List<int>& inputGeneratorPowers)
{ assert(&input!=&output);
  output=input;
  root tempRoot;
  outputCoeff.MakeOne();
  Rational tempRat;
  for (int i=inputGeneratorSequence.size-1; i>=0; i--)
  { MatrixLargeRational& currentPosGen= simplePosGenerators.TheObjects[inputGeneratorSequence.TheObjects[i]];
    MatrixLargeRational& currentNegGen=SimpleNegGenerators.TheObjects[inputGeneratorSequence.TheObjects[i]];
    this->ClimbDownFromHighestWeightAlongSl2String(output, tempRoot, tempRat, currentPosGen, currentNegGen, inputGeneratorPowers.TheObjects[i]);
    outputCoeff.MultiplyBy(tempRat);
    output=tempRoot;
  }
}

void SSalgebraModule::ClimbDownFromHighestWeightAlongSl2String
  (root& input, root& output, Rational& outputCoeff, MatrixLargeRational& posGenerator, MatrixLargeRational& negGenerator, int generatorPower)
{ assert(&input!=&output);
  Rational currentWeight;
  negGenerator.ActOnAroot(input, output);
  posGenerator.ActOnAroot(output);
  input.IsProportionalTo(output, currentWeight);
  Rational RaiseCoeff;
  RaiseCoeff.MakeZero();
  outputCoeff.MakeOne();
  output=input;
  for (int i=0; i<generatorPower; i++)
  { RaiseCoeff+=currentWeight;
    currentWeight-=2;
    outputCoeff*=RaiseCoeff;
    negGenerator.ActOnAroot(output);
  }
}

void SSalgebraModule::ClimbUpFromVector
  (root& input, root& outputLastNonZero, List<MatrixLargeRational>& SimplePositiveGenerators, List<int>& outputGeneratorSequence, List<int>& outputGeneratorPowers)
{ root tempRoot;
  assert(&input!=&outputLastNonZero);
  outputLastNonZero=input;
  outputGeneratorPowers.size=0;
  outputGeneratorSequence.size=0;
  bool found=true;
  while (found)
  { found=false;
    for (int i=0; i<SimplePositiveGenerators.size; i++)
    { MatrixLargeRational& currentMat=SimplePositiveGenerators.TheObjects[i];
      int counter=0;
      for(currentMat.ActOnAroot(outputLastNonZero, tempRoot); !tempRoot.IsEqualToZero(); currentMat.ActOnAroot(tempRoot))
      { counter++;
        found=true;
        outputLastNonZero=tempRoot;
//        std::cout << "<br>" << outputLastNonZero.ElementToString();
//        std::cout.flush();
      }
      if (found)
      { outputGeneratorSequence.AddObjectOnTop(i);
        outputGeneratorPowers.AddObjectOnTop(counter);
      }
    }
  }
}

void SSalgebraModule::ConvertElementsToAdMatrixFormNegativeRootSpacesFirst
  (const List<ElementSimpleLieAlgebra>& input, const SemisimpleLieAlgebra& ambientLieAlgebra, List<MatrixLargeRational>& output)
{ output.SetSize(input.size);
  for (int i=0; i<input.size; i++)
    this->ConvertElementsToAdMatrixFormNegativeRootSpacesFirst(input.TheObjects[i], ambientLieAlgebra, output.TheObjects[i]);
}

void SSalgebraModule::ConvertElementsToAdMatrixFormNegativeRootSpacesFirst
  (const ElementSimpleLieAlgebra& input, const SemisimpleLieAlgebra& ambientLieAlgebra, MatrixLargeRational& output)
{ ElementSimpleLieAlgebra tempElt1, tempElt2;
  int numGenerators=ambientLieAlgebra.GetNumGenerators();
  output.init(numGenerators, numGenerators);
  root tempRoot;
  for (int i=0; i<numGenerators; i++)
  { tempElt1.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(i,ambientLieAlgebra);
    ambientLieAlgebra.LieBracket(input, tempElt1, tempElt2);
    tempElt2.ElementToVectorNegativeRootSpacesFirst(tempRoot);
    for (int j=0; j<numGenerators; j++)
      output.elements[j][i]=tempRoot.TheObjects[j];
  }
//  std::cout << "<br><div class=\"math\">" << output.ElementToString(false, true) << "</div>";
}

void SSalgebraModule::ActOnPolynomialOverModule
  (const ElementSimpleLieAlgebra& theActingElement, const PolynomialOverModule& theArgument, PolynomialOverModule& output)
{ root vectorFormElement;
  theActingElement.ElementToVectorNegativeRootSpacesFirst(vectorFormElement);
  PolynomialOverModule Accum;
  Accum.Nullify(*this);
  PolynomialRationalCoeff tempP;
  for (int i=0; i<vectorFormElement.size; i++)
    if (!vectorFormElement.TheObjects[i].IsEqualToZero())
      for (int k=0; k<theArgument.size; k++)
      { this->ActOnMonomialOverModule(i, theArgument.TheObjects[k], tempP);
        tempP.TimesConstant(vectorFormElement.TheObjects[i]);
        //std::cout << "<br>" << tempP.ElementToString();
        Accum.AddPolynomial(tempP);
      }
  output.Assign(Accum);
}

void SSalgebraModule::ActOnMonomialOverModule
  (int indexChevalleyGeneratorNegativeSpacesFirst, const Monomial<Rational>& theArgument, PolynomialRationalCoeff& output)
{ int theDim=this->GetDim();
  output.Nullify(theDim);
  Monomial<Rational> tempMon;
  PolynomialRationalCoeff tempP;
  MatrixLargeRational& theOperator=this->actionsNegativeRootSpacesCartanPositiveRootspaces.TheObjects[indexChevalleyGeneratorNegativeSpacesFirst];
  for (int i=0; i<theArgument.NumVariables; i++)
    if (theArgument.degrees[i]>0)
    { tempP.Nullify(theDim);
      for (int k=0; k<theDim; k++)
      { tempMon.MakeNVarFirstDegree(k, (int) theDim, theOperator.elements[k][i]);
        tempP.AddMonomial(tempMon);
      }
      //std::cout <<"<br>" << tempP.ElementToString();
      tempP.TimesConstant(theArgument.degrees[i]);
      tempMon.Assign(theArgument);
      tempMon.degrees[i]--;
      tempP.MultiplyByMonomial(tempMon);
      output.AddPolynomial(tempP);
    }
}

void SSalgebraModule::ComputeInvariantsOfDegree
  (int degree, std::stringstream& out, GlobalVariables& theGlobalVariables)
{ SelectionWithMaxMultiplicity theSel;
  int theDim=this->GetDim();
  int numPosRoots=this->theAlgebra.theWeyl.RootsOfBorel.size;
  int theRank= this->theAlgebra.theWeyl.CartanSymmetric.NumRows;
//  int numGenerators=this->actionsNegativeRootSpacesCartanPositiveRootspaces.size;
  theSel.initMaxMultiplicity(theDim, degree);
  PolynomialOutputFormat PolyFormatLocal;
  int numCycles=theSel.NumCombinationsOfCardinality(degree);
  PolynomialRationalCoeff basisMonsZeroWeight, basisMonsAll;
  basisMonsZeroWeight.Nullify(theDim);
  basisMonsZeroWeight.MakeActualSizeAtLeastExpandOnTop(numCycles);
  basisMonsAll.Nullify(theDim);
  basisMonsAll.MakeActualSizeAtLeastExpandOnTop(numCycles);
  Monomial<Rational> theMon;
  theMon.init(theDim);
  root theWeight;
  roots theCartanActions;
  theCartanActions.SetSize(theDim);
  theWeight.SetSize(theDim);
  for (int i=0; i<theRank; i++)
  { root& current=theCartanActions.TheObjects[i];
    current.SetSize(theDim);
    for (int j=0; j<theDim; j++)
      current.TheObjects[j]=this->actionsNegativeRootSpacesCartanPositiveRootspaces.TheObjects[i+numPosRoots].elements[j][j];
  }
  theSel.IncrementSubsetFixedCardinality(degree);
  for (int i=0; i<numCycles; i++, theSel.IncrementSubsetFixedCardinality(degree))
  { for (int j=0; j<theDim; j++)
    { theMon.degrees[j]=theSel.Multiplicities.TheObjects[j];
      theWeight.TheObjects[j]=theMon.degrees[j];
    }
    bool isGood=true;
    for (int k=0; k<theRank; k++)
      if(!root::RootScalarEuclideanRoot(theWeight, theCartanActions.TheObjects[k]).IsEqualToZero())
      { isGood=false;
        break;
      }
    basisMonsAll.AddMonomial(theMon);
    if (isGood)
    { theMon.Coefficient.MakeOne();
      basisMonsZeroWeight.AddMonomial(theMon);
    }
  }
  out << "<br>Num cycles:" << numCycles << "<br>The basis mons (thera are " << basisMonsZeroWeight.size << " of them): "  << basisMonsZeroWeight.ElementToString(PolyFormatLocal);
  MatrixLargeRational tempMat;
  tempMat.init(basisMonsAll.size*theRank*2, basisMonsZeroWeight.size);
//  tempMat.init(basisMonsAll.size*numGenerators, basisMonsZeroWeight.size);
  PolynomialRationalCoeff tempP;
  for (int l=0; l<2; l++)
    for (int i=0; i<theRank; i++)
//    for (int i=0; i<numGenerators; i++)
      for (int k=0; k<basisMonsZeroWeight.size; k++)
      { int theIndex= (l==0) ? numPosRoots+theRank+i : numPosRoots-1-i;
        //int theIndex=i;
        this->ActOnMonomialOverModule(theIndex, basisMonsZeroWeight.TheObjects[k], tempP);
        for (int j=0; j<basisMonsAll.size; j++)
        { int indexInResult=tempP.IndexOfObjectHash(basisMonsAll.TheObjects[j]);
          int currentRow=(theRank*l+i)*basisMonsAll.size+j;
          //int currentRow=i*basisMonsAll.size+j;
          if (indexInResult==-1)
            tempMat.elements[currentRow][k]=0;
          else
            tempMat.elements[currentRow][k]=tempP.TheObjects[indexInResult].Coefficient;
        }
      }
  if (tempMat.NumRows<120)
    out << "<div class=\"math\" scale=\"50\">" << tempMat.ElementToString(false, true) << "</div>";
  roots tempRoots;
  tempMat.FindZeroEigenSpace(tempRoots, theGlobalVariables);
  this->invariantsFound.SetSize(tempRoots.size);
  out << "<br> .... and the invariants are: ";
  for (int i=0; i<this->invariantsFound.size; i++)
  { Polynomial<Rational>& current=this->invariantsFound.TheObjects[i];
    current.Nullify(theDim);
    for (int j=0; j<basisMonsZeroWeight.size; j++)
      if (!tempRoots.TheObjects[i].TheObjects[j].IsEqualToZero())
      { theMon.Assign(basisMonsZeroWeight.TheObjects[j]);
        theMon.Coefficient=tempRoots.TheObjects[i].TheObjects[j];
        current.AddMonomial(theMon);
      }
    out << "<br>Invariant " << i << ":<br>" << current.ElementToString(PolyFormatLocal);
  }
}

void SSalgebraModule::mapInvariantsToEmbedding
  (std::stringstream& out, SemisimpleLieAlgebra& owner, GlobalVariables& theGlobalVariables)
{ //PolynomialRationalCoeff tempP="x_1^2";
  PolynomialOutputFormat PolyFormatLocal;
  this->invariantsMappedToEmbedding.SetSize(this->invariantsFound.size);
  for (int i=0; i<this->invariantsFound.size; i++)
  { ElementUniversalEnveloping& currentElt=this->invariantsMappedToEmbedding.TheObjects[i];
    Polynomial<Rational>& currentPoly=this->invariantsFound.TheObjects[i];
    currentElt.Nullify(owner);
    for (int k=0; k<currentPoly.size; k++)
    { this->mapMonomialToEmbedding(currentPoly.TheObjects[k], currentElt, owner, out, theGlobalVariables);
    }
//    currentElt.Simplify();
    out << "<br>The substitution: <div class=\"math\" scale=\"50\">\\begin{eqnarray*}" << currentPoly.ElementToString(false, PolyFormatLocal) << "&\\to&" << currentElt.ElementToString(true) << "\\end{eqnarray*}</div>";
  }
}

void SSalgebraModule::mapMonomialToEmbedding
  (Monomial<Rational>& input, ElementUniversalEnveloping& Accum, SemisimpleLieAlgebra& owner, std::stringstream& out, GlobalVariables& theGlobalVariables)
{ permutation thePermutation;
  PolynomialOutputFormat PolyFormatLocal;
  thePermutation.initPermutation(input.NumVariables);
  int numPermutations= thePermutation.GetNumPermutations();
  ElementUniversalEnveloping tempElt;
  ElementUniversalEnveloping currentContribution;
  ElementUniversalEnveloping theUEUnit;
  theUEUnit.MakeConst((Rational) 1, 0, owner);
  List<int> permutationMap;
  thePermutation.GetPermutationLthElementIsTheImageofLthIndex(permutationMap);
  out << input.ElementToString(PolyFormatLocal);
  for (int i=0; i<numPermutations; i++, thePermutation.incrementAndGetPermutation(permutationMap))
  { currentContribution.MakeConst((Rational)1, 0, owner);
    for (int j=0; j<input.NumVariables; j++)
      if (input.degrees[j]>0)
      { tempElt.AssignElementLieAlgebra(this->moduleElementsEmbedded.TheObjects[permutationMap.TheObjects[j]], 0, owner);
        out << "<br>current generator: " << tempElt.ElementToString(false);
        MathRoutines::RaiseToPower(tempElt, input.degrees[j], theUEUnit);
        currentContribution*=tempElt;
      }
    currentContribution.Simplify();
    Accum+=currentContribution;
  }
}

void ElementUniversalEnveloping::GetCoordinateFormOfSpanOfElements(List<ElementUniversalEnveloping>& theElements, roots& outputCoordinates, ElementUniversalEnveloping& outputCorrespondingMonomials, GlobalVariables& theGlobalVariables)
{ if (theElements.size==0)
    return;
  outputCorrespondingMonomials.Nullify(*theElements.TheObjects[0].owner);
  for (int i=0; i<theElements.size; i++)
    for (int j=0; j<theElements.TheObjects[i].size; j++)
      outputCorrespondingMonomials.AddObjectOnTopNoRepetitionOfObjectHash(theElements.TheObjects[i].TheObjects[j]);
  outputCoordinates.SetSize(theElements.size);
  Rational tempRat;
  for (int i=0; i<theElements.size; i++)
  { root& current=outputCoordinates.TheObjects[i];
    current.MakeZero(outputCorrespondingMonomials.size);
    ElementUniversalEnveloping& currentElt=theElements.TheObjects[i];
    for (int j=0; j<currentElt.size; j++)
    { MonomialUniversalEnveloping& currentMon=currentElt.TheObjects[j];
      if (currentMon.Coefficient.size>0)
        tempRat=currentMon.Coefficient.TheObjects[0].Coefficient;
      else
        tempRat.MakeZero();
      current.TheObjects[outputCorrespondingMonomials.IndexOfObjectHash(currentMon)]=tempRat;
    }
  }
}

void ElementUniversalEnveloping::AssignFromCoordinateFormWRTBasis
  (List<ElementUniversalEnveloping>& theBasis, rootPoly& input, SemisimpleLieAlgebra& owner)
{ /*int numVars=0;
  if (theBasis.size>0)
    numVars= theBasis.TheObjects[0].GetNumVariables();*/
  this->Nullify(owner);
  ElementUniversalEnveloping tempElt;
  for (int i=0; i<input.size; i++)
    if (!input.TheObjects[i].IsEqualToZero())
    { tempElt.operator=(theBasis.TheObjects[i]);
      tempElt.operator*=(input.TheObjects[i]);
      this->operator+=(tempElt);
    }
}

void SemisimpleLieAlgebra::ComputeCommonAdEigenVectors
(int theDegree, List<ElementUniversalEnveloping>& theGenerators, List<ElementUniversalEnveloping>& generatorsBeingActedOn,
 List<ElementUniversalEnveloping>& output, std::stringstream& out,
 GlobalVariables& theGlobalVariables)
{ SelectionWithMaxMultiplicity theSel;
  PolynomialRationalCoeff::PreferredHashSize=1;
  int numGenerators=generatorsBeingActedOn.size;
  theSel.initMaxMultiplicity(numGenerators+1, theDegree);
  int numCycles=theSel.NumCombinationsOfCardinality(theDegree);
  List<ElementUniversalEnveloping> candidateElements, theBracketsOfTheElements;
  ElementUniversalEnveloping tempElt, tempElt2, currentOutput, Accum, UEUnit;
  theBracketsOfTheElements.ListActualSizeIncrement=50;
  theBracketsOfTheElements.size=0;
  theSel.IncrementSubsetFixedCardinality(theDegree);
  int numVars=this->GetRank();
  for (int i=0; i<numCycles; i++, theSel.IncrementSubsetFixedCardinality(theDegree))
  { Accum.MakeConst((Rational) 1, 0, *this);
    for (int j=0; j<theSel.elements.size; j++)
      if (theSel.elements.TheObjects[j]<numGenerators)
      { int generatorIndex=theSel.elements.TheObjects[j];
        int generatorPower=theSel.Multiplicities.TheObjects[generatorIndex];
        tempElt.operator=(generatorsBeingActedOn.TheObjects[generatorIndex]);
        tempElt.RaiseToPower(generatorPower);
        Accum.MultiplyBy(tempElt);
      }
    tempElt.operator=(Accum);
    tempElt.SetNumVariables(numVars);
    candidateElements.AddObjectOnTop(tempElt);
//    out << "<br>" << Accum.ElementToString(true);
    for (int j=0; j<theGenerators.size; j++)
    { tempElt2.operator=(theGenerators.TheObjects[j]);
      tempElt2.SetNumVariables(numVars);
      tempElt2.LieBracketOnTheRight(tempElt, currentOutput);
//      currentOutput.ComputeDebugString();
//      std::cout<< currentOutput.DebugString;
      currentOutput.Simplify();
      if (numVars==0)
        currentOutput.ModOutVermaRelations(true);
      else
        currentOutput.ModOutVermaRelations(false);
      theBracketsOfTheElements.AddObjectOnTop(currentOutput);
      out << "<br>";
      //out << "<div class=\"math\">";
      out << "[" << theGenerators.TheObjects[j].ElementToString() << "," << Accum.ElementToString() << "]=";
      //out << "\\begin{eqnarray*}&&";
      out << currentOutput.ElementToString();
      //out << "  (mod Verma relations)";
      //out << "\\end{eqnarray*}</div>";
    }
  }
  out << "<br>number of monomials of given degree: " << candidateElements.size;
  List<rootPoly> theBasisRootForm;
  ElementUniversalEnveloping theMonBasis;
  ElementUniversalEnveloping::GetCoordinateFormOfSpanOfElements(numVars, theBracketsOfTheElements, theBasisRootForm, theMonBasis, theGlobalVariables);
  std::string tempS;
  out << "<br>...and the monomial basis is(" << theMonBasis.size << " elements total): ";
  for (int i=0; i<theMonBasis.size; i++)
    out << theMonBasis.TheObjects[i].ElementToString(false) << ", ";
  Matrix<RationalFunction> theSystem;
  theSystem.init(theMonBasis.size*theGenerators.size, candidateElements.size);
  for (int k=0; k<theGenerators.size; k++)
    for (int i=0; i<candidateElements.size; i++)
    { rootPoly& currentRoot=theBasisRootForm.TheObjects[k+i*theGenerators.size];
      //out << "<br>root index" << i << ": " << currentRoot.ElementToString();
      for (int j=0; j<currentRoot.size; j++)
        theSystem.elements[currentRoot.size*k+j][i]=currentRoot.TheObjects[j];
    }
  out << "<br>...and the system is: <div class=\"math\">" <<  theSystem.ElementToString(false, true) << "</div>";
  List<List<RationalFunction> > theEigenVectors;
  PolynomialRationalCoeff::PreferredHashSize=50;
  RationalFunction oneRF, minusOneRF, zeroRF;
  oneRF.MakeNVarConst(numVars, (Rational) 1, &theGlobalVariables);
  minusOneRF.MakeNVarConst(numVars, (Rational) -1, &theGlobalVariables);
  zeroRF.MakeNVarConst(numVars, (Rational) 0, &theGlobalVariables);

  theSystem.FindZeroEigenSpacE(theEigenVectors, oneRF, minusOneRF, zeroRF, theGlobalVariables);
  out << "<br> the dim of the eigen space: " << theEigenVectors.size;
  rootPoly tempProot;

  for (int i=0; i<theEigenVectors.size; i++)
  { List<RationalFunction>& currentEigen=theEigenVectors.TheObjects[i];
    RationalFunction::ScaleClearDenominator(currentEigen, tempProot);
    tempElt.AssignFromCoordinateFormWRTBasis(candidateElements, tempProot, *this);
    out << "<br>" << tempElt.ElementToString();
  }
}

void RationalFunction::ScaleClearDenominator
  (List<RationalFunction>& input, rootPoly& output)
{ PolynomialRationalCoeff tempP;
  List<RationalFunction> buffer;
  buffer.CopyFromBase(input);
  for (int i=0; i<buffer.size; i++)
  { RationalFunction& current=buffer.TheObjects[i];
    if (current.expressionType==RationalFunction::typeRationalFunction)
    { tempP.operator=(current.Denominator.GetElement());
      for (int j=0; j<buffer.size; j++)
        buffer.TheObjects[j].operator*=(tempP);
    }
  }
  output.SetSize(input.size);
  for (int i=0; i<buffer.size; i++)
  { buffer.TheObjects[i].GetNumerator(tempP);
    output.TheObjects[i]=tempP;
  }
}

void SemisimpleLieAlgebra::ComputeCommonAdEigenVectorsFixedWeight
(root& theWeight, roots& theHs, List<ElementUniversalEnveloping>& theGenerators,
 List<ElementUniversalEnveloping>& output, std::stringstream& out,
 GlobalVariables& theGlobalVariables)
{ VectorPartition theVP;
  PolynomialRationalCoeff::PreferredHashSize=1;
  int numGenerators= this->GetNumPosRoots();
  int numVars=this->GetRank();
  int theRank=this->GetRank();
  theVP.PartitioningRoots.SetSize(numGenerators);
  List<ElementUniversalEnveloping> generatorsBeingActedOn;
  generatorsBeingActedOn.SetSize(numGenerators);
  theVP.PartitioningRoots.operator=(this->theWeyl.RootsOfBorel);
  out << "<br>" << theWeight.ElementToString() << "<br> the H's: " << theHs.ElementToString();
  out << "<br> Partitioning roots: " << theVP.PartitioningRoots.ElementToString();
  for (int i=0; i<numGenerators; i++)
  { ElementUniversalEnveloping& currentUE=generatorsBeingActedOn.TheObjects[i];
    currentUE.MakeOneGeneratorCoeffOne(i, 0, *this);
  }
  theVP.theRoot=theWeight;
  theVP.ComputeAllPartitions();
  out << "<br><br>" << theVP.ElementToString(true);
  root accumulatedHweight, tempRoot;
  for (int i=0; i<theVP.thePartitions.size; i++)
  { List<int>& currentPartition=theVP.thePartitions.TheObjects[i];
    accumulatedHweight.MakeZero(theRank);
    for (int generatorIndex=0; generatorIndex<currentPartition.size; generatorIndex++)
    { int generatorPower=currentPartition.TheObjects[generatorIndex];
      accumulatedHweight+=this->theWeyl.RootSystem.TheObjects[this->theWeyl.RootSystem.size-1-generatorIndex]* generatorPower;
    }
    bool isGood=true;
    for (int j=0; j<theHs.size; j++)
    { root& currentH=theHs.TheObjects[j];
      Rational theTargetScalar;
      Rational currentScalar;
      bool found=false;
      for (int k=0; k<currentH.size; k++)
        if (currentH.TheObjects[k]!=0)
        { tempRoot.MakeEi(currentH.size, k);
          currentScalar=this->theWeyl.RootScalarCartanRoot(tempRoot, accumulatedHweight);
          if (!found)
          { theTargetScalar=currentScalar;
            found=true;
          }
          if (theTargetScalar!=currentScalar)
          { isGood=false;
            break;
          }
        }
      if (!isGood)
        break;
    }
    if (isGood)
    { out << "<br>" << accumulatedHweight.ElementToString();
      out << " is good";
    } else
    { theVP.thePartitions.PopIndexSwapWithLast(i);
      i--;
    }
  }
  List<ElementUniversalEnveloping> candidateElements, theBracketsOfTheElements;
  ElementUniversalEnveloping tempElt, tempElt2, currentOutput, Accum, UEUnit;
  theBracketsOfTheElements.ListActualSizeIncrement=50;
  theBracketsOfTheElements.size=0;
  for (int i=0; i<theVP.thePartitions.size; i++)
  { Accum.MakeConst((Rational) 1, 0, *this);
    List<int>& currentPartition=theVP.thePartitions.TheObjects[i];
    for (int generatorIndex=0; generatorIndex<currentPartition.size; generatorIndex++)
    { int generatorPower=currentPartition.TheObjects[generatorIndex];
      tempElt.operator=(generatorsBeingActedOn.TheObjects[generatorIndex]);
      tempElt.RaiseToPower(generatorPower);
      Accum.MultiplyBy(tempElt);
    }
    tempElt.operator=(Accum);
    tempElt.SetNumVariables(numVars);
    candidateElements.AddObjectOnTop(tempElt);
//    out << "<br>" << Accum.ElementToString(true);
    for (int j=0; j<theGenerators.size; j++)
    { tempElt2.operator=(theGenerators.TheObjects[j]);
      tempElt2.SetNumVariables(numVars);
      tempElt2.LieBracketOnTheRight(tempElt, currentOutput);
//      currentOutput.ComputeDebugString();
//      std::cout<< currentOutput.DebugString;
      currentOutput.Simplify();
      if (numVars==0)
        currentOutput.ModOutVermaRelations(true);
      else
        currentOutput.ModOutVermaRelations(false);
      theBracketsOfTheElements.AddObjectOnTop(currentOutput);
      out << "<br>";
      //out << "<div class=\"math\">";
      out << "[" << theGenerators.TheObjects[j].ElementToString() << "," << Accum.ElementToString() << "]=";
      //out << "\\begin{eqnarray*}&&";
      out << currentOutput.ElementToString();
      //out << "  (mod Verma relations)";
      //out << "\\end{eqnarray*}</div>";
    }
  }
  out << "<br>number of monomials of given degree: " << candidateElements.size;
  List<rootPoly> theBasisRootForm;
  ElementUniversalEnveloping theMonBasis;
  ElementUniversalEnveloping::GetCoordinateFormOfSpanOfElements(numVars, theBracketsOfTheElements, theBasisRootForm, theMonBasis, theGlobalVariables);
  std::string tempS;
  out << "<br>...and the monomial basis is(" << theMonBasis.size << " elements total): ";
  for (int i=0; i<theMonBasis.size; i++)
    out << theMonBasis.TheObjects[i].ElementToString(false) << ", ";
  Matrix<RationalFunction> theSystem;
  theSystem.init(theMonBasis.size*theGenerators.size, candidateElements.size);
  for (int k=0; k<theGenerators.size; k++)
    for (int i=0; i<candidateElements.size; i++)
    { rootPoly& currentRoot=theBasisRootForm.TheObjects[k+i*theGenerators.size];
      //out << "<br>root index" << i << ": " << currentRoot.ElementToString();
      for (int j=0; j<currentRoot.size; j++)
        theSystem.elements[currentRoot.size*k+j][i]=currentRoot.TheObjects[j];
    }
  out << "<br>...and the system is: <div class=\"math\">" <<  theSystem.ElementToString(false, true) << "</div>";
  List<List<RationalFunction> > theEigenVectors;
  PolynomialRationalCoeff::PreferredHashSize=50;
  RationalFunction oneRF, minusOneRF, zeroRF;
  oneRF.MakeNVarConst(numVars, (Rational) 1, &theGlobalVariables);
  minusOneRF.MakeNVarConst(numVars, (Rational) -1, &theGlobalVariables);
  zeroRF.MakeNVarConst(numVars, (Rational) 0, &theGlobalVariables);

  theSystem.FindZeroEigenSpacE(theEigenVectors, oneRF, minusOneRF, zeroRF, theGlobalVariables);
  out << "<br> the dim of the eigen space: " << theEigenVectors.size;
  rootPoly tempProot;

  for (int i=0; i<theEigenVectors.size; i++)
  { List<RationalFunction>& currentEigen=theEigenVectors.TheObjects[i];
    RationalFunction::ScaleClearDenominator(currentEigen, tempProot);
    tempElt.AssignFromCoordinateFormWRTBasis(candidateElements, tempProot, *this);
    out << "<br>" << tempElt.ElementToString();
  }
}

std::string EigenVectorComputation::ComputeEigenVectorsOfWeight
  (HomomorphismSemisimpleLieAlgebra& inputHmm, SemisimpleLieAlgebraOrdered& theOwner, List<ElementUniversalEnveloping>& output, root& theWeight, GlobalVariables& theGlobalVariables)
{ output.size=0;
  roots PosRootsEmbeddings, PosRootsProjections;
  std::stringstream out;
  int theDimension=inputHmm.theRange.theWeyl.CartanSymmetric.NumRows;
  int theDomainDimension= inputHmm.theDomain.theWeyl.CartanSymmetric.NumRows;
  int numPosRootsDomain=inputHmm.theDomain.theWeyl.RootsOfBorel.size;
  int numPosRootsRange=inputHmm.theRange.theWeyl.RootsOfBorel.size;
  PosRootsEmbeddings.SetSize(numPosRootsDomain);
  for (int i=0; i<numPosRootsDomain; i++)
  { PosRootsEmbeddings.TheObjects[i].MakeZero(theDimension);
    for (int j=0; j<theDomainDimension; j++)
      PosRootsEmbeddings.TheObjects[i]+=inputHmm.imagesAllChevalleyGenerators.TheObjects[numPosRootsDomain+j].Hcomponent*inputHmm.theDomain.theWeyl.RootsOfBorel.TheObjects[i].TheObjects[j];
  }
  out << "Embeddings of roots:" << PosRootsEmbeddings.ElementToString(false, true, true);
  PosRootsProjections.SetSize(numPosRootsRange);
  for (int i=0; i<numPosRootsRange; i++)
    inputHmm.ProjectOntoSmallCartan(inputHmm.theRange.theWeyl.RootsOfBorel.TheObjects[i], PosRootsProjections.TheObjects[i], theGlobalVariables);
  out << "<br>Projections of roots in simple root coordinates with respect to the subalgebra: " << PosRootsProjections.ElementToString(false, true, true);
  VectorPartition theVP;
  theVP.PartitioningRoots=PosRootsProjections;
  theVP.theRoot=theWeight;
  theVP.ComputeAllPartitions();
  out << "the partitions: <br>" << theVP.ElementToString(true);
  output.SetSize(theVP.thePartitions.size);
  MonomialUniversalEnveloping currentMon;
  ElementUniversalEnveloping tempElt;
  for (int i=0; i<output.size; i++)
  { currentMon.Nullify(theDomainDimension, inputHmm.theRange);
    Rational tempRat=1;
    currentMon.Coefficient.ComputeDebugString();
    currentMon.Coefficient.MakeNVarConst((int)theDimension, tempRat);
    for (int j=theVP.thePartitions.TheObjects[i].size-1; j>=0; j--)
      currentMon.MultiplyByGeneratorPowerOnTheRight(inputHmm.theRange.RootToIndexInUE(-inputHmm.theRange.theWeyl.RootsOfBorel.TheObjects[j]), theVP.thePartitions.TheObjects[i].TheObjects[j]);
    out << currentMon.ElementToString(false) << "<br>" ;
    tempElt.Nullify(inputHmm.theRange);
    tempElt.AddObjectOnTopHash(currentMon);
    output.TheObjects[i]=tempElt;
  }
  List<List<ElementUniversalEnveloping> > targets;
  List<List<ElementUniversalEnveloping> > targetsNoMod;
  targets.SetSize(theDomainDimension);
  targetsNoMod.SetSize(theDomainDimension);
  ElementUniversalEnveloping theSimpleGenerator;
  std::string beginMath = "<DIV class=\"math\" scale=\"50\">";
  std::string endMath = "</DIV>";
  List<List<PolynomialRationalCoeff> > theSystem;
  theSystem.size=0;
  theSystem.SetSize(output.size);
  ElementUniversalEnveloping basisMonomialBuffer;
  for (int i=0; i<targets.size; i++)
  { List<ElementUniversalEnveloping>& currentTargets= targets.TheObjects[i];
    List<ElementUniversalEnveloping>& currentTargetsNoMod= targetsNoMod.TheObjects[i];
    theSimpleGenerator.AssignElementLieAlgebra(inputHmm.imagesSimpleChevalleyGenerators.TheObjects[i], theDimension, inputHmm.theRange);
    theSimpleGenerator.ComputeDebugString();
    out << "Generator number " << i+1 << ": " << beginMath;
    for (int j=0; j<output.size; j++)
    { theSimpleGenerator.LieBracketOnTheRight(output.TheObjects[j], tempElt);
      tempElt.Simplify();
      currentTargetsNoMod.AddObjectOnTop(tempElt);
      tempElt.ModOutVermaRelations();
      currentTargets.AddObjectOnTop(tempElt);
      out << tempElt.ElementToString() << ", \\quad ";
    }
    out << endMath << "\n<br>";
    out << "Elements before modding out: " << beginMath;
    for (int j=0; j<output.size; j++)
      out << currentTargetsNoMod.TheObjects[j].ElementToString() << ", \\quad ";
    out << endMath << "\n<br>";
    List<rootPoly> tempList;
    //Let the monomials corresponding to the given partition be m_1, \dots, m_l
    //Let the Chevalley generators of the smaller Lie algebra be k_1,\dots, k_s
    //Then the elements [k_i, m_1], \dots, [k_i, m_l] are recorded in this order in currentTargets
    ElementUniversalEnveloping::GetCoordinateFormOfSpanOfElements(theDimension, currentTargets, tempList, basisMonomialBuffer, theGlobalVariables);
    out << "Coordinate form of the above elements: ";
    for (int j=0; j<tempList.size; j++)
    { out << tempList.TheObjects[j].ElementToString() << ",";
      //theSystem holds in the j^th row the action on the monomial m_j
      theSystem.TheObjects[j].AddListOnTop(tempList.TheObjects[j]);
    }
    out << "<br>";
  }
  Matrix<RationalFunction> matSystem;
  int numEquations=theSystem.TheObjects[0].size;
  matSystem.init(numEquations, output.size);
  for (int i=0; i<matSystem.NumRows; i++)
    for (int j=0; j<matSystem.NumCols; j++)
      matSystem.elements[i][j]=theSystem.TheObjects[j].TheObjects[i];
  matSystem.ComputeDebugString(false, true);
  out << "<br>The system we need to solve:<br>" << beginMath << matSystem.DebugString << endMath << "<br>";
  RationalFunction ZeroRF, unitRF, MinusUnitPoly;
  ZeroRF.MakeNVarConst(theDimension, (Rational) 0, &theGlobalVariables);
  unitRF.MakeNVarConst(theDimension, (Rational) 1, &theGlobalVariables);
  PolynomialRationalCoeff unitPoly, zeroPolynomial;
  unitPoly.MakeNVarConst(theDimension, (Rational) 1);
  zeroPolynomial.Nullify(theDimension);
  MinusUnitPoly.MakeNVarConst(theDimension, (Rational) -1, &theGlobalVariables);
  List<List<RationalFunction> > theAnswer;
  matSystem.FindZeroEigenSpacE(theAnswer, unitRF, MinusUnitPoly, ZeroRF, theGlobalVariables);
  out << "The found solutions: <br>";
  rootRationalFunction tempRatRoot;
  std::string tempS;
  ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff> tempEltOrdered, AccumOrdered;
  PolynomialRationalCoeff tempP;
  PolynomialsRationalCoeff theSub;
  PolynomialOutputFormat polyformatLocal;
  polyformatLocal.MakeAlphabetyi();
  this->PrepareCartanSub(theOwner, theSub, theGlobalVariables);
  for (int i=0; i<theAnswer.size; i++)
  { tempRatRoot.CopyFromBase(theAnswer.TheObjects[i]);
    tempRatRoot.ScaleToPolynomial();
    AccumOrdered.Nullify(theOwner);
    out << beginMath << tempRatRoot.ElementToString() << endMath << "<br>";
    out << "Corresponding expression in monomial form: " << beginMath;
    for (int j=0; j<output.size; j++)
    { RationalFunction& currentCoeff= theAnswer.TheObjects[i].TheObjects[j];
      if (!currentCoeff.IsEqualToZero())
      { tempS= currentCoeff.ElementToString(true, false);
        if (tempS=="-1")
          out << "-";
        else
        { if (j!=0)
            out << "+";
          if (tempS!="1")
            out << "(" << tempS << ")";
        }
        out << output.TheObjects[j].ElementToString();
        tempEltOrdered.AssignElementUniversalEnveloping(output.TheObjects[j], theOwner, unitPoly, zeroPolynomial, &theGlobalVariables);
        tempRatRoot.TheObjects[j].GetNumerator(tempP);
        tempP.Substitution(theSub, theDimension, (Rational) 1);
        tempEltOrdered.operator*=(tempP);
      }
      AccumOrdered.operator+=(tempEltOrdered);
    }
    out << endMath << "<br>";
    out << "Corresponding ordered expression: " << "<div class=\"math\">\\begin{eqnarray*}&&" << AccumOrdered.ElementToString(true, polyformatLocal) << "\\end{eqnarray*}</div><br>";
  }
  return out.str();
}

void EigenVectorComputation::PrepareCartanSub
(SemisimpleLieAlgebraOrdered& theOwner, PolynomialsRationalCoeff& outputSub, GlobalVariables& theGlobalVariables)
{ MatrixLargeRational MatrixCartanSub;
  int theDimension=theOwner.theOwner.GetRank();
  MatrixCartanSub.init(theDimension, theDimension);
  for (int i=0; i<theDimension; i++)
    for (int j=0; j<theDimension; j++)
      MatrixCartanSub.elements[i][j]=theOwner.theOrder.TheObjects[i+theOwner.theOwner.GetNumPosRoots()].Hcomponent.TheObjects[j];
  MatrixCartanSub.Invert(theGlobalVariables);
  root tempRoot; tempRoot.MakeZero(theDimension);
  outputSub.SetSize(theDimension);
  for (int i=0; i<theDimension; i++)
  { MatrixCartanSub.RowToRoot(i, tempRoot);
    tempRoot.ComputeDebugString();
    outputSub.TheObjects[i].MakeLinPolyFromRoot(tempRoot);
  }
}

std::string EigenVectorComputation::ComputeEigenVectorsOfWeightConventionOrdered
  (HomomorphismSemisimpleLieAlgebra& inputHmm, SemisimpleLieAlgebraOrdered& theOwner, List<ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff> >& output, root& theWeight, GlobalVariables& theGlobalVariables)
{ output.size=0;
  roots PosRootsProjections;
  std::stringstream out;
  int theDimension=inputHmm.theRange.theWeyl.CartanSymmetric.NumRows;
  int theDomainDimension= inputHmm.theDomain.theWeyl.CartanSymmetric.NumRows;
  int numPosRootsDomain=inputHmm.theDomain.theWeyl.RootsOfBorel.size;
  int numPosRootsRange=inputHmm.theRange.theWeyl.RootsOfBorel.size;
  PolynomialOutputFormat polyFormatLocal;
  PosRootsProjections.SetSize(numPosRootsRange);
  Rational tempRat;
  ElementSimpleLieAlgebra tempElt1;
  MatrixLargeRational invertedSmallCartan=inputHmm.theDomain.theWeyl.CartanSymmetric;
  invertedSmallCartan.Invert(theGlobalVariables);
  for (int i=0; i<numPosRootsRange; i++)
  { PosRootsProjections.TheObjects[i].MakeZero(theDomainDimension);
    ElementSimpleLieAlgebra& currentElt= theOwner.theOrder.TheObjects[i];
    for (int j=0; j<theDomainDimension; j++)
    { inputHmm.theRange.LieBracket(inputHmm.imagesAllChevalleyGenerators.TheObjects[numPosRootsDomain+j], currentElt, tempElt1);
      if (currentElt.IsProportionalTo(tempElt1, tempRat))
        PosRootsProjections.TheObjects[i].TheObjects[j]=-tempRat;
      else
        return "error: the given basis does not consist of eigen spaces with respect to the subalgebra.";
    }
    invertedSmallCartan.ActOnAroot(PosRootsProjections.TheObjects[i]);
  }
  out << "<br>Projections of roots in simple root coordinates with respect to the subalgebra: " << PosRootsProjections.ElementToString(false, true, true);
  //return out.str();
  VectorPartition theVP;
  theVP.PartitioningRoots=PosRootsProjections;
  theVP.theRoot=theWeight;
  theVP.ComputeAllPartitions();
  out << "the partitions: <br>" << theVP.ElementToString(true);
  output.SetSize(theVP.thePartitions.size);
  MonomialUniversalEnvelopingOrdered<PolynomialRationalCoeff> currentMon;
  ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff> tempElt;
  for (int i=0; i<output.size; i++)
  { currentMon.Nullify(theDomainDimension, theOwner, &theGlobalVariables);
    Rational tempRat=1;
    currentMon.Coefficient.ComputeDebugString();
    currentMon.Coefficient.MakeNVarConst(theDimension, tempRat);
    for (int j=theVP.thePartitions.TheObjects[i].size-1; j>=0; j--)
      currentMon.MultiplyByGeneratorPowerOnTheRight(j, theVP.thePartitions.TheObjects[i].TheObjects[j]);
    out << currentMon.ElementToString(false, true, polyFormatLocal) << "<br>" ;
    tempElt.Nullify(theOwner);
    tempElt.AddObjectOnTopHash(currentMon);
    output.TheObjects[i]=tempElt;
  }
  List<List<ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff> > > targets;
  List<List<ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff> > > targetsNoMod;
  targets.SetSize(theDomainDimension);
  targetsNoMod.SetSize(theDomainDimension);
  ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff> theSimpleGenerator;
  std::string beginMath = "<DIV class=\"math\" scale=\"50\">";
  std::string endMath = "</DIV>";
  List<List<PolynomialRationalCoeff> > theSystem;
  theSystem.size=0;
  theSystem.SetSize(output.size);
  ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff> basisMonomialBuffer;
  PolynomialsRationalCoeff theSub;
  PolynomialRationalCoeff polyOne, polyZero;
  polyOne.MakeNVarConst(theDimension, (Rational)1);
  RationalFunction RFOne;
  RFOne=polyOne;
  polyZero.Nullify(theDimension);
  this->PrepareCartanSub(theOwner, theSub, theGlobalVariables);
  for (int i=0; i<targets.size; i++)
  { List<ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff> >& currentTargets= targets.TheObjects[i];
    List<ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff> >& currentTargetsNoMod= targetsNoMod.TheObjects[i];
    theSimpleGenerator.AssignElementLieAlgebra(inputHmm.imagesSimpleChevalleyGenerators.TheObjects[i], polyOne, polyZero, theOwner);
    theSimpleGenerator.ComputeDebugString();
    out << "Generator number " << i+1 << ": " << beginMath;
    for (int j=0; j<output.size; j++)
    { theSimpleGenerator.LieBracketOnTheRight(output.TheObjects[j], tempElt);
      tempElt.Simplify(&theGlobalVariables);
      currentTargetsNoMod.AddObjectOnTop(tempElt);
      tempElt.ModOutVermaRelations(false, theSub, &theGlobalVariables, polyOne);
      currentTargets.AddObjectOnTop(tempElt);
      out << tempElt.ElementToString() << ", \\quad ";
    }
    out << endMath << "\n<br>";
    out << "Elements before modding out: " << beginMath;
    for (int j=0; j<output.size; j++)
      out << currentTargetsNoMod.TheObjects[j].ElementToString() << ", \\quad ";
    out << endMath << "\n<br>";
    List<rootPoly> tempList;
    //Let the monomials corresponding to the given partition be m_1, \dots, m_l
    //Let the Chevalley generators of the smaller Lie algebra be k_1,\dots, k_s
    //Then the elements [k_i, m_1], \dots, [k_i, m_l] are recorded in this order in currentTargets
    ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff>::GetCoordinateFormOfSpanOfElements(theDimension, currentTargets, tempList, basisMonomialBuffer, theGlobalVariables);
    out << "Coordinate form of the above elements: ";
    for (int j=0; j<tempList.size; j++)
    { out << tempList.TheObjects[j].ElementToString() << ",";
      //theSystem holds in the j^th row the action on the monomial m_j
      theSystem.TheObjects[j].AddListOnTop(tempList.TheObjects[j]);
    }
    out << "<br>";
  }
  Matrix<RationalFunction> matSystem;
  int numEquations=theSystem.TheObjects[0].size;
  matSystem.init(numEquations, output.size);
  for (int i=0; i<matSystem.NumRows; i++)
    for (int j=0; j<matSystem.NumCols; j++)
      matSystem.elements[i][j]=theSystem.TheObjects[j].TheObjects[i];
  matSystem.ComputeDebugString(false, true);
  out << "<br>The system we need to solve:<br>" << beginMath << matSystem.DebugString << endMath << "<br>";
  RationalFunction ZeroRF, UnitPoly, MinusUnitPoly;
  ZeroRF.MakeNVarConst(theDimension, (Rational) 0, &theGlobalVariables);
  UnitPoly.MakeNVarConst(theDimension, (Rational) 1, &theGlobalVariables);
  MinusUnitPoly.MakeNVarConst(theDimension, (Rational) -1, &theGlobalVariables);
  List<List<RationalFunction> > theAnswer;
  //return out.str();
  matSystem.FindZeroEigenSpacE(theAnswer, UnitPoly, MinusUnitPoly, ZeroRF, theGlobalVariables);
  if (theAnswer.size>0)
    out << "The found solutions: <br>";
  else
    out << "No solutions<br>";
  rootRationalFunction tempRatRoot;
  std::string tempS;
  for (int i=0; i<theAnswer.size; i++)
  { tempRatRoot.CopyFromBase(theAnswer.TheObjects[i]);
    out << beginMath << tempRatRoot.ElementToString() << endMath << "<br>";
    out << "Corresponding expression in monomial form: " << beginMath;
    for (int j=0; j<output.size; j++)
    { RationalFunction& currentCoeff= theAnswer.TheObjects[i].TheObjects[j];
      if (!currentCoeff.IsEqualToZero())
      { tempS= currentCoeff.ElementToString(true, false);
        if (tempS=="-1")
          out << "-";
        else
        { if (j!=0)
            out << "+";
          if (tempS!="1")
            out << "(" << tempS << ")";
        }
        out << output.TheObjects[j].ElementToString();
      }
    }
    out << endMath << "<br>";
  }
  ElementUniversalEnvelopingOrdered<PolynomialRationalCoeff> tempOElt;
  for (int i=0; i<theOwner.theOrder.size; i++)
  { tempOElt.AssignElementLieAlgebra(theOwner.theOrder.TheObjects[i], polyOne, polyZero, theOwner);
    out << "<br>" << tempOElt.ElementToString(true, polyFormatLocal);
    out << " = " << theOwner.theOrder.TheObjects[i].ElementToStringNegativeRootSpacesFirst(true, false, inputHmm.theRange);
  }
  return out.str();
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::Simplify(GlobalVariables* theContext)
{ ElementUniversalEnvelopingOrdered buffer;
  ElementUniversalEnvelopingOrdered output;
  //this->ComputeDebugString();
  output.Nullify(*this->owner);
  for (int i=0; i<this->size; i++)
  { this->TheObjects[i].Simplify(buffer, theContext);
    output+=buffer;
    //output.ComputeDebugString();
  }
  *this=output;
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::Nullify(SemisimpleLieAlgebraOrdered& theOwner)
{ this->ClearTheObjects();
  this->owner=&theOwner;
}

template <class CoefficientType>
void MonomialUniversalEnvelopingOrdered<CoefficientType>::Simplify(ElementUniversalEnvelopingOrdered<CoefficientType>& output, GlobalVariables* theContext)
{ output.Nullify(*this->owner);
  output.AddObjectOnTopHash(*this);
  this->SimplifyAccumulateInOutputNoOutputInit(output, theContext);
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::CleanUpZeroCoeff()
{ for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].Coefficient.IsEqualToZero())
    { this->PopIndexSwapWithLastHash(i);
      i--;
    }
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::operator+=(const ElementUniversalEnvelopingOrdered<CoefficientType>& other)
{ this->MakeActualSizeAtLeastExpandOnTop(other.size);
  for (int i=0; i<other.size; i++)
    this->AddMonomialNoCleanUpZeroCoeff(other.TheObjects[i]);
  this->CleanUpZeroCoeff();
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::operator-=(const ElementUniversalEnvelopingOrdered<CoefficientType>& other)
{ this->MakeActualSizeAtLeastExpandOnTop(other.size);
  MonomialUniversalEnvelopingOrdered<CoefficientType> tempMon;
  for (int i=0; i<other.size; i++)
  { tempMon=other.TheObjects[i];
    tempMon.Coefficient.TimesConstant(-1);
    this->AddMonomialNoCleanUpZeroCoeff(tempMon);
  }
  this->CleanUpZeroCoeff();
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::operator*=(const CoefficientType& other)
{ if (other.IsEqualToZero())
  { this->Nullify(*this->owner);
    return;
  }
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].Coefficient.operator*=(other);
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::operator/=(const CoefficientType& other)
{ for (int i=0; i<this->size; i++)
    this->TheObjects[i].Coefficient.operator/=(other);
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::operator*=(const Rational& other)
{ if (other.IsEqualToZero())
  { this->Nullify(*this->owner);
    return;
  }
  for (int i=0; i<this->size; i++)
    this->TheObjects[i].Coefficient.TimesConstant(other);
}

template <class CoefficientType>
void MonomialUniversalEnvelopingOrdered<CoefficientType>::MultiplyByNoSimplify(const MonomialUniversalEnvelopingOrdered& other)
{ assert(this!=&other);
  this->generatorsIndices.MakeActualSizeAtLeastExpandOnTop(other.generatorsIndices.size+this->generatorsIndices.size);
  this->Powers.MakeActualSizeAtLeastExpandOnTop(other.generatorsIndices.size+this->generatorsIndices.size);
  this->Coefficient.MultiplyBy(other.Coefficient);
  if (other.generatorsIndices.size==0)
    return;
  int firstIndex=other.generatorsIndices.TheObjects[0];
  int i=0;
//  std::string tempS;
//  tempS=other.ElementToString();
  if (this->generatorsIndices.size>0)
    if (firstIndex==(*this->generatorsIndices.LastObject()))
    { //this->ComputeDebugString();
      *this->Powers.LastObject()+=other.Powers.TheObjects[0];
      i=1;
    }
  for (; i<other.generatorsIndices.size; i++)
  { this->Powers.AddObjectOnTop(other.Powers.TheObjects[i]);
    this->generatorsIndices.AddObjectOnTop(other.generatorsIndices.TheObjects[i]);
  }
}

template <class CoefficientType>
bool ElementUniversalEnvelopingOrdered<CoefficientType>::IsProportionalTo
 (const ElementUniversalEnvelopingOrdered<CoefficientType>& other, CoefficientType& outputTimesMeEqualsOther,
  const CoefficientType& theRingZero)const
{ if (this->IsEqualToZero())
  { if (other.IsEqualToZero())
      return true;
    return false;
  }
  if (other.IsEqualToZero())
  { outputTimesMeEqualsOther=theRingZero;
    return true;
  }
  if (other.size!=this->size)
    return false;
  MonomialUniversalEnvelopingOrdered<CoefficientType>& theMon= this->TheObjects[0];
  int theIndex=other.IndexOfObjectHash(theMon);
  if (theIndex==-1)
    return false;
  MonomialUniversalEnvelopingOrdered<CoefficientType>& otherMon= other.TheObjects[theIndex];
  theMon.ComputeDebugString();
  otherMon.ComputeDebugString();
  outputTimesMeEqualsOther=otherMon.Coefficient;
  outputTimesMeEqualsOther/=theMon.Coefficient;
  ElementUniversalEnvelopingOrdered<CoefficientType> tempElt;

  tempElt=*this;
  tempElt*=outputTimesMeEqualsOther;
  tempElt-=other;
  return tempElt.IsEqualToZero();
}

template<class CoefficientType>
void MonomialUniversalEnvelopingOrdered<CoefficientType>::operator*=
(const MonomialUniversalEnvelopingOrdered& other)
{ assert(this!=&other);
  this->Coefficient*=other.Coefficient;
  for (int i=0; i<other.generatorsIndices.size; i++)
    this->MultiplyByGeneratorPowerOnTheRight(other.generatorsIndices.TheObjects[i], other.Powers.TheObjects[i]);
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::operator*=(const ElementUniversalEnvelopingOrdered<CoefficientType>& other)
{ ElementUniversalEnvelopingOrdered output;
  output.Nullify(*this->owner);
  output.MakeActualSizeAtLeastExpandOnTop(this->size*other.size);
  MonomialUniversalEnvelopingOrdered<CoefficientType> tempMon;
  for (int i=0; i<this->size; i++)
    for(int j=0; j<other.size; j++)
    { tempMon=this->TheObjects[i];
      tempMon*=other.TheObjects[j];
      output.AddMonomial(tempMon);
    }
  *this=output;
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::AddMonomialNoCleanUpZeroCoeff(const MonomialUniversalEnvelopingOrdered<CoefficientType>& input)
{ int theIndex= this->IndexOfObjectHash(input);
  if (theIndex==-1)
    this->AddObjectOnTopHash(input);
  else
    this->TheObjects[theIndex].Coefficient+=input.Coefficient;
}

template <class CoefficientType>
void MonomialUniversalEnvelopingOrdered<CoefficientType>::SimplifyAccumulateInOutputNoOutputInit
(ElementUniversalEnvelopingOrdered<CoefficientType>& output, GlobalVariables* theContext)
{ int IndexlowestNonSimplified=0;
  ElementUniversalEnvelopingOrdered<CoefficientType> buffer2;
  MonomialUniversalEnvelopingOrdered<CoefficientType> tempMon;
  //simplified order is descending order
  while (IndexlowestNonSimplified<output.size)
  { bool reductionOccurred=false;
    if (output.TheObjects[IndexlowestNonSimplified].Coefficient.IsEqualToZero())
      reductionOccurred=true;
    else
      for (int i=0; i<output.TheObjects[IndexlowestNonSimplified].generatorsIndices.size-1; i++)
        if (output.TheObjects[IndexlowestNonSimplified].generatorsIndices.TheObjects[i]>output.TheObjects[IndexlowestNonSimplified].generatorsIndices.TheObjects[i+1])
        { if (output.TheObjects[IndexlowestNonSimplified].SwitchConsecutiveIndicesIfTheyCommute(i, tempMon, theContext))
          { output.AddMonomialNoCleanUpZeroCoeff(tempMon);
            tempMon.ComputeDebugString();
            reductionOccurred=true;
            break;
          }
          if (this->CommutingRightIndexAroundLeftIndexAllowed(output.TheObjects[IndexlowestNonSimplified].Powers.TheObjects[i], output.TheObjects[IndexlowestNonSimplified].generatorsIndices.TheObjects[i], output.TheObjects[IndexlowestNonSimplified].Powers.TheObjects[i+1], output.TheObjects[IndexlowestNonSimplified].generatorsIndices.TheObjects[i+1]))
          { output.TheObjects[IndexlowestNonSimplified].CommuteConsecutiveIndicesRightIndexAroundLeft(i, buffer2, theContext);
            for (int j=0; j<buffer2.size; j++)
              output.AddMonomialNoCleanUpZeroCoeff(buffer2.TheObjects[j]);
            output.ComputeDebugString();
            reductionOccurred=true;
            break;
          }
          if (this->CommutingLeftIndexAroundRightIndexAllowed(output.TheObjects[IndexlowestNonSimplified].Powers.TheObjects[i], output.TheObjects[IndexlowestNonSimplified].generatorsIndices.TheObjects[i], output.TheObjects[IndexlowestNonSimplified].Powers.TheObjects[i+1], output.TheObjects[IndexlowestNonSimplified].generatorsIndices.TheObjects[i+1]))
          { output.TheObjects[IndexlowestNonSimplified].CommuteConsecutiveIndicesLeftIndexAroundRight(i, buffer2, theContext);
            for (int j=0; j<buffer2.size; j++)
              output.AddMonomialNoCleanUpZeroCoeff(buffer2.TheObjects[j]);
            output.ComputeDebugString();
            reductionOccurred=true;
            break;
          }
        }
    if (reductionOccurred)
      output.PopIndexSwapWithLastHash(IndexlowestNonSimplified);
    else
      IndexlowestNonSimplified++;
    output.ComputeDebugString();
  }
  output.CleanUpZeroCoeff();
}

template <class CoefficientType>
bool MonomialUniversalEnvelopingOrdered<CoefficientType>::SwitchConsecutiveIndicesIfTheyCommute
(int theLeftIndex, MonomialUniversalEnvelopingOrdered<CoefficientType>& output, GlobalVariables* theContext)
{ if (theLeftIndex>=this->generatorsIndices.size-1)
    return false;
  int theLeftGeneratorIndex=this->generatorsIndices.TheObjects[theLeftIndex];
  int theRightGeneratorIndex=this->generatorsIndices.TheObjects[theLeftIndex+1];
  ElementSimpleLieAlgebra tempElt;
  this->owner->theOwner.LieBracket(this->owner->theOrder.TheObjects[theLeftGeneratorIndex], this->owner->theOrder.TheObjects[theRightGeneratorIndex], tempElt);
  if (tempElt.IsEqualToZero())
  { output.generatorsIndices.MakeActualSizeAtLeastExpandOnTop(this->generatorsIndices.size);
    output.Powers.MakeActualSizeAtLeastExpandOnTop(this->generatorsIndices.size);
    output.Nullify(this->Coefficient.NumVars, *this->owner, theContext);
    output.Coefficient=this->Coefficient;
    //output.ComputeDebugString();
    for (int i=0; i<theLeftIndex; i++)
      output.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[i], this->Powers.TheObjects[i]);
    output.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[theLeftIndex+1], this->Powers.TheObjects[theLeftIndex+1]);
    output.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[theLeftIndex], this->Powers.TheObjects[theLeftIndex]);
    for (int i=theLeftIndex+2; i<this->generatorsIndices.size; i++)
      output.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[i], this->Powers.TheObjects[i]);
    return true;
  }
  return false;
}

template <class CoefficientType>
bool MonomialUniversalEnvelopingOrdered<CoefficientType>::CommutingRightIndexAroundLeftIndexAllowed(CoefficientType& theLeftPower, int leftGeneratorIndex, CoefficientType& theRightPower, int rightGeneratorIndex)
{ return this->CommutingLeftIndexAroundRightIndexAllowed(theRightPower, rightGeneratorIndex, theLeftPower, leftGeneratorIndex);
}

template <class CoefficientType>
void MonomialUniversalEnvelopingOrdered<CoefficientType>::CommuteConsecutiveIndicesRightIndexAroundLeft(int theIndeX, ElementUniversalEnvelopingOrdered<CoefficientType>& output, GlobalVariables* theContext)
{ if (theIndeX==this->generatorsIndices.size-1)
    return;
  output.Nullify(*this->owner);
  MonomialUniversalEnvelopingOrdered tempMon;
  tempMon.Nullify(this->Coefficient.NumVars, *this->owner, theContext);
  tempMon.Powers.MakeActualSizeAtLeastExpandOnTop(this->generatorsIndices.size+2);
  tempMon.generatorsIndices.MakeActualSizeAtLeastExpandOnTop(this->generatorsIndices.size+2);
  tempMon.Powers.size=0;
  tempMon.generatorsIndices.size=0;
  int rightGeneratorIndeX= this->generatorsIndices.TheObjects[theIndeX+1];
  int leftGeneratorIndeX=this->generatorsIndices.TheObjects[theIndeX];
  CoefficientType theRightPoweR, theLeftPoweR;
  theRightPoweR= this->Powers.TheObjects[theIndeX+1];
  theLeftPoweR= this->Powers.TheObjects[theIndeX];
  theRightPoweR-=1;
  int powerDroP=0;
//  if (this->flagAnErrorHasOccurredTimeToPanic)
//  if (this->ElementToString()=="2f_{5}f_{-5}f_{-4}" || this->ElementToString()=="2f_{11}f_{-4}")
//  { std::cout << "here we are!";
//    this->flagAnErrorHasOccurredTimeToPanic=true;
//  }

  CoefficientType acquiredCoefficienT, polyOne;
  acquiredCoefficienT=this->Coefficient;
  tempMon.Coefficient=this->Coefficient;
  for (int i=0; i<theIndeX; i++)
    tempMon.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[i], this->Powers.TheObjects[i]);
  MonomialUniversalEnvelopingOrdered startMon;
  startMon=tempMon;
  ElementSimpleLieAlgebra adResulT, tempElT, theLeftElt;
  this->owner->AssignGeneratorCoeffOne(rightGeneratorIndeX, adResulT);
  this->owner->AssignGeneratorCoeffOne(leftGeneratorIndeX, theLeftElt);
  //tempLefttElt.ComputeDebugString(*this->owner, false, false);
  polyOne.MakeNVarConst(this->Coefficient.NumVars, (Rational) 1, theContext);
  root theCoeffs;
  do
  { if(this->flagAnErrorHasOccurredTimeToPanic)
    { acquiredCoefficienT.ComputeDebugString();
      theRightPoweR.ComputeDebugString();
      theLeftPoweR.ComputeDebugString();
      adResulT.ComputeDebugString( false, false);
      tempMon.ComputeDebugString();
    }
    this->owner->GetLinearCombinationFrom(adResulT, theCoeffs);
    for (int i=0; i<theCoeffs.size; i++)
      if (theCoeffs.TheObjects[i]!=0)
      { int theNewGeneratorIndex=i;
        tempMon=startMon;
        if (this->flagAnErrorHasOccurredTimeToPanic)
        { tempMon.ComputeDebugString();
          this->ComputeDebugString();
        }
        tempMon.Coefficient=acquiredCoefficienT;
        if (this->flagAnErrorHasOccurredTimeToPanic)
        { tempMon.ComputeDebugString();
          this->ComputeDebugString();
        }
        tempMon.Coefficient.TimesConstant(theCoeffs.TheObjects[i]);
        if (this->flagAnErrorHasOccurredTimeToPanic)
        { tempMon.ComputeDebugString();
          this->ComputeDebugString();
        }
        tempMon.MultiplyByGeneratorPowerOnTheRight(theNewGeneratorIndex, polyOne);
        tempMon.MultiplyByGeneratorPowerOnTheRight(leftGeneratorIndeX, theLeftPoweR);
        tempMon.MultiplyByGeneratorPowerOnTheRight(rightGeneratorIndeX, theRightPoweR);
        for (int i=theIndeX+2; i<this->generatorsIndices.size; i++)
          tempMon.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[i], this->Powers.TheObjects[i]);
        if (this->flagAnErrorHasOccurredTimeToPanic)
        { tempMon.ComputeDebugString();
          this->ComputeDebugString();
        }
        output.AddObjectOnTopHash(tempMon);
      }
    acquiredCoefficienT.MultiplyBy(theLeftPoweR);
    theLeftPoweR-=1;
    this->owner->theOwner.LieBracket(theLeftElt, adResulT, tempElT);
    adResulT=tempElT;
    powerDroP++;
    acquiredCoefficienT/=powerDroP;
    if (this->flagAnErrorHasOccurredTimeToPanic)
      adResulT.ComputeDebugString(false, false);
  }while(!adResulT.IsEqualToZero() && !acquiredCoefficienT.IsEqualToZero());
}

template <class CoefficientType>
void MonomialUniversalEnvelopingOrdered<CoefficientType>::CommuteConsecutiveIndicesLeftIndexAroundRight(int theIndeX, ElementUniversalEnvelopingOrdered<CoefficientType>& output, GlobalVariables* theContext)
{ if (theIndeX==this->generatorsIndices.size-1)
    return;
  output.Nullify(*this->owner);
  MonomialUniversalEnvelopingOrdered tempMon;
  tempMon.Nullify(this->Coefficient.NumVars, *this->owner, theContext);
  tempMon.Powers.MakeActualSizeAtLeastExpandOnTop(this->generatorsIndices.size+2);
  tempMon.generatorsIndices.MakeActualSizeAtLeastExpandOnTop(this->generatorsIndices.size+2);
  tempMon.Powers.size=0;
  tempMon.generatorsIndices.size=0;
  int rightGeneratorIndex= this->generatorsIndices.TheObjects[theIndeX+1];
  int leftGeneratorIndex=this->generatorsIndices.TheObjects[theIndeX];
  CoefficientType theRightPower, theLeftPower;
  theRightPower= this->Powers.TheObjects[theIndeX+1];
  theLeftPower= this->Powers.TheObjects[theIndeX];
  theLeftPower-=1;
  int powerDrop=0;
 /* if (this->ElementToString()=="2f_{5}f_{-5}f_{-4}" || this->ElementToString()=="2f_{11}f_{-4}")
  { std::cout << "here we are!";
    this->flagAnErrorHasOccurredTimeToPanic=true;
  }*/

  CoefficientType acquiredCoefficient, polyOne;
  acquiredCoefficient.Assign(this->Coefficient);
  tempMon.Coefficient=this->Coefficient;
  for (int i=0; i<theIndeX; i++)
    tempMon.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[i], this->Powers.TheObjects[i]);
  tempMon.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[theIndeX], theLeftPower);
  MonomialUniversalEnvelopingOrdered startMon, tempMon2;
  startMon=tempMon;
  ElementSimpleLieAlgebra adResult, tempElt, tempRightElt;
  this->owner->AssignGeneratorCoeffOne(leftGeneratorIndex, adResult);
  this->owner->AssignGeneratorCoeffOne(rightGeneratorIndex, tempRightElt);
//  tempRightElt.ComputeDebugString(*this->owner, false, false);
  polyOne.MakeNVarConst(this->Coefficient.NumVars, (Rational) 1, theContext);
  root theCoeffs;
  do
  { //acquiredCoefficient.ComputeDebugString();
    //theRightPower.ComputeDebugString();
    //adResult.ComputeDebugString(*this->owner, false, false);
    //tempMon.ComputeDebugString();
    //tempMon.ComputeDebugString();
    this->owner->GetLinearCombinationFrom(adResult, theCoeffs);
    for (int i=0; i<theCoeffs.size; i++)
      if(theCoeffs.TheObjects[i]!=0)
      { int theNewGeneratorIndex= i;
        tempMon=startMon;
        tempMon.MultiplyByGeneratorPowerOnTheRight(rightGeneratorIndex, theRightPower);
        tempMon.Coefficient=acquiredCoefficient;
        tempMon.Coefficient.TimesConstant(theCoeffs.TheObjects[i]);
        tempMon.MultiplyByGeneratorPowerOnTheRight(theNewGeneratorIndex, polyOne);
        for (int i=theIndeX+2; i<this->generatorsIndices.size; i++)
          tempMon.MultiplyByGeneratorPowerOnTheRight(this->generatorsIndices.TheObjects[i], this->Powers.TheObjects[i]);
        output.AddObjectOnTopHash(tempMon);
      }
    acquiredCoefficient.MultiplyBy(theRightPower);
    theRightPower-=1;
    this->owner->theOwner.LieBracket(adResult, tempRightElt, tempElt);
    adResult=tempElt;
    powerDrop++;
    acquiredCoefficient/=powerDrop;
    //adResult.ComputeDebugString(*this->owner, false, false);
  }while(!adResult.IsEqualToZero() && !acquiredCoefficient.IsEqualToZero());
}

template <class CoefficientType>
bool MonomialUniversalEnvelopingOrdered<CoefficientType>::CommutingLeftIndexAroundRightIndexAllowed(CoefficientType& theLeftPower, int leftGeneratorIndex, CoefficientType& theRightPower, int rightGeneratorIndex)
{ int tempInt;
  if (theLeftPower.IsSmallInteger(tempInt))
  { if(theRightPower.IsSmallInteger(tempInt))
      return true;
    int numPosRoots=this->owner->theOwner.theWeyl.RootsOfBorel.size;
    int theDimension= this->owner->theOwner.theWeyl.CartanSymmetric.NumRows;
    if(rightGeneratorIndex>= numPosRoots && rightGeneratorIndex<numPosRoots+theDimension)
    { ElementSimpleLieAlgebra tempElt;
      this->owner->theOwner.LieBracket(this->owner->theOrder.TheObjects[leftGeneratorIndex], this->owner->theOrder.TheObjects[rightGeneratorIndex], tempElt);
      if (tempElt.IsEqualToZero())
        return true;
      else
        return false;
    } else
      return true;
  }
  return false;
}

template <class CoefficientType>
void MonomialUniversalEnvelopingOrdered<CoefficientType>::Nullify(int numVars, SemisimpleLieAlgebraOrdered& theOwner, GlobalVariables* theContext)
{ this->Coefficient.Nullify((int)numVars, theContext);
  this->owner=&theOwner;
  this->generatorsIndices.size=0;
  this->Powers.size=0;
}

template <class CoefficientType>
void MonomialUniversalEnvelopingOrdered<CoefficientType>::Nullify(const CoefficientType& theRingZero, SemisimpleLieAlgebraOrdered& theOwner)
{ this->Coefficient=theRingZero;
  this->owner=&theOwner;
  this->generatorsIndices.size=0;
  this->Powers.size=0;
}

template <class CoefficientType>
int MonomialUniversalEnvelopingOrdered<CoefficientType>::HashFunction() const
{ int top=MathRoutines::Minimum(SomeRandomPrimesSize, this->generatorsIndices.size);
  int result=0;
  for (int i=0; i<top; i++)
    result+=SomeRandomPrimes[i]*this->generatorsIndices.TheObjects[i];
  return result;
}

template <class CoefficientType>
void MonomialUniversalEnvelopingOrdered<CoefficientType>::MultiplyByGeneratorPowerOnTheRight(int theGeneratorIndex, int thePower)
{ if (thePower==0)
    return;
  PolynomialRationalCoeff tempP;
  tempP.MakeNVarConst(this->Coefficient.NumVars, thePower);
  this->MultiplyByGeneratorPowerOnTheRight(theGeneratorIndex, tempP);
}

template <class CoefficientType>
void MonomialUniversalEnvelopingOrdered<CoefficientType>::MultiplyByGeneratorPowerOnTheRight(int theGeneratorIndex, const CoefficientType& thePower)
{ if (thePower.IsEqualToZero())
    return;
  if (this->generatorsIndices.size>0)
    if (*this->generatorsIndices.LastObject()==theGeneratorIndex)
    { (*this->Powers.LastObject())+=thePower;
      return;
    }
  this->Powers.AddObjectOnTop(thePower);
  this->generatorsIndices.AddObjectOnTop(theGeneratorIndex);
}

void SemisimpleLieAlgebraOrdered::GetLinearCombinationFrom
  (ElementSimpleLieAlgebra& input, root& theCoeffs)
{ theCoeffs.MakeZero(this->theOwner.GetNumGenerators());
  for (int i=0; i<input.NonZeroElements.CardinalitySelection; i++)
  { int theIndex=input.NonZeroElements.elements[i];
    theCoeffs.TheObjects[this->theOwner.RootIndexOrderAsInRootSystemToGeneratorIndexNegativeRootsThenCartanThenPositive(theIndex)]=input.coeffsRootSpaces.TheObjects[theIndex];
  }
  int numPosRoots=this->theOwner.GetNumPosRoots();
  for (int i=0; i<input.Hcomponent.size; i++)
    theCoeffs.TheObjects[numPosRoots+i]= input.Hcomponent.TheObjects[i];
  this->ChevalleyGeneratorsInCurrentCoords.ActOnAroot(theCoeffs);
}

int SemisimpleLieAlgebraOrdered::GetDisplayIndexFromGeneratorIndex(int GeneratorIndex)
{ int numPosRoots=this->theOwner.GetNumPosRoots();
  int posRootsPlusRank=numPosRoots+this->theOwner.GetRank();
  if (GeneratorIndex>= posRootsPlusRank )
    return GeneratorIndex-posRootsPlusRank+1;
  if (GeneratorIndex>=numPosRoots)
    return GeneratorIndex+1;
  return -numPosRoots+GeneratorIndex;
}

void SemisimpleLieAlgebraOrdered::init
(List<ElementSimpleLieAlgebra>& inputOrder, SemisimpleLieAlgebra& owner, GlobalVariables& theGlobalVariables)
{ if (inputOrder.size!=owner.GetNumGenerators())
    return;
  this->theOwner=owner;
  this->theOrder=inputOrder;
  this->ChevalleyGeneratorsInCurrentCoords.init(owner.GetNumGenerators(), owner.GetNumGenerators());
  this->ChevalleyGeneratorsInCurrentCoords.NullifyAll();
  ElementSimpleLieAlgebra tempElt;
  Vector<Rational> coordsInCurrentBasis;
  ElementSimpleLieAlgebra currentElt;
  for (int i=0; i<owner.GetNumGenerators(); i++)
  { currentElt.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(i, this->theOwner);
    currentElt.GetCoordsInBasis(this->theOrder, coordsInCurrentBasis, theGlobalVariables);
    for (int j=0; j<coordsInCurrentBasis.size; j++)
      this->ChevalleyGeneratorsInCurrentCoords.elements[j][i]=coordsInCurrentBasis.TheObjects[j];
//    std::cout << "<br> " << currentElt.ElementToString() << " in new coords becomes: " << coordsInCurrentBasis.ElementToString();
  }
//  std::cout << this->ChevalleyGeneratorsInCurrentCoords.ElementToString(true, false) << "<br><br>";

 // this->ChevalleyGeneratorsInCurrentCoords.Invert(theGlobalVariables);
  //std::cout << this->ChevalleyGeneratorsInCurrentCoords.ElementToString(true, false);
}

void SemisimpleLieAlgebraOrdered::initDefaultOrder
  (SemisimpleLieAlgebra& owner, GlobalVariables& theGlobalVariables)
{ List<ElementSimpleLieAlgebra> defaultOrder;
  defaultOrder.SetSize(owner.GetNumGenerators());
  for (int i=0; i<defaultOrder.size; i++)
  { ElementSimpleLieAlgebra& currentElt=defaultOrder.TheObjects[i];
    currentElt.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(i, owner);
  }
  this->init(defaultOrder, owner, theGlobalVariables);
}

bool ElementSimpleLieAlgebra::MustUseBracketsWhenDisplayingMeRaisedToPower()
{ if (this->NonZeroElements.CardinalitySelection==1 && this->Hcomponent.IsEqualToZero())
    if (this->coeffsRootSpaces.TheObjects[this->NonZeroElements.elements[0]]==1)
      return false;
  if (this->NonZeroElements.CardinalitySelection==0)
  { int numNonZeroElements=0;
    for (int i=0; i<this->Hcomponent.size; i++)
    { if (this->Hcomponent.TheObjects[i]!=1 && this->Hcomponent.TheObjects[i]!=0)
        return true;
      if (this->Hcomponent.TheObjects[i]==1)
        numNonZeroElements++;
    }
    if (numNonZeroElements<=1)
      return false;
  }
  return true;
}

template <class CoefficientType>
std::string MonomialUniversalEnvelopingOrdered<CoefficientType>::ElementToString(bool useLatex, bool useGeneratorLetters, const PolynomialOutputFormat& PolyFormatLocal)const
{ if (this->owner==0)
    return "faulty monomial non-initialized owner. Slap the programmer.";
  if (this->IsEqualToZero())
    return "0";
  std::stringstream out;
  std::string tempS;
  if (this->generatorsIndices.size>0)
  { tempS= MathRoutines::ElementToStringBrackets(this->Coefficient);
    if (tempS=="1")
      tempS="";
    if (tempS=="-1")
      tempS="-";
  } else
    tempS= this->Coefficient.ElementToString(PolyFormatLocal);
  out <<tempS;
  for (int i=0; i<this->generatorsIndices.size; i++)
  { CoefficientType& thePower=this->Powers.TheObjects[i];
    int theIndex=this->generatorsIndices.TheObjects[i];
    if (!useGeneratorLetters)
      tempS=this->owner->theOrder.TheObjects[theIndex].ElementToStringNegativeRootSpacesFirst(false, false, this->owner->theOwner);
    else
    { std::stringstream tempStream;
      tempStream << "f_{" << this->owner->GetDisplayIndexFromGeneratorIndex(theIndex) << "}";
      tempS=tempStream.str();
    }
    //if (thePower>1)
    //  out << "(";
    bool usebrackets=false;
    if (!useGeneratorLetters)
      usebrackets=this->owner->theOrder.TheObjects[theIndex].MustUseBracketsWhenDisplayingMeRaisedToPower();
    if (usebrackets)
      out << "(";
    out << tempS;
    if (usebrackets)
      out << ")";
    tempS=thePower.ElementToString(PolyFormatLocal);
    if (tempS!="1")
    { out << "^";
     // if (useLatex)
      out << "{";
      out << tempS;
      //if (useLatex)
      out << "}";
    }
    //if (thePower>1)
    //  out << ")";
  }
  return out.str();
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::ElementToString
(std::string& output, bool useLatex, const PolynomialOutputFormat& PolyFormatLocal)const
{ std::stringstream out;
  std::string tempS;
  if (this->size==0)
    out << "0";
  int IndexCharAtLastLineBreak=0;
  for (int i=0; i<this->size; i++)
  { MonomialUniversalEnvelopingOrdered<CoefficientType>& current=this->TheObjects[i];
    tempS=current.ElementToString(false, true, PolyFormatLocal);
    if (i!=0)
      if (tempS.size()>0)
        if (tempS[0]!='-')
          out << '+';
    out << tempS;
    if (((int)out.tellp())- IndexCharAtLastLineBreak>150)
    { IndexCharAtLastLineBreak=out.tellp();
      out << "\\\\&&";
    }
  }
  output=out.str();
}

template <class CoefficientType>
bool ElementUniversalEnvelopingOrdered<CoefficientType>::AssignElementUniversalEnveloping
  (ElementUniversalEnveloping& input, SemisimpleLieAlgebraOrdered& owner, const CoefficientType& theRingUnit, const CoefficientType& theRingZero, GlobalVariables* theContext)
{ ElementUniversalEnvelopingOrdered<CoefficientType> tempElt;
  this->Nullify(owner);
  for (int i=0; i<input.size; i++)
  { if(!tempElt.AssignMonomialUniversalEnveloping(input.TheObjects[i], owner, theRingUnit, theRingZero, theContext))
      return false;
    this->operator+=(tempElt);
  }
  this->Simplify(theContext);
  return true;
}

template <class CoefficientType>
bool ElementUniversalEnvelopingOrdered<CoefficientType>::AssignMonomialUniversalEnveloping
  (MonomialUniversalEnveloping& input, SemisimpleLieAlgebraOrdered& owner, const CoefficientType& theRingUnit, const CoefficientType& theRingZero, GlobalVariables* theContext)
{ ElementUniversalEnvelopingOrdered theMon;
  ElementSimpleLieAlgebra tempElt;
  CoefficientType theCoeff;
  theCoeff=theRingUnit;
  theCoeff=input.Coefficient;
  this->MakeConst(theCoeff, owner);
  //std::cout << "<br>after initialization with constant I am " << this->ElementToString();
  for (int i=0; i<input.generatorsIndices.size; i++)
  { int thePower;
    bool isASmallInt=input.Powers.TheObjects[i].IsSmallInteger(thePower);
    if (isASmallInt)
    { tempElt.AssignChevalleyGeneratorCoeffOneIndexNegativeRootspacesFirstThenCartanThenPositivE(input.generatorsIndices.TheObjects[i], owner.theOwner);
      theMon.AssignElementLieAlgebra(tempElt, theRingUnit, theRingZero, owner);
      //std::cout << "<br>raising " << theMon.ElementToString() << " to power " << thePower;
      theMon.RaiseToPower(thePower, theRingUnit);
      //std::cout << " to obtain " << theMon.ElementToString();
    }
    else
      return false;
    this->MultiplyBy(theMon);

  }
  //this->Simplify(theContext);
  return true;
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::AssignElementLieAlgebra
(const ElementSimpleLieAlgebra& input, const CoefficientType& theRingUnit, const CoefficientType& theRingZero, SemisimpleLieAlgebraOrdered& theOwner)
{ this->Nullify(theOwner);
  root ElementRootForm;
  input.ElementToVectorNegativeRootSpacesFirst(ElementRootForm);
  theOwner.ChevalleyGeneratorsInCurrentCoords.ActOnAroot(ElementRootForm);
  MonomialUniversalEnvelopingOrdered<CoefficientType> tempMon;
  tempMon.Nullify(theRingZero, theOwner);
  tempMon.generatorsIndices.SetSize(1);
  tempMon.Powers.SetSize(1);
  tempMon.Powers.TheObjects[0]=theRingUnit;
  for (int theIndex=0; theIndex<ElementRootForm.size; theIndex++)
    if ( ElementRootForm.TheObjects[theIndex]!=0)
    { tempMon.Coefficient=theRingUnit;
      tempMon.Coefficient*=ElementRootForm.TheObjects[theIndex];
      tempMon.generatorsIndices.TheObjects[0]=theIndex;
      this->AddObjectOnTopHash(tempMon);
    }
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::RaiseToPower(int thePower, const CoefficientType& theRingUnit)
{ if (this->size==0)
    return;
  ElementUniversalEnvelopingOrdered<CoefficientType> buffer;
  buffer.operator=(*this);
  this->MakeConst(theRingUnit, *this->owner);
  //std::cout << "<br>raising " <<buffer.ElementToString() << " to power " << thePower;
  for (int i=0; i<thePower; i++)
    this->operator*=(buffer);
  //std::cout << "<br> and the result is " << this->ElementToString();
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::LieBracketOnTheRight(const ElementUniversalEnvelopingOrdered& right, ElementUniversalEnvelopingOrdered& output)
{ ElementUniversalEnvelopingOrdered tempElt, tempElt2;
  tempElt=*this;
  tempElt*=right;
  tempElt2=right;
  tempElt2*=*this;
  output=tempElt;
  output-=tempElt2;
}

template<class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::AddMonomial(const MonomialUniversalEnvelopingOrdered<CoefficientType>& input)
{ if (input.IsEqualToZero())
    return;
  int theIndex= this->IndexOfObjectHash(input);
  if (theIndex==-1)
    this->AddObjectOnTopHash(input);
  else
  { this->TheObjects[theIndex].Coefficient+=input.Coefficient;
    if (this->TheObjects[theIndex].Coefficient.IsEqualToZero())
      this->PopIndexSwapWithLastHash(theIndex);
  }
}

bool ParserNode::ConvertToNextType
(int GoalType, bool& ErrorHasOccured, GlobalVariables& theGlobalVariables)
{ ErrorHasOccured=false;
  switch(this->ExpressionType)
  { case ParserNode::typePoly:
      this->polyValue.GetElement().SetNumVariablesSubDeletedVarsByOne(this->owner->NumVariables);
      break;
    case ParserNode::typeUEelement:
      this->UEElement.GetElement().SetNumVariables(this->owner->NumVariables);
      break;
    case ParserNode::typeUEElementOrdered:
      this->UEElementOrdered.GetElement().SetNumVariables(this->owner->NumVariables);
      break;
    case ParserNode::typeRationalFunction:
      this->ratFunction.GetElement().SetNumVariablesSubDeletedVarsByOne(this->owner->NumVariables);
      break;
    case ParserNode::typeWeylAlgebraElement:
      this->WeylAlgebraElement.GetElement().SetNumVariablesPreserveExistingOnes(this->owner->NumVariables);
      break;
  }
  if (GoalType==this->ExpressionType)
    return false;
  if (this->ExpressionType==this->typeIntegerOrIndex)
  { this->rationalValue= this->intValue;
    this->ExpressionType=this->typeRational;
    return true;
  }
  if (this->ExpressionType==this->typeRational)
  { this->polyValue.GetElement().MakeNVarConst((int)this->owner->NumVariables, this->rationalValue);
    this->ExpressionType=this->typePoly;
    return true;
  }
  if (this->ExpressionType==this->typePoly)
  { int typeToConvertTo=this->typeRationalFunction;
    if (GoalType==this->typeUEElementOrdered || GoalType==this->typeUEelement)
      typeToConvertTo=this->typeUEElementOrdered;
    if (GoalType==this->typeWeylAlgebraElement)
      typeToConvertTo=this->typeWeylAlgebraElement;
    switch (typeToConvertTo)
    { case ParserNode::typeUEelement:
        this->UEElement.GetElement().MakeConst(this->polyValue.GetElement(), *this->ContextLieAlgebra);
        this->ExpressionType=this->typeUEelement;
        return true;
      case ParserNode::typeWeylAlgebraElement:
        this->WeylAlgebraElement.GetElement().AssignPolynomial(this->polyValue.GetElement());
        this->ExpressionType=this->typeWeylAlgebraElement;
        return true;
      case ParserNode::typeRationalFunction:
        this->ratFunction.GetElement()=this->polyValue.GetElement();
        this->ExpressionType=this->typeRationalFunction;
        return true;
      case ParserNode::typeUEElementOrdered:
        this->UEElementOrdered.GetElement().MakeConst(this->polyValue.GetElement(), this->owner->testAlgebra);
        this->ExpressionType=this->typeUEElementOrdered;
        return true;
    }
  }
  if (this->ExpressionType==this->typeUEelement)
  { PolynomialRationalCoeff unitPoly, zeroPoly;
    unitPoly.MakeNVarConst(this->UEElement.GetElement().GetNumVariables(), (Rational) 1);
    zeroPoly.Nullify(unitPoly.NumVars);
    if (this->UEElementOrdered.GetElement().AssignElementUniversalEnveloping(this->UEElement.GetElement(), this->owner->testAlgebra, unitPoly, zeroPoly, &theGlobalVariables))
    { this->ExpressionType=this->typeUEElementOrdered;
      return true;
    } else
    { ErrorHasOccured=true;
      return false;
    }
  }
  if (this->ExpressionType==this->typeUEElementOrdered && GoalType==this->typeUEelement)
  { if (!this->UEElementOrdered.GetElement().GetElementUniversalEnveloping(this->UEElement.GetElement(), this->owner->theHmm.theRange))
    { ErrorHasOccured=true;
      return false;
    }
    this->ExpressionType=this->typeUEelement;
    return true;
  }
  return false;
}

bool ParserNode::ConvertToType
(int theType, GlobalVariables& theGlobalVariables)
{ if (this->ExpressionType==this->typeError)
    return false;
  if (theType==this->typeUndefined)
    return false;
  switch(this->ExpressionType)
  { case ParserNode::typeMapPolY: this->polyBeingMappedTo.GetElement().SetNumVariablesSubDeletedVarsByOne(this->owner->NumVariables);
    case ParserNode::typePoly: this->polyValue.GetElement().SetNumVariablesSubDeletedVarsByOne(this->owner->NumVariables); break;
    case ParserNode::typeRationalFunction: this->ratFunction.GetElement().SetNumVariablesSubDeletedVarsByOne(this->owner->NumVariables); break;
    case ParserNode::typeUEelement: this->UEElement.GetElement().SetNumVariables(this->owner->NumVariables); break;
    case ParserNode::typeUEElementOrdered: this->UEElementOrdered.GetElement().SetNumVariables(this->owner->NumVariables); break;
    case ParserNode::typeMapWeylAlgebra: this->weylEltBeingMappedTo.GetElement().SetNumVariablesPreserveExistingOnes(this->owner->NumVariables);
    case ParserNode::typeWeylAlgebraElement: this->WeylAlgebraElement.GetElement().SetNumVariablesPreserveExistingOnes(this->owner->NumVariables); break;
  }
  bool ConversionError;
  while (this->ConvertToNextType(theType, ConversionError, theGlobalVariables))
    if (ConversionError)
    { this->SetError(this->errorConversionError);
      return false;
    }
  if (this->ExpressionType!=theType)
  { this->SetError(this->errorConversionError);
    return false;
  }
  return true;
}

template <class CoefficientType>
bool ElementUniversalEnvelopingOrdered<CoefficientType>::GetElementUniversalEnveloping
  (ElementUniversalEnveloping& output, SemisimpleLieAlgebra& owner)
{ ElementUniversalEnveloping Accum, tempElt;
  Accum.Nullify(owner);
  for (int i=0; i<this->size; i++)
    if (!this->TheObjects[i].GetElementUniversalEnveloping(tempElt, owner))
      return false;
    else
      Accum+=tempElt;
  output=Accum;
  return true;
}

template <class CoefficientType>
bool MonomialUniversalEnvelopingOrdered<CoefficientType>::GetElementUniversalEnveloping
  (ElementUniversalEnveloping& output, SemisimpleLieAlgebra& owner)
{ ElementUniversalEnveloping Accum;
  ElementUniversalEnveloping tempMon;
  int theIndex;
  Accum.MakeConst(this->Coefficient, owner);
  for (int i=0; i<this->generatorsIndices.size; i++)
    if (this->Powers.TheObjects[i].IsSmallInteger())
    { tempMon.AssignElementLieAlgebra(this->owner->theOrder.TheObjects[this->generatorsIndices.TheObjects[i]], this->Coefficient.NumVars, owner);
      tempMon.RaiseToPower(this->Powers.TheObjects[i].TheObjects[0].Coefficient.NumShort);
      Accum.MultiplyBy(tempMon);
    }
    else
      if (this->owner->theOrder.TheObjects[this->generatorsIndices.TheObjects[i]].IsACoeffOneChevalleyGenerator(theIndex, owner))
      { tempMon.MakeOneGeneratorCoeffOne(theIndex, this->Coefficient.NumVars, owner);
        tempMon.TheObjects[0].Powers.TheObjects[0]=this->Powers.TheObjects[i];
        Accum.MultiplyBy(tempMon);
      } else
        return false;
  output.operator=(Accum);
  return true;
}

bool ElementSimpleLieAlgebra::IsACoeffOneChevalleyGenerator(int& outputGenerator, SemisimpleLieAlgebra& owner)
{ if (this->NonZeroElements.CardinalitySelection>1)
    return false;
  if (this->NonZeroElements.CardinalitySelection==1)
  { if (!this->Hcomponent.IsEqualToZero())
      return false;
    if (this->coeffsRootSpaces.TheObjects[this->NonZeroElements.elements[0]].IsEqualToOne())
    { outputGenerator=owner.RootIndexOrderAsInRootSystemToGeneratorIndexNegativeRootsThenCartanThenPositive(this->NonZeroElements.elements[0]);
      return true;
    }
    return false;
  }
  outputGenerator=-1;
  for (int i=0; i<this->Hcomponent.size; i++)
    if (!this->Hcomponent.TheObjects[i].IsEqualToZero())
    { if (!this->Hcomponent.TheObjects[i].IsEqualToOne()|| outputGenerator!=-1)
        return false;
      outputGenerator=i;
    }
  outputGenerator+=owner.GetNumPosRoots();
  return true;
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::SetNumVariables(int newNumVars)
{ //this->ComputeDebugString();
  if (this->size==0)
    return;
  int currentNumVars=this->TheObjects[0].Coefficient.NumVars;
  if (currentNumVars==newNumVars)
    return;
  ElementUniversalEnvelopingOrdered Accum;
  Accum.Nullify(*this->owner);
  MonomialUniversalEnvelopingOrdered<CoefficientType> tempMon;
  for (int i=0; i<this->size; i++)
  { tempMon=this->TheObjects[i];
    tempMon.SetNumVariables(newNumVars);
    Accum.AddMonomial(tempMon);
  }
//  Accum.ComputeDebugString();
  this->operator=(Accum);
 // this->ComputeDebugString();
}

template <class CoefficientType>
void MonomialUniversalEnvelopingOrdered<CoefficientType>::SetNumVariables(int newNumVars)
{ if (this->Coefficient.NumVars==newNumVars)
    return;
  this->Coefficient.SetNumVariablesSubDeletedVarsByOne((int)newNumVars);
  for(int i=0; i<this->generatorsIndices.size; i++)
    this->Powers.TheObjects[i].SetNumVariablesSubDeletedVarsByOne((int)newNumVars);
}

std::string ParserNode::ElementToStringValueOnlY(bool useHtml, int RecursionDepth, int maxRecursionDepth)
{ std::stringstream LatexOutput;
  PolynomialOutputFormat PolyFormatLocal;
  int i;
  switch (this->ExpressionType)
  { case ParserNode::typeIntegerOrIndex: LatexOutput << this->intValue; break;
    case ParserNode::typeRational: LatexOutput << this->rationalValue.ElementToString(); break;
    case ParserNode::typePoly: LatexOutput << this->polyValue.GetElement().ElementToString(PolyFormatLocal); break;
    case ParserNode::typeRationalFunction: LatexOutput << this->ratFunction.GetElement().ElementToString(PolyFormatLocal); break;
    case ParserNode::typeUEElementOrdered: LatexOutput << this->UEElementOrdered.GetElement().ElementToString(true, PolyFormatLocal); break;
    case ParserNode::typeUEelement: LatexOutput << this->UEElement.GetElement().ElementToString(); break;
    case ParserNode::typeWeylAlgebraElement: LatexOutput << this->WeylAlgebraElement.GetElement().ElementToString(true); break;
   // case ParserNode:: typeCone: LatexOutput << this->theCone.GetElement().ElementToString(); break;
    case ParserNode::typeArray:
      LatexOutput << "(";
      RecursionDepth++;
      if (RecursionDepth<=maxRecursionDepth)
        for (i=0; i<this->array.GetElement().size; i++)
        { LatexOutput << this->owner->TheObjects[this->array.GetElement().TheObjects[i]].ElementToStringValueOnlY(useHtml, RecursionDepth, maxRecursionDepth);
          if (i!=this->array.GetElement().size-1)
            LatexOutput << ",";
        }
      else
        LatexOutput << "...";
      LatexOutput << ")";
      break;
    default: break;
  }
  return LatexOutput.str();
}

std::string ParserNode::ElementToStringValueAndType(bool useHtml, int RecursionDepth, int maxRecursionDepth)
{ std::stringstream out;
  PolynomialOutputFormat PolyFormatLocal;
  std::string stringValueOnly= this->ElementToStringValueOnlY(useHtml, RecursionDepth, maxRecursionDepth);
  switch (this->ExpressionType)
  { case ParserNode::typeIntegerOrIndex:  out << " an integer of value: "; break;
    case ParserNode::typeRational: out << " a rational number of value: "; break;
    case ParserNode::typePoly: out << " a polynomial of value: "; break;
    case ParserNode::typeRationalFunction: out << " a rational function of value: "; break;
    case ParserNode::typeUEElementOrdered: out << "an element of U(g) ordered:"; break;
    case ParserNode::typeUEelement: out << " an element of U(g) of value: "; break;
    case ParserNode::typeWeylAlgebraElement: out << " a Weyl algebra element: "; break;
    case ParserNode::typeArray: out << " an array of " << this->array.GetElement().size << " elements. "; break;
    case ParserNode::typeString: out << "<br>A printout of value: "; break;
    case ParserNode::typeError: out << this->ElementToStringErrorCode(useHtml); break;
    case ParserNode::typeLattice: out << "A lattice."; break;
    case ParserNode::typeCone: out << "a cone with walls: "; break;
    default: out << "The programmer(s) have forgotten to enter a type description. "; break;
  }
  if (stringValueOnly!="")
  { if (!useHtml)
      out << stringValueOnly;
    else
    { out << "\n<div id=\"theResult" << this->indexInOwner << "\" class=\"math\" scale=\"50\">\\begin{eqnarray*}&&";
      out << stringValueOnly;
      out << "\\end{eqnarray*}</div>";
      out << "<textarea id=\"theResultLatex" << this->indexInOwner << "\" style=\"display: none\">";
      out << "\\begin{eqnarray*}" << stringValueOnly << "\\end{eqnarray*}";
      out << "</textarea>";
      out << "<br>\n<button id=\"ButtonToggleLatex\" onclick=\"switchMenu('theResult" << this->indexInOwner << "'); switchMenu('theResultLatex" << this->indexInOwner << "');\"\">Show LaTeX/Show eye candy</button>";
    }
  }
  if (this->outputString!="" && this->ExpressionType!=this->typeString)
    out << "<br>In addition, the program generated the following printout. ";
  out << this->outputString;
  if (this->ExpressionType==this->typeArray)
  { out << "<br>Elements of the array follow.";
    RecursionDepth++;
    if (RecursionDepth<=maxRecursionDepth)
      for (int i=0; i<this->array.GetElement().size; i++)
        out << "<br>Element of index " << i+1 << ":" << this->owner->TheObjects[this->array.GetElement().TheObjects[i]].ElementToStringValueAndType(useHtml, RecursionDepth, maxRecursionDepth);
  }
  return out.str();
}

bool EigenVectorComputation::AreUnimodular
(roots& input, Selection& outputBasisUnimodularity, GlobalVariables& theGlobalVariables)
{ int theRank=input.GetRankOfSpanOfElements(theGlobalVariables);
  Selection theSel;
  theSel.init(input.size);
  int NumCycles=MathRoutines::NChooseK(input.size, theRank);
  theSel.incrementSelectionFixedCardinality(theRank);
  roots currentSelection;
  root tempRoot2;
  bool isIntegral=true;
  for (int i=0; i<NumCycles; i++, theSel.incrementSelectionFixedCardinality(theRank))
  { input.SubSelection(theSel, currentSelection);
    if (currentSelection.GetRankOfSpanOfElements(theGlobalVariables)==theRank)
    { isIntegral=true;
      for (int j=0; j<input.size; j++)
        if(!theSel.selected[j])
        { input.TheObjects[j].GetCoordsInBasis(currentSelection, tempRoot2, theGlobalVariables);
          isIntegral=tempRoot2.IsIntegral();
          if(!isIntegral)
            break;
        }
      if (isIntegral)
        break;
    }
  }
  if(isIntegral)
    outputBasisUnimodularity.Assign(theSel);
  return isIntegral;
}

/*void EigenVectorComputation::TakeOutOfTheBracketFromTheRight
  (PolynomialRationalCoeff& input, NonExpandedOnTheRightRationalPoly& output)
{ int numVars=input.NumVars;
  List<bool> Explored(input.size, false);
  PolynomialRationalCoeff currentInnerPoly;
  Monomial<Rational> tempMon;
  for (int i=0; i<input.size; i++)
    if(!Explored.TheObjects[i])
    { Monomial<Rational>& currentMon=input.TheObjects[i];
      Explored.TheObjects[i]=true;
      int indexFirstNonZeroPowerFromTheRight=-1;
      int powerFirstNonZeroPowerFromTheRight=-1;
      for (int k=0; k<currentMon.NumVariables; k++)
        if (currentMon.degrees[k]!=0)
        { indexFirstNonZeroPowerFromTheRight=k;
          inde
          break;
        }
      if (indexFirstNonZeroPowerFromTheRight!=-1)
      { currentInnerPoly.Nullify(numVars);
        for (int j=i; j<input.size; j++)
          if(!Explored.TheObjects[j] && input.TheObjects[j].degrees[indexFirstNonZeroPowerFromTheRight]!=0)
          { Monomial<Rational>& currentInnerMon=input.nput.TheObjects[j];
            tempMon.Assign(currentInnerMon);
            tempMon.degrees[indexFirstNonZeroPowerFromTheRight]=0;
          }
      }
    }
}*/

void GeneralizedMonomialRational::MakeOne(int NumVars)
{ PolynomialRationalCoeff tempP;
  tempP.Nullify((int)NumVars);
  this->degrees.initFillInObject(NumVars, tempP);
  this->Coefficient.MakeNVarConst((int) NumVars, (Rational) 1);
}

void GeneralizedMonomialRational::Nullify
  (int numVars)
{ PolynomialRationalCoeff tempP;
  tempP.Nullify((int)numVars);
  this->degrees.initFillInObject(numVars, tempP);
  this->Coefficient.Nullify(numVars);
}

void GeneralizedPolynomialRational::Nullify
(int numVarsCoeff, int numberMainVars)
{ this->ClearTheObjects();
  this->NumCoeffVars=numVarsCoeff;
  this->NumMainVars=numberMainVars;
}

void EigenVectorComputation::WeylElementActsOnGeneralizedMonomial
  (ElementWeylAlgebra& inputWeylElement, GeneralizedMonomialRational& inputMonomial, GeneralizedPolynomialRational& output)
{ output.Nullify(inputMonomial.degrees.size, inputMonomial.Coefficient.size);
  PolynomialRationalCoeff weylBuffer;
  GeneralizedMonomialRational tempM;
  inputWeylElement.GetStandardOrder(weylBuffer);
  for (int i=0; i<weylBuffer.size; i++)
  { this->WeylMonomialActsOnGeneralizedMonomial(weylBuffer.TheObjects[i], inputMonomial, tempM);
    output.operator+=(tempM);
  }
}

void EigenVectorComputation::WeylMonomialActsOnGeneralizedMonomial
  (Monomial<Rational>& inputWeylMon, GeneralizedMonomialRational& inputMonomial, GeneralizedMonomialRational& output)
{ output.operator=(inputMonomial);
  for (int i=0; i<inputWeylMon.NumVariables/2; i++)
  { int posInWeylMon=i+inputWeylMon.NumVariables/2;
    for (int j=0; j<inputWeylMon.degrees[posInWeylMon]; j++)
    { output.Coefficient.MultiplyBy(output.degrees.TheObjects[i]);
      if (output.Coefficient.IsEqualToZero())
      { output.Nullify(inputMonomial.Coefficient.NumVars);
        return;
      }
      output.degrees.TheObjects[i]-=1;
    }
  }
  Monomial<Rational> tempM;
  tempM.MakeConstantMonomial(inputWeylMon.NumVariables/2, inputWeylMon.Coefficient);
  for (int i=0; i<inputWeylMon.NumVariables/2; i++)
    tempM.degrees[i]=inputWeylMon.degrees[i];
  output.Coefficient.MultiplyByMonomial(tempM);
}

void GeneralizedPolynomialRational::operator+=(const GeneralizedMonomialRational& theMon)
{ if (theMon.IsEqualToZero())
    return;
  int theIndex=this->IndexOfObjectHash(theMon);
  if (theIndex==-1)
    this->AddObjectOnTopHash(theMon);
  else
  { this->TheObjects[theIndex].Coefficient+=theMon.Coefficient;
    if (this->TheObjects[theIndex].IsEqualToZero())
      this->PopIndexSwapWithLastHash(theIndex);
  }
}

void GeneralizedMonomialRational::MakeGenericMon
(int numVars,  int startingIndexFormalExponent)
{ if (numVars<0)
    return;
  this->degrees.SetSize(numVars);
  for (int i=0; i<startingIndexFormalExponent; i++)
    this->degrees.TheObjects[i].Nullify(numVars);
  for (int i=startingIndexFormalExponent; i<this->degrees.size; i++)
    this->degrees.TheObjects[i].MakeMonomialOneLetter((int) numVars, i, 1, (Rational) 1);
  this->Coefficient.MakeNVarConst(numVars, (Rational) 1);
}

std::string GeneralizedMonomialRational::ElementToString(PolynomialOutputFormat& PolyFormatLocal)
{ if (this->IsConstant())
    return this->Coefficient.ElementToString(PolyFormatLocal);
  std::stringstream out;
  std::string tempS;
  if (this->Coefficient.size>1) out << "(";
  this->Coefficient.ElementToString(tempS, PolyFormatLocal);
  if (tempS=="1")
    tempS="";
  if (tempS=="-1")
    tempS="-";
  out << tempS;
  if (this->Coefficient.size>1) out << ")";
  for (int i=0; i<this->degrees.size; i++)
    if (!this->degrees.TheObjects[i].IsEqualToZero())
    { out << "y_{" << i+1 << "}";
      if (!this->degrees.TheObjects[i].IsEqualToOne())
        out << "^{" << this->degrees.TheObjects[i].ElementToString(PolyFormatLocal) << "}";
    }
  return out.str();
}

std::string GeneralizedPolynomialRational::ElementToString(PolynomialOutputFormat& PolyFormatLocal)
{ if (this->size==0)
    return "0";
  std::stringstream out;
  std::string buffer;
  int sizeSinceLastCutOff=0;
  for (int i=0; i<this->size; i++)
  { buffer=this->TheObjects[i].ElementToString(PolyFormatLocal);
    if (buffer[0]!='-' && i!=0)
      out << "+";
    out << buffer;
    sizeSinceLastCutOff+=buffer.size();
    if (sizeSinceLastCutOff>200)
    { sizeSinceLastCutOff=0;
      out << "\\\\&&";
    }
  }
  return out.str();
}

void ParserNode::EvaluateSubstitution(GlobalVariables& theGlobalVariables)
{ if (this->children.size!=2)
  { this->SetError(this->errorBadOrNoArgument);
    return;
  }
  if(!this->ConvertChildrenToType(this->typeWeylAlgebraElement, theGlobalVariables))
  { this->SetError(this->errorBadOrNoArgument);
    return;
  }
  this->WeylAlgebraElement.GetElement()=this->owner->TheObjects[this->children.TheObjects[0]].WeylAlgebraElement.GetElementConst();
  this->weylEltBeingMappedTo.GetElement()=this->owner->TheObjects[this->children.TheObjects[1]].WeylAlgebraElement.GetElementConst();
  this->ExpressionType=this->typeMapWeylAlgebra;
}

void ParserNode::EvaluateDereferenceArray(GlobalVariables& theGlobalVariables)
{ if (this->children.size!=2)
  { this->SetError(this->errorBadOrNoArgument);
    return;
  }
  ParserNode& firstChild=this->owner->TheObjects[this->children.TheObjects[0]];
  ParserNode& secondChild=this->owner->TheObjects[this->children.TheObjects[1]];
  if (secondChild.ExpressionType!=this->typeIntegerOrIndex || firstChild.ExpressionType!=this->typeArray)
  { this->SetError(this->errorBadOrNoArgument);
    return;
  }
  int arraySize=firstChild.array.GetElement().size;
  int arrayIndex=secondChild.intValue-1;
  if (arrayIndex>=arraySize || arrayIndex<0)
  { this->SetError(this->errorBadIndex);
    return;
  }
  ParserNode& relevantChild=this->owner->TheObjects[firstChild.array.GetElement().TheObjects[arrayIndex]];
  this->CopyValue(relevantChild);
  return;
}

void ParserNode::EvaluateApplySubstitution(GlobalVariables& theGlobalVariables)
{ if (this->children.size<2)
  { this->SetError(this->errorProgramming);
    return;
  }
  PolynomialsRationalCoeff theSub;
  int theDimension=this->owner->NumVariables;
  theSub.MakeIdSubstitution((int) theDimension*2, (Rational) 1);
  List<bool> Explored(theDimension*2, false);
  PolynomialRationalCoeff currentLeft, currentRight;
  for (int i=0; i<this->children.size-1; i++)
  { ParserNode& currentNode=this->owner->TheObjects[this->children.TheObjects[i]];
    currentNode.WeylAlgebraElement.GetElement().SetNumVariablesPreserveExistingOnes(theDimension);
    currentNode.weylEltBeingMappedTo.GetElement().SetNumVariablesPreserveExistingOnes(theDimension);
    currentNode.WeylAlgebraElement.GetElement().GetStandardOrder(currentLeft);
    currentNode.weylEltBeingMappedTo.GetElement().GetStandardOrder(currentRight);
    if (currentLeft.size!=1)
    { this->SetError(this->errorBadOrNoArgument);
      return;
    }
    Monomial<Rational>& theMon=currentLeft.TheObjects[0];
    int theLetterIndex;
    if (!theMon.IsOneLetterFirstDegree(theLetterIndex))
    { this->SetError(this->errorBadOrNoArgument);
      return;
    }
    if (Explored.TheObjects[theLetterIndex])
    { this->SetError(this->errorBadSubstitution);
      return;
    }
//    std::cout << "<br> currentRight is: " << currentRight.ElementToString();
    Explored.TheObjects[theLetterIndex]=true;
    theSub.TheObjects[theLetterIndex]=currentRight;
//    std::cout << "<br> and currently we have: " << theSub.TheObjects[theLetterIndex].ElementToString();
    theSub.TheObjects[theLetterIndex]/=theMon.Coefficient;
//    std::cout << "<br> and currently we have: " << theSub.TheObjects[theLetterIndex].ElementToString();
    theSub.TheObjects[theLetterIndex].SetNumVariablesSubDeletedVarsByOne(theDimension*2);
//    std::cout << "<br> and currently we have: " << theSub.TheObjects[theLetterIndex].ElementToString();
  }
  ParserNode& lastNode=this->owner->TheObjects[*this->children.LastObject()];
  this->CopyValue(lastNode);
  this->CarryOutSubstitutionInMe(theSub, theGlobalVariables);
}

void ParserNode::CarryOutSubstitutionInMe(PolynomialsRationalCoeff& theSub, GlobalVariables& theGlobalVariables)
{ int theDimension=this->owner->NumVariables;
  Rational ratOne;
  ratOne.MakeOne();
  switch(this->ExpressionType)
  { case ParserNode::typeWeylAlgebraElement:
      this->WeylAlgebraElement.GetElement().SubstitutionTreatPartialsAndVarsAsIndependent(theSub);
      this->ExpressionType=this->typeWeylAlgebraElement;
      return;
    case ParserNode::typeIntegerOrIndex:
    case ParserNode::typeRational:
    case ParserNode::typePoly:
 //     std::cout << "<br> ... and the sub is: " << theSub.ElementToString();
      theSub.SetSize(theDimension);
      for (int i=0; i<theDimension; i++)
        theSub.TheObjects[i].SetNumVariablesSubDeletedVarsByOne(theDimension);
   //   std::cout << "<br> ... and the sub is: " << theSub.ElementToString();
      this->polyValue.GetElement().Substitution(theSub, theDimension, ratOne);
      this->ExpressionType=this->typePoly;
      return;
    case ParserNode::typeArray:
      for (int i=0; i<this->array.GetElement().size; i++)
        this->owner->TheObjects[this->array.GetElement().TheObjects[i]].CarryOutSubstitutionInMe(theSub, theGlobalVariables);
      return;
    default:
      this->SetError(this->errorDunnoHowToDoOperation);
      return;
  }
}

void ParserNode::CopyValue(const ParserNode& other)
{ this->intValue=other.intValue;
  this->ErrorType=other.ErrorType;
  this->rationalValue=other.rationalValue;
  this->ContextLieAlgebra=other.ContextLieAlgebra;
  this->children.CopyFromBase(other.children);
  this->Evaluated= other.Evaluated;
  this->outputString= other.outputString;
  this->ExpressionType=other.ExpressionType;
  if (other.ExpressionType==this->typeWeylAlgebraElement)
    this->WeylAlgebraElement.GetElement().Assign(other.WeylAlgebraElement.GetElementConst());
  if (other.ExpressionType==this->typeUEelement)
    this->UEElement.GetElement().operator=(other.UEElement.GetElementConst());
  if (other.ExpressionType==this->typeUEElementOrdered)
    this->UEElementOrdered.GetElement().operator=(other.UEElementOrdered.GetElementConst());
  if (other.ExpressionType==this->typePoly)
    this->polyValue.GetElement().operator=(other.polyValue.GetElementConst());
  if (other.ExpressionType==this->typeMapPolY)
  { this->polyValue.GetElement().operator=(other.polyValue.GetElementConst());
    this->polyBeingMappedTo.GetElement().operator=(other.polyBeingMappedTo.GetElementConst());
  }
  if (other.ExpressionType==this->typeMapWeylAlgebra)
  { this->WeylAlgebraElement.GetElement().operator=(other.WeylAlgebraElement.GetElementConst());
    this->weylEltBeingMappedTo.GetElement().operator=(other.weylEltBeingMappedTo.GetElementConst());
  }
  if (other.ExpressionType==this->typeArray)
    this->array.GetElement().CopyFromBase(other.array.GetElementConst());
  if(other.ExpressionType==this->typeRationalFunction)
    this->ratFunction.GetElement().operator=(other.ratFunction.GetElementConst());
}

void ParserNode::operator=(const ParserNode& other)
{ this->owner=other.owner;
  this->indexParentNode=other.indexParentNode;
  this->indexInOwner=other.indexInOwner;
  this->Operation=other.Operation;
  this->CopyValue(other);
}

bool Parser::lookAheadTokenAllowsMapsTo(int theToken)
{ return theToken==this->tokenComma || theToken==this->tokenCloseBracket || theToken==this->tokenEnd || theToken==this->tokenEndStatement || theToken==this->tokenColon;
}

bool Parser::StackTopIsARoot(int& outputDimension)
{ return this->StackTopIsADelimiter1ECdotsCEDelimiter2(outputDimension, this->tokenOpenBracket, this->tokenCloseBracket);
}

void Parser::AddXECdotsCEX(int theDimension, int theOperation)
{ this->ExtendOnTop(1);
  ParserNode& lastNode=*this->LastObject();
  lastNode.Operation=theOperation;
  lastNode.children.SetSize(theDimension);
  for (int i=0; i<theDimension; i++)
  { int indexChild=this->ValueStack.TheObjects[this->ValueStack.size-2-2*i];
    lastNode.children.TheObjects[theDimension-1-i]=indexChild;
    this->TheObjects[indexChild].indexParentNode=this->size-1;
  }
  this->DecreaseStackSetExpressionLastNode(theDimension*2);
}

void Parser::AddXECdotsCEXEX(int theDimension, int theOperation)
{ this->ExtendOnTop(1);
  ParserNode& lastNode=*this->LastObject();
  lastNode.Operation=theOperation;
  lastNode.children.SetSize(theDimension+1);
  for (int i=0; i<theDimension+1; i++)
  { int indexChild=this->ValueStack.TheObjects[this->ValueStack.size- theDimension*2-2+i*2];
    lastNode.children.TheObjects[i]=indexChild;
    this->TheObjects[indexChild].indexParentNode=this->size-1;
  }
  this->DecreaseStackSetExpressionLastNode(theDimension*2+2);
}

bool Parser::StackTopIsADelimiter1ECdotsCEDelimiter2(int& outputDimension, int LeftDelimiter, int RightDelimiter)
{ if (*this->TokenStack.LastObject()!=RightDelimiter)
    return false;
  outputDimension=0;
  for (int i=this->TokenStack.size-2; i>=1; i--)
  { if (this->TokenStack.TheObjects[i]!=this->tokenExpression)
      return false;
    i--;
    outputDimension++;
    if (this->TokenStack.TheObjects[i]==LeftDelimiter)
      return true;
    if (this->TokenStack.TheObjects[i]!=this->tokenComma)
      return false;
  }
  return false;
}

bool Parser::StackTopIsDelimiter1ECdotsCEDelimiter2EDelimiter3
  (int& outputDimension, int LeftDelimiter, int middleDelimiter, int rightDelimiter)
{ int LastToken=this->TokenStack.TheObjects[this->TokenStack.size-1];
  int SecondToLastToken=this->TokenStack.TheObjects[this->TokenStack.size-2];
  int ThirdToLastToken=this->TokenStack.TheObjects[this->TokenStack.size-3];
  if (LastToken!=rightDelimiter || SecondToLastToken!=this->tokenExpression || ThirdToLastToken!=middleDelimiter)
    return false;
  outputDimension=0;
  for (int i=this->TokenStack.size-4; i>=1; i--)
  { if (this->TokenStack.TheObjects[i]!=this->tokenExpression)
      return false;
    i--;
    outputDimension++;
    if (this->TokenStack.TheObjects[i]==LeftDelimiter)
      return true;
    if (this->TokenStack.TheObjects[i]!=this->tokenComma)
      return false;
  }
  return false;
}

void ElementWeylAlgebra::SubstitutionTreatPartialsAndVarsAsIndependent
(PolynomialsRationalCoeff& theSub)
{ assert(theSub.size==this->NumVariables*2);
//  std::cout << "<br>...and the sub is: " << theSub.ElementToString();
  this->StandardOrder.Substitution(theSub, this->NumVariables*2, (Rational) 1);
}

void ElementWeylAlgebra::RaiseToPower(int thePower)
{ ElementWeylAlgebra WeylOne;
  WeylOne.MakeConst(this->NumVariables, (Rational) 1);
  MathRoutines::RaiseToPower(*this, thePower, WeylOne);
}

template <class CoefficientType>
bool ElementUniversalEnvelopingOrdered<CoefficientType>::GetCoordsInBasis
  (List<ElementUniversalEnvelopingOrdered<CoefficientType> >& theBasis, Vector<CoefficientType>& output,
   const CoefficientType& theRingUnit, const CoefficientType& theRingZero, GlobalVariables& theGlobalVariables)const
{ List<ElementUniversalEnvelopingOrdered<CoefficientType> > tempBasis, tempElts;
  tempBasis=theBasis;
  tempBasis.AddObjectOnTop(*this);
  Vectors<CoefficientType> tempCoords;
  this->GetBasisFromSpanOfElements(tempBasis, tempCoords, tempElts, theRingUnit, theRingZero, theGlobalVariables);
  Vector<CoefficientType> tempRoot;
  tempRoot=*tempCoords.LastObject();
  tempCoords.SetSize(theBasis.size);
  return tempRoot.GetCoordsInBasiS(tempCoords, output, theRingUnit, theRingZero);
}

template <class CoefficientType>
void ElementUniversalEnvelopingOrdered<CoefficientType>::GetCoordinateFormOfSpanOfElements
  (int numVars, List<ElementUniversalEnvelopingOrdered>& theElements, List<rootPoly>& outputCoordinates,
   ElementUniversalEnvelopingOrdered& outputCorrespondingMonomials, GlobalVariables& theGlobalVariables)
{ if (theElements.size==0)
    return;
  outputCorrespondingMonomials.Nullify(*theElements.TheObjects[0].owner);
  MonomialUniversalEnveloping tempMon;
  for (int i=0; i<theElements.size; i++)
    for (int j=0; j<theElements.TheObjects[i].size; j++)
      outputCorrespondingMonomials.AddObjectOnTopNoRepetitionOfObjectHash(theElements.TheObjects[i].TheObjects[j]);
  outputCoordinates.SetSize(theElements.size);
  PolynomialRationalCoeff ZeroPoly;
  ZeroPoly.Nullify((int)numVars);
  for (int i=0; i<theElements.size; i++)
  { rootPoly& current=outputCoordinates.TheObjects[i];
    current.initFillInObject(outputCorrespondingMonomials.size, ZeroPoly);
    ElementUniversalEnvelopingOrdered& currentElt=theElements.TheObjects[i];
    for (int j=0; j<currentElt.size; j++)
    { MonomialUniversalEnvelopingOrdered<CoefficientType>& currentMon=currentElt.TheObjects[j];
      current.TheObjects[outputCorrespondingMonomials.IndexOfObjectHash(currentMon)]=currentMon.Coefficient;
    }
  }
}

void rootRationalFunction::ScaleToPolynomial()
{ PolynomialRationalCoeff tempP1;
  for (int i=0; i<this->size; i++)
    if (this->TheObjects[i].expressionType==RationalFunction::typeRationalFunction)
    { this->TheObjects[i].GetDenominator(tempP1);
      for (int j=0; j<this->size; j++)
        this->TheObjects[j]*=tempP1;
    }
}

void HomomorphismSemisimpleLieAlgebra::GetWeightsWrtK
  (roots& outputWeights, List<ElementSimpleLieAlgebra>& inputElts, GlobalVariables& theGlobalVariables)
{ outputWeights.SetSize(inputElts.size);
  Rational tempRat;
  ElementSimpleLieAlgebra tempLieElement;
  for (int i=0; i<inputElts.size; i++)
  { root& currentWeight= outputWeights.TheObjects[i];
    currentWeight.MakeZero(this->theDomain.GetRank());
    ElementSimpleLieAlgebra& currentLieElt=inputElts.TheObjects[i];
    for (int j=0; j<this->theDomain.GetRank(); j++)
    { this->theRange.LieBracket(this->imagesAllChevalleyGenerators.TheObjects[j+this->theDomain.GetNumPosRoots()], currentLieElt, tempLieElement);
      if(!currentLieElt.IsProportionalTo(tempLieElement, tempRat)){ assert(false);}
      currentWeight.TheObjects[j]=tempRat;
    }
  }
}

std::string TranslationFunctorGmodKVermaModule::RunTheComputationSl2StringVersion
  (Parser& theParser, GlobalVariables& theGlobalVariables, EigenVectorComputation& owner)
{ std::stringstream out;
  owner.PrepareCartanSub(theParser.testAlgebra, this->HighestWeightSub, theGlobalVariables);
  std::cout << this->HighestWeightSub.ElementToString();

  out << this->initTheCandidateMonomialsSl2StringVersion(theParser, theGlobalVariables);

  int theDomainRank=theParser.theHmm.theDomain.GetRank();
  int numPosRootsDomain=theParser.theHmm.theDomain.GetNumPosRoots();
  List<ElementSimpleLieAlgebra> theSimplePosGenerators, theSimpleNegGenerators;
  theSimplePosGenerators.SetSize(theDomainRank);
  theSimpleNegGenerators.SetSize(theDomainRank);
  for (int i=0; i<theDomainRank; i++)
  { theSimplePosGenerators.TheObjects[i]=theParser.theHmm.imagesAllChevalleyGenerators.TheObjects[i+theDomainRank+numPosRootsDomain];
    theSimpleNegGenerators.TheObjects[i]=theParser.theHmm.imagesAllChevalleyGenerators.TheObjects[-1-i+numPosRootsDomain];
  }
  ElementSimpleLieAlgebra zeroAlgebraElement;
  ElementVermaModuleOrdered<RationalFunction> zeroVermaElement;
  zeroAlgebraElement.Nullify(theParser.theHmm.theRange);
  zeroVermaElement.Nullify(theParser.testAlgebra, this->HighestWeightSub);
  RationalFunction RFOne, RFZero;
  RFOne.MakeNVarConst(theParser.theHmm.theRange.GetRank(), (Rational) 1, &theGlobalVariables);
  RFZero.Nullify(theParser.theHmm.theRange.GetRank(), &theGlobalVariables);
  this->theSpace.initTheSpacesSl2StringVersion(theSimplePosGenerators, theSimpleNegGenerators, theParser.theHmm.theRange, zeroVermaElement, zeroAlgebraElement, RFOne, RFZero, theGlobalVariables);

  //this->theSpace.ExtractHighestWeightVectorsFromVector(this->theSpace.theSeedVector, this->theOutput, theGlobalVariables, this->theSpace.theTargetSpace.theRingUniT);
  return out.str();
}

std::string TranslationFunctorGmodKVermaModule::RunTheComputation
  (Parser& theParser, GlobalVariables& theGlobalVariables, EigenVectorComputation& owner)
{ std::stringstream out;
  owner.PrepareCartanSub(theParser.testAlgebra, this->HighestWeightSub, theGlobalVariables);
  std::cout << this->HighestWeightSub.ElementToString();
//return "";
  out << this->initTheCandidateMonomials(theParser, theGlobalVariables);
  int theDomainRank=theParser.theHmm.theDomain.GetRank();
  int numPosRootsDomain=theParser.theHmm.theDomain.GetNumPosRoots();
  List<ElementSimpleLieAlgebra> theSimpleGenerators;
  theSimpleGenerators.SetSize(theDomainRank);
  for (int i=0; i<theDomainRank; i++)
    theSimpleGenerators.TheObjects[i]=theParser.theHmm.imagesAllChevalleyGenerators.TheObjects[i+theDomainRank+numPosRootsDomain];
  //return out.str();
  ElementSimpleLieAlgebra zeroAlgebraElement;
  ElementVermaModuleOrdered<RationalFunction> zeroVermaElement;
  zeroAlgebraElement.Nullify(theParser.theHmm.theRange);
  zeroVermaElement.Nullify(theParser.testAlgebra, this->HighestWeightSub);
  RationalFunction RFOne, RFZero;
  RFOne.MakeNVarConst(theParser.theHmm.theRange.GetRank(), (Rational) 1, &theGlobalVariables);
  RFZero.Nullify(theParser.theHmm.theRange.GetRank(), &theGlobalVariables);
  //for (int i=this->theModuleWeightsShifted.size-1; i>=0; i--)
  int i=0;
  { TensorProductSpaceAndElements<ElementVermaModuleOrdered<RationalFunction>, ElementSimpleLieAlgebra, RationalFunction>& currentCollection=this->theElements.TheObjects[i];
    currentCollection.FindEigenVectorsWithRespectTo(theSimpleGenerators, this->theLeftComponentsByWeight.TheObjects[i], this->theRightComponentsByWeight.TheObjects[i], theParser.theHmm.theRange, this->theEigenVectors.TheObjects[i], zeroVermaElement, zeroAlgebraElement, RFOne, RFZero, theGlobalVariables);
  }
  return out.str();
}

std::string TranslationFunctorGmodKVermaModule::initTheWeights
    (Parser& theParser, GlobalVariables& theGlobalVariables)
{std::stringstream out;
//  int theDomainRank=theParser.theHmm.theDomain.GetRank();
//  int numPosRootsDomain=theParser.theHmm.theDomain.GetNumPosRoots();
  roots theAlgebraWeights;
  theParser.theHmm.GetWeightsGmodK(this->theModuleWeightsShifted, theGlobalVariables);
  theParser.theHmm.GetWeightsK(theAlgebraWeights, theGlobalVariables);
//  SemisimpleLieAlgebraOrdered& theAlgebra=theParser.testAlgebra;
  this->theElements.SetSize(this->theModuleWeightsShifted.size);
  this->theEigenVectors.SetSize(this->theModuleWeightsShifted.size);
  this->theLeftComponentsByWeight.SetSize(this->theModuleWeightsShifted.size);
  this->theRightComponentsByWeight.SetSize(this->theModuleWeightsShifted.size);

  MatrixLargeRational invertedCartan;
  invertedCartan=theParser.theHmm.theDomain.theWeyl.CartanSymmetric;
  invertedCartan.Invert(theGlobalVariables);
//  out << "<br>" << this->theModuleWeightsShifted.ElementToString() << "<br>";
  invertedCartan.ActOnRoots(this->theModuleWeightsShifted);
  invertedCartan.ActOnRoots(theAlgebraWeights);
//  out << "<br>" << this->theModuleWeightsShifted.ElementToString() << "<br>";
  root tempRoot=*this->theModuleWeightsShifted.LastObject();
  this->theModuleWeightsNonShifted=this->theModuleWeightsShifted;
  for (int i=0; i<this->theModuleWeightsShifted.size; i++)
    this->theModuleWeightsShifted.TheObjects[i]-=tempRoot;
//  out << "<br>" << this->theModuleWeightsShifted.ElementToString() << "<br>";
  this->ElementsOfKofNegativeWeights.size=0;
  this->theVectorPartition.PartitioningRoots.size=0;
  for (int i=0; i<theAlgebraWeights.size; i++)
    if (theAlgebraWeights.TheObjects[i].IsNegativeOrZero()&& !theAlgebraWeights.TheObjects[i].IsEqualToZero())
    { this->theVectorPartition.PartitioningRoots.AddObjectOnTop(-theAlgebraWeights.TheObjects[i]);
      this->ElementsOfKofNegativeWeights.AddObjectOnTop(theParser.theHmm.imagesAllChevalleyGenerators.TheObjects[i]);
    }
  out << "<br>" << this->theVectorPartition.PartitioningRoots.ElementToString() << "<br>";
  return out.str();
}

std::string TranslationFunctorGmodKVermaModule::initTheCandidateMonomials
  (Parser& theParser, GlobalVariables& theGlobalVariables)
{ std::stringstream out;
  out << this->initTheWeights(theParser, theGlobalVariables);
  assert(this->HighestWeightSub.size==3);
  for (int i=this->theModuleWeightsShifted.size-1; i>=0; i--)
  {     //for testing purposes:
    //if (i<theModuleWeightsShifted.size-2)
     // break;

    root& weightTotal=theModuleWeightsShifted.TheObjects[i];
    for (int k=i; k<this->theModuleWeightsShifted.size; k++)
    { root& weightRight=this->theModuleWeightsShifted.TheObjects[k];
      root weightLeft=-weightTotal+weightRight;
      if (weightLeft.IsPositiveOrZero())
      { this->theVectorPartition.theRoot=weightLeft;
//        theVP.ComputeDebugString(false);
//        theVP.PartitioningRoots.ComputeDebugString();
        this->theVectorPartition.ComputeAllPartitions();
//        out << theVP.ElementToString(true) << "<br><br>";
        out << this->GetLeftAndRightFromVP(i, k, this->theVectorPartition, theParser, theGlobalVariables);
        out << "<br><br><br>";
      }
    }
  }

  return out.str();
}

std::string TranslationFunctorGmodKVermaModule::initTheCandidateMonomialsSl2StringVersion
  (Parser& theParser, GlobalVariables& theGlobalVariables)
{ std::stringstream out;
  out << this->initTheWeights(theParser, theGlobalVariables);
  out << this->theVectorPartition.ElementToString(true);
  assert(this->HighestWeightSub.size==3);
  this->theSpace.theTargetSpace.leftSpaceBasis.size=0;
  this->theSpace.theRightLowestWeight=this->theModuleWeightsShifted.TheObjects[0];
  SelectionWithDifferentMaxMultiplicities theSel;
  theSel.initIncomplete(this->theSpace.theRightLowestWeight.size);
  this->theSpace.theTargetSpace.rightWeights.SetSize(this->theModuleWeightsNonShifted.size);
  for (int i=0; i<this->theModuleWeightsNonShifted.size; i++)
    this->theSpace.theTargetSpace.rightWeights.TheObjects[i]=this->theModuleWeightsNonShifted.TheObjects[this->theModuleWeightsShifted.size-1-i];
  for (int i=0; i<this->theSpace.theRightLowestWeight.size; i++)
    theSel.MaxMultiplicities.TheObjects[i]=-this->theSpace.theRightLowestWeight.TheObjects[i].NumShort;
  int numCycles=theSel.getTotalNumSubsets();
  out << "Total num weights: " << numCycles << "<br>";
  this->theSpace.theTargetSpace.rightSpaceBasis.size=0;
  for (int i=0; i<this->theModuleWeightsShifted.size; i++)
  { ElementSimpleLieAlgebra& rightComponent=theParser.theHmm.GmodK.TheObjects[i];
    this->theSpace.theTargetSpace.rightSpaceBasis.AddObjectOnTop(rightComponent);
  }

  root weightTotal;
  for (int i=0; i<numCycles; i++, theSel.IncrementSubset())
  { weightTotal.operator=(theSel);
    weightTotal.MinusRoot();
    this->theVectorPartition.theRoot=-weightTotal;
    this->theVectorPartition.ComputeAllPartitions();
//    this->theVectorPartition.ComputeDebugString(false);
    out << this->GetLeftFromVP( this->theVectorPartition, theParser, theGlobalVariables);
    out << "<br><br><br>";
  }
  return out.str();
}

std::string TranslationFunctorGmodKVermaModule::GetLeftFromVP
  ( VectorPartition& theVP, Parser& theParser, GlobalVariables& theGlobalVariables)
{ std::stringstream out;
  out << "<br>total weight: " << theVP.theRoot.ElementToString();
  ElementVermaModuleOrdered<RationalFunction> leftComponent;
  ElementUniversalEnvelopingOrdered<RationalFunction> leftComponentBeforeModdingVermaRels, tempElt;
  RationalFunction RFOne, RFZero;
  PolynomialOutputFormat polyFormatLocal;
  int theNumVars=theParser.theHmm.theRange.GetRank();
  RFOne.MakeNVarConst(theNumVars, (Rational) 1, &theGlobalVariables);
  RFZero.Nullify(theNumVars, &theGlobalVariables);
  out << "<br> the vector partition: " << theVP.ElementToString(true);
  ElementVermaModuleOrdered<RationalFunction> theVermaZero;
  assert(this->HighestWeightSub.size==3);
  theVermaZero.Nullify(theParser.testAlgebra, this->HighestWeightSub);
  for (int i=0; i<theVP.thePartitions.size; i++)
  { leftComponentBeforeModdingVermaRels.MakeConst(RFOne, theParser.testAlgebra);
    for (int j=0; j<theVP.thePartitions.TheObjects[i].size; j++)
    { int currentMultiplicity=theVP.thePartitions.TheObjects[i].TheObjects[j];
      if (currentMultiplicity>0)
      { tempElt.AssignElementLieAlgebra(this->ElementsOfKofNegativeWeights.TheObjects[j], RFOne, RFZero, theParser.testAlgebra);
        tempElt.RaiseToPower(currentMultiplicity, RFOne);
        leftComponentBeforeModdingVermaRels.operator*=(tempElt);
      }
    }
    leftComponent.AssignElementUniversalEnvelopingOrderedTimesHighestWeightVector
    (leftComponentBeforeModdingVermaRels, theVermaZero, &theGlobalVariables,
     RFOne
     );
    this->theSpace.theTargetSpace.leftSpaceBasis.AddObjectOnTop(leftComponent);
    this->theSpace.theTargetSpace.leftWeights.AddObjectOnTop(theVP.theRoot);
    //out << "<br>Left element before modding: " << leftComponentBeforeModdingVermaRels.ElementToString() << " and after modding: "<< leftComponent.ElementToString();
    out << "<br>Left element: "<< leftComponent.ElementToString();
  }
  return out.str();
//  currentElement.AssignTensor(leftComponent, rightComponent);
}


std::string TranslationFunctorGmodKVermaModule::GetLeftAndRightFromVP
  (int indexTotalWeight, int indexRightWeight, VectorPartition& theVP, Parser& theParser, GlobalVariables& theGlobalVariables)
{ std::stringstream out;
  out << "<br>total weight: " << this->theModuleWeightsShifted.TheObjects[indexTotalWeight].ElementToString();
  out << "<br> left weight: " << (-theVP.theRoot).ElementToString() << "  right weight: " << this->theModuleWeightsShifted.TheObjects[indexRightWeight].ElementToString();
  ElementSimpleLieAlgebra& rightComponent=theParser.theHmm.GmodK.TheObjects[indexRightWeight];
  ElementVermaModuleOrdered<RationalFunction> leftComponent;
  ElementUniversalEnvelopingOrdered<RationalFunction> leftComponentBeforeModdingVermaRels, tempElt;
  RationalFunction RFOne, RFZero;
  PolynomialOutputFormat polyFormatLocal;
  int theNumVars=theParser.theHmm.theRange.GetRank();
  RFOne.MakeNVarConst(theNumVars, (Rational) 1, &theGlobalVariables);
  RFZero.Nullify(theNumVars, &theGlobalVariables);
  //RFOne.operator=(PolyOne);
  out << "<br>right element:" << rightComponent.ElementToStringNegativeRootSpacesFirst(false, false, theParser.theHmm.theRange);
  List<ElementVermaModuleOrdered<RationalFunction> >& currentLeftCollection= this->theLeftComponentsByWeight.TheObjects[indexTotalWeight];
  List<ElementSimpleLieAlgebra>& currentRightCollection = this->theRightComponentsByWeight.TheObjects[indexTotalWeight];
  out << "<br> the vector partition: " << theVP.ElementToString(true);
  ElementVermaModuleOrdered<RationalFunction> theVermaZero;
  assert(this->HighestWeightSub.size==3);
  theVermaZero.Nullify(theParser.testAlgebra, this->HighestWeightSub);

  for (int i=0; i<theVP.thePartitions.size; i++)
  { leftComponentBeforeModdingVermaRels.MakeConst(RFOne, theParser.testAlgebra);
    for (int j=0; j<theVP.thePartitions.TheObjects[i].size; j++)
    { int currentMultiplicity=theVP.thePartitions.TheObjects[i].TheObjects[j];
      if (currentMultiplicity>0)
      { tempElt.AssignElementLieAlgebra(this->ElementsOfKofNegativeWeights.TheObjects[j], RFOne, RFZero, theParser.testAlgebra);
        tempElt.RaiseToPower(currentMultiplicity, RFOne);
        leftComponentBeforeModdingVermaRels.operator*=(tempElt);
      }
    }

    leftComponent.AssignElementUniversalEnvelopingOrderedTimesHighestWeightVector
    (leftComponentBeforeModdingVermaRels, theVermaZero, &theGlobalVariables,
     RFOne)
     ;
    currentLeftCollection.AddObjectOnTop(leftComponent);
    currentRightCollection.AddObjectOnTop(rightComponent);
    out << "<br>Left element before modding: " << leftComponentBeforeModdingVermaRels.ElementToString() << " and after modding: "<< leftComponent.ElementToString();
  }
  return out.str();
//  currentElement.AssignTensor(leftComponent, rightComponent);
}

template <class CoefficientType>
void ElementVermaModuleOrdered<CoefficientType>::AssignElementUniversalEnvelopingOrderedTimesHighestWeightVector
  (ElementUniversalEnvelopingOrdered<CoefficientType>& input, const ElementVermaModuleOrdered<CoefficientType>& theRingZero, GlobalVariables* theContext, const CoefficientType& theRingUnit)
{ this->theElT.operator=(input);
  assert(theRingZero.theSub.size==3);
  this->theSub=theRingZero.theSub;
  this->theElT.ModOutVermaRelations(false, this->theSub, theContext, theRingUnit);
}

template <class CoefficientType>
void ElementVermaModuleOrdered<CoefficientType>::MultiplyOnTheLeft
(const ElementSimpleLieAlgebra& other, ElementVermaModuleOrdered<CoefficientType>& output, const CoefficientType& theRingUnit, const CoefficientType& theRingZero, GlobalVariables* theContext)
{ ElementUniversalEnvelopingOrdered<CoefficientType> tempElt;
  tempElt.AssignElementLieAlgebra(other, theRingUnit, theRingZero, *this->theElT.owner);
  //std::cout << "<br>multiplying " << tempElt.ElementToString() << " times " << this->ElementToString();
  tempElt*=this->theElT;
  output.theElT=tempElt;
  //std::cout << "<br> ... and the result before simplifying is: " << output.theElT.ElementToString();
  output.theElT.Simplify(theContext);
  //std::cout << "<br> before modding out we get: " << output.theElT.ElementToString();
  output.theElT.ModOutVermaRelations(false, this->theSub, theContext, theRingUnit);
  //std::cout << "<br> finally we get: " << output.theElT.ElementToString();
}

template <class CoefficientType>
std::string ElementVermaModuleOrdered<CoefficientType>::ElementToString()const
{ std::stringstream out;
  PolynomialOutputFormat polyFormatLocal;
  std::string tempS=MathRoutines::ElementToStringBrackets(this->theElT, polyFormatLocal);
  if (tempS.size()>1)
    out << "(";
  if (tempS!="1")
    out << tempS;
  if (tempS.size()>1)
    out << ")";
  if (tempS!="0")
    out << " v";
  return out.str();
}

template<class CoefficientType>
void ElementVermaModuleOrdered<CoefficientType>::ActOnMe
  (const ElementSimpleLieAlgebra& actingElt, ElementVermaModuleOrdered<CoefficientType>& output, SemisimpleLieAlgebra& owner,
   const CoefficientType& theRingUnit, const CoefficientType& theRingZero, GlobalVariables* theContext)const
{ ElementUniversalEnvelopingOrdered<CoefficientType> tempElt;
  tempElt.AssignElementLieAlgebra(actingElt, theRingUnit, theRingZero, *this->theElT.owner);
//  std::cout << "<br>" << actingElt.ElementToString() << " acts on " << this->ElementToString();
  tempElt.LieBracketOnTheRight(this->theElT, output.theElT);
  output.theElT.Simplify(theContext);
  output.theSub=this->theSub;
//  std::cout << "<br>and the result before modding out is: " << output.ElementToString();
//  int numVars=output.theElt.GetNumVariables();
  output.theElT.ModOutVermaRelations(false, this->theSub, theContext, theRingUnit);
//  std::cout << "<br>and after modding out we get: " << output.ElementToString();
}

void ElementSimpleLieAlgebra::ActOnMe
  (const ElementSimpleLieAlgebra& theElt, ElementSimpleLieAlgebra& output, SemisimpleLieAlgebra& owner)
{ owner.LieBracket(theElt, *this, output);
}

void ElementSimpleLieAlgebra::ActOnMe
  (const ElementSimpleLieAlgebra& theElt, ElementSimpleLieAlgebra& output, SemisimpleLieAlgebra& owner,
   const RationalFunction& theRingUnit, const RationalFunction& theRingZero, GlobalVariables* theGlobalVariables)
{ owner.LieBracket(theElt, *this, output);
}

template <class ElementLeft, class ElementRight, class CoefficientType>
std::string TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>::ElementToString()
{ std::stringstream out;
  out << "The elements (" << this->size << ") are: ";
  for (int i=0; i<this->size; i++)
  { out << this->TheObjects[i].ElementToString() << "<br>";
  }
  out << "starting space: " << this->theStartingSpace.ElementToString() << "<br>target space: " << this->theTargetSpace.ElementToString();
  return out.str();
}

template <class ElementLeft, class ElementRight, class CoefficientType>
bool TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>::FindEigenVectorsWithRespectTo
  (List<ElementSimpleLieAlgebra>& theElementsActing,  List<ElementLeft>& theLeftElts, List<ElementRight>& theRightElts,
   SemisimpleLieAlgebra& theAlgebra, TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>& output,
   const ElementLeft& leftZero, const ElementRight& rightZero,
   const CoefficientType& theRingUnit, const CoefficientType& theRingZero,
   GlobalVariables& theGlobalVariables)
{ Matrix<RationalFunction> theSystem;
  this->initTheSpacesForAdjointAction(theElementsActing, theAlgebra, theLeftElts, theRightElts, leftZero, rightZero, theRingUnit, theRingZero, theGlobalVariables);
  std::cout << "<br><br>the starting space: " << this->theStartingSpace.ElementToString();
  std::cout << "<br><br>the target space: " << this->theTargetSpace.ElementToString();
  this->PrepareTheMatrix(theElementsActing, theAlgebra, theSystem, theGlobalVariables);
  return false;
}

template <class ElementLeft, class ElementRight, class CoefficientType>
void TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>::initTheSpacesForAdjointAction
    (List<ElementSimpleLieAlgebra>& theElementsActing,
     SemisimpleLieAlgebra& theAlgebra,
     List<ElementLeft>& theLeftElts,
     List<ElementRight>& theRightElts,
     const ElementLeft& leftZero,
     const ElementRight& rightZero,
     const CoefficientType& theRingUnit,
     const CoefficientType& theRingZero,
     GlobalVariables& theGlobalVariables)
{ List<ElementLeft> tempLeftElts;
  List<ElementRight> tempRightElts;
  Vectors<RationalFunction> tempCoords;
  ElementLeft tempLeft;
  ElementRight tempRight;
  this->SetSize(theLeftElts.size);
  for (int i=0; i<theLeftElts.size; i++)
    for (int j=0; j<theElementsActing.size; j++)
    { assert(theLeftElts.TheObjects[i].theSub.size==3);
      theLeftElts.TheObjects[i].ActOnMe(theElementsActing.TheObjects[j], tempLeft, theAlgebra, theRingUnit, theRingZero, &theGlobalVariables);
      tempLeftElts.AddObjectOnTop(tempLeft);
      theRightElts.TheObjects[i].ActOnMe(theElementsActing.TheObjects[j], tempRight, theAlgebra);
      tempRightElts.AddObjectOnTop(tempRight);
      tempRight.ComputeDebugString( false, false);
      tempLeft.ComputeDebugString();
    }
  this->theStartingSpace.theRingUniT=theRingUnit;
  this->theTargetSpace.theRingUniT=theRingUnit;
  this->theStartingSpace.theRingZerO=theRingZero;
  this->theTargetSpace.theRingZerO=theRingZero;
  tempLeftElts.AddListOnTop(theLeftElts);
  tempRightElts.AddListOnTop(theRightElts);
  std::cout << "<br><br><br> before extracting a basis the new left elements are:<br>";
  for (int i=0; i<tempLeftElts.size; i++)
    std::cout << tempLeftElts.TheObjects[i].ElementToString() << "<br>";
  std::cout << "<br> before extracting a basis the new right elements are:<br>";
  for (int i=0; i<tempRightElts.size; i++)
    std::cout << tempRightElts.TheObjects[i].ElementToString() << "<br>";
  std::stringstream out;
  if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()!=0)
  { theGlobalVariables.theIndicatorVariables.StatusString1NeedsRefresh=true;
    out << "Obtaining basis on the *target* left vector space...";
    theGlobalVariables.theIndicatorVariables.StatusString1=out.str();
    theGlobalVariables.MakeReport();
  }
  ElementLeft::GetBasisFromSpanOfElements(tempLeftElts, tempCoords, this->theTargetSpace.leftSpaceBasis, theRingUnit, theRingZero, theGlobalVariables);
  if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()!=0)
  { out << "done\nObtaining basis on the *target* right vector space...";
    theGlobalVariables.theIndicatorVariables.StatusString1=out.str();
    theGlobalVariables.MakeReport();
  }
  ElementRight::GetBasisFromSpanOfElements(tempRightElts, tempCoords, this->theTargetSpace.rightSpaceBasis, theGlobalVariables);
  if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()!=0)
  { out << "done\nObtaining basis on the *starting* left vector space";
    theGlobalVariables.theIndicatorVariables.StatusString1=out.str();
    theGlobalVariables.MakeReport();
  }
  ElementLeft::GetBasisFromSpanOfElements(theLeftElts, tempCoords, this->theStartingSpace.leftSpaceBasis, theRingUnit, theRingZero, theGlobalVariables);
  if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()!=0)
  { out << "done\nObtaining basis on the *starting* right vector space";
    theGlobalVariables.theIndicatorVariables.StatusString1=out.str();
    theGlobalVariables.MakeReport();
  }
  ElementRight::GetBasisFromSpanOfElements(theRightElts, tempCoords, this->theStartingSpace.rightSpaceBasis, theGlobalVariables);
  if (theGlobalVariables.GetFeedDataToIndicatorWindowDefault()!=0)
  { out << "done\n";
    theGlobalVariables.theIndicatorVariables.StatusString1=out.str();
    theGlobalVariables.MakeReport();
  }
  std::cout << "<br> starting space LOOK here: " << this->theStartingSpace.ElementToString();
  std::cout << "<br> target space LOOK here: " << this->theTargetSpace.ElementToString();
  std::cout << "<br> the elements we are acting upon are (" << theLeftElts.size << "): ";
  for (int i=0; i<theLeftElts.size; i++)
  { this->TheObjects[i].SetTensorProduct(theLeftElts.TheObjects[i], theRightElts.TheObjects[i], this->theStartingSpace, theGlobalVariables);
    std::cout << this->TheObjects[i].ElementToString() << ", ";
  }

}

template <class ElementLeft, class ElementRight, class CoefficientType>
void TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>::initTheSpacesSl2StringVersion
  ( List<ElementSimpleLieAlgebra>& theSimplePosElts,  List<ElementSimpleLieAlgebra>& theSimpleNegElts, SemisimpleLieAlgebra& theAlgebra,
    const ElementLeft& leftZero, const ElementRight& rightZero, const CoefficientType& theRingUnit, const CoefficientType& theRingZero,
    GlobalVariables& theGlobalVariables)
{ this->theTargetSpace.theRingUniT=theRingUnit;
  this->theTargetSpace.theRingZerO=theRingZero;
  this->MakeActualSizeAtLeastExpandOnTop(this->theTargetSpace.leftSpaceBasis.size*this->theTargetSpace.rightSpaceBasis.size);
  this->size=0;
  std::stringstream de_Bugger;
  bool foundSeed=false;
  for (int i=0; i< this->theTargetSpace.leftSpaceBasis.size; i++)
    for (int j=0; j< this->theTargetSpace.rightSpaceBasis.size; j++)
    { this->ExpandOnTop(1);
      this->LastObject()->SetTensorProductBasisElement(i, j, this->theTargetSpace, theGlobalVariables);
      de_Bugger << this->TheObjects[i].ElementToString() << "  <br>\n";
      std::cout << "Element of index " << i << ", " << j << ": " << this->TheObjects[i].ElementToString() << "<br>";
      if(!foundSeed)
        if (this->theRightLowestWeight==this->theTargetSpace.rightWeights.TheObjects[j] && i==this->theTargetSpace.leftSpaceBasis.size-1)
          this->theSeedVector=*this->LastObject();
    }
  std::cout << this->theTargetSpace.ElementToString();
  //return;

  ElementLeft resultLeft; ElementRight  resultRight;
  Vector<CoefficientType> theResultVector;
  this->simplePositiveGeneratorsActions.SetSize(theSimplePosElts.size);
  this->simpleNegativeGeneratorsActions.SetSize(theSimpleNegElts.size);
  List<ElementSimpleLieAlgebra>* curentGeneratorCollection=&theSimplePosElts;
  for (int j=0; j<2; j++, curentGeneratorCollection=& theSimpleNegElts)
    for (int i=0; i<curentGeneratorCollection->size; i++)
    { ElementSimpleLieAlgebra& currentGenerator=curentGeneratorCollection->TheObjects[i];
      Polynomials<CoefficientType>* currentAction= (j==0)? (&this->simplePositiveGeneratorsActions.TheObjects[i]) : (&this->simpleNegativeGeneratorsActions.TheObjects[i]);
      currentAction->SetSize(this->theTargetSpace.leftSpaceBasis.size+this->theTargetSpace.rightSpaceBasis.size);
      for (int k=0; k<this->theTargetSpace.leftSpaceBasis.size; k++)
      { ElementLeft& currentLeftElt=this->theTargetSpace.leftSpaceBasis.TheObjects[k];
        Polynomial<CoefficientType>& currentPoly=currentAction->TheObjects[k];
        currentLeftElt.ActOnMe(currentGenerator, resultLeft, theAlgebra, this->theTargetSpace.theRingUniT, this->theTargetSpace.theRingZerO, &theGlobalVariables);
        std::cout << "<br>" << currentGenerator.ElementToString() << " maps " << currentLeftElt.ElementToString() << " to " << resultLeft.ElementToString();
        this->theTargetSpace.GetInternalRepresentationFromVectorLeft(resultLeft, currentPoly, theGlobalVariables);
        std::cout << "<br>" << currentGenerator.ElementToString() << "maps x_{" << k << "} to: " << currentPoly.ElementToString() << "<br><br>";
      }
      for (int k=0; k<this->theTargetSpace.rightSpaceBasis.size; k++)
      { ElementRight& currentRightElt=this->theTargetSpace.rightSpaceBasis.TheObjects[k];
        Polynomial<CoefficientType>& currentPoly=currentAction->TheObjects[k];
        currentRightElt.ActOnMe(currentGenerator, resultRight, theAlgebra, this->theTargetSpace.theRingUniT, this->theTargetSpace.theRingZerO, &theGlobalVariables);
        std::cout << "<br>" << currentGenerator.ElementToString() << " maps " << currentRightElt.ElementToString() << " to " << resultRight.ElementToString();
        this->theTargetSpace.GetInternalRepresentationFromVectorRight(resultRight, currentPoly, theGlobalVariables);
        std::cout << "<br>" << currentGenerator.ElementToString() << "maps x_{" << k << "} to: " << currentPoly.ElementToString() << "<br><br>";
      }
    }
}

template <class ElementLeft, class ElementRight, class CoefficientType>
void TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>::PrepareTheMatrix
  (List<ElementSimpleLieAlgebra>& theElementsActing, SemisimpleLieAlgebra& theAlgebra, Matrix<CoefficientType>& output, GlobalVariables& theGlobalVariables)
{ TensorProductElement<ElementLeft, ElementRight, CoefficientType> resultElt;
  output.init(this->theTargetSpace.leftSpaceBasis.size*this->theTargetSpace.rightSpaceBasis.size*theElementsActing.size, this->size);
  output.NullifyAll(this->theStartingSpace.theRingZerO);
  this->ComputeDebugString();
  Vector<CoefficientType> theVector;
  for (int i=0; i<theElementsActing.size; i++)
  { ElementSimpleLieAlgebra& currentGenerator= theElementsActing.TheObjects[i];
    //if (i<1)
    //  i=1;
    for (int j=0; j<this->size; j++)
    { //if (j<6 && i==0)
        //j=6;
      TensorProductElement<ElementLeft, ElementRight, CoefficientType>& currentElt= this->TheObjects[j];
      assert(currentElt.internalRepresentation.NumVars==this->theStartingSpace.leftSpaceBasis.size+this->theStartingSpace.rightSpaceBasis.size);
      currentElt.ActOnMe(currentGenerator, resultElt, this->theStartingSpace, this->theTargetSpace, theAlgebra, theGlobalVariables);
      /*resultElt.ComputeDebugString();
      if (i==1 && j==2)
      { resultElt.ComputeDebugString();
        this->flagAnErrorHasOccurredTimeToPanic=true;
      }*/
      resultElt.ElementToVector(theVector, this->theTargetSpace, theGlobalVariables);
      theVector.ComputeDebugString();
      std::cout << "<br>" << currentGenerator.ElementToString() << " acting on ";
      std::cout << currentElt.ElementToString(this->theStartingSpace) << " gives ";
      std::cout << resultElt.ElementToString(this->theTargetSpace);
      for (int k=0; k<theVector.size; k++)
        output.elements[i*theVector.size+k][j]=theVector.TheObjects[k];
    }
  }
  std::cout << "<br><br><br><br>... and the matrix is: <div class=\"math\">" << output.ElementToString(false, true) <<"</div>";

}

template <class ElementLeft, class ElementRight, class CoefficientType>
std::string TensorProductElement<ElementLeft, ElementRight, CoefficientType>::ElementToString
  (TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& owner)
{ int theLeftIndex=-1, theRightIndex=-1;
  std::stringstream out;
  for (int i=0; i<this->internalRepresentation.size; i++)
  { Monomial<CoefficientType>& currentMon=this->internalRepresentation.TheObjects[i];
    owner.GetLeftAndRightIndexFromMonomial(currentMon, theLeftIndex, theRightIndex);
    std::string tempS= currentMon.Coefficient.ElementToString();
    if (tempS=="1")
      out << "(" << tempS << ")";
    out << "(" << owner.leftSpaceBasis.TheObjects[theLeftIndex].ElementToString() << ")\\otimes(" << owner.rightSpaceBasis.TheObjects[theRightIndex].ElementToString() << ")";
  }
  return out.str();
}

template <class ElementLeft, class ElementRight, class CoefficientType>
void TensorProductElement<ElementLeft, ElementRight, CoefficientType>::ElementToVector
  (Vector<CoefficientType>& output, TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& owner, GlobalVariables& theGlobalVariables)const
{ output.MakeZero(owner.leftSpaceBasis.size*owner.rightSpaceBasis.size, owner.theRingZerO);
  for (int i=0; i<this->internalRepresentation.size; i++)
  { int relevantIndex=owner.GetIndexFromMonomial(this->internalRepresentation.TheObjects[i]);
    if (TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>::flagAnErrorHasOccurredTimeToPanic)
    { output.ComputeDebugString();
      this->internalRepresentation.TheObjects[i].Coefficient.ComputeDebugString();
    }
    output.TheObjects[relevantIndex]=this->internalRepresentation.TheObjects[i].Coefficient;
  }
}

template <class ElementLeft, class ElementRight, class CoefficientType>
void TensorProductElement<ElementLeft, ElementRight, CoefficientType>::AssignVector
  (Vector<CoefficientType>& input, TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& owner, GlobalVariables& theGlobalVariables)
{ this->Nullify(owner);
  TensorProductElement<ElementLeft, ElementRight, CoefficientType> tempElt;
  for (int i=0; i<input.size; i++)
  { owner.GetEltFromIndex(i, tempElt, theGlobalVariables);
    this->operator+=(tempElt);
  }
}

template <class ElementLeft, class ElementRight, class CoefficientType>
void TensorProductElement<ElementLeft, ElementRight, CoefficientType>::ActOnMe
  (const ElementSimpleLieAlgebra& theElt, TensorProductElement<ElementLeft, ElementRight, CoefficientType>& output,
   TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& theStartingSpace,
   TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& theTargetSpace,
   SemisimpleLieAlgebra& theAlgebra, GlobalVariables& theGlobalVariables)
{ assert(this!=&output);
  TensorProductElement<ElementLeft, ElementRight, CoefficientType> newSummand;
  output.Nullify(theTargetSpace);
  ElementLeft leftComponent, newLeftComponent;
  ElementRight rightComponent, newRightComponent;
  Polynomial<CoefficientType> tempP;
  for (int i=0; i<this->internalRepresentation.size; i++)
  { theStartingSpace.GetComponentsFromInternalRepresentation(this->internalRepresentation.TheObjects[i], leftComponent, rightComponent);
    //leftComponent.ComputeDebugString();
    //rightComponent.ComputeDebugString(false, false);
    leftComponent.ActOnMe(theElt, newLeftComponent, theAlgebra, theStartingSpace.theRingUniT, theStartingSpace.theRingZerO, &theGlobalVariables);
    std::cout << "<br>" << theElt.ElementToString() << " acting on " << leftComponent.ElementToString() << " gives " << newLeftComponent.ElementToString();
    rightComponent.ActOnMe(theElt, newRightComponent, theAlgebra);
    leftComponent.ComputeDebugString();
    rightComponent.ComputeDebugString(false, false);
    newRightComponent.ComputeDebugString(false, false);
    newLeftComponent.ComputeDebugString();
    std::cout << "<br>" << theElt.ElementToString() << " acting on " << rightComponent.ElementToString() << " gives " << newRightComponent.ElementToString();

    theTargetSpace.GetInternalRepresentationFromLeftAndRight(newLeftComponent, rightComponent, tempP, theGlobalVariables);
    tempP.ComputeDebugString();
    output.internalRepresentation.AddPolynomial(tempP);
    theTargetSpace.GetInternalRepresentationFromLeftAndRight(leftComponent, newRightComponent, tempP, theGlobalVariables);
    tempP.ComputeDebugString();
    output.internalRepresentation.AddPolynomial(tempP);
  }
}

template <class ElementLeft, class ElementRight, class CoefficientType>
void TensorProductElement<ElementLeft, ElementRight, CoefficientType>::SetTensorProduct
  (const  ElementLeft& leftVector, const  ElementRight& rightVector, const TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& owner, GlobalVariables& theGlobalVariables)
{ owner.GetInternalRepresentationFromLeftAndRight(leftVector, rightVector, this->internalRepresentation, theGlobalVariables);
}

template <class ElementLeft, class ElementRight, class CoefficientType>
void TensorProductElement<ElementLeft, ElementRight, CoefficientType>::SetTensorProductBasisElement
  (int leftIndex, int rightIndex, const TensorProductSpace<ElementLeft, ElementRight, CoefficientType>& owner, GlobalVariables& theGlobalVariables)
{ Polynomial<CoefficientType> tempP;
  tempP.MakeMonomialOneLetter(owner.leftSpaceBasis.size+owner.rightSpaceBasis.size, leftIndex, 1 , owner.theRingUniT);
  this->internalRepresentation.MakeMonomialOneLetter(owner.leftSpaceBasis.size+owner.rightSpaceBasis.size, rightIndex+owner.leftSpaceBasis.size, 1 , owner.theRingUniT);
  this->internalRepresentation*=tempP;
}

template <class ElementLeft, class ElementRight, class CoefficientType>
std::string TensorProductElement<ElementLeft, ElementRight, CoefficientType>::ElementToString()
{ std::stringstream out;
  std::stringstream tempS;
  out << this->internalRepresentation.ElementToString();
  return out.str();
}

template<class CoefficientType>
template<class CoefficientTypeQuotientField>
void ElementUniversalEnvelopingOrdered<CoefficientType>::GetBasisFromSpanOfElements
  (List<ElementUniversalEnvelopingOrdered<CoefficientType> >& theElements,
   Vectors<CoefficientTypeQuotientField>& outputCoords,
   List<ElementUniversalEnvelopingOrdered<CoefficientType> >& outputTheBasis, const CoefficientTypeQuotientField& theFieldUnit, const CoefficientTypeQuotientField& theFieldZero,
   GlobalVariables& theGlobalVariables)
{ if (theElements.size==0)
    return;
  ElementUniversalEnvelopingOrdered<CoefficientType> outputCorrespondingMonomials;
  outputCorrespondingMonomials.Nullify(*theElements.TheObjects[0].owner);
  Vectors<CoefficientTypeQuotientField> outputCoordsBeforeReduction;
  for (int i=0; i<theElements.size; i++)
    for (int j=0; j<theElements.TheObjects[i].size; j++)
      outputCorrespondingMonomials.AddObjectOnTopNoRepetitionOfObjectHash(theElements.TheObjects[i].TheObjects[j]);
  outputCoordsBeforeReduction.SetSize(theElements.size);
  for (int i=0; i<theElements.size; i++)
  { Vector<CoefficientTypeQuotientField>& currentList=outputCoordsBeforeReduction.TheObjects[i];
    currentList.MakeZero(outputCorrespondingMonomials.size, theFieldZero);
    ElementUniversalEnvelopingOrdered<CoefficientType>& currentElt=theElements.TheObjects[i];
    for (int j=0; j<currentElt.size; j++)
    { MonomialUniversalEnvelopingOrdered<CoefficientType>& currentMon=currentElt.TheObjects[j];
      currentList.TheObjects[outputCorrespondingMonomials.IndexOfObjectHash(currentMon)]=currentMon.Coefficient;
    }
  }
  outputTheBasis.size=0;
  outputTheBasis.MakeActualSizeAtLeastExpandOnTop(theElements.size);
  Vectors<CoefficientTypeQuotientField> basisCoordForm;
  basisCoordForm.MakeActualSizeAtLeastExpandOnTop(theElements.size);
  Selection selectedBasis;
  outputCoordsBeforeReduction.ComputeDebugString();
  outputCoordsBeforeReduction.SelectABasis(basisCoordForm, theFieldZero, selectedBasis, theGlobalVariables);
  for (int i=0; i<selectedBasis.CardinalitySelection; i++)
    outputTheBasis.AddObjectOnTop(theElements.TheObjects[selectedBasis.elements[i]]);
  Matrix<CoefficientType> bufferMat;
  Vectors<CoefficientType> bufferVectors;
  outputCoordsBeforeReduction.GetCoordsInBasis(basisCoordForm, outputCoords, bufferVectors, bufferMat, theFieldUnit, theFieldZero);
}

void ElementSimpleLieAlgebra::GetBasisFromSpanOfElements
  (List<ElementSimpleLieAlgebra>& theElements, Vectors<RationalFunction>& outputCoords, List<ElementSimpleLieAlgebra>& outputTheBasis, GlobalVariables& theGlobalVariables)
{ roots theRootForm;
  theRootForm.SetSize(theElements.size);
  for(int i=0; i<theElements.size; i++)
  { ElementSimpleLieAlgebra& currentElt=theElements.TheObjects[i];
    currentElt.ElementToVectorNegativeRootSpacesFirst(theRootForm.TheObjects[i]);
  }
  int theRank=0; int numRoots=0;
  if (theElements.size>0)
  { theRank=theElements.TheObjects[0].Hcomponent.size;
    numRoots=theElements.TheObjects[0].coeffsRootSpaces.size;
  }
  theRootForm.ChooseABasis(theGlobalVariables);
  outputTheBasis.SetSize(theRootForm.size);
  for(int i=0; i<theRootForm.size; i++)
  { ElementSimpleLieAlgebra& currentElt=outputTheBasis.TheObjects[i];
    currentElt.AssignVectorNegRootSpacesCartanPosRootSpaces(theRootForm.TheObjects[i], numRoots, theRank);
  }

}

void roots::ChooseABasis(GlobalVariables& theGlobalVariables)
{ roots output;
  for (int i=0; i<this->size; i++)
  { output.AddObjectOnTop(this->TheObjects[i]);
    if (output.GetRankOfSpanOfElements(theGlobalVariables)< output.size)
      output.PopLastObject();
  }
  this->operator=(output);
}

template <class ElementLeft, class ElementRight, class CoefficientType>
void TensorProductSpace<ElementLeft, ElementRight, CoefficientType>::GetInternalRepresentationFromVectorRight
  (const ElementRight& input, Polynomial<CoefficientType>& output, GlobalVariables& theGlobalVariables)const
{ output.Nullify(this->leftSpaceBasis.size+this->rightSpaceBasis.size);
  Monomial<CoefficientType> tempMon;
  Vector<CoefficientType> vectorFormInput;
  input.GetCoordsInBasis(this->rightSpaceBasis, vectorFormInput, theGlobalVariables);
  for(int i=0; i<vectorFormInput.size; i++)
    if (!vectorFormInput.TheObjects[i].IsEqualToZero())
    { tempMon.MakeMonomialOneLetter(output.NumVars, i+this->leftSpaceBasis.size, 1, vectorFormInput.TheObjects[i]);
      output.AddMonomial(tempMon);
    }
}

template <class ElementLeft, class ElementRight, class CoefficientType>
bool TensorProductSpace<ElementLeft, ElementRight, CoefficientType>::GetInternalRepresentationFromVectorLeft
  (const ElementLeft& input, Polynomial<CoefficientType>& output, GlobalVariables& theGlobalVariables)const
{ output.Nullify(this->leftSpaceBasis.size+this->rightSpaceBasis.size);
  Monomial<CoefficientType> tempMon;
  Vector<CoefficientType> vectorFormInput;
  std::string tempS=input.ElementToString();
  std::string tempS2=this->leftSpaceBasis.ElementToStringGeneric();
  if (! input.GetCoordsInBasis(this->leftSpaceBasis, vectorFormInput, this->theRingUniT, this->theRingZerO, theGlobalVariables))
    return false;
  vectorFormInput.ComputeDebugString();
  for(int i=0; i<vectorFormInput.size; i++)
    if (!vectorFormInput.TheObjects[i].IsEqualToZero())
    { tempMon.MakeMonomialOneLetter(output.NumVars, i, 1, vectorFormInput.TheObjects[i]);
      output.AddMonomial(tempMon);
    }
  return true;
}

template <class ElementLeft, class ElementRight, class CoefficientType>
void TensorProductSpace<ElementLeft, ElementRight, CoefficientType>::
GetComponentsFromInternalRepresentation
  (const Monomial<CoefficientType>& input, ElementLeft& leftOutput, ElementRight& rightOutput)
{ for (int i=0; i<this->leftSpaceBasis.size; i++)
    if (input.degrees[i]==1)
    { leftOutput.operator=(this->leftSpaceBasis.TheObjects[i]);
      break;
    }
  for (int i=0; i<this->rightSpaceBasis.size; i++)
    if (input.degrees[i+leftSpaceBasis.size]==1)
    { rightOutput.operator=(this->rightSpaceBasis.TheObjects[i]);
      break;
    }
  leftOutput.operator*=(input.Coefficient);

}

template <class ElementLeft, class ElementRight, class CoefficientType>
std::string TensorProductSpace<ElementLeft, ElementRight, CoefficientType>::ElementToString()
{ std::stringstream out;
  out << "<br> Basis of the left components (" << this->leftSpaceBasis.size << " elements): <br>";
  for (int i=0; i<this->leftSpaceBasis.size; i++)
    out << this->leftSpaceBasis.TheObjects[i].ElementToString() << "<br> ";
  out << "<br> Basis of the right components (" << this->rightSpaceBasis.size << " elements): <br>";
  for (int i=0; i<this->rightSpaceBasis.size; i++)
    out << this->rightSpaceBasis.TheObjects[i].ElementToString() << "<br> ";
  return out.str();
}

template<class CoefficientType>
void ElementVermaModuleOrdered<CoefficientType>::GetBasisFromSpanOfElements
  (List<ElementVermaModuleOrdered>& theElements, Vectors<RationalFunction>& outputCoordinates, List<ElementVermaModuleOrdered>& outputTheBasis,
    const RationalFunction& RFOne, const RationalFunction& RFZero, GlobalVariables& theGlobalVariables)
{ List<ElementUniversalEnvelopingOrdered<CoefficientType> > theEltsUEform;
  theEltsUEform.SetSize(theElements.size);
  for (int i=0; i<theElements.size; i++)
    theEltsUEform.TheObjects[i]=theElements.TheObjects[i].theElT;
  List<ElementUniversalEnvelopingOrdered<CoefficientType> > theBasisUEform;
  ElementUniversalEnvelopingOrdered<CoefficientType>::GetBasisFromSpanOfElements(theEltsUEform, outputCoordinates, theBasisUEform, RFOne, RFZero, theGlobalVariables);
  outputTheBasis.SetSize(theBasisUEform.size);
  for (int i=0; i<theBasisUEform.size; i++)
  { outputTheBasis.TheObjects[i].theElT=theBasisUEform.TheObjects[i];
    outputTheBasis.TheObjects[i].theSub=theElements.TheObjects[0].theSub;
  }
}

template<class CoefficientType>
bool ElementVermaModuleOrdered<CoefficientType>::GetCoordsInBasis
  (const List<ElementVermaModuleOrdered<CoefficientType> >& theBasis, Vector<CoefficientType>& output, const CoefficientType& theRingUnit, const CoefficientType& theRingZero, GlobalVariables& theGlobalVariables)const
{ List<ElementUniversalEnvelopingOrdered<CoefficientType> > theEltsUEform;
  theEltsUEform.SetSize(theBasis.size);
  for (int i=0; i<theBasis.size; i++)
  { theEltsUEform.TheObjects[i]=theBasis.TheObjects[i].theElT;
  }
  return this->theElT.GetCoordsInBasis(theEltsUEform, output, theRingUnit, theRingZero, theGlobalVariables);
}

bool ElementSimpleLieAlgebra::GetCoordsInBasis(const List<ElementSimpleLieAlgebra>& theBasis, Vector<Rational>& output, GlobalVariables& theGlobalVariables)const
{ Vectors<Rational> tempBasis;
  root tempRoot;
  tempBasis.SetSize(theBasis.size);
  for (int i=0 ; i<theBasis.size; i++)
    theBasis.TheObjects[i].ElementToVectorNegativeRootSpacesFirst(tempBasis.TheObjects[i]);
  this->ElementToVectorNegativeRootSpacesFirst(tempRoot);
  return tempRoot.GetCoordsInBasiS(tempBasis, output, (Rational) 1, (Rational) 0);
}

bool RationalFunction::gcdQuicK
  (const PolynomialRationalCoeff& left, const PolynomialRationalCoeff& right, PolynomialRationalCoeff& output)
{ if (left.TotalDegree()>1 && right.TotalDegree()>1)
    return false;
  PolynomialRationalCoeff quotient, remainder;
  if (left.TotalDegree()>right.TotalDegree())
  { left.DivideBy(right, quotient, remainder);
    if (remainder.IsEqualToZero())
      output=right;
    else
      output.MakeNVarConst(left.NumVars, (Rational) 1);
  } else
  { std::string tempS1, tempS2, tempS3, tempS4;
    tempS1=left.ElementToString();
    tempS2=right.ElementToString();
    if ((&right)==(PolynomialRationalCoeff*)0x82ea6b8)
      std::cout << tempS1;
    right.DivideBy(left, quotient, remainder);
    tempS3=quotient.ElementToString();
    tempS4=remainder.ElementToString();
    if (remainder.IsEqualToZero())
      output=left;
    else
      output.MakeNVarConst(left.NumVars, (Rational) 1);
  }
  return true;
}

void ParserNode::EvaluateDivide(GlobalVariables& theGlobalVariables)
{ if (!this->AllChildrenAreOfDefinedNonErrorType())
  { this->SetError(this->errorOperationByUndefinedOrErrorType);
    return;
  }
  if (this->children.size!=2)
  { this->SetError(this->errorProgramming);
    return;
  }
  ParserNode& leftNode=this->owner->TheObjects[this->children.TheObjects[0]];
  ParserNode& rightNode=this->owner->TheObjects[this->children.TheObjects[1]];
  switch(leftNode.ExpressionType)
  { case ParserNode::typeIntegerOrIndex:
    case ParserNode::typeRational:
    case ParserNode::typePoly:
    case ParserNode::typeRationalFunction:
      this->ExpressionType=this->typeRationalFunction;
      this->InitForMultiplication(&theGlobalVariables);
      if (! rightNode.ConvertToType(this->typeRationalFunction, theGlobalVariables))
      { this->SetError(this->errorConversionError);
        return;
      }
      leftNode.ConvertToType(this->typeRationalFunction, theGlobalVariables);
      this->ratFunction.GetElement()=leftNode.ratFunction.GetElementConst();
      this->ratFunction.GetElement()/=rightNode.ratFunction.GetElement();
      this->ExpressionType=this->typeRationalFunction;
      this->ReduceRatFunction();
      break;
    case ParserNode::typeUEelement:
      if (!rightNode.ConvertToType(this->typeRational, theGlobalVariables))
      { this->SetError(this->errorDunnoHowToDoOperation);
        return;
      }
      this->UEElement.GetElement()=leftNode.UEElement.GetElement();
      this->UEElement.GetElement()/=rightNode.rationalValue;
      this->ExpressionType=this->typeUEelement;
    case ParserNode::typeUEElementOrdered:
      if (!rightNode.ConvertToType(this->typeRational, theGlobalVariables))
      { this->SetError(this->errorDunnoHowToDoOperation);
        return;
      }
      this->UEElementOrdered.GetElement()=leftNode.UEElementOrdered.GetElement();
      this->UEElementOrdered.GetElement()/=rightNode.rationalValue;
      this->ExpressionType=this->typeUEElementOrdered;
    break;
    default: this->SetError(this->errorDivisionByNonAllowedType); return;
  }
}


void RationalFunction::RaiseToPower(int thePower)
{ PolynomialRationalCoeff theNum, theDen;
  this->checkConsistency();
  switch (this->expressionType)
  { case RationalFunction::typeRational:
      this->ratValue.RaiseToPower(thePower);
      break;
    case RationalFunction::typePoly:
      this->Numerator.GetElement().RaiseToPower(thePower, (Rational) 1);
      break;
    case RationalFunction::typeRationalFunction:
      this->Numerator.GetElement().RaiseToPower(thePower, (Rational) 1);
      this->Denominator.GetElement().RaiseToPower(thePower, (Rational) 1);
      break;
  }
  this->checkConsistency();
}

void ComputationSetup::TheG2inB3Computation(ComputationSetup& inputData, GlobalVariables& theGlobalVariables)
{ Parser theParser;
  theParser.theHmm.MakeG2InB3(theParser, theGlobalVariables);
  SSalgebraModule theModule;
  std::stringstream out;
  theModule.InduceFromEmbedding(out, theParser.theHmm, theGlobalVariables);
  List<ElementSimpleLieAlgebra> theBasis;
  theBasis.SetSize(theParser.theHmm.theRange.GetNumGenerators());
  for (int i=0; i<theParser.theHmm.imagesAllChevalleyGenerators.size; i++)
  { int theIndex=i;
    if (i>=6 && i<8)
      theIndex=3+i;
    if (i>=8)
      theIndex=i+7;
      /*
      if (i==0) theIndex=3;
      if (i==1) theIndex=4;
      if (i==2) theIndex=5;
      if (i==3) theIndex=6;
      if (i==4) theIndex=7;
      if (i==5) theIndex=8;
      if (i==6) theIndex=9;
      if (i==7) theIndex=10;
      if (i==8) theIndex=12;
      if (i==9) theIndex=13;
      if (i==10) theIndex=14;
      if (i==11) theIndex=15;
      if (i==12) theIndex=16;
      if (i==13) theIndex=17;
      */
    ElementSimpleLieAlgebra& currentElt=theBasis.TheObjects[theIndex];
    currentElt=theParser.theHmm.imagesAllChevalleyGenerators.TheObjects[i];
  }
  for (int i=0; i<theModule.moduleElementsEmbedded.size; i++)
  { int theIndex=i+6;
    if (i>=3)
      theIndex=8+i;
    /*
    if (i==0) theIndex=0;
    if (i==1) theIndex=1;
    if (i==2) theIndex=2;
    if (i==3) theIndex=11;
    if (i==4) theIndex=18;
    if (i==5) theIndex=19;
    if (i==6) theIndex=20;
    */
    ElementSimpleLieAlgebra& currentElt=theBasis.TheObjects[theIndex];
    currentElt=theModule.moduleElementsEmbedded.TheObjects[i];
  }
  for (int i=0; i<theBasis.size; i++)
  { //std::cout << "<br>" << theBasis.TheObjects[i].ElementToStringNegativeRootSpacesFirst(false, false, theParser.theHmm.theRange);
  }
  theParser.testAlgebra.init(theBasis, theParser.theHmm.theRange, theGlobalVariables);
  std::string  civilizedInput="secretSauceOrdered";
  theParser.ParseEvaluateAndSimplify(civilizedInput, theGlobalVariables);
}

void RationalFunction::gcd
(const PolynomialRationalCoeff& left, const PolynomialRationalCoeff& right, PolynomialRationalCoeff& output, GlobalVariables* theContext)
{ if (RationalFunction::gcdQuicK(left, right, output))
    return;
  if (theContext==0)
  { PolynomialRationalCoeff buffer1, buffer2, buffer3, buffer4, buffer5; List<PolynomialRationalCoeff> bufferList; Monomial<Rational> tempMon1, tempMon2;
    RationalFunction::gcd(left, right, output, buffer1, buffer2, buffer3, buffer4, buffer5, tempMon1, tempMon2, bufferList);
  } else
    RationalFunction::gcd(left, right, output, theContext->RFgcdBuffer1, theContext->RFgcdBuffer2, theContext->RFgcdBuffer3, theContext->RFgcdBuffer4, theContext->RFgcdBuffer5,  theContext->RFgcdBuferMon1, theContext->RFgcdBuferMon2,  theContext->RFgcdBufferList1);
}

template <class ElementLeft, class ElementRight, class CoefficientType>
void TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>::ClimbDownFromHighestWeightAlongSl2String
  (TensorProductElement<ElementLeft, ElementRight, CoefficientType>& input,
   TensorProductElement<ElementLeft, ElementRight, CoefficientType>& output,
    CoefficientType& outputCoeff,
    Polynomials<CoefficientType>& posGenerator,
    Polynomials<CoefficientType>& negGenerator, int generatorPower, const CoefficientType& theRingUnit)
{ assert(&input!=&output);
  CoefficientType currentWeight;
  input.ActOnMe(negGenerator, output, theRingUnit);
  output.ActOnMe(posGenerator, theRingUnit);
  input.internalRepresentation.IsProportionalTo(output.internalRepresentation, currentWeight, theRingUnit);
  CoefficientType RaiseCoeff;
  RaiseCoeff=this->theTargetSpace.theRingZerO;
  outputCoeff=theRingUnit;
  output=input;
  for (int i=0; i<generatorPower; i++)
  { RaiseCoeff+=currentWeight;
    currentWeight-=2;
    outputCoeff*=RaiseCoeff;
    output.ActOnMe(negGenerator, output, theRingUnit);
  }
}

template <class ElementLeft, class ElementRight, class CoefficientType>
void TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>::ClimbDownFromVectorAccordingToSequence
  (TensorProductElement<ElementLeft, ElementRight, CoefficientType>& input,
   TensorProductElement<ElementLeft, ElementRight, CoefficientType>& output, CoefficientType& outputCoeff,
   List<int>& inputGeneratorSequence, List<int>& inputGeneratorPowers, GlobalVariables& theGlobalVariables, const CoefficientType& theRingUnit)
{ assert(&input!=&output);
  output=input;
  TensorProductElement<ElementLeft, ElementRight, CoefficientType> tempElt;
  outputCoeff=theRingUnit;
  CoefficientType tempCoeff;
  for (int i=inputGeneratorSequence.size-1; i>=0; i--)
  { Polynomials<CoefficientType>& currentPosGen= this->simplePositiveGeneratorsActions.TheObjects[inputGeneratorSequence.TheObjects[i]];
    Polynomials<CoefficientType>& currentNegGen=this->simpleNegativeGeneratorsActions.TheObjects[inputGeneratorSequence.TheObjects[i]];
    this->ClimbDownFromHighestWeightAlongSl2String
    (output, tempElt, tempCoeff, currentPosGen, currentNegGen, inputGeneratorPowers.TheObjects[i], theRingUnit);
    outputCoeff*=(tempCoeff);
    output=tempElt;
  }
}

template <class ElementLeft, class ElementRight, class CoefficientType>
void TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>::ClimbUpFromVector
  (TensorProductElement<ElementLeft, ElementRight, CoefficientType>& input,
   TensorProductElement<ElementLeft, ElementRight, CoefficientType>& outputLastNonZero,
   List<int>& outputGeneratorSequence, List<int>& outputGeneratorPowers, GlobalVariables& theGlobalVariables)
{ TensorProductElement<ElementLeft, ElementRight, CoefficientType> tempElt;
  assert(&input!=&outputLastNonZero);
  outputLastNonZero=input;
  outputGeneratorPowers.size=0;
  outputGeneratorSequence.size=0;
  bool found=true;
  while (found)
  { found=false;
    for (int i=0; i<this->simplePositiveGeneratorsActions.size; i++)
    { Polynomials<CoefficientType>& currentAction=this->simplePositiveGeneratorsActions.TheObjects[i];
      int counter=0;
      for(outputLastNonZero.ActOnMe(currentAction, tempElt, this->theTargetSpace.theRingUniT); !tempElt.IsEqualToZero(); tempElt.ActOnMe(currentAction, this->theTargetSpace.theRingUniT))
      { counter++;
        found=true;
        outputLastNonZero=tempElt;
//        std::cout << "<br>" << outputLastNonZero.ElementToString();
//        std::cout.flush();
      }
      if (found)
      { outputGeneratorSequence.AddObjectOnTop(i);
        outputGeneratorPowers.AddObjectOnTop(counter);
      }
    }
  }
}

template <class ElementLeft, class ElementRight, class CoefficientType>
std::string TensorProductSpaceAndElements<ElementLeft, ElementRight, CoefficientType>::ExtractHighestWeightVectorsFromVector
( TensorProductElement<ElementLeft, ElementRight, CoefficientType>& input, List<TensorProductElement<ElementLeft, ElementRight, CoefficientType> >& outputVectors,
  GlobalVariables& theGlobalVariables, const CoefficientType& theRingUnit)
{ //Index ordering of simpleNegGenerators:
  //if simplePosGenerators.TheObjects[i] is a positive root space then its opposite root space should be
  //simpleNegGenerators.TheObjects[i]
  std::stringstream out;
  outputVectors.size=0;
  TensorProductElement<ElementLeft, ElementRight, CoefficientType> remainderElement, componentElement, currentHighestWeightElement;
  remainderElement=input;
  CoefficientType theCoeff;
  List<int> GeneratorSequence, GeneratorPowers;
  while(!remainderElement.IsEqualToZero())
  { this->ClimbUpFromVector
      (remainderElement, currentHighestWeightElement,
       GeneratorSequence, GeneratorPowers, theGlobalVariables);
    this->ClimbDownFromVectorAccordingToSequence
      (currentHighestWeightElement, componentElement, theCoeff, GeneratorSequence, GeneratorPowers, theGlobalVariables, theRingUnit);
    assert(!theCoeff.IsEqualToZero());
    componentElement/=theCoeff;
    outputVectors.AddObjectOnTop(componentElement);
    remainderElement-=*outputVectors.LastObject();
    std::cout << "<br>found element: " << componentElement.ElementToString();
  }
  return out.str();
}

template<class CoefficientType>
void ElementGeneralizedVerma<CoefficientType>::Nullify
  (GeneralizedVermaModuleData<CoefficientType>& owner)
{ this->theOwner=&owner;
  this->leftComponents.SetSize(owner.theFDspace.size);
  for (int i=0; i<this->leftComponents.size; i++)
  { ElementVermaModuleOrdered<CoefficientType>& currentElt=this->leftComponents.TheObjects[i];
    currentElt.Nullify(this->theOwner->theOwner, this->theOwner->VermaHighestWeighSub);
  }
}

template <class CoefficientType>
std::string ElementGeneralizedVerma<CoefficientType>::ExtractHighestWeightVectors
  (Parser& theParser, List<ElementGeneralizedVerma<CoefficientType> >& outputVectors,
    GlobalVariables& theGlobalVariables)
{ //Index ordering of simpleNegGenerators:
  //if simplePosGenerators.TheObjects[i] is a positive root space then its opposite root space should be
  //simpleNegGenerators.TheObjects[i]
  std::stringstream out;
  outputVectors.size=0;
  ElementGeneralizedVerma<CoefficientType> remainderElement, tempElt, currentHighestWeightElement;
  remainderElement=*this;
  CoefficientType tempCoeff, theCoeff, CentralCharacterAction;
  List<int> GeneratorSequence, GeneratorPowers;
  int counter=0;
  ElementUniversalEnveloping abstractCasimir, embeddedCasimirNonOrdered;
  abstractCasimir.MakeCasimir(theParser.theHmm.theDomain, theParser.theHmm.theRange.GetRank(), theGlobalVariables);
  out << "<br>abstract Casimir: " << abstractCasimir.ElementToString();
  theParser.theHmm.ApplyHomomorphism(abstractCasimir, embeddedCasimirNonOrdered, theGlobalVariables);
  embeddedCasimirNonOrdered.Simplify();
  out << "<br> embedded Casimir non-ordered: " << embeddedCasimirNonOrdered.ElementToString();
  ElementUniversalEnvelopingOrdered<CoefficientType> embeddedCasimir;
  embeddedCasimir.AssignElementUniversalEnveloping(embeddedCasimirNonOrdered, theParser.testAlgebra, this->theOwner->theRingUnit, this->theOwner->theRingZero, &theGlobalVariables);
  out << "<br>the embedded Casimir is: " << embeddedCasimir.ElementToString();
  //return out.str();
  while(!remainderElement.IsEqualToZero() )//&& counter<7)
  { //std::cout << "<br>remainder element: " << remainderElement.ElementToString();
    this->ClimbUpFromVector
      (remainderElement, currentHighestWeightElement,
       GeneratorSequence, GeneratorPowers, theGlobalVariables);
    assert(GeneratorSequence.size==GeneratorPowers.size);
    std::cout << "<br><br><br>And the current sequence is: ";
    for (int i=0; i<GeneratorSequence.size; i++)
    { std:: cout << "(generator " << GeneratorSequence.TheObjects[i] << ")^" << GeneratorPowers.TheObjects[i] << ", ";
    }
    out << "<br>current highest weight element: <div class=\"math\"> " << currentHighestWeightElement.ElementToString() << "</div>";
    currentHighestWeightElement.ActOnMe(embeddedCasimir, tempElt, &theGlobalVariables);
    out << "<br>Casimir acting on current highest: <div class=\"math\"> " << tempElt.ElementToString() <<"</div>";
    bool tempBool=currentHighestWeightElement.IsProportionalTo(tempElt, CentralCharacterAction);
    out << "<br>proportionality coefficient: " << CentralCharacterAction.ElementToString();
    assert(tempBool);
    remainderElement.ActOnMe(embeddedCasimir, tempElt, &theGlobalVariables);
    out << "<br>Casimir acting on <div class=\"math\">" << remainderElement.ElementToString() << "</div> yields <div class=\"math\">" << tempElt.ElementToString() << "</div>";
    remainderElement*=CentralCharacterAction;
    remainderElement-=tempElt;
    remainderElement.ClearDenominators(tempCoeff);
    std::cout << "<br><br>Remaining after clearing the denominators: " << remainderElement.ElementToString();
    counter++;
  }
  return out.str();
}

template <class CoefficientType>
std::string ElementGeneralizedVerma<CoefficientType>::GetStringFormGmodKindex(int theIndex)
{ std::stringstream out;
  if (theIndex<3)
    out << "f_{" << theIndex-3 << "}";
  if (theIndex==3)
    out << "f_{0,3}";
  if (theIndex>3)
    out << "f_{" << theIndex-3 << "}";
  return out.str();
}

template <class CoefficientType>
std::string ElementGeneralizedVerma<CoefficientType>::ElementToString
(bool displayLeftComponenetsOnTheRight, bool useOtimes, bool useFs)
{ if (this->IsEqualToZero())
    return "0";
  std::stringstream out; std::string leftString, rightString;
  bool foundFirstNonZero=false;
  for (int i=0; i<this->leftComponents.size; i++)
  { ElementVermaModuleOrdered<CoefficientType>& currentElt= this->leftComponents.TheObjects[i];
    if (!currentElt.IsEqualToZero())
    { if (foundFirstNonZero)
        out << "+";
      foundFirstNonZero=true;
      leftString=MathRoutines::ElementToStringBrackets(currentElt);
      if (!useFs)
        rightString=MathRoutines::ElementToStringBrackets(this->theOwner->theFDspace.TheObjects[i]);
      else
        rightString= this->GetStringFormGmodKindex(i);
      if (displayLeftComponenetsOnTheRight)
        MathRoutines::swap(leftString, rightString);
      out << leftString;
      if (useOtimes)
        out << "\\otimes";
      out << rightString;
    }
  }
  return out.str();
}

template <class CoefficientType>
void ElementGeneralizedVerma<CoefficientType>::ClimbDownFromHighestWeightAlongSl2String
(ElementGeneralizedVerma<CoefficientType>& input,
   ElementGeneralizedVerma<CoefficientType>& output,
    CoefficientType& outputCoeff,
   const ElementSimpleLieAlgebra& posGenerator, const ElementSimpleLieAlgebra& negGenerator,
     int generatorPower, GlobalVariables& theGlobalVariables)
{ assert(&input!=&output);
  CoefficientType currentWeight;
  ElementGeneralizedVerma<CoefficientType> debugElt;
  input.ActOnMe(posGenerator, debugElt, &theGlobalVariables);
  std::cout << "<br>climbing down with (" << negGenerator.ElementToString() << " )^" << generatorPower << ": ";
  std::cout << input.ElementToString() << "->";
  //if (!debugElt.IsEqualToZero())
  //{ std::cout << "<br>positive generator acting on the supposedly highest weight vector equals: " << debugElt.ElementToString();
  //  std::cout.flush();
  //  assert(false);
  //}
  input.ActOnMe(negGenerator, output, &theGlobalVariables);
  std::cout << output.ElementToString() << "->";
  output.ActOnMe(posGenerator, &theGlobalVariables);
  std::cout << output.ElementToString() << "->";
  std::cout.flush();
  bool tempBool=input.IsProportionalTo(output, currentWeight);
  assert(tempBool);
  CoefficientType RaiseCoeff;
  RaiseCoeff=this->theOwner->theRingZero;
  outputCoeff=this->theOwner->theRingUnit;
  output=input;
  for (int i=0; i<generatorPower; i++)
  { RaiseCoeff+=currentWeight;
    currentWeight-=2;
    outputCoeff*=RaiseCoeff;
    output.ActOnMe(negGenerator, &theGlobalVariables);

  }
}

template <class CoefficientType>
void ElementGeneralizedVerma<CoefficientType>::ClimbUpFromVector
  (ElementGeneralizedVerma<CoefficientType>& input,
   ElementGeneralizedVerma<CoefficientType>& outputLastNonZero,
   List<int>& outputGeneratorSequence, List<int>& outputGeneratorPowers, GlobalVariables& theGlobalVariables)
{ ElementGeneralizedVerma<CoefficientType> tempElt;
  assert(&input!=&outputLastNonZero);
  outputLastNonZero=input;
  outputGeneratorPowers.size=0;
  outputGeneratorSequence.size=0;
  bool found=true;
  while (found)
  { for (int i=0; i<this->theOwner->posGenerators.size; i++)
    { ElementSimpleLieAlgebra& currentGen=this->theOwner->posGenerators.TheObjects[i];
      int counter=0;
      found=false;
      for(outputLastNonZero.ActOnMe(currentGen, tempElt, &theGlobalVariables); !tempElt.IsEqualToZero(); tempElt.ActOnMe(currentGen, &theGlobalVariables))
      { counter++;
        found=true;
        outputLastNonZero=tempElt;
  //      std::cout << "<br> Current state of the element: " << outputLastNonZero.ElementToString();
    //    std::cout.flush();
      }
      if (found)
      { outputGeneratorSequence.AddObjectOnTop(i);
        outputGeneratorPowers.AddObjectOnTop(counter);
      //  std:: cout << "<br> the corresponding generator: " << i << " to the power of " << counter;
      }
    }
  }
}

template <class CoefficientType>
void ElementGeneralizedVerma<CoefficientType>::ActOnMe
(const ElementSimpleLieAlgebra& theElt, ElementGeneralizedVerma<CoefficientType>& output, GlobalVariables* theContext)
{ assert(this!=&output);
  ElementGeneralizedVerma<CoefficientType> actingOnRight;
  output.Nullify(*this->theOwner);
  actingOnRight.Nullify(*this->theOwner);
  ElementSimpleLieAlgebra tempLieElt;
  Vector<RationalFunction> coordFormRightElt;
  for (int i=0; i<output.leftComponents.size; i++)
  { ElementVermaModuleOrdered<CoefficientType>& currentLeft= this->leftComponents.TheObjects[i];
    currentLeft.ActOnMe(theElt, output.leftComponents.TheObjects[i], this->theOwner->theOwner.theOwner, this->theOwner->theRingUnit, this->theOwner->theRingZero, theContext);
    currentLeft.MultiplyOnTheLeft(theElt, output.leftComponents.TheObjects[i], this->theOwner->theRingUnit, this->theOwner->theRingZero, theContext);
  }
//  std::cout << "<br><br>acting on the Universal enveloping part we get:" << output.ElementToString();
  ElementVermaModuleOrdered<CoefficientType> tempElt;
  for (int i=0; i<output.leftComponents.size; i++)
  { ElementSimpleLieAlgebra& currentAlgebraElt=this->theOwner->theFDspace.TheObjects[i];
    this->theOwner->theOwner.theOwner.LieBracket(theElt, currentAlgebraElt, tempLieElt);
    //std::cout << "<br><br>" << theElt.ElementToString() << " acts on " << currentAlgebraElt.ElementToString() << " to obtain: " << tempLieElt.ElementToString();

    bool tempBool=tempLieElt.GetCoordsInBasis(this->theOwner->theFDspace, coordFormRightElt, *theContext);
    //std::cout << "<br>translated in coordinate form this is: " << coordFormRightElt.ElementToString();
    assert(tempBool);
    for (int j=0; j<coordFormRightElt.size; j++)
    { tempElt=this->leftComponents.TheObjects[i];
      tempElt*=(coordFormRightElt.TheObjects[j]);
      output.leftComponents.TheObjects[j]+=tempElt;
    }
  }
//  std::cout<< "<br><br>finally we have: " << output.ElementToString() << " <br>";

}

template <class CoefficientType>
void ElementGeneralizedVerma<CoefficientType>::ClimbDownFromVectorAccordingToSequence
  (ElementGeneralizedVerma<CoefficientType>& input,
   ElementGeneralizedVerma<CoefficientType>& output, CoefficientType& outputCoeff,
   List<int>& inputGeneratorSequence, List<int>& inputGeneratorPowers, GlobalVariables& theGlobalVariables)
 { assert(&input!=&output);
  output=input;
  ElementGeneralizedVerma<CoefficientType> tempElt;
  outputCoeff=this->theOwner->theRingUnit;
  CoefficientType tempCoeff;
  for (int i=inputGeneratorSequence.size-1; i>=0; i--)
  { ElementSimpleLieAlgebra& currentPosGen= this->theOwner->posGenerators.TheObjects[inputGeneratorSequence.TheObjects[i]];
    ElementSimpleLieAlgebra& currentNegGen=this->theOwner->negGenerators.TheObjects[inputGeneratorSequence.TheObjects[i]];
    this->ClimbDownFromHighestWeightAlongSl2String
    (output, tempElt, tempCoeff, currentPosGen, currentNegGen, inputGeneratorPowers.TheObjects[i], theGlobalVariables);
    outputCoeff*=(tempCoeff);
//    std::cout << "<br><br><br>... and the coefficient currently is: " << outputCoeff.ElementToString();
    output=tempElt;
  }
}

template <class CoefficientType>
void ElementGeneralizedVerma<CoefficientType>::ClearDenominators
  (CoefficientType& outputWasMultipliedByThis)
{ outputWasMultipliedByThis=this->theOwner->theRingUnit;
  CoefficientType CurrentCoeff;
  for (int i=0; i<this->leftComponents.size; i++)
  { ElementVermaModuleOrdered<CoefficientType>& currentElt=this->leftComponents.TheObjects[i];
    currentElt.ClearDenominators(CurrentCoeff, this->theOwner->theRingUnit);
    for (int j=0; j<this->leftComponents.size; j++)
      if (i!=j)
        this->leftComponents.TheObjects[j]*=CurrentCoeff;
    outputWasMultipliedByThis*=CurrentCoeff;
  }
}

void RationalFunction::ClearDenominators
(RationalFunction& outputWasMultipliedBy)
{ //outputWasMultipliedBy.MakeNVarConst(this->NumVars, (Rational) 1, this->context);
  Rational tempRat;
  switch(this->expressionType)
  { case RationalFunction::typeRational:
      this->ratValue.GetDen(tempRat);
      outputWasMultipliedBy.MakeNVarConst(this->NumVars, tempRat, this->context);
      this->ratValue*=tempRat;
    break;
    case RationalFunction::typePoly:
      this->Numerator.GetElement().ClearDenominators(tempRat);
      outputWasMultipliedBy.MakeNVarConst(this->NumVars, tempRat, this->context);
    break;
    case RationalFunction::typeRationalFunction:
      RationalFunction tempRF;
      outputWasMultipliedBy.operator=(this->Denominator.GetElement());
      *this*=outputWasMultipliedBy;
      this->ClearDenominators(tempRF);
      outputWasMultipliedBy*=tempRF;
      break;
  }
}

template <class CoefficientType>
bool ElementGeneralizedVerma<CoefficientType>::ActOnMe
  (const ElementUniversalEnvelopingOrdered<CoefficientType>& theElt, ElementGeneralizedVerma<CoefficientType>& output, GlobalVariables* theContext)
{ ElementGeneralizedVerma<CoefficientType> Accum, tempElt;
  Accum.Nullify(*this->theOwner);
  for (int i=0; i<theElt.size; i++)
  { MonomialUniversalEnvelopingOrdered<CoefficientType>& currentMon=theElt.TheObjects[i];
    tempElt=*this;
    for (int j=currentMon.generatorsIndices.size-1; j>=0 ; j--)
    { int thePower;
      if (!currentMon.Powers.TheObjects[j].IsSmallInteger(thePower))
        return false;
      ElementSimpleLieAlgebra& currentLieElt=this->theOwner->theOwner.theOrder.TheObjects[currentMon.generatorsIndices.TheObjects[j]];
      for (int k=0; k<thePower; k++)
        tempElt.ActOnMe(currentLieElt, theContext);
    }
    tempElt*=currentMon.Coefficient;
    Accum+=tempElt;
  }
  output=Accum;
  return true;
}

bool ElementSimpleLieAlgebra::ElementToStringNeedsBracketsForMultiplication()const
{ return this->Hcomponent.GetNumNonZeroCoords()+this->NonZeroElements.CardinalitySelection>1;
}

template<class CoefficientType>
bool ElementVermaModuleOrdered<CoefficientType>::ElementToStringNeedsBracketsForMultiplication()const
{ return this->theElT.ElementToStringNeedsBracketsForMultiplication();
}

class slTwoInSlN
{
  int GetModuleIndexFromHighestWeightVector(const MatrixLargeRational& input)
  { Rational tempRat;
    for (int i=0; i<this->theHighestWeightVectors.size; i++)
      if (this->theHighestWeightVectors.TheObjects[i].IsProportionalTo(input, tempRat))
        return i;
    return -1;
  }
public:
  int theDimension;
  MatrixLargeRational theH;
  MatrixLargeRational theE;
  MatrixLargeRational theF;

  List<int> thePartition;
  List<MatrixLargeRational> theProjectors;
  List<MatrixLargeRational> theHighestWeightVectors;
  List<List<MatrixLargeRational> > theGmodKModules;
  List<List<List<int> > > PairingTable;
  void GetIsPlusKIndexingFrom(int input, int& s, int& k);
  std::string ElementMatrixToTensorString(const MatrixLargeRational& input, bool useHtml);
  std::string initFromModuleDecomposition(List<int>& decompositionDimensions, bool useHtml);
  std::string initPairingTable(bool useHtml);
  std::string ElementModuleIndexToString(int input, bool useHtml);
  std::string GetNotationString(bool useHtml);

  std::string PairTwoIndices
  (List<int>& output, int leftIndex, int rightIndex, bool useHtml)
  ;
  void ExtractHighestWeightVectorsFromVector
  (MatrixLargeRational& input, List<MatrixLargeRational>& outputDecompositionOfInput, List<MatrixLargeRational>& outputTheHWVectors)
  ;
  void ClimbDownFromHighestWeightAlongSl2String
  (MatrixLargeRational& input, MatrixLargeRational& output, Rational& outputCoeff, int generatorPower)
  ;
  void ClimbUpFromVector
  (MatrixLargeRational& input, MatrixLargeRational& outputLastNonZero, int& largestPowerNotKillingInput)
  ;
};

void slTwoInSlN::ClimbDownFromHighestWeightAlongSl2String
  (MatrixLargeRational& input, MatrixLargeRational& output, Rational& outputCoeff, int generatorPower)
{ assert(&input!=&output);
  Rational currentWeight;
  MatrixLargeRational::LieBracket(this->theH, input, output);
  bool tempBool=input.IsProportionalTo(output, currentWeight);
  if (!tempBool)
    std::cout << "<br>oh no! climbing down is fucked up!";
  Rational RaiseCoeff;
  RaiseCoeff.MakeZero();
  outputCoeff.MakeOne();
  output=input;
  for (int i=0; i<generatorPower; i++)
  { RaiseCoeff+=currentWeight;
    currentWeight-=2;
    outputCoeff*=RaiseCoeff;
    MatrixLargeRational::LieBracket(this->theF, output, output);
  }
}

std::string slTwoInSlN::ElementModuleIndexToString(int input, bool useHtml)
{ std::string beginMath, endMath, newLine;
  if (useHtml)
  { beginMath= "<span class=\"math\">";
    endMath= "</span>";
    newLine="<br>";
  } else
  { beginMath="$";
    endMath="$";
    newLine="\n\n\n";
  }
  MatrixLargeRational& currentHW=this->theHighestWeightVectors.TheObjects[input];
  int currentEtaHw=this->theGmodKModules.TheObjects[input].size-1;
  //currentEtaHw-=currentEtaHw/2;
  int firstNonZeroRow, firstNonZeroColumn;
  bool found=false;
  for (int i=0; i<currentHW.NumRows; i++)
  { if (found)
      break;
    for (int j=0; j<currentHW.NumCols; j++)
      if (!currentHW.elements[i][j].IsEqualToZero())
      { firstNonZeroColumn=j;
        firstNonZeroRow=i;
        found =true;
        break;
      }
  }
  int sRow, kRow, sColumn, kColumn;
  this->GetIsPlusKIndexingFrom(firstNonZeroRow, sRow, kRow);
  this->GetIsPlusKIndexingFrom(firstNonZeroColumn, sColumn, kColumn);
  std::stringstream out;
  out << "V_{";
  if (currentEtaHw!=0)
  { if (currentEtaHw!=1)
      out << currentEtaHw;
    out << "\\frac\\eta 2";
  }
  if (sRow!=sColumn)
    out << "-\\zeta_" << sColumn << "+\\zeta_" << sRow;
  out << "}";
  return out.str();
}

void slTwoInSlN::GetIsPlusKIndexingFrom(int input, int& s, int& k)
{ s=0;
  k=input;
  if (input >=this->theDimension || input <0)
    return;
  for (int offset=0; offset<=input; offset+=this->thePartition.TheObjects[s-1])
  { k=input-offset;
    s++;
  }
}

std::string slTwoInSlN::ElementMatrixToTensorString(const MatrixLargeRational& input, bool useHtml)
{ std::string beginMath, endMath, newLine;
  if (useHtml)
  { beginMath= "<span class=\"math\">";
    endMath= "</span>";
    newLine="<br>";
  } else
  { beginMath="$";
    endMath="$";
    newLine="\n\n\n";
  }
  std::stringstream out;
  std::string tempS;
  bool found=false;
  for (int i=0; i<input.NumRows; i++)
    for(int j=0; j<input.NumCols; j++)
      if (!input.elements[i][j].IsEqualToZero())
      { input.elements[i][j].ElementToString(tempS);
        if (tempS=="-1")
          tempS="-";
        if (tempS=="1")
        { tempS="";
          if (found)
            out << "+";
        } else
          if (found)
            if (tempS[0]!='-')
              out << "+";
        found=true;
        out << tempS;
        int sI, kI, sJ, kJ;
        this->GetIsPlusKIndexingFrom(i, sI, kI);
        this->GetIsPlusKIndexingFrom(j, sJ, kJ);
        out << "v_{i_{" << sI << "}";
        if (kI!=0)
          out <<"+" << kI;
        out << "}\\otimes v^*_{i_{" << sJ << "}";
        if (kJ!=0)
          out  << "+" << kJ;
        out << "}";
      }
  return out.str();
}

void slTwoInSlN::ExtractHighestWeightVectorsFromVector
  (MatrixLargeRational& input, List<MatrixLargeRational>& outputDecompositionOfInput, List<MatrixLargeRational>& outputTheHWVectors)
{ outputDecompositionOfInput.size=0; outputTheHWVectors.size=0;
  MatrixLargeRational remainder; remainder=input;
  MatrixLargeRational component, highestWeightVector, tempMat;
  Rational theCoeff, tempRat;
  int largestPowerNotKillingInput;
  while(!remainder.IsEqualToZero() )
  { //std::cout << "<br>remainder:<div class=\"math\">" << remainder.ElementToString(false, true) << "</div>";
    this->ClimbUpFromVector(remainder, highestWeightVector, largestPowerNotKillingInput);
    //std::cout << "<br>highest weight vector:<div class=\"math\">" << highestWeightVector.ElementToString(false, true) << "</div>";
    this->ClimbDownFromHighestWeightAlongSl2String(highestWeightVector, component, theCoeff, largestPowerNotKillingInput);
    for (int i=0; i<this->theProjectors.size; i++)
    { MatrixLargeRational& currentProjector=this->theProjectors.TheObjects[i];
      tempMat=highestWeightVector;
      tempMat.MultiplyOnTheLeft(currentProjector);
      if (!tempMat.IsEqualToZero())
      { tempMat.FindFirstNonZeroElementSearchEntireRow(tempRat);
        tempMat/=tempRat;
        outputTheHWVectors.AddObjectOnTop(tempMat);
      }
    }
    //assert(!theCoeff.IsEqualToZero());
    component.DivideByRational(theCoeff);
    outputDecompositionOfInput.AddObjectOnTop(component);
    //std::cout << "<br>component:<div class=\"math\">" << component.ElementToString(false, true) << "</div><br><br><br><br>";
    remainder.Subtract(component);
  }
  //remainder.NullifyAll();
//  for (int i=0; i<outputVectors.size; i++)
//    remainder.Add(outputVectors.TheObjects[i]);
//  std::cout << "<br>sum of all components:<div class=\"math\">" << remainder.ElementToString(false, true) << "</div>";

}

void slTwoInSlN::ClimbUpFromVector
  (MatrixLargeRational& input, MatrixLargeRational& outputLastNonZero, int& largestPowerNotKillingInput)
{ MatrixLargeRational tempMat;
  assert(&input!=&outputLastNonZero);
  outputLastNonZero=input;
  largestPowerNotKillingInput=0;
  for(MatrixLargeRational::LieBracket(this->theE, outputLastNonZero, tempMat); !tempMat.IsEqualToZero(); MatrixLargeRational::LieBracket(this->theE, outputLastNonZero, tempMat))
  { largestPowerNotKillingInput++;
    outputLastNonZero=tempMat;
  }
}

std::string slTwoInSlN::GetNotationString(bool useHtml)
{ std::stringstream out;
  std::string beginMath, endMath, newLine;
  if (useHtml)
  { beginMath= "<span class=\"math\">";
    endMath= "</span>";
    newLine="<br>";
  } else
  { beginMath="$";
    endMath="$";
    newLine="\n\n\n";
  }
  out << newLine << "Let the starting index of the j-th block be " << beginMath << "i_j" << endMath;
  out << "." << newLine << "In particular let: ";
  int offset=1;
  for (int i=0; i< this->thePartition.size; i++)
  { out << beginMath << "i_" << i+1 << "=" << offset << endMath << " ";
    out << " (size of block = " << this->thePartition.TheObjects[i] << "), ";
    offset+=this->thePartition.TheObjects[i];
  }
  out << newLine << "Let " << beginMath << "\\eta" << endMath << " be the weight corresponding to h.";
  out << newLine << "Let " << beginMath << "\\zeta_{j}" << endMath << " be the weight corresponding to the j-th block";
  return out.str();
}

std::string slTwoInSlN::initFromModuleDecomposition(List<int>& decompositionDimensions, bool useHtml)
{ std::stringstream out;
  this->thePartition.CopyFromBase(decompositionDimensions);
  this->thePartition.QuickSortDescending();
  this->theDimension=0;
  for (int i=0; i<this->thePartition.size; i++)
    this->theDimension+=this->thePartition.TheObjects[i];
  theH.init(this->theDimension, this->theDimension); theH.NullifyAll();
  theE.init(this->theDimension, this->theDimension); theE.NullifyAll();
  theF.init(this->theDimension, this->theDimension); theF.NullifyAll();
  this->theProjectors.SetSize(this->thePartition.size);
  int currentOffset=0;
  std::string beginMath, endMath, newLine;
  if (useHtml)
  { beginMath= "<span class=\"math\">";
    endMath= "</span>";
    newLine="<br>";
  } else
  { beginMath="$";
    endMath="$";
    newLine="\n\n\n";
  }
  for (int i=0; i<this->thePartition.size; i++)
  { this->theProjectors.TheObjects[i].init(this->theDimension, this->theDimension);
    this->theProjectors.TheObjects[i].NullifyAll();
    for (int j=0; j<this->thePartition.TheObjects[i]; j++)
    { theH.elements[currentOffset+j][currentOffset+j]=this->thePartition.TheObjects[i]-1-2*j;
      this->theProjectors.TheObjects[i].elements[currentOffset+j][currentOffset+j]=1;
      if (j!=this->thePartition.TheObjects[i]-1)
      { theF.elements[currentOffset +j+1][currentOffset +j]=1;
        theE.elements[currentOffset +j][currentOffset +j+1]=(j+1)*(this->thePartition.TheObjects[i]-j-1);
      }
    }
    currentOffset+=this->thePartition.TheObjects[i];
  }
  out << newLine << beginMath << "h=" << this->ElementMatrixToTensorString(this->theH, useHtml) << "=" << this->theH.ElementToStringWithBlocks(this->thePartition) << endMath;
  out << newLine << beginMath << "e=" << this->ElementMatrixToTensorString(this->theE, useHtml) << "=" << this->theE.ElementToStringWithBlocks(this->thePartition) << endMath;
  out << newLine << beginMath << "f=" << this->ElementMatrixToTensorString(this->theF, useHtml) << "=" << this->theF.ElementToStringWithBlocks(this->thePartition)  << endMath;
  MatrixLargeRational tempMat;
  tempMat.init(this->theDimension, this->theDimension);
  List<MatrixLargeRational> Decomposition, theHwCandidatesBeforeProjection, theHwCandidatesProjected;
  this->theHighestWeightVectors.size=0;
  this->theGmodKModules.size=0;
  for (int i=0; i<this->theDimension; i++)
    for (int j=0; j< this->theDimension; j++)
    { tempMat.NullifyAll();
      tempMat.elements[i][j]=1;
      this->ExtractHighestWeightVectorsFromVector(tempMat, Decomposition, theHwCandidatesBeforeProjection);
      theHwCandidatesProjected.size=0;
      for (int k=0; k<theHwCandidatesBeforeProjection.size; k++)
        for (int l=0; l<this->theProjectors.size; l++)
        { tempMat=theHwCandidatesBeforeProjection.TheObjects[k];
          tempMat.MultiplyOnTheLeft(this->theProjectors.TheObjects[l]);
          if (!tempMat.IsEqualToZero())
            theHwCandidatesProjected.AddObjectOnTop(tempMat);
        }
      for (int k=0; k<theHwCandidatesProjected.size; k++)
        if (this->GetModuleIndexFromHighestWeightVector(theHwCandidatesProjected.TheObjects[k])==-1)
        { MatrixLargeRational& currentHighest=theHwCandidatesProjected.TheObjects[k];
          this->theHighestWeightVectors.AddObjectOnTop(currentHighest);
          this->theGmodKModules.ExpandOnTop(1);
          List<MatrixLargeRational>& currentMod=*this->theGmodKModules.LastObject();
          currentMod.size=0;
          for (tempMat=currentHighest; !tempMat.IsEqualToZero(); MatrixLargeRational::LieBracket(this->theF, tempMat, tempMat))
            currentMod.AddObjectOnTop(tempMat);
        }
    }
  out << this->GetNotationString(useHtml);
  out << newLine << "...and the highest weights of the module decomposition are (" << this->theHighestWeightVectors.size << " modules):";
  for (int i=0; i<this->theHighestWeightVectors.size; i++)
  { out << newLine << beginMath << this->ElementMatrixToTensorString(theHighestWeightVectors.TheObjects[i], useHtml) << endMath << ", highest weight of ";
    out << beginMath << this->ElementModuleIndexToString(i, useHtml) << endMath;
   //for (int j=1; j<this->theGmodKModules.TheObjects[i].size; j++)
   //   out << "<br><div class=\"math\">" << this->theGmodKModules.TheObjects[i].TheObjects[j].ElementToString(false, true) << "</div>";
   // out << "<br><br><br>";
  }
  out << this->initPairingTable(useHtml);
  return out.str();
}

std::string slTwoInSlN::initPairingTable(bool useHtml)
{ std::stringstream out;
  this->PairingTable.SetSize(this->theHighestWeightVectors.size);
  for (int i=0; i<this->PairingTable.size; i++)
  { this->PairingTable.TheObjects[i].SetSize(this->theHighestWeightVectors.size);
    for(int j=0; j<this->PairingTable.TheObjects[i].size; j++)
    { List<int>& currentPairing=this->PairingTable.TheObjects[i].TheObjects[j];
      out << this->PairTwoIndices(currentPairing, i, j, useHtml);
    }
  }
  return out.str();
}

std::string slTwoInSlN::PairTwoIndices
  (List<int>& output, int leftIndex, int rightIndex, bool useHtml)
{ std::string beginMath, endMath, newLine;
  if (useHtml)
  { beginMath= "<span class=\"math\">";
    endMath= "</span>";
    newLine="<br>";
  } else
  { beginMath="$";
    endMath="$";
    newLine="\n\n\n";
  }
  std::stringstream out;
  output.size=0;
  List<MatrixLargeRational>& leftElements=this->theGmodKModules.TheObjects[leftIndex];
  List<MatrixLargeRational>& rightElements=this->theGmodKModules.TheObjects[rightIndex];
  MatrixLargeRational tempMat;
  List<MatrixLargeRational> HighestWeightsContainingModules;
  List<MatrixLargeRational> tempDecomposition;
  for (int i=0; i<leftElements.size; i++)
    for (int j=0; j<rightElements.size; j++)
    { MatrixLargeRational& leftElt=leftElements.TheObjects[i];
      MatrixLargeRational& rightElt=rightElements.TheObjects[j];
      MatrixLargeRational::LieBracket(leftElt, rightElt, tempMat);
      if (!tempMat.IsEqualToZero())
      { this->ExtractHighestWeightVectorsFromVector(tempMat, tempDecomposition, HighestWeightsContainingModules);
        for (int k=0; k<HighestWeightsContainingModules.size; k++)
        { output.AddOnTopNoRepetition(this->GetModuleIndexFromHighestWeightVector(HighestWeightsContainingModules.TheObjects[k]));
          if (this->GetModuleIndexFromHighestWeightVector(HighestWeightsContainingModules.TheObjects[k])==-1)
            std::cout << newLine << beginMath << "[" << leftElt.ElementToString(false, true) << ", " << rightElt.ElementToString(false, true) << "]=" << tempMat.ElementToString(false, true) << endMath;
        }
      }
    }
  out << newLine << beginMath << this->ElementModuleIndexToString(leftIndex, useHtml) << endMath << " and " << beginMath << this->ElementModuleIndexToString(rightIndex, useHtml) << endMath << " pair to: ";
  for (int i=0; i<output.size; i++)
  { out << beginMath << this->ElementModuleIndexToString(output.TheObjects[i], useHtml) << endMath;
    if (i!=output.size-1)
      out << beginMath << "\\oplus" << endMath;
  }
  if (output.size>0)
  { out << "  hw vectors: ";
    for (int i=0; i<output.size; i++)
      out << beginMath << this->ElementMatrixToTensorString(this->theHighestWeightVectors.TheObjects[output.TheObjects[i]], useHtml) << endMath << ",";
  }
  return out.str();
}

void ParserNode::EvaluateSlTwoInSlN(GlobalVariables& theGlobalVariables)
{ if (this->children.size!=1)
  { this->SetError(this->errorProgramming);
    return;
  }
  ParserNode& theArgument=this->owner->TheObjects[this->children.TheObjects[0]];
  List<int> thePartition;
  if (theArgument.ExpressionType==this->typeArray)
  { if (!theArgument.ConvertChildrenToType(this->typeIntegerOrIndex, theGlobalVariables))
    { this->SetError(this->errorBadOrNoArgument);
      return;
    }
    int theDimension=theArgument.children.size;
    thePartition.SetSize(theDimension);
    for (int i=0; i<theDimension; i++)
    { ParserNode& current= this->owner->TheObjects[theArgument.children.TheObjects[i]];
      thePartition.TheObjects[i]=current.intValue;
    }
  } else
    if (!theArgument.ConvertToType(this->typeIntegerOrIndex, theGlobalVariables))
    { this->SetError(this->errorBadOrNoArgument);
      return;
    } else
    { thePartition.SetSize(1);
      thePartition.TheObjects[0]=theArgument.intValue;
    }
    slTwoInSlN theSl2;

    this->ExpressionType=this->typeString;
    std::fstream outputFile;
    std::string fileName;
    fileName.append(this->owner->outputFolderPath);
    fileName.append("output.tex");
    CGIspecificRoutines::OpenDataFileOrCreateIfNotPresent(outputFile, fileName, false, true, false);
    outputFile << "\\documentclass{article} \\begin{document}\n" << theSl2.initFromModuleDecomposition(thePartition, false) << "\n\\end{document}";
    std::stringstream out;
    out << "A latex/pdf file: <a href=\"" << this->owner->outputFolderDisplayPath << "output.tex\"> output.tex</a>";
    out << ", <a href=\"" << this->owner->outputFolderDisplayPath << "output.pdf\"> output.pdf</a>";
    this->outputString=out.str();
    std::stringstream theCommand;
    theCommand << "pdflatex -output-directory=" << this->owner->outputFolderPath << "   " << fileName ;
    this->owner->SystemCommands.AddObjectOnTop(theCommand.str());
}

void RationalFunction::AddHonestRF
(const RationalFunction& other)
{ Rational tempRat;
  if (!this->Denominator.GetElement().IsProportionalTo(other.Denominator.GetElementConst(), tempRat, (Rational) 1))
  { PolynomialRationalCoeff buffer;
    RationalFunction debugger;
    debugger=other;
    debugger.ComputeDebugString();
    this->ComputeDebugString();
    buffer=this->Denominator.GetElement();
    this->Numerator.GetElement().MultiplyBy(other.Denominator.GetElementConst());
    buffer.MultiplyBy(other.Numerator.GetElementConst());
    this->Numerator.GetElement().AddPolynomial(buffer);
    this->Denominator.GetElement().MultiplyBy(other.Denominator.GetElementConst());
    this->Simplify();
    this->ComputeDebugString();
  } else
  { this->Numerator.GetElement().TimesConstant(tempRat);
    this->Denominator.GetElement().TimesConstant(tempRat);
    this->Numerator.GetElement().AddPolynomial(other.Numerator.GetElementConst());
    this->ReduceMemory();
    this->SimplifyLeadingCoefficientOnly();
  }
  assert(this->checkConsistency());
}

int ParserNode::EvaluateTimes(GlobalVariables& theGlobalVariables)
{ if (!this->AllChildrenAreOfDefinedNonErrorType())
    return this->SetError(this->errorOperationByUndefinedOrErrorType);
  this->ConvertChildrenAndMyselfToStrongestExpressionChildren(theGlobalVariables);
  this->InitForMultiplication(&theGlobalVariables);
  LargeInt theInt;
  for (int i=0; i<this->children.size; i++)
  { ParserNode& currentChild=this->owner->TheObjects[this->children.TheObjects[i]];
    switch (this->ExpressionType)
    { case ParserNode::typeIntegerOrIndex:
        theInt=this->intValue;
        theInt*=currentChild.intValue;
        if (theInt.value.size>1)
        { this->ExpressionType= this->typeRational;
          this->rationalValue=theInt;
        } else
          this->intValue=theInt.value.TheObjects[0]*theInt.sign;
      break;
      case ParserNode::typeRational: this->rationalValue*=currentChild.rationalValue; break;
      case ParserNode::typeRationalFunction: this->ratFunction.GetElement()*=currentChild.ratFunction.GetElement(); break;
      case ParserNode::typePoly: this->polyValue.GetElement().MultiplyBy(currentChild.polyValue.GetElement()); break;
      case ParserNode::typeUEelement: this->UEElement.GetElement()*=currentChild.UEElement.GetElement(); break;
      case ParserNode::typeUEElementOrdered: this->UEElementOrdered.GetElement()*=currentChild.UEElementOrdered.GetElement(); break;
      case ParserNode::typeWeylAlgebraElement: this->WeylAlgebraElement.GetElement().MultiplyOnTheRight(currentChild.WeylAlgebraElement.GetElement()); break;
      case ParserNode::typeLattice:
        this->theLattice.GetElement()=this->owner->TheObjects[this->children.TheObjects[0]].theLattice.GetElement();
        this->theLattice.GetElement().IntersectWith(this->owner->TheObjects[this->children.TheObjects[1]].theLattice.GetElement());
        this->outputString=this->theLattice.GetElement().ElementToString();
        return this->errorNoError;
      default: return this->SetError(this->errorMultiplicationByNonAllowedTypes);
    }
  }
  return this->errorNoError;
}

int ParserNode::EvaluatePlus(GlobalVariables& theGlobalVariables)
{ if (!this->AllChildrenAreOfDefinedNonErrorType())
    return this->SetError(this->errorOperationByUndefinedOrErrorType);
  this->ConvertChildrenAndMyselfToStrongestExpressionChildren(theGlobalVariables);
  this->InitForAddition(&theGlobalVariables);
  LargeInt theInt;
  for (int i=0; i<this->children.size; i++)
  { ParserNode& currentChild=this->owner->TheObjects[this->children.TheObjects[i]];
    switch (this->ExpressionType)
    { case ParserNode::typeIntegerOrIndex:
        theInt=this->intValue;
        theInt+=currentChild.intValue;
        if (theInt.value.size>1)
        { this->ExpressionType= this->typeRational;
          this->rationalValue=theInt;
        } else
          this->intValue=theInt.value.TheObjects[0]*theInt.sign;
      break;
      case ParserNode::typeRational: this->rationalValue+=currentChild.rationalValue; break;
      case ParserNode::typeRationalFunction: this->ratFunction.GetElement()+=currentChild.ratFunction.GetElement(); break;
      case ParserNode::typePoly: this->polyValue.GetElement().AddPolynomial(currentChild.polyValue.GetElement()); break;
      case ParserNode::typeUEElementOrdered: this->UEElementOrdered.GetElement().operator+=(currentChild.UEElementOrdered.GetElement()); break;
      case ParserNode::typeUEelement: this->UEElement.GetElement()+=currentChild.UEElement.GetElement(); break;
      case ParserNode::typeWeylAlgebraElement: this->WeylAlgebraElement.GetElement().Add(currentChild.WeylAlgebraElement.GetElement()); break;
      case ParserNode::typeLattice:
        this->theLattice.GetElement()=currentChild.theLattice.GetElement();
        this->theLattice.GetElement().RefineByOtherLattice(this->owner->TheObjects[this->children.TheObjects[1]].theLattice.GetElement());
        this->outputString=this->theLattice.GetElement().ElementToString();
        return this->errorNoError;
      default: return this->SetError(this->errorUnknownOperation);
    }
  }
  return this->errorNoError;
}
