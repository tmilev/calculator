// The current file is licensed under the license terms found in the main header file "calculator.h".
// For additional information refer to the file "calculator.h".
#include "general_lists.h"
#include "math_general_implementation.h"
#include "math_general.h"
#include "math_general_polynomial_computations_basic_implementation.h"
#include "math_extra_algebraic_numbers.h"
#include "math_extra_universal_enveloping.h"
#include "math_rational_function_implementation.h"
#include "math_extra_semisimple_lie_algebras_root_subalgebras.h"
#include "math_extra_semisimple_lie_algebras_implementation.h"
#include "math_extra_finite_groups_implementation.h"
#include "math_extra_universal_enveloping_implementation.h" // undefined reference to `ElementUniversalEnveloping<RationalFunctionOld>::makeZero(SemisimpleLieAlgebra&)'
#include "math_extra_differential_operators.h"

std::string MonomialWeylAlgebra::toString(FormatExpressions* format) const {
  if (this->isConstant()) {
    return "1";
  }
  std::stringstream out;
  FormatExpressions tempFormat;
  if (format == nullptr) {
    tempFormat.polyDefaultLetter = "\\partial";
  } else {
    tempFormat.polyDefaultLetter = format->weylAlgebraDefaultLetter;
    tempFormat.polynomialAlphabet = format->weylAlgebraLetters;
  }
  std::string firstS = this->polynomialPart.toString(format);
  std::string secondS = this->differentialPart.toString(&tempFormat);
  if (firstS != "1") {
    out << firstS;
  }
  if (secondS != "1") {
    out << secondS;
  }
  return out.str();
}

std::string QuasiDifferentialMononomial::toString(FormatExpressions* format) const {
  std::stringstream out;
  out << this->weylMonomial.toString(format) << "\\otimes ";
  out << this->matrixMonomial.toString(format);
  return out.str();
}

Vector<Rational> SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms::getRho() {
  Vector<Rational> result;
  this->rootsOfBorel.sum(result, this->ambientWeyl->getDimension());
  result /= 2;
  return result;
}

void SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms::getMatrixOfElement(
  const ElementSubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms& input, Matrix<Rational>& outputMatrix
) const {
  Vectors<Rational> startBasis, imageBasis;
  startBasis.makeEiBasis(this->ambientWeyl->getDimension());
  this->actByElement(input, startBasis, imageBasis);
  outputMatrix.assignVectorsToRows(imageBasis);
  outputMatrix.transpose();
}

bool SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms::computeSubGroupFromGeneratingReflections(
  Vectors<Rational>* inputRoots,
  List<Vectors<Rational> >* inputExternalAutos,
  int upperLimitNumberOfElements,
  bool recomputeAmbientRho
) {
  MacroRegisterFunctionWithName("SubgroupWeylGroupAutomorphisms::SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms");
  this->checkInitialization();
  HashedList<Vector<Rational> > orbitRho;
  this->truncated = false;
  this->allElements.clear();
  orbitRho.clear();
  if (this->ambientWeyl->cartanSymmetric.numberOfRows < 1) {
    return false;
  }
  if (recomputeAmbientRho) {
    this->ambientWeyl->computeRho(false);
  }
  this->simpleRootsInner.setSize(0);
  if (inputRoots != nullptr) {
    this->simpleRootsInner = *inputRoots;
  }
  if (inputExternalAutos != nullptr) {
    this->externalAutomorphisms = *inputExternalAutos;
  }
  this->ambientWeyl->transformToSimpleBasisGenerators(this->simpleRootsInner, this->ambientWeyl->rootSystem);
  this->computeRootSubsystem();
  ElementSubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms currentElement;
  currentElement.owner = this;
  Vector<Rational> vectorGeneratingFaithfulOrbit;
  vectorGeneratingFaithfulOrbit = this->ambientWeyl->rho;
  // We desire that the stabilizer of vectorGeneratingFaithfulOrbit
  // is trivial, i.e., the orbit generated by that vector will have as many
  // elements as the subgroup.
  // This is guaranteed if the vector has trivial stabilizer in the
  // ambient Weyl group + outer automorphisms.
  // The rho element (half sum of positive roots divided by 2)
  // almost meets the requirements: it has no stabilizer in the Weyl group
  // but unfortunately is not stabilized by the outer automorphisms.
  // To circumvent the issue, we make the following dirty hack
  // which will work on any simple Weyl group. A proper fix
  // requires some math work and we postpone it to the future.
  vectorGeneratingFaithfulOrbit *= 50; // scale rho by 50
  vectorGeneratingFaithfulOrbit[0].addInteger(1); // <- slightly perturb the first coordinate.
  // This perturbation breaks the outer automorphism invariance for all
  // simple Weyl group of simple Lie algebras.
  // This needs needs improvement for non-simple groups.
  orbitRho.addOnTop(vectorGeneratingFaithfulOrbit);
  this->allElements.addOnTop(currentElement);
  Vector<Rational> currentRoot;
  for (int i = 0; i < this->allElements.size; i ++) {
    for (int j = 0; j < this->simpleRootsInner.size; j ++) {
      this->ambientWeyl->reflectBetaWithRespectToAlpha(this->simpleRootsInner[j], orbitRho[i], false, currentRoot);
      if (!orbitRho.contains(currentRoot)) {
        orbitRho.addOnTop(currentRoot);
        currentElement = this->allElements[i];
        currentElement.multiplyOnTheRightBySimpleRootInner(j);
        this->allElements.addOnTop(currentElement);
      }
    }
    for (int j = 1; j < this->externalAutomorphisms.size; j ++) {
      orbitRho[i].getCoordinatesInBasis(this->externalAutomorphisms[j], currentRoot);
      if (!orbitRho.contains(currentRoot)) {
        orbitRho.addOnTop(currentRoot);
        currentElement = this->allElements[i];
        currentElement.multiplyOnTheRightByOuterAutomorphism(j);
        this->allElements.addOnTop(currentElement);
      }
    }
    if (upperLimitNumberOfElements > 0) {
      if (this->allElements.size >= upperLimitNumberOfElements) {
        this->truncated = true;
        return false;
      }
    }
  }
  return true;
}

std::string DrawOperations::typeCircleAtVector = "circleAtVector";
std::string DrawOperations::typePath = "path";
std::string DrawOperations::typeSegment = "segment";
std::string DrawOperations::typeSegment2DFixed = "segment2DFixed";
std::string DrawOperations::typeTextAtVector = "text";
std::string DrawOperations::typeText2DFixed = "text2DFixed";
std::string DrawOperations::typeFilledShape = "filledShape";
std::string DrawOperations::typeHighlightGroup = "highlightGroup";

std::string DrawOperations::fieldColor = "color";
std::string DrawOperations::fieldOperation = "operation";
std::string DrawOperations::fieldPoints = "points";
std::string DrawOperations::fieldLocation = "location";
std::string DrawOperations::fieldRadius = "radius";
std::string DrawOperations::fieldPenStyle = "penStyle";
std::string DrawOperations::fieldText = "text";
std::string DrawOperations::fieldLabels = "labels";
std::string DrawOperations::fieldLineWidth = "lineWidth";
std::string DrawOperations::fieldFrameId = "frameId";
std::string DrawOperations::fieldFrameIndex = "frameIndex";

void DrawOperations::drawCircleAtVectorBufferRational(
  const Vector<Rational>& input, const std::string& color, double radius, const std::string& frameId, int frameIndex
) {
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeCircleAtVector;
  theOperation[DrawOperations::fieldLocation] = input.getVectorDouble();
  theOperation[DrawOperations::fieldRadius] = radius;
  theOperation[DrawOperations::fieldColor] = color;
  if (frameId != "") {
    theOperation[DrawOperations::fieldFrameId] = frameId;
    theOperation[DrawOperations::fieldFrameIndex] = frameIndex;
  }
  //theOperation[DrawOperations::fieldPenStyle] = DrawOperations::fieldPenStyle;
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawCircleAtVectorBufferDouble(
  const Vector<double>& input, const std::string& color, double radius
) {
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeCircleAtVector;
  theOperation[DrawOperations::fieldLocation] = input;
  theOperation[DrawOperations::fieldRadius] = radius;
  theOperation[DrawOperations::fieldColor] = color;
  //theOperation[DrawOperations::fieldPenStyle] = DrawOperations::fieldPenStyle;
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawLineBetweenTwoVectorsBufferRational(
  const Vector<Rational>& vector1, const Vector<Rational>& vector2, const std::string& color, double lineWidth
) {
  this->drawLineBetweenTwoVectorsBufferDouble(vector1.getVectorDouble(), vector2.getVectorDouble(), color, lineWidth);
}

void DrawOperations::drawPath(
  const Vectors<Rational>& vectors,
  const std::string& color,
  double lineWidth,
  const std::string& frameId,
  int frameIndex
) {
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typePath;
  Vectors<double> vectorsDouble;
  vectors.getVectorsDouble(vectorsDouble);
  theOperation[DrawOperations::fieldPoints] = vectorsDouble;
  theOperation[DrawOperations::fieldFrameId] = frameId;
  theOperation[DrawOperations::fieldFrameIndex] = frameIndex;
  if (color != "") {
    theOperation[DrawOperations::fieldColor] = color;
  }
  if (lineWidth != 1.0) {
    theOperation[DrawOperations::fieldLineWidth] = lineWidth;
  }
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawLineBetweenTwoVectorsBufferDouble(
  const Vector<double>& vector1, const Vector<double>& vector2, const std::string& color, double lineWidth
) {
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeSegment;
  theOperation[DrawOperations::fieldPoints] = JSData::token::tokenArray;
  theOperation[DrawOperations::fieldPoints][0] = vector1;
  theOperation[DrawOperations::fieldPoints][1] = vector2;
  if (color != "") {
    theOperation[DrawOperations::fieldColor] = color;
  }
  if (lineWidth != 1.0) {
    theOperation[DrawOperations::fieldLineWidth] = lineWidth;
  }
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawFilledShape(
  const List<Vector<double> >& corners,
  uint32_t penStyle,
  int colorIndex,
  int fillColorIndex,
  double lineWidth
) {
  (void) penStyle;
  (void) colorIndex;
  (void) fillColorIndex;
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeFilledShape;
  theOperation[DrawOperations::fieldPoints] = JSData::token::tokenArray;
  for (int i = 0; i < corners.size; i ++) {
    theOperation[DrawOperations::fieldPoints][i] = corners[i];
  }
  if (lineWidth != 1.0) {
    theOperation[DrawOperations::fieldLineWidth] = lineWidth;
  }
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawTextAtVectorBufferRational(
  const Vector<Rational>& input, const std::string& inputText, const std::string& color, int fontSize
) {
  (void) color;
  (void) fontSize;
  JSData operation;
  operation[DrawOperations::fieldOperation] = DrawOperations::typeTextAtVector;
  operation[DrawOperations::fieldLocation] = input.getVectorDouble();
  operation[DrawOperations::fieldText] = inputText;
  this->theOperations.addOnTop(operation);
}

void DrawOperations::drawTextAtVectorBufferDouble(
  const Vector<double>& input,
  const std::string& inputText,
  int ColorIndex,
  int fontSize,
  int textStyle
) {
  (void) ColorIndex;
  (void) fontSize;
  (void) textStyle;
  JSData operation;
  operation[DrawOperations::fieldOperation] = DrawOperations::typeTextAtVector;
  operation[DrawOperations::fieldLocation] = input;
  operation[DrawOperations::fieldText] = inputText;
  this->theOperations.addOnTop(operation);
}

void DrawingVariables::drawLineDirectly(
  double x1,
  double y1,
  double x2,
  double y2,
  uint32_t thePenStyle,
  int colorIndex,
  double lineWidth
) {
  this->operations.drawLineBuffer(x1, y1, x2, y2, thePenStyle, colorIndex, lineWidth);
}

void DrawOperations::drawHighlightGroup(
  Vectors<double>& highlightGroup, List<std::string>& labels, const std::string& color, int radius
) {
  JSData operation;
  operation[DrawOperations::fieldOperation] = DrawOperations::typeHighlightGroup;
  operation[DrawOperations::fieldPoints] = highlightGroup;
  operation[DrawOperations::fieldLabels] = labels;
  operation[DrawOperations::fieldColor] = color;
  operation[DrawOperations::fieldRadius] = radius;
  this->theOperations.addOnTop(operation);
}

void DrawOperations::drawLineBuffer(
  double x1,
  double y1,
  double x2,
  double y2,
  uint32_t thePenStyle,
  int colorIndex,
  double lineWidth
) {
  (void) thePenStyle;
  (void) colorIndex;
  (void) lineWidth;
  JSData operation;
  operation[DrawOperations::fieldOperation] = DrawOperations::typeSegment2DFixed;
  operation[DrawOperations::fieldPoints].elementType = JSData::token::tokenArray;
  operation[DrawOperations::fieldPoints][0][0] = x1;
  operation[DrawOperations::fieldPoints][0][1] = y1;
  operation[DrawOperations::fieldPoints][1][0] = x2;
  operation[DrawOperations::fieldPoints][1][1] = y2;
  this->theOperations.addOnTop(operation);
}

void DrawOperations::drawTextBuffer(
  double x1,
  double y1,
  const std::string& inputText,
  int ColorIndex,
  int fontSize,
  int textStyle
) {
  (void) fontSize;
  (void) ColorIndex;
  (void) textStyle;
  JSData operation;
  operation[DrawOperations::fieldOperation] = DrawOperations::typeSegment2DFixed;
  operation[DrawOperations::fieldLocation].elementType = JSData::token::tokenArray;
  operation[DrawOperations::fieldLocation][0] = x1;
  operation[DrawOperations::fieldLocation][1] = y1;
  operation[DrawOperations::fieldText] = inputText;
  this->theOperations.addOnTop(operation);
}

int DrawingVariables::getActualPenStyleFromFlagsAnd(int inputPenStyle) {
  if (inputPenStyle == this->PenStyleInvisible) {
    return this->PenStyleInvisible;
  }
  if (inputPenStyle == this->PenStyleDashed) {
    return this->PenStyleDashed;
  }
  if (inputPenStyle == this->PenStyleDotted) {
    return this->PenStyleDotted;
  }
  if (inputPenStyle == this->PenStyleNormal) {
    return this->PenStyleNormal;
  }
  if (!this->flagDrawingInvisibles) {
    if (
      inputPenStyle == this->PenStyleLinkToOriginPermanentlyZeroChamber ||
      inputPenStyle == this->PenStyleLinkToOriginZeroChamber ||
      inputPenStyle == this->PenStyleZeroChamber ||
      inputPenStyle == this->PenStylePermanentlyZeroChamber
    ) {
      return this->PenStyleInvisible;
    }
  }
  if (
    inputPenStyle == this->PenStyleLinkToOrigin ||
    inputPenStyle == this->PenStyleLinkToOriginPermanentlyZeroChamber ||
    inputPenStyle == this->PenStyleLinkToOriginZeroChamber
  ) {
    if (this->flagDrawingLinkToOrigin) {
      return this->PenStyleDashed;
    } else {
      return this->PenStyleInvisible;
    }
  }
  if (inputPenStyle == this->PenStylePermanentlyZeroChamber || inputPenStyle == this->PenStyleZeroChamber) {
    return this->PenStyleDotted;
  }
  return this->PenStyleNormal;
}

int DrawingVariables::getActualTextStyleFromFlagsAnd(int inputTextStyle) {
  if (inputTextStyle == this->TextStyleInvisible) {
    return this->TextStyleInvisible;
  }
  if (inputTextStyle == this->TextStyleNormal) {
    return this->TextStyleNormal;
  }
  if (!this->flagDrawChamberIndices && (
      inputTextStyle == this->TextStyleChamber ||
      inputTextStyle == this->TextStylePermanentlyZeroChamber ||
      inputTextStyle == this->TextStyleZeroChamber
  )) {
    return this->TextStyleInvisible;
  }
  if (!this->flagDrawingInvisibles && (
    inputTextStyle == this->TextStylePermanentlyZeroChamber || inputTextStyle == this->TextStyleZeroChamber
  )) {
    return this->TextStyleInvisible;
  }
  return this->TextStyleNormal;
}

void DrawingVariables::drawLineBuffer(
  double x1,
  double y1,
  double x2,
  double y2,
  uint32_t thePenStyle,
  int colorIndex,
  double lineWidth
) {
  this->operations.drawLineBuffer(x1, y1, x2, y2, thePenStyle, colorIndex, lineWidth);
}

void DrawingVariables::drawTextBuffer(double X1, double Y1, const std::string& inputText, int color) {
  this->operations.drawTextBuffer(X1, Y1, inputText, color, this->fontSizeNormal, this->TextStyleNormal);
}

void DrawingVariables::drawString(
  DrawElementInputOutput& drawData, const std::string& input, int fontSize, int textStyle
) {
  drawData.outputHeight = 0; drawData.outputWidth = 0;
  if (input == "") {
    return;
  }
  for (unsigned int i = 0; i < input.size(); i ++) {
    std::string tempS;
    tempS = input.at(i);
    this->operations.drawTextBuffer(
      drawData.outputWidth + drawData.topLeftCornerX,
      drawData.outputHeight + drawData.topLeftCornerY,
      tempS,
      0,
      fontSize,
      textStyle
    );
    drawData.outputWidth += static_cast<int>(static_cast<double>(fontSize) / 1.15);
  }
}

void HtmlRoutines::replaceEqualitiesAndAmpersandsBySpaces(std::string& inputOutput) {
  for (unsigned i = 0; i < inputOutput.size(); i ++) {
    if (inputOutput[i] == '=' || inputOutput[i] == '&') {
      inputOutput[i] = ' ';
    }
  }
}

bool VectorPartition::initialize(const Vectors<Rational>& inputPartitioningRoots, const Vector<Rational>& inputRoot) {
  MacroRegisterFunctionWithName("VectorPartition::initialize");
  for (int i = 0; i < inputPartitioningRoots.size; i ++) {
    if (!inputPartitioningRoots[i].isPositive()) {
      return false;
    }
  }
  this->partitioningRoots = inputPartitioningRoots;
  if (this->partitioningRoots.size == 0) {
    return false;
  }
  if (this->goalVector.isEqualToZero()) {
    return false;
  }
  this->goalVector = inputRoot;
  this->currentPartition.initializeFillInObject(this->partitioningRoots.size, 0);
  this->currentPartitionSum.makeZero(this->goalVector.size);
  return true;
}

Vector<Rational> VectorPartition::getPartitionSum() {
  Vector<Rational> result;
  result.makeZero(this->goalVector.size);
  for (int i = 0; i < this->currentPartition.size; i ++) {
    result += this->partitioningRoots[i] * this->currentPartition[i];
  }
  return result;
}

void VectorPartition::beefUpPartition() {
  MacroRegisterFunctionWithName("VectorPartition::beefUpPartition");
  Vector<Rational> remainder = this->goalVector - this->currentPartitionSum;
  while ((remainder - *this->partitioningRoots.lastObject()).isPositiveOrZero()) {
    (*this->currentPartition.lastObject()) ++;
    this->currentPartitionSum += *(this->partitioningRoots.lastObject());
    remainder -= *this->partitioningRoots.lastObject();
  }
}

bool VectorPartition::nudgePartition() {
  MacroRegisterFunctionWithName("VectorPartition::nudgePartition");
  int indexFirstNonZero = - 1;
  for (int i = this->currentPartition.size - 1; i >= 0; i --) {
    if (this->currentPartition[i] != 0) {
      indexFirstNonZero = i;
      break;
    }
  }
  if (indexFirstNonZero == - 1) {
    global.fatal << "Error: an internal check has failed in VectorPartition::incrementReturnFalseIfPastLast." << global.fatal;
  }
  if (indexFirstNonZero == 0) {
    return false;
  }
  this->currentPartition[indexFirstNonZero - 1] ++;
  this->currentPartitionSum += this->partitioningRoots[indexFirstNonZero - 1];
  this->currentPartitionSum -= this->partitioningRoots[indexFirstNonZero] * this->currentPartition[indexFirstNonZero];
  this->currentPartition[indexFirstNonZero] = 0;
  return true;
}

bool VectorPartition::incrementReturnFalseIfPastLast() {
  MacroRegisterFunctionWithName("VectorPartition::incrementReturnFalseIfPastLast");
  if (this->currentPartitionSum == this->goalVector) {
    this->nudgePartition();
  }
  while (true) {
    this->beefUpPartition();
    if (this->currentPartitionSum == this->goalVector) {
      return true;
    }
    if (!this->nudgePartition()) {
      return false;
    }
  }
  // return false;
}

std::string VectorPartition::toStringPartitioningVectors() {
  MacroRegisterFunctionWithName("VectorPartition::toStringPartitioningVectors");
  std::stringstream out;
  for (int i = 0; i < this->partitioningRoots.size; i ++) {
    out << "e_{" << i + 1 << "}=" << this->partitioningRoots[i].toString() << "<br>";
  }
  out << "<hr>";
  out << "Looking for partitions of: " << this->goalVector.toString();
  out << "<hr>";
  return out.str();
}

std::string VectorPartition::toStringOnePartition(const List<int>& currentPartition) {
  Vector<Rational> theV;
  theV = currentPartition;
  return theV.toStringLetterFormat("e");
}

std::string VectorPartition::toStringAllPartitions(bool useHtml) {
  MacroRegisterFunctionWithName("VectorPartition::toString");
  std::stringstream out;
  out << this->goalVector.toString() << "\n\n";
  if (useHtml) {
    out << "<br>";
  }
  for (int i = 0; i < this->thePartitions.size; i ++) {
    out << "=";
    out << this->toStringOnePartition(this->thePartitions[i]);
    out << "\n\n";
    if (useHtml) {
      out << "<br>\n";
    }
  }
  return out.str();
}

template <class Coefficient>
void ElementUniversalEnveloping<Coefficient>::assignFromCoordinateFormWithRespectToBasis(
  List<ElementUniversalEnveloping<Coefficient> >& basis, Vector<Coefficient>& input, SemisimpleLieAlgebra& owner
) {
  this->makeZero(owner);
  ElementUniversalEnveloping<Coefficient> element;
  for (int i = 0; i < input.size; i ++) {
    if (!input[i].isEqualToZero()) {
      element.operator=(basis[i]);
      element.operator*=(input[i]);
      this->operator+=(element);
    }
  }
}

bool SemisimpleLieAlgebraOrdered::checkInitialization() const {
  if (this->ownerSemisimpleLieAlgebra == nullptr) {
    global.fatal << "Use of semisimple Lie algebra without an owner. " << global.fatal;
  }
  if (this->ownerSemisimpleLieAlgebra->flagDeallocated) {
    global.fatal << "Use after free of semisimple Lie algebra. ";
  }
  return true;
}

void SemisimpleLieAlgebraOrdered::getLinearCombinationFrom(
  ElementSemisimpleLieAlgebra<Rational>& input, Vector<Rational>& coefficients
) {
  this->checkInitialization();
  coefficients.makeZero(this->ownerSemisimpleLieAlgebra->getNumberOfGenerators());
  for (int i = 0; i < input.size(); i ++) {
    int index = input[i].generatorIndex;
    coefficients[this->ownerSemisimpleLieAlgebra->getGeneratorFromRootIndex(index)] = input.coefficients[i];
  }
  int numPosRoots = this->ownerSemisimpleLieAlgebra->getNumberOfPositiveRoots();
  Vector<Rational> tempH = input.getCartanPart();
  for (int i = 0; i < this->ownerSemisimpleLieAlgebra->getRank(); i ++) {
    coefficients[numPosRoots + i] = tempH[i];
  }
  this->chevalleyGeneratorsInCurrentCoordinates.actOnVectorColumn(coefficients);
}

int SemisimpleLieAlgebraOrdered::getDisplayIndexFromGeneratorIndex(int generatorIndex) {
  int numPosRoots = this->ownerSemisimpleLieAlgebra->getNumberOfPositiveRoots();
  int posRootsPlusRank = numPosRoots + this->ownerSemisimpleLieAlgebra->getRank();
  if (generatorIndex >= posRootsPlusRank) {
    return generatorIndex - posRootsPlusRank + 1;
  }
  if (generatorIndex >= numPosRoots) {
    return generatorIndex + 1;
  }
  return - numPosRoots + generatorIndex;
}

void SemisimpleLieAlgebraOrdered::initialize(
  List<ElementSemisimpleLieAlgebra<Rational> >& inputOrder, SemisimpleLieAlgebra& owner
) {
  global.fatal << "not implemented" << global.fatal;
  if (inputOrder.size != owner.getNumberOfGenerators()) {
    return;
  }
  this->ownerSemisimpleLieAlgebra = &owner;
  this->elementOrder = inputOrder;
  this->chevalleyGeneratorsInCurrentCoordinates.initialize(owner.getNumberOfGenerators(), owner.getNumberOfGenerators());
  this->chevalleyGeneratorsInCurrentCoordinates.makeZero();
  Vector<Rational> coordsInCurrentBasis;
  ElementSemisimpleLieAlgebra<Rational> currentElt;
  for (int i = 0; i < owner.getNumberOfGenerators(); i ++) {
    currentElt.makeGenerator(i, owner);
    currentElt.getCoordinatesInBasis(this->elementOrder, coordsInCurrentBasis);
    for (int j = 0; j < coordsInCurrentBasis.size; j ++) {
      this->chevalleyGeneratorsInCurrentCoordinates.elements[j][i] = coordsInCurrentBasis[j];
    }
  }
}

void SemisimpleLieAlgebraOrdered::initDefaultOrder(SemisimpleLieAlgebra& owner) {
  List<ElementSemisimpleLieAlgebra<Rational> > defaultOrder;
  defaultOrder.setSize(owner.getNumberOfGenerators());
  for (int i = 0; i < defaultOrder.size; i ++) {
    ElementSemisimpleLieAlgebra<Rational>& currentElt = defaultOrder[i];
    currentElt.makeGenerator(i, owner);
  }
  this->initialize(defaultOrder, owner);
}

template <class Coefficient>
bool ElementSemisimpleLieAlgebra<Coefficient>::isCoefficientOneChevalleyGenerator() {
  if (this->size == 1) {
    return this->coefficients[0] == 1;
  }
  return false;
}

void HomomorphismSemisimpleLieAlgebra::getWeightsRelativeToKInSimpleKCoordinates(
  Vectors<Rational>& outputWeights,
  List<ElementSemisimpleLieAlgebra<Rational> >& inputElements
) {
  outputWeights.setSize(inputElements.size);
  Rational scalar;
  ElementSemisimpleLieAlgebra<Rational> tempLieElement;
  for (int i = 0; i < inputElements.size; i ++) {
    Vector<Rational>& currentWeight = outputWeights[i];
    currentWeight.makeZero(this->domainAlgebra().getRank());
    ElementSemisimpleLieAlgebra<Rational>& currentLieElt = inputElements[i];
    for (int j = 0; j < this->domainAlgebra().getRank(); j ++) {
      this->coDomainAlgebra().lieBracket(
        this->imagesAllChevalleyGenerators[j + this->domainAlgebra().getNumberOfPositiveRoots()],
        currentLieElt,
        tempLieElement
      );
      if (!currentLieElt.isProportionalTo(tempLieElement, scalar)) {
        global.fatal << "Lie algebra elements not "
        << "proportional as expected. " << global.fatal;
      }
      currentWeight[j] = scalar;
    }
  }
  Matrix<Rational> invertedCartan = this->domainAlgebra().weylGroup.cartanSymmetric;
  invertedCartan.invert();
  invertedCartan.actOnVectorsColumn(outputWeights);
}

template <class Coefficient>
void ElementSemisimpleLieAlgebra<Coefficient>::getBasisFromSpanOfElements(
  List<ElementSemisimpleLieAlgebra>& elements,
  List<ElementSemisimpleLieAlgebra>& outputBasis
) {
  Vectors<Rational> rootForm;
  rootForm.setSize(elements.size);
  for (int i = 0; i < elements.size; i ++) {
    ElementSemisimpleLieAlgebra& currentElt = elements[i];
    currentElt.toVectorNegativeRootSpacesFirst(rootForm[i]);
  }
  rootForm.chooseABasis();
  outputBasis.setSize(rootForm.size);
  for (int i = 0; i < rootForm.size; i ++) {
    ElementSemisimpleLieAlgebra& currentElt = outputBasis[i];
    currentElt.assignVectorNegativeRootSpacesCartanPosistiveRootSpaces(
      rootForm[i], (*currentElt.ownerArray)[currentElt.indexOfOwnerAlgebra]
    );
  }
}

template <class Coefficient>
bool ElementSemisimpleLieAlgebra<Coefficient>::needsParenthesisForMultiplication() const {
  return this->size > 1;
}

void SlTwoInSlN::climbDownFromHighestWeightAlongSl2String(
  Matrix<Rational>& input, Matrix<Rational>& output, Rational& outputCoeff, int generatorPower
) {
  MacroRegisterFunctionWithName("SlTwoInSlN::climbDownFromHighestWeightAlongSl2String");
  if (&input == &output) {
    global.fatal << "Input coincides with output. " << global.fatal;
  }
  Rational currentWeight;
  Matrix<Rational>::lieBracket(this->hElement, input, output);
  bool tempBool = input.isProportionalTo(output, currentWeight);
  if (!tempBool) {
    global.comments << "<br>Climbing down does not work as expected!";
  }
  Rational raiseCoeff;
  raiseCoeff.makeZero();
  outputCoeff.makeOne();
  output = input;
  for (int i = 0; i < generatorPower; i ++) {
    raiseCoeff += currentWeight;
    currentWeight -= 2;
    outputCoeff *= raiseCoeff;
    Matrix<Rational>::lieBracket(this->fElement, output, output);
  }
}

std::string SlTwoInSlN::ElementModuleIndexToString(int input, bool useHtml) {
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class ='mathcalculator'>";
    endMath = "</span>";
    newLine = "<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  Matrix<Rational>& currentHW = this->highestWeightVectors.objects[input];
  int currentEtaHw = this->gModKModules.objects[input].size - 1;
  //currentEtaHw-= currentEtaHw/2;
  int firstNonZeroRow = - 1, firstNonZeroColumn = - 1;
  bool found = false;
  for (int i = 0; i < currentHW.numberOfRows; i ++) {
    if (found) {
      break;
    }
    for (int j = 0; j < currentHW.numberOfColumns; j ++) {
      if (!currentHW.elements[i][j].isEqualToZero()) {
        firstNonZeroColumn = j;
        firstNonZeroRow = i;
        found = true;
        break;
      }
    }
  }
  int sRow, kRow, sColumn, kColumn;
  this->getIsPlusKIndexingFrom(firstNonZeroRow, sRow, kRow);
  this->getIsPlusKIndexingFrom(firstNonZeroColumn, sColumn, kColumn);
  std::stringstream out;
  out << "V_{";
  if (currentEtaHw != 0) {
    if (currentEtaHw != 1) {
      out << currentEtaHw;
    }
    out << "\\frac\\eta 2";
  }
  if (sRow != sColumn) {
    out << "-\\zeta_" << sColumn << "+\\zeta_" << sRow;
  }
  out << "}";
  return out.str();
}

void SlTwoInSlN::getIsPlusKIndexingFrom(int input, int& s, int& k) {
  s = 0;
  k = input;
  if (input >= this->dimension || input < 0) {
    return;
  }
  for (int offset = 0; offset <= input; offset += this->partition[s - 1]) {
    k = input - offset;
    s ++;
  }
}

std::string SlTwoInSlN::elementMatrixToTensorString(const Matrix<Rational>& input, bool useHtml) {
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class ='mathcalculator'>";
    endMath = "</span>";
    newLine ="<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  std::stringstream out;
  std::string tempS;
  bool found = false;
  for (int i = 0; i < input.numberOfRows; i ++) {
    for (int j = 0; j < input.numberOfColumns; j ++) {
      if (!input.elements[i][j].isEqualToZero()) {
        tempS = input.elements[i][j].toString();
        if (tempS == "- 1" || tempS == "-1") {
          tempS = "-";
        }
        if (tempS == "1") {
          tempS = "";
          if (found) {
            out << "+";
          }
        } else {
          if (found) {
            if (tempS[0] != '-') {
              out << "+";
            }
          }
        }
        found = true;
        out << tempS;
        int sI, kI, sJ, kJ;
        this->getIsPlusKIndexingFrom(i, sI, kI);
        this->getIsPlusKIndexingFrom(j, sJ, kJ);
        out << "v_{i_{" << sI << "}";
        if (kI != 0) {
          out << "+" << kI;
        }
        out << "}\\otimes v^*_{i_{" << sJ << "}";
        if (kJ != 0) {
          out  << "+" << kJ;
        }
        out << "}";
      }
    }
  }
  return out.str();
}

void SlTwoInSlN::extractHighestWeightVectorsFromVector(
  Matrix<Rational>& input, List<Matrix<Rational> >& outputDecompositionOfInput, List<Matrix<Rational> >& outputTheHWVectors
) {
  outputDecompositionOfInput.size = 0;
  outputTheHWVectors.size = 0;
  Matrix<Rational> remainder;
  remainder = input;
  Matrix<Rational> component;
  Matrix<Rational> highestWeightVector;
  Matrix<Rational> matrix;
  Rational coefficient;
  Rational scalar;
  int largestPowerNotKillingInput;
  while (!remainder.isEqualToZero() ) {
    this->climbUpFromVector(remainder, highestWeightVector, largestPowerNotKillingInput);
    this->climbDownFromHighestWeightAlongSl2String(
      highestWeightVector, component, coefficient, largestPowerNotKillingInput
    );
    for (int i = 0; i < this->projectors.size; i ++) {
      Matrix<Rational>& currentProjector = this->projectors[i];
      matrix = highestWeightVector;
      matrix.multiplyOnTheLeft(currentProjector);
      if (!matrix.isEqualToZero()) {
        matrix.findFirstNonZeroElementSearchEntireRow(scalar);
        matrix /= scalar;
        outputTheHWVectors.addOnTop(matrix);
      }
    }
    global.fatal << "Extract highest vector not fully implemented yet. " << global.fatal;
    component /= coefficient;
    outputDecompositionOfInput.addOnTop(component);
    remainder -= component;
  }
}

void SlTwoInSlN::climbUpFromVector(
  Matrix<Rational>& input,
  Matrix<Rational>& outputLastNonZero,
  int& largestPowerNotKillingInput
) {
  Matrix<Rational> matrix;
  if (&input == &outputLastNonZero) {
    global.fatal << "Input not allowed to coincide with the output. " << global.fatal;
  }
  outputLastNonZero = input;
  largestPowerNotKillingInput = 0;
  for (
    Matrix<Rational>::lieBracket(this->eElement, outputLastNonZero, matrix);
    !matrix.isEqualToZero();
    Matrix<Rational>::lieBracket(this->eElement, outputLastNonZero, matrix)
  ) {
    largestPowerNotKillingInput ++;
    outputLastNonZero = matrix;
  }
}

std::string SlTwoInSlN::GetNotationString(bool useHtml) {
  std::stringstream out;
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class ='mathcalculator'>";
    endMath = "</span>";
    newLine ="<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  out << newLine << "Let the starting index of the j-th block be " << beginMath << "i_j" << endMath;
  out << "." << newLine << "In particular let: ";
  int offset = 1;
  for (int i = 0; i < this->partition.size; i ++) {
    out << beginMath << "i_" << i + 1 << "=" << offset << endMath << " ";
    out << " (size of block = " << this->partition[i] << "), ";
    offset += this->partition[i];
  }
  out << newLine << "Let " << beginMath << "\\eta" << endMath << " be the weight corresponding to h.";
  out << newLine << "Let " << beginMath << "\\zeta_{j}" << endMath << " be the weight corresponding to the j-th block";
  return out.str();
}

std::string SlTwoInSlN::initFromModuleDecomposition(List<int>& decompositionDimensions, bool useHtml, bool computePairingTable) {
  std::stringstream out;
  this->partition = decompositionDimensions;
  this->partition.quickSortDescending();
  this->dimension = 0;
  for (int i = 0; i < this->partition.size; i ++) {
    this->dimension += this->partition[i];
  }
  hElement.initialize(this->dimension, this->dimension);
  hElement.makeZero();
  eElement.initialize(this->dimension, this->dimension);
  eElement.makeZero();
  fElement.initialize(this->dimension, this->dimension);
  fElement.makeZero();
  this->projectors.setSize(this->partition.size);
  int currentOffset = 0;
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class ='mathcalculator'>";
    endMath = "</span>";
    newLine = "<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  for (int i = 0; i < this->partition.size; i ++) {
    this->projectors[i].initialize(this->dimension, this->dimension);
    this->projectors[i].makeZero();
    for (int j = 0; j < this->partition[i]; j ++) {
      hElement.elements[currentOffset + j][currentOffset + j] = this->partition[i] - 1 - 2 * j;
      this->projectors[i].elements[currentOffset + j][currentOffset + j] = 1;
      if (j != this->partition[i] - 1) {
        fElement.elements[currentOffset + j + 1][currentOffset + j] = 1;
        eElement.elements[currentOffset + j][currentOffset + j + 1] = (j + 1) * (this->partition[i] - j - 1);
      }
    }
    currentOffset += this->partition[i];
  }
  out << newLine << beginMath << "h =" << this->elementMatrixToTensorString(this->hElement, useHtml) << "="
  << this->hElement.toStringWithBlocks(this->partition) << endMath;
  out << newLine << beginMath << "e =" << this->elementMatrixToTensorString(this->eElement, useHtml) << "="
  << this->eElement.toStringWithBlocks(this->partition) << endMath;
  out << newLine << beginMath << "f =" << this->elementMatrixToTensorString(this->fElement, useHtml) << "="
  << this->fElement.toStringWithBlocks(this->partition) << endMath;
  Matrix<Rational> matrix;
  matrix.initialize(this->dimension, this->dimension);
  List<Matrix<Rational> > Decomposition, theHwCandidatesBeforeProjection, theHwCandidatesProjected;
  this->highestWeightVectors.size = 0;
  this->gModKModules.size = 0;
  for (int i = 0; i < this->dimension; i ++) {
    for (int j = 0; j < this->dimension; j ++) {
      matrix.makeZero();
      matrix.elements[i][j] = 1;
      this->extractHighestWeightVectorsFromVector(matrix, Decomposition, theHwCandidatesBeforeProjection);
      theHwCandidatesProjected.size = 0;
      for (int k = 0; k < theHwCandidatesBeforeProjection.size; k ++) {
        for (int l = 0; l < this->projectors.size; l ++) {
          matrix = theHwCandidatesBeforeProjection[k];
          matrix.multiplyOnTheLeft(this->projectors[l]);
          if (!matrix.isEqualToZero()) {
            theHwCandidatesProjected.addOnTop(matrix);
          }
        }
      }
      for (int k = 0; k < theHwCandidatesProjected.size; k ++) {
        if (this->getModuleIndexFromHighestWeightVector(theHwCandidatesProjected[k]) == - 1) {
          Matrix<Rational>& currentHighest = theHwCandidatesProjected[k];
          this->highestWeightVectors.addOnTop(currentHighest);
          this->gModKModules.expandOnTop(1);
          List<Matrix<Rational> >& currentMod = *this->gModKModules.lastObject();
          currentMod.size = 0;
          for (
            matrix = currentHighest;
            !matrix.isEqualToZero();
            Matrix<Rational>::lieBracket(this->fElement, matrix, matrix)
          ) {
            currentMod.addOnTop(matrix);
          }
        }
      }
    }
  }
  out << this->GetNotationString(useHtml);
  out << newLine << "...and the highest weights of the module decomposition are ("
  << this->highestWeightVectors.size << " modules):";
  for (int i = 0; i < this->highestWeightVectors.size; i ++) {
    out << newLine << beginMath << this->elementMatrixToTensorString(highestWeightVectors[i], useHtml)
    << endMath << ", highest weight of ";
    out << beginMath << this->ElementModuleIndexToString(i, useHtml) << endMath;
  }
  if (computePairingTable) {
    out << this->initPairingTable(useHtml);
  }
  return out.str();
}

std::string SlTwoInSlN::initPairingTable(bool useHtml) {
  std::stringstream out;
  this->pairingTable.setSize(this->highestWeightVectors.size);
  for (int i = 0; i < this->pairingTable.size; i ++) {
    this->pairingTable[i].setSize(this->highestWeightVectors.size);
    for (int j = 0; j < this->pairingTable[i].size; j ++) {
      List<int>& currentPairing = this->pairingTable[i][j];
      out << this->pairTwoIndices(currentPairing, i, j, useHtml);
    }
  }
  return out.str();
}

std::string SlTwoInSlN::pairTwoIndices(List<int>& output, int leftIndex, int rightIndex, bool useHtml) {
  std::string beginMath, endMath, newLine;
  FormatExpressions latexFormat;
  latexFormat.flagUseLatex = true;
  latexFormat.flagUseHTML = false;
  if (useHtml) {
    beginMath = "<span class ='mathcalculator'>";
    endMath = "</span>";
    newLine = "<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  std::stringstream out;
  output.size = 0;
  List<Matrix<Rational> >& leftElements = this->gModKModules[leftIndex];
  List<Matrix<Rational> >& rightElements = this->gModKModules[rightIndex];
  Matrix<Rational> matrix;
  List<Matrix<Rational> > HighestWeightsContainingModules;
  List<Matrix<Rational> > tempDecomposition;
  for (int i = 0; i < leftElements.size; i ++) {
    for (int j = 0; j < rightElements.size; j ++) {
      Matrix<Rational>& leftElt = leftElements[i];
      Matrix<Rational>& rightElt = rightElements[j];
      Matrix<Rational>::lieBracket(leftElt, rightElt, matrix);
      if (!matrix.isEqualToZero()) {
        this->extractHighestWeightVectorsFromVector(matrix, tempDecomposition, HighestWeightsContainingModules);
        for (int k = 0; k < HighestWeightsContainingModules.size; k ++) {
          output.addOnTopNoRepetition(this->getModuleIndexFromHighestWeightVector(HighestWeightsContainingModules[k]));
          if (this->getModuleIndexFromHighestWeightVector(HighestWeightsContainingModules[k]) == - 1) {
            global.comments << newLine << beginMath << "[" << leftElt.toString(&latexFormat) << ", "
            << rightElt.toString(&latexFormat) << "] =" << matrix.toString(&latexFormat) << endMath;
          }
        }
      }
    }
  }
  out << newLine << beginMath << this->ElementModuleIndexToString(leftIndex, useHtml) << endMath << " and "
  << beginMath << this->ElementModuleIndexToString(rightIndex, useHtml) << endMath << " pair to: ";
  for (int i = 0; i <output.size; i ++) {
    out << beginMath << this->ElementModuleIndexToString(output[i], useHtml) << endMath;
    if (i != output.size - 1) {
      out << beginMath << "\\oplus" << endMath;
    }
  }
  if (output.size > 0) {
    out << "  hw vectors: ";
    for (int i = 0; i < output.size; i ++) {
      out << beginMath << this->elementMatrixToTensorString(this->highestWeightVectors[output[i]], useHtml)
      << endMath << ",";
    }
  }
  return out.str();
}

void MonomialPolynomial::makeEi(int letterIndex, int power, int expectedNumberOfVariables) {
  (void) expectedNumberOfVariables;
  this->makeOne();
  if (power == 0) {
    return;
  }
  this->setVariable(letterIndex, power);
}

void MonomialPolynomial::setVariable(int variableIndex, const Rational& power) {
  if (variableIndex >= this->monomialBody.size) {
    this->setSize(variableIndex + 1);
  }
  this->monomialBody[variableIndex] = power;
  this->trimTrailingZeroes();
}

void MonomialPolynomial::multiplyByVariable(int variableIndex, const Rational& variablePower) {
  if (variablePower.isEqualToZero()) {
    return;
  }
  if (variableIndex >= this->monomialBody.size) {
    this->setSize(variableIndex);
  }
  this->monomialBody[variableIndex] += variablePower;
  this->trimTrailingZeroes();
}

const Rational& MonomialPolynomial::operator[](int i) const {
  if (i < 0 || i >= this->monomialBody.size) {
    global.fatal << "Requested exponent "
    << "of monomial variable with index "
    << i << " which is out of range (size = "
    << this->monomialBody.size
    << "). " << global.fatal;
  }
  return this->monomialBody[i];
}

Rational MonomialPolynomial::operator()(int i) const {
  if (i < 0) {
    global.fatal
    << "Requested exponent of monomial variable "
    << "with index " << i << " which is negative. " << global.fatal;
  }
  if (i >= this->monomialBody.size) {
    return 0;
  }
  return this->monomialBody[i];
}

bool MonomialPolynomial::hasPositiveOrZeroExponents() const {
  for (int i = 0; i < this->monomialBody.size; i ++) {
    if (this->monomialBody[i].isNegative()) {
      return false;
    }
  }
  return true;
}

void MonomialPolynomial::exponentMeBy(const Rational& exponent) {
  for (int i = 0; i < this->monomialBody.size; i ++) {
    this->monomialBody[i] *= exponent;
  }
}

bool MonomialPolynomial::operator>(const MonomialPolynomial& other) const {
  return MonomialPolynomial::greaterThan_totalDegree_leftLargerWins(*this, other);
}

bool MonomialPolynomial::isDivisibleBy(const MonomialPolynomial& other) const {
  for (int i = other.monomialBody.size - 1; i >= this->monomialBody.size; i --) {
    if (other.monomialBody[i] > 0) {
      return false;
    }
  }
  int upperLimit = MathRoutines::minimum(this->monomialBody.size, other.monomialBody.size);
  for (int i = 0; i < upperLimit; i ++) {
    if (this->monomialBody[i] < other.monomialBody[i]) {
      return false;
    }
  }
  return true;
}

bool MonomialPolynomial::operator==(const MonomialPolynomial& other) const {
  for (int i = other.monomialBody.size - 1; i >= this->monomialBody.size; i --) {
    if (other.monomialBody[i] != 0) {
      return false;
    }
  }
  for (int i = this->monomialBody.size - 1; i >= other.monomialBody.size; i --) {
    if (this->monomialBody[i] != 0) {
      return false;
    }
  }
  int highestIndex = MathRoutines::minimum(this->minimalNumberOfVariables(), other.minimalNumberOfVariables()) - 1;
  for (int i = highestIndex; i >= 0; i --) {
    if (this->monomialBody[i] != other.monomialBody[i]) {
      return false;
    }
  }
  return true;
}

bool MonomialPolynomial::greaterThan_totalDegree_rightSmallerWins(
  const MonomialPolynomial& left, const MonomialPolynomial& right
) {
  if (left == right) {
    return false;
  }
  if (left.totalDegree() > right.totalDegree()) {
    return true;
  }
  if (left.totalDegree() < right.totalDegree()) {
    return false;
  }
  return !MonomialPolynomial::greaterThan_rightLargerWins(left, right);
}

// "Graded lexicographic" order.
bool MonomialPolynomial::greaterThan_totalDegree_leftLargerWins(
  const MonomialPolynomial& left, const MonomialPolynomial& right
) {
  if (left.totalDegree() > right.totalDegree()) {
    return true;
  }
  if (left.totalDegree() < right.totalDegree()) {
    return false;
  }
  return left.greaterThan_leftLargerWins(right);
}


bool MonomialPolynomial::greaterThan_rightLargerWins(const MonomialPolynomial& other) const {
  for (int i = other.monomialBody.size - 1; i >= this->monomialBody.size; i --) {
    if (other.monomialBody[i] > 0) {
      return false;
    }
    if (other.monomialBody[i] < 0) {
      return true;
    }
  }
  for (int i = this->monomialBody.size - 1; i >= other.monomialBody.size; i --) {
    if (this->monomialBody[i] > 0) {
      return true;
    }
    if (this->monomialBody[i] < 0) {
      return false;
    }
  }
  int highestIndex = MathRoutines::minimum(
    this->minimalNumberOfVariables(), other.minimalNumberOfVariables()
  ) - 1;
  for (int i = highestIndex; i >= 0; i --) {
    if (this->monomialBody[i] > other.monomialBody[i]) {
      return true;
    }
    if (this->monomialBody[i] < other.monomialBody[i]) {
      return false;
    }
  }
  return false;
}

List<MonomialPolynomial>::Comparator& MonomialPolynomial::orderDefault() {
  static List<MonomialPolynomial>::Comparator result(MonomialPolynomial::greaterThan_totalDegree_leftLargerWins);
  return result;
}

List<MonomialPolynomial>::Comparator& MonomialPolynomial::orderForGreatestCommonDivisor() {
  static List<MonomialPolynomial>::Comparator result(MonomialPolynomial::greaterThan_rightLargerWins);
  return result;
}

List<MonomialPolynomial>::Comparator& MonomialPolynomial::orderDegreeThenLeftLargerWins() {
  static List<MonomialPolynomial>::Comparator result(MonomialPolynomial::greaterThan_totalDegree_leftLargerWins);
  return result;
}

bool MonomialPolynomial::greaterThan_leftLargerWins(const MonomialPolynomial &other) const {
  int commonSize = MathRoutines::minimum(
    this->minimalNumberOfVariables(), other.minimalNumberOfVariables()
  );
  for (int i = 0; i < commonSize; i ++) {
    if (this->monomialBody[i] > other.monomialBody[i]) {
      return true;
    }
    if (this->monomialBody[i] < other.monomialBody[i]) {
      return false;
    }
  }
  for (int i = this->monomialBody.size; i < other.monomialBody.size; i ++) {
    if (other.monomialBody[i] > 0) {
      return false;
    }
    if (other.monomialBody[i] < 0) {
      return true;
    }
  }
  for (int i = other.monomialBody.size; i < this->monomialBody.size; i ++) {
    if (this->monomialBody[i] > 0) {
      return true;
    }
    if (this->monomialBody[i] < 0) {
      return false;
    }
  }
  return false;
}

void MonomialPolynomial::trimTrailingZeroes() {
  for (int i = this->monomialBody.size - 1; i >= 0; i --) {
    if (this->monomialBody[i] != 0) {
      break;
    }
    this->monomialBody.setSize(this->monomialBody.size - 1);
  }
}

bool MonomialPolynomial::hasSmallIntegralPositivePowers(int* whichtotalDegree) const {
  for (int i = 0; i < this->monomialBody.size; i ++) {
    if (!this->monomialBody[i].isIntegerFittingInInt(nullptr)) {
      return false;
    }
    if (this->monomialBody[i] < 0) {
      return false;
    }
  }
  return this->totalDegree().isIntegerFittingInInt(whichtotalDegree);
}

void MonomialPolynomial::raiseToPower(const Rational& power) {
  for (int i = 0; i < this->monomialBody.size; i ++) {
    this->monomialBody[i] *= power;
  }
  this->trimTrailingZeroes();
}

void MonomialPolynomial::operator*=(const MonomialPolynomial& other) {
  this->setSize(MathRoutines::maximum(this->monomialBody.size, other.monomialBody.size));
  for (int i = 0; i < other.monomialBody.size; i ++) {
    this->monomialBody[i] += other.monomialBody[i];
  }
  this->trimTrailingZeroes();
}

void MonomialPolynomial::operator/=(const MonomialPolynomial& other) {
  this->setSize(MathRoutines::maximum(this->monomialBody.size, other.monomialBody.size));
  for (int i = 0; i < other.monomialBody.size; i ++) {
    this->monomialBody[i] -= other.monomialBody[i];
  }
  this->trimTrailingZeroes();
}

void MonomialPolynomial::setSize(int variableCount) {
  if (variableCount < 0) {
    variableCount = 0;
  }
  int oldSize = this->monomialBody.size;
  this->monomialBody.setSize(variableCount);
  for (int i = oldSize; i < this->monomialBody.size; i ++) {
    this->monomialBody[i] = 0;
  }
}

bool Cone::isInCone(const Vector<Rational>& point) const {
  if (this->flagIsTheZeroCone) {
    return point.isEqualToZero();
  }
  Rational scalarProduct;
  for (int i = 0; i < this->normals.size; i ++) {
    scalarProduct = point.scalarEuclidean(this->normals[i]);
    if (scalarProduct.isNegative()) {
      return false;
    }
  }
  return true;
}

std::string MonomialPolynomial::toString(FormatExpressions* polynomialFormat) const {
  std::stringstream out;
  MemorySaving<FormatExpressions> tempFormat;
  if (polynomialFormat == nullptr) {
    polynomialFormat = &tempFormat.getElement();
  }
  if (this->isConstant()) {
    return "1";
  }
  for (int i = 0; i < this->monomialBody.size; i ++) {
    if (!(this->monomialBody[i].isEqualToZero())) {
      out << polynomialFormat->getPolynomialLetter(i);
      if (!(this->monomialBody[i] == 1)) {
        out << "^{" << this->monomialBody[i] << "}";
      } else {
        out << " ";
      }
    }
  }
  return out.str();
}
