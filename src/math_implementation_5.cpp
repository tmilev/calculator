// The current file is licensed under the license terms found in the main header file "calculator.h".
// For additional information refer to the file "calculator.h".
#include "general_lists.h"
#include "math_general_implementation.h"
#include "math_general.h"
#include "math_general_polynomial_computations_basic_implementation.h"
#include "math_extra_algebraic_numbers.h"
#include "math_extra_universal_enveloping.h"
#include "math_extra_semisimple_Lie_algebras_root_subalgebras.h"
#include "math_extra_semisimple_Lie_algebras_implementation.h"
#include "math_extra_finite_groups_implementation.h"
#include "math_extra_universal_enveloping_implementation.h" // undefined reference to `ElementUniversalEnveloping<RationalFunctionOld>::makeZero(SemisimpleLieAlgebra&)'

std::string MonomialWeylAlgebra::toString(FormatExpressions* theFormat) const {
  if (this->IsConstant()) {
    return "1";
  }
  std::stringstream out;
  FormatExpressions tempFormat;
  if (theFormat == nullptr) {
    tempFormat.polyDefaultLetter = "\\partial";
  } else {
    tempFormat.polyDefaultLetter = theFormat->WeylAlgebraDefaultLetter;
    tempFormat.polyAlphabeT = theFormat->weylAlgebraLetters;
  }
  std::string firstS = this->polynomialPart.toString(theFormat);
  std::string secondS = this->differentialPart.toString(&tempFormat);
  if (firstS != "1") {
    out << firstS;
  }
  if (secondS != "1") {
    out << secondS;
  }
  return out.str();
}

Vector<Rational> SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms::GetRho() {
  Vector<Rational> result;
  this->RootsOfBorel.sum(result, this->AmbientWeyl->GetDim());
  result /= 2;
  return result;
}

void SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms::GetMatrixOfElement(
  const ElementSubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms& input, Matrix<Rational>& outputMatrix
) const {
  Vectors<Rational> startBasis, imageBasis;
  startBasis.MakeEiBasis(this->AmbientWeyl->GetDim());
  this->ActByElement(input, startBasis, imageBasis);
  outputMatrix.AssignVectorsToRows(imageBasis);
  outputMatrix.Transpose();
}

bool SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms::ComputeSubGroupFromGeneratingReflections(
  Vectors<Rational>* inputRoots,
  List<Vectors<Rational> >* inputExternalAutos,
  int UpperLimitNumElements,
  bool recomputeAmbientRho
) {
  MacroRegisterFunctionWithName("SubgroupWeylGroupAutomorphisms::SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms");
  this->CheckInitialization();
  HashedList<Vector<Rational> > orbitRho;
  this->truncated = false;
  this->allElements.Clear();
  orbitRho.Clear();
  if (this->AmbientWeyl->CartanSymmetric.NumRows < 1) {
    return false;
  }
  if (recomputeAmbientRho) {
    this->AmbientWeyl->ComputeRho(false);
  }
  this->simpleRootsInner.setSize(0);
  if (inputRoots != nullptr) {
    this->simpleRootsInner = *inputRoots;
  }
  if (inputExternalAutos != nullptr) {
    this->ExternalAutomorphisms = *inputExternalAutos;
  }
  this->AmbientWeyl->TransformToSimpleBasisGenerators(this->simpleRootsInner, this->AmbientWeyl->RootSystem);
  this->ComputeRootSubsystem();
  ElementSubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms currentElement;
  currentElement.owner = this;
  Vector<Rational> vectorGeneratingFaithfulOrbit;
  vectorGeneratingFaithfulOrbit = this->AmbientWeyl->rho;
  //We desire that the stabilizer of vectorGeneratingFaithfulOrbit
  //is trivial, i.e., the orbit generated by that vector will have as many
  //elements as the subgroup.
  //This is guaranteed if the vector has trivial stabilizer in the
  //ambient Weyl group + outer automorphisms.
  //The rho element (half sum of positive roots divided by 2)
  //almost meets the requirements: it has no stabilizer in the Weyl group
  //but unfortunately is not stabilized by the outer automorphisms.
  //To circumvent the issue, we make the following dirty hack
  //which will work on any simple Weyl group. A proper fix
  //requires some math work and we postpone it to the future.
  vectorGeneratingFaithfulOrbit *= 50; // scale rho by 50
  vectorGeneratingFaithfulOrbit[0].AddInteger(1); // <- slightly perturb the first coordinate.
  //This perturbation breaks the outer automorphism invariance for all
  //simple Weyl group of simple Lie algebras.
  //This needs needs improvement for non-simple groups.
  orbitRho.addOnTop(vectorGeneratingFaithfulOrbit);
  this->allElements.addOnTop(currentElement);
  Vector<Rational> currentRoot;
  for (int i = 0; i < this->allElements.size; i ++) {
    for (int j = 0; j < this->simpleRootsInner.size; j ++) {
      this->AmbientWeyl->ReflectBetaWRTAlpha(this->simpleRootsInner[j], orbitRho[i], false, currentRoot);
      if (!orbitRho.Contains(currentRoot)) {
        orbitRho.addOnTop(currentRoot);
        currentElement = this->allElements[i];
        currentElement.MultiplyOnTheRightBySimpleRootInner(j);
        this->allElements.addOnTop(currentElement);
      }
    }
    for (int j = 1; j < this->ExternalAutomorphisms.size; j ++) {
      orbitRho[i].GetCoordsInBasiS(this->ExternalAutomorphisms[j], currentRoot);
      if (!orbitRho.Contains(currentRoot)) {
        orbitRho.addOnTop(currentRoot);
        currentElement = this->allElements[i];
        currentElement.MultiplyOnTheRightByOuterAutomorphism(j);
        this->allElements.addOnTop(currentElement);
      }
    }
    if (UpperLimitNumElements > 0) {
      if (this->allElements.size >= UpperLimitNumElements) {
        this->truncated = true;
        return false;
      }
    }
  }
  return true;
}

std::string DrawOperations::typeCircleAtVector = "circleAtVector";
std::string DrawOperations::typePath = "path";
std::string DrawOperations::typeSegment = "segment";
std::string DrawOperations::typeSegment2DFixed = "segment2DFixed";
std::string DrawOperations::typeTextAtVector = "text";
std::string DrawOperations::typeText2DFixed = "text2DFixed";
std::string DrawOperations::typeFilledShape = "filledShape";
std::string DrawOperations::typeHighlightGroup = "highlightGroup";

std::string DrawOperations::fieldColor = "color";
std::string DrawOperations::fieldOperation = "operation";
std::string DrawOperations::fieldPoints = "points";
std::string DrawOperations::fieldLocation = "location";
std::string DrawOperations::fieldRadius = "radius";
std::string DrawOperations::fieldPenStyle = "penStyle";
std::string DrawOperations::fieldText = "text";
std::string DrawOperations::fieldLabels = "labels";
std::string DrawOperations::fieldLineWidth = "lineWidth";
std::string DrawOperations::fieldFrameId = "frameId";
std::string DrawOperations::fieldFrameIndex = "frameIndex";

void DrawOperations::drawCircleAtVectorBufferRational(
  const Vector<Rational>& input, const std::string& color, double radius, const std::string& frameId, int frameIndex
) {
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeCircleAtVector;
  theOperation[DrawOperations::fieldLocation] = input.GetVectorDouble();
  theOperation[DrawOperations::fieldRadius] = radius;
  theOperation[DrawOperations::fieldColor] = color;
  if (frameId != "") {
    theOperation[DrawOperations::fieldFrameId] = frameId;
    theOperation[DrawOperations::fieldFrameIndex] = frameIndex;
  }
  //theOperation[DrawOperations::fieldPenStyle] = DrawOperations::fieldPenStyle;
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawCircleAtVectorBufferDouble(
  const Vector<double>& input, const std::string& color, double radius
) {
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeCircleAtVector;
  theOperation[DrawOperations::fieldLocation] = input;
  theOperation[DrawOperations::fieldRadius] = radius;
  theOperation[DrawOperations::fieldColor] = color;
  //theOperation[DrawOperations::fieldPenStyle] = DrawOperations::fieldPenStyle;
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawLineBetweenTwoVectorsBufferRational(
  const Vector<Rational>& vector1, const Vector<Rational>& vector2, const std::string& color, double lineWidth
) {
  this->drawLineBetweenTwoVectorsBufferDouble(vector1.GetVectorDouble(), vector2.GetVectorDouble(), color, lineWidth);
}

void DrawOperations::drawPath(
  const Vectors<Rational>& theVectors,
  const std::string& color,
  double lineWidth,
  const std::string& frameId,
  int frameIndex
) {
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typePath;
  Vectors<double> vectorsDouble;
  theVectors.GetVectorsDouble(vectorsDouble);
  theOperation[DrawOperations::fieldPoints] = vectorsDouble;
  theOperation[DrawOperations::fieldFrameId] = frameId;
  theOperation[DrawOperations::fieldFrameIndex] = frameIndex;
  if (color != "") {
    theOperation[DrawOperations::fieldColor] = color;
  }
  if (lineWidth != 1.0) {
    theOperation[DrawOperations::fieldLineWidth] = lineWidth;
  }
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawLineBetweenTwoVectorsBufferDouble(
  const Vector<double>& vector1, const Vector<double>& vector2, const std::string& color, double lineWidth
) {
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeSegment;
  theOperation[DrawOperations::fieldPoints] = JSData::token::tokenArray;
  theOperation[DrawOperations::fieldPoints][0] = vector1;
  theOperation[DrawOperations::fieldPoints][1] = vector2;
  if (color != "") {
    theOperation[DrawOperations::fieldColor] = color;
  }
  if (lineWidth != 1.0) {
    theOperation[DrawOperations::fieldLineWidth] = lineWidth;
  }
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawFilledShape(
  const List<Vector<double> >& theCorners, uint32_t thePenStyle, int ColorIndex, int fillColorIndex, double lineWidth
) {
  (void) thePenStyle;
  (void) ColorIndex;
  (void) fillColorIndex;
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeFilledShape;
  theOperation[DrawOperations::fieldPoints] = JSData::token::tokenArray;
  for (int i = 0; i < theCorners.size; i ++) {
    theOperation[DrawOperations::fieldPoints][i] = theCorners[i];
  }
  if (lineWidth != 1.0) {
    theOperation[DrawOperations::fieldLineWidth] = lineWidth;
  }
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawTextAtVectorBufferRational(
  const Vector<Rational>& input, const std::string& inputText, const std::string& color, int fontSize
) {
  (void) color;
  (void) fontSize;
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeTextAtVector;
  theOperation[DrawOperations::fieldLocation] = input.GetVectorDouble();
  theOperation[DrawOperations::fieldText] = inputText;
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawTextAtVectorBufferDouble(
  const Vector<double>& input, const std::string& inputText, int ColorIndex, int theFontSize, int theTextStyle
) {
  (void) ColorIndex;
  (void) theFontSize;
  (void) theTextStyle;
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeTextAtVector;
  theOperation[DrawOperations::fieldLocation] = input;
  theOperation[DrawOperations::fieldText] = inputText;
  this->theOperations.addOnTop(theOperation);
}

void DrawingVariables::drawLineDirectly(
  double X1, double Y1, double X2, double Y2, uint32_t thePenStyle, int ColorIndex, double lineWidth
) {
  this->theBuffer.drawLineBuffer(X1, Y1, X2, Y2, thePenStyle, ColorIndex, lineWidth);
}

void DrawOperations::drawHighlightGroup(
  Vectors<double>& highlightGroup, List<std::string>& labels, const std::string& color, int radius
) {
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeHighlightGroup;
  theOperation[DrawOperations::fieldPoints] = highlightGroup;
  theOperation[DrawOperations::fieldLabels] = labels;
  theOperation[DrawOperations::fieldColor] = color;
  theOperation[DrawOperations::fieldRadius] = radius;
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawLineBuffer(
  double X1, double Y1, double X2, double Y2, uint32_t thePenStyle, int ColorIndex, double lineWidth
) {
  (void) thePenStyle;
  (void) ColorIndex;
  (void) lineWidth;
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeSegment2DFixed;
  theOperation[DrawOperations::fieldPoints].theType = JSData::token::tokenArray;
  theOperation[DrawOperations::fieldPoints][0][0] = X1;
  theOperation[DrawOperations::fieldPoints][0][1] = Y1;
  theOperation[DrawOperations::fieldPoints][1][0] = X2;
  theOperation[DrawOperations::fieldPoints][1][1] = Y2;
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawTextBuffer(
  double X1, double Y1, const std::string& inputText, int ColorIndex, int theFontSize, int theTextStyle
) {
  (void) theFontSize;
  (void) ColorIndex;
  (void) theTextStyle;
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeSegment2DFixed;
  theOperation[DrawOperations::fieldLocation].theType = JSData::token::tokenArray;
  theOperation[DrawOperations::fieldLocation][0] = X1;
  theOperation[DrawOperations::fieldLocation][1] = Y1;
  theOperation[DrawOperations::fieldText] = inputText;
  this->theOperations.addOnTop(theOperation);
}

int DrawingVariables::GetActualPenStyleFromFlagsAnd(int inputPenStyle) {
  if (inputPenStyle == this->PenStyleInvisible) {
    return this->PenStyleInvisible;
  }
  if (inputPenStyle == this->PenStyleDashed) {
    return this->PenStyleDashed;
  }
  if (inputPenStyle == this->PenStyleDotted) {
    return this->PenStyleDotted;
  }
  if (inputPenStyle == this->PenStyleNormal) {
    return this->PenStyleNormal;
  }
  if (!this->flagDrawingInvisibles) {
    if (
      inputPenStyle == this->PenStyleLinkToOriginPermanentlyZeroChamber ||
      inputPenStyle == this->PenStyleLinkToOriginZeroChamber ||
      inputPenStyle == this->PenStyleZeroChamber ||
      inputPenStyle == this->PenStylePermanentlyZeroChamber
    ) {
      return this->PenStyleInvisible;
    }
  }
  if (
    inputPenStyle == this->PenStyleLinkToOrigin ||
    inputPenStyle == this->PenStyleLinkToOriginPermanentlyZeroChamber ||
    inputPenStyle == this->PenStyleLinkToOriginZeroChamber
  ) {
    if (this->flagDrawingLinkToOrigin) {
      return this->PenStyleDashed;
    } else {
      return this->PenStyleInvisible;
    }
  }
  if (inputPenStyle == this->PenStylePermanentlyZeroChamber || inputPenStyle == this->PenStyleZeroChamber) {
    return this->PenStyleDotted;
  }
  return this->PenStyleNormal;
}

int DrawingVariables::GetActualTextStyleFromFlagsAnd(int inputTextStyle) {
  if (inputTextStyle == this->TextStyleInvisible) {
    return this->TextStyleInvisible;
  }
  if (inputTextStyle == this->TextStyleNormal) {
    return this->TextStyleNormal;
  }
  if (!this->flagDrawChamberIndices && (
      inputTextStyle == this->TextStyleChamber ||
      inputTextStyle == this->TextStylePermanentlyZeroChamber ||
      inputTextStyle == this->TextStyleZeroChamber
  )) {
    return this->TextStyleInvisible;
  }
  if (!this->flagDrawingInvisibles && (
    inputTextStyle == this->TextStylePermanentlyZeroChamber || inputTextStyle == this->TextStyleZeroChamber
  )) {
    return this->TextStyleInvisible;
  }
  return this->TextStyleNormal;
}

void DrawingVariables::drawLineBuffer(
  double X1, double Y1, double X2, double Y2, uint32_t thePenStyle, int ColorIndex, double lineWidth
) {
  this->theBuffer.drawLineBuffer(X1, Y1, X2, Y2, thePenStyle, ColorIndex, lineWidth);
}

void DrawingVariables::drawTextBuffer(double X1, double Y1, const std::string& inputText, int color) {
  this->theBuffer.drawTextBuffer(X1, Y1, inputText, color, this->fontSizeNormal, this->TextStyleNormal);
}

void DrawingVariables::drawString(
  DrawElementInputOutput& theDrawData, const std::string& input, int theFontSize, int theTextStyle
) {
  theDrawData.outputHeight = 0; theDrawData.outputWidth = 0;
  if (input == "") {
    return;
  }
  for (unsigned int i = 0; i < input.size(); i ++) {
    std::string tempS;
    tempS = input.at(i);
    this->theBuffer.drawTextBuffer(
      theDrawData.outputWidth + theDrawData.TopLeftCornerX,
      theDrawData.outputHeight + theDrawData.TopLeftCornerY,
      tempS,
      0,
      theFontSize,
      theTextStyle
    );
    theDrawData.outputWidth += static_cast<int>(static_cast<double>(theFontSize) / 1.15);
  }
}

void SemisimpleLieAlgebra::ComputeOneAutomorphism(Matrix<Rational>& outputAuto, bool useNegativeRootsFirst) {
  global.fatal << "Not implemented yet!!!!!" << global.fatal;
  rootSubalgebra theRootSA;
//  theRootSA.init(*this);
  int theDimension = this->theWeyl.CartanSymmetric.NumRows;
  theRootSA.genK.MakeEiBasis(theDimension);
  SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms theAutos;
  theRootSA.GenerateAutomorphismsPreservingBorel(theAutos);
  Matrix<Rational> mapOnRootSpaces;
  int theAutoIndex = theAutos.ExternalAutomorphisms.size > 1 ? 1 : 0;
  /*if (this->theWeyl.WeylLetter == 'D' && theDimension ==4)
    theAutoIndex =2;
*/
  mapOnRootSpaces.AssignVectorsToRows(theAutos.ExternalAutomorphisms[theAutoIndex]);
  mapOnRootSpaces.Transpose();
//  mapOnRootSpaces.ComputeDebugString();
//  Matrix<Rational>  theDet =mapOnRootSpaces;
//  Rational tempRat;
//  theDet.ComputeDeterminantOverwriteMatrix(tempRat);
  Selection NonExplored;
  int numRoots = this->theWeyl.RootSystem.size;
  NonExplored.init(numRoots);
  NonExplored.MakeFullSelection();
  Vector<Rational> domainRoot, rangeRoot;

  this->ComputeChevalleyConstants();
  List<ElementSemisimpleLieAlgebra<Rational> > Domain, Range;
  Range.setSize(numRoots + theDimension);
  Domain.setSize(numRoots + theDimension);
  ElementSemisimpleLieAlgebra<Rational> tempElt;
  for (int i = 0; i < theDimension; i ++) {
    domainRoot.MakeEi(theDimension, i);
    mapOnRootSpaces.ActOnVectorColumn(domainRoot, rangeRoot);
    tempElt.MakeHgenerator(domainRoot, *this);
    Domain[numRoots + i] = tempElt;
    tempElt.MakeHgenerator(rangeRoot, *this);
    Range[numRoots + i] = tempElt;
    for (int i = 0; i < 2; i ++, domainRoot.Minus(), rangeRoot.Minus()) {
      int theIndex = this->theWeyl.RootSystem.GetIndex(rangeRoot);
      tempElt.MakeGGenerator(rangeRoot, *this);
      Range[theIndex] = tempElt;
      tempElt.MakeGGenerator(domainRoot, *this);
      Domain[theIndex] = tempElt;
      NonExplored.RemoveSelection(theIndex);
    }
  }
  Vector<Rational> left, right;
  while (NonExplored.CardinalitySelection > 0) {
    for (int i = 0; i < NonExplored.CardinalitySelection; i ++) {
      int theIndex = NonExplored.elements[i];
      const Vector<Rational>& current = this->theWeyl.RootSystem[theIndex];
      for (int j = 0; j < theDimension; j ++) {
        left.MakeEi(theDimension, j);
        for (int k = 0; k < 2; k ++, left.Minus()) {
          right = current - left;
          if (this->theWeyl.IsARoot(right)) {
            int leftIndex = this->theWeyl.RootSystem.GetIndex(left);
            int rightIndex = this->theWeyl.RootSystem.GetIndex(right);
            if (!NonExplored.selected[rightIndex]) {
              ElementSemisimpleLieAlgebra<Rational>& leftDomainElt = Domain[leftIndex];
              ElementSemisimpleLieAlgebra<Rational>& rightDomainElt = Domain[rightIndex];
              this->LieBracket(leftDomainElt, rightDomainElt, Domain[theIndex]);
              ElementSemisimpleLieAlgebra<Rational>& leftRangeElt = Range[leftIndex];
              ElementSemisimpleLieAlgebra<Rational>& rightRangeElt = Range[rightIndex];
              this->LieBracket(leftRangeElt, rightRangeElt, Range[theIndex]);
              NonExplored.RemoveSelection(theIndex);
            }
          }
        }
      }
    }
  }
  Vectors<Rational> vectorsLeft, vectorsRight;
  vectorsLeft.setSize(Range.size);
  vectorsRight.setSize(Range.size);
  if (!useNegativeRootsFirst) {
    for (int i = 0; i < Range.size; i ++) {
      Range[i].ElementToVectorNegativeRootSpacesFirst(vectorsRight[i]);
      Domain[i].ElementToVectorNegativeRootSpacesFirst(vectorsLeft[i]);
    }
  } else {
    for (int i = 0; i < Range.size; i ++) {
      Range[i].ElementToVectorNegativeRootSpacesFirst(vectorsRight[i]);
      Domain[i].ElementToVectorNegativeRootSpacesFirst(vectorsLeft[i]);
    }
  }
  outputAuto.MakeLinearOperatorFromDomainAndRange(vectorsLeft, vectorsRight);
}

bool SemisimpleLieAlgebra::IsInTheWeightSupport(Vector<Rational>& theWeight, Vector<Rational>& highestWeight) {
  Vector<Rational> correspondingDominant = theWeight;
  this->theWeyl.RaiseToDominantWeight(correspondingDominant);
  Vector<Rational> theDiff = highestWeight - correspondingDominant;
  if (!theDiff.IsPositiveOrZero())
    return false;
  return true;
}

void SemisimpleLieAlgebra::CreateEmbeddingFromFDModuleHaving1dimWeightSpaces(Vector<Rational>& theHighestWeight) {
  (void) theHighestWeight;
  /*Vectors<Rational> weightSupport;
  this->GenerateWeightSupport(theHighestWeight, weightSupport);
  int highestWeight, distanceToHW;
  this->EmbeddingsRootSpaces.setSize(this->theWeyl.RootSystem.size);
  int theDimension = this->theWeyl.CartanSymmetric.NumRows;
  List<bool> Explored;
  Explored.initializeFillInObject(this->theWeyl.RootSystem.size, false);
  int numExplored = 0;
  for (int i = 0; i < this->theWeyl.RootSystem.size; i ++) {
    Vector<Rational>& current = this->theWeyl.RootSystem.theObjects[i];
    if (current.SumCoordinates() ==1 || current.SumCoordinates() == - 1) {
      numExplored++;
      Explored.theObjects[i] = true;
      Matrix<Rational> & currentMat = this->EmbeddingsRootSpaces.theObjects[i];
      currentMat.init(weightSupport.size, weightSupport.size);
      currentMat.makeZero();
      for (int j = 0; j<weightSupport.size; j ++) {
        int indexTarget = weightSupport.GetIndex(current +weightSupport.theObjects[j]);
        if (indexTarget != - 1) {
          highestWeight = - 1+ this->GetLengthStringAlongAlphaThroughBeta(current, weightSupport.theObjects[j], distanceToHW, weightSupport);
          if (current.IsNegativeOrZero())
            currentMat.elements[indexTarget][j] =1;
          else
            currentMat.elements[indexTarget][j] =(highestWeight-distanceToHW+ 1)*distanceToHW;
        }
      }
    }
  }
  Vectors<Rational> simpleBasis;
  simpleBasis.MakeEiBasis(theDimension);
  while (numExplored< this->theWeyl.RootSystem.size) {
    for (int i = 0; i < this->theWeyl.RootSystem.size; i ++)
      if (Explored.theObjects[i])
        for (int j = 0; j < this->theWeyl.RootSystem.size; j ++)
          if (Explored.theObjects[j]) {
            Vector<Rational> tempRoot = this->theWeyl.RootSystem.theObjects[i] + this->theWeyl.RootSystem.theObjects[j];
            if (this->theWeyl.IsARoot(tempRoot)) {
              int index = this->theWeyl.RootSystem.GetIndex(tempRoot);
              if (!Explored.theObjects[index]) {
                Explored.theObjects[index] = true;
                numExplored++;
                this->EmbeddingsRootSpaces.theObjects[index] = this->EmbeddingsRootSpaces.theObjects[i];
                this->EmbeddingsRootSpaces.theObjects[index].LieBracketWith(this->EmbeddingsRootSpaces.theObjects[j]);
              }
            }
          }
  }
  this->EmbeddingsCartan.setSize(theDimension);
  for (int i = 0; i < theDimension; i ++) {
    Matrix<Rational> & current = this->EmbeddingsCartan.theObjects[i];
    current.init(weightSupport.size, weightSupport.size);
    current.makeZero();
    Vector<Rational> tempRoot;
    tempRoot.MakeEi(theDimension, i);
    for (int j = 0; j<weightSupport.size; j ++)
      current.elements[j][j] = this->theWeyl.RootScalarCartanRoot(tempRoot, weightSupport.theObjects[j]);
  }*/
}

int SemisimpleLieAlgebra::GetLengthStringAlongAlphaThroughBeta(Vector<Rational>& alpha, Vector<Rational>& beta, int& distanceToHighestWeight, Vectors<Rational>& weightSupport) {
  Vector<Rational> tempRoot = beta;
  for (int i = 0; ; i ++) {
    tempRoot += alpha;
    if (!weightSupport.Contains(tempRoot)) {
      distanceToHighestWeight = i;
      break;
    }
  }
  for (int i = 0; ; i ++) {
    tempRoot -= alpha;
    if (!weightSupport.Contains(tempRoot)) {
      return i;
    }
  }
//  global.fatal << global.fatal;
//  return - 1;
}

bool HomomorphismSemisimpleLieAlgebra::ComputeHomomorphismFromImagesSimpleChevalleyGenerators() {
  MacroRegisterFunctionWithName("HomomorphismSemisimpleLieAlgebra::ComputeHomomorphismFromImagesSimpleChevalleyGenerators");
  this->theDomain().ComputeChevalleyConstants();
  this->theRange().ComputeChevalleyConstants();
  int theDomainDimension = this->theDomain().theWeyl.CartanSymmetric.NumRows;
  Selection NonExplored;
  int numRoots = this->theDomain().theWeyl.RootSystem.size;
  NonExplored.init(numRoots);
  NonExplored.MakeFullSelection();
  List<ElementSemisimpleLieAlgebra<Rational> > tempDomain, tempRange;
  tempDomain.setSize(numRoots+theDomainDimension);
  tempRange.setSize(numRoots+theDomainDimension);
  Vector<Rational> tempRoot;
  for (int i = 0; i < theDomainDimension; i ++) {
    tempRoot.MakeEi(theDomainDimension, i);
    for (int j = 0; j < 2; j ++, tempRoot.Minus()) {
      int index = this->theDomain().theWeyl.RootSystem.GetIndex(tempRoot);
      tempDomain[index].makeZero();
      ChevalleyGenerator tempGen;
      tempGen.MakeGenerator(this->theDomain(), this->theDomain().GetGeneratorFromRoot(tempRoot));
      tempDomain[index].AddMonomial(tempGen, 1);
      tempRange[index] = this->imagesSimpleChevalleyGenerators[i +j*theDomainDimension];
      NonExplored.RemoveSelection(index);
    }
  }
  Vector<Rational> right;
  while (NonExplored.CardinalitySelection > 0) {
    for (int i = 0; i < NonExplored.CardinalitySelection; i ++) {
      int theIndex = NonExplored.elements[i];
      const Vector<Rational>& current = this->theDomain().theWeyl.RootSystem[theIndex];
      for (int j = 0; j < NonExplored.MaxSize; j ++) {
        if (!NonExplored.selected[j]) {
          const Vector<Rational>& left = this->theDomain().theWeyl.RootSystem[j];
          right = current - left;
          if (this->theDomain().theWeyl.IsARoot(right)) {
            int leftIndex = this->theDomain().theWeyl.RootSystem.GetIndex(left);
            int rightIndex = this->theDomain().theWeyl.RootSystem.GetIndex(right);
            if (!NonExplored.selected[rightIndex]) {
              ElementSemisimpleLieAlgebra<Rational>& leftDomainElt = tempDomain[leftIndex];
              ElementSemisimpleLieAlgebra<Rational>& rightDomainElt = tempDomain[rightIndex];
              this->theDomain().LieBracket(leftDomainElt, rightDomainElt, tempDomain[theIndex]);
              ElementSemisimpleLieAlgebra<Rational>& leftRangeElt = tempRange[leftIndex];
              ElementSemisimpleLieAlgebra<Rational>& rightRangeElt = tempRange[rightIndex];
              this->theRange().LieBracket(leftRangeElt, rightRangeElt, tempRange[theIndex]);
              NonExplored.RemoveSelection(theIndex);
              break;
            }
          }
        }
      }
    }
  }
  for (int i = 0; i < theDomainDimension; i ++) {
    tempRoot.MakeEi(theDomainDimension, i);
    int leftIndex = this->theDomain().theWeyl.RootSystem.GetIndex(tempRoot);
    int rightIndex = this->theDomain().theWeyl.RootSystem.GetIndex(- tempRoot);
    this->theDomain().LieBracket(tempDomain[leftIndex], tempDomain[rightIndex], tempDomain[numRoots + i]);
    this->theRange().LieBracket(tempRange[leftIndex], tempRange[rightIndex], tempRange[numRoots + i]);
  }
  Vectors<Rational> vectorsLeft, vectorsRight;
  vectorsLeft.setSize(tempDomain.size);
  vectorsRight.setSize(tempDomain.size);
  for (int i = 0; i < tempRange.size; i ++) {
    tempDomain[i].ElementToVectorNegativeRootSpacesFirst(vectorsLeft[i]);
    tempRange[i].ElementToVectorNegativeRootSpacesFirst(vectorsRight[i]);
  }
  Matrix<Rational> tempMat;
  tempMat.MakeLinearOperatorFromDomainAndRange(vectorsLeft, vectorsRight);
  Vector<Rational> imageRoot;
  this->domainAllChevalleyGenerators.setSize(tempDomain.size);
  this->imagesAllChevalleyGenerators.setSize(tempDomain.size);
  for (int i = 0; i < this->theDomain().GetNumGenerators(); i ++) {
    this->domainAllChevalleyGenerators[i].MakeGenerator(i, this->theDomain());
  }
  for (int i = 0; i < this->imagesAllChevalleyGenerators.size; i ++) {
    this->domainAllChevalleyGenerators[i].ElementToVectorNegativeRootSpacesFirst(tempRoot);
    tempMat.ActOnVectorColumn(tempRoot, imageRoot);
    this->imagesAllChevalleyGenerators[i].AssignVectorNegRootSpacesCartanPosRootSpaces(imageRoot, this->theRange());
  }
  return true;
}

void HomomorphismSemisimpleLieAlgebra::ProjectOntoSmallCartan(Vectors<Rational>& input, Vectors<Rational>& output) {
  output.setSize(input.size);
  for (int i = 0; i < input.size; i ++) {
    this->ProjectOntoSmallCartan(input[i], output[i]);
  }
}

void HomomorphismSemisimpleLieAlgebra::ProjectOntoSmallCartan(Vector<Rational>& input, Vector<Rational>& output) {
  Matrix<Rational> invertedSmallCartan;
  invertedSmallCartan = this->theDomain().theWeyl.CartanSymmetric;
  invertedSmallCartan.Invert();
  int theSmallDimension = this->theDomain().theWeyl.CartanSymmetric.NumRows;
  output.makeZero(theSmallDimension);
  for (int i = 0; i < theSmallDimension; i ++) {
    output[i] = this->theRange().theWeyl.RootScalarCartanRoot(
      this->imagesAllChevalleyGenerators[this->theDomain().theWeyl.RootsOfBorel.size + i].GetCartanPart(), input
    );
  }
  invertedSmallCartan.ActOnVectorColumn(output, output);
}

bool HomomorphismSemisimpleLieAlgebra::ApplyHomomorphism(
  const MonomialUniversalEnveloping<RationalFunction>& input,
  const RationalFunction& theCoeff,
  ElementUniversalEnveloping<RationalFunction>& output
) {
  ElementUniversalEnveloping<RationalFunction> tempElt;
  output.makeZero(this->theRange());
  RationalFunction polyOne;
  polyOne = theCoeff.one();
  output.MakeConst(theCoeff, this->theRange());
  for (int i = 0; i < input.generatorsIndices.size; i ++) {
    if (input.generatorsIndices[i] >= this->imagesAllChevalleyGenerators.size) {
      return false;
    }
    tempElt.AssignElementLieAlgebra(
      this->imagesAllChevalleyGenerators[input.generatorsIndices[i]],
      this->theRange(),
      polyOne
    );
    RationalFunction& thePower = input.Powers[i];
    int theIntegralPower;
    if (!thePower.IsSmallInteger(&theIntegralPower)) {
      return false;
    }
    for (int j = 0; j < theIntegralPower; j ++) {
      output *= tempElt;
    }
  }
  return true;
}

void HomomorphismSemisimpleLieAlgebra::ApplyHomomorphism(
  const ElementSemisimpleLieAlgebra<Rational>& input, ElementSemisimpleLieAlgebra<Rational>& output
) {
  if (&output == &input) {
    global.fatal << "Output required to be different from input. " << global.fatal;
  }
  output.makeZero();
  for (int i = 0; i < input.size(); i ++) {
    int currentIndex = input[i].theGeneratorIndex;
    output += this->imagesAllChevalleyGenerators[currentIndex] * input.coefficients[i];
  }
}

void HomomorphismSemisimpleLieAlgebra::GetMapSmallCartanDualToLargeCartanDual(Matrix<Rational>& output) {
  output.init(this->theRange().GetRank(), this->theDomain().GetRank());
  ElementSemisimpleLieAlgebra<Rational> domainElt, imageElt;
  for (int i = 0; i < this->theDomain().GetRank(); i ++) {
    domainElt.MakeHgenerator(Vector<Rational>::GetEi(this->theDomain().GetRank(), i), this->theDomain());
    this->ApplyHomomorphism(domainElt, imageElt);
    output.AssignVectorToColumnKeepOtherColsIntactNoInit(i, imageElt.GetCartanPart());
  }
}

bool HomomorphismSemisimpleLieAlgebra::ApplyHomomorphism(
  const ElementUniversalEnveloping<RationalFunction>& input,
  ElementUniversalEnveloping<RationalFunction>& output
) {
  if (&output == &input) {
    global.fatal << "Output must be different from input. " << global.fatal;
  }
  output.makeZero(this->theRange());
  ElementUniversalEnveloping<RationalFunction> tempElt;
  for (int i = 0; i < input.size(); i ++) {
    if (!this->ApplyHomomorphism(input[i], input.coefficients[i], tempElt)) {
      return false;
    }
    output += tempElt;
  }
  return true;
}

void HomomorphismSemisimpleLieAlgebra::MakeGinGWithId(
  char theWeylLetter, int theWeylDim, MapReferences<DynkinType, SemisimpleLieAlgebra>& ownerOfAlgebras
) {
  MacroRegisterFunctionWithName("HomomorphismSemisimpleLieAlgebra::MakeGinGWithId");
  DynkinType theType;
  theType.MakeSimpleType(theWeylLetter, theWeylDim);
  this->domainAlg = &ownerOfAlgebras.GetValueCreateNoInit(theType);
  this->rangeAlg = this->domainAlg;
  this->domainAlg->theWeyl.MakeArbitrarySimple(theWeylLetter, theWeylDim);
  this->theDomain().ComputeChevalleyConstants();
  int numPosRoots = this->theDomain().theWeyl.RootsOfBorel.size;
  this->imagesAllChevalleyGenerators.setSize(numPosRoots * 2 + theWeylDim);
  this->domainAllChevalleyGenerators.setSize(numPosRoots * 2 + theWeylDim);
  this->imagesSimpleChevalleyGenerators.setSize(theWeylDim * 2);
  for (int i = 0; i < 2 * numPosRoots + theWeylDim; i ++) {
    ElementSemisimpleLieAlgebra<Rational>& tempElt1 = this->imagesAllChevalleyGenerators[i];
    ElementSemisimpleLieAlgebra<Rational>& tempElt2 = this->domainAllChevalleyGenerators[i];
    tempElt2.MakeGenerator(i, this->theDomain());
    tempElt1.MakeGenerator(i, this->theRange());
  }
  for (int i = 0; i < theWeylDim; i ++) {
    ElementSemisimpleLieAlgebra<Rational>& tempElt1 = this->imagesSimpleChevalleyGenerators[i];
    tempElt1.MakeGenerator(i, this->theRange());
    ElementSemisimpleLieAlgebra<Rational>& tempElt2 = this->imagesSimpleChevalleyGenerators[theWeylDim + i];
    tempElt2.MakeGenerator(i + numPosRoots, this->theRange());
  }
}

void HomomorphismSemisimpleLieAlgebra::toString(std::string& output, bool useHtml) {
  std::stringstream out;
  if (this->CheckClosednessLieBracket()) {
    out << "Lie bracket closes, everything is good!";
  } else {
    out << "The Lie bracket is incorrect!";
  }
  if (useHtml) {
    out << "<br>";
  }
  out << "Images simple Chevalley generators:\n\n";
  if (useHtml) {
    out << "<br>";
  }
  for (int i = 0; i < this->imagesSimpleChevalleyGenerators.size; i ++) {
    out << this->imagesSimpleChevalleyGenerators[i].toString(&global.theDefaultFormat.GetElement()) << "\n\n";
    if (useHtml) {
      out << "<br>";
    }
  }
  out << "Maps of Chevalley generators:\n\n";
  for (int i = 0; i < this->domainAllChevalleyGenerators.size; i ++) {
    out << "<br>" << this->domainAllChevalleyGenerators[i].toString(&global.theDefaultFormat.GetElement())
    << " \\mapsto " << this->imagesAllChevalleyGenerators[i].toString(&global.theDefaultFormat.GetElement());
  }
  output = out.str();
}

class slTwoInSlN;

void HomomorphismSemisimpleLieAlgebra::GetRestrictionAmbientRootSystemToTheSmallerCartanSA(Vectors<Rational>& output) {
  List<Vector<Rational> >& theRootSystem= this->theRange().theWeyl.RootSystem;
  int rankSA = this->theDomain().theWeyl.GetDim();
  Matrix<Rational> tempMat;
  tempMat = this->theDomain().theWeyl.CartanSymmetric;
  tempMat.Invert();
  int numPosRootsDomain = this->theDomain().theWeyl.RootsOfBorel.size;
  output.setSize(theRootSystem.size);
  Vector<Rational> theScalarProducts;
  theScalarProducts.setSize(rankSA);
  for (int i = 0; i < theRootSystem.size; i ++) {
    for (int j = 0; j < rankSA; j ++) {
      ElementSemisimpleLieAlgebra<Rational>& currentH = this->imagesAllChevalleyGenerators[j + numPosRootsDomain];
      theScalarProducts[j] = this->theRange().theWeyl.RootScalarCartanRoot(currentH.GetCartanPart(), theRootSystem[i]);
    }
    tempMat.ActOnVectorColumn(theScalarProducts, output[i]);
  }
  this->ImagesCartanDomain.setSize(rankSA);
  for (int i = 0; i < rankSA; i ++) {
    this->ImagesCartanDomain[i] = this->imagesAllChevalleyGenerators[i +numPosRootsDomain].GetCartanPart();
  }
}

bool HomomorphismSemisimpleLieAlgebra::CheckClosednessLieBracket() {
  ElementSemisimpleLieAlgebra<Rational> tempElt;
  Vectors<Rational> tempRoots;
  Vector<Rational> tempRoot;
  tempRoots.setSize(this->imagesAllChevalleyGenerators.size);
  for (int i = 0; i < tempRoots.size; i ++) {
    this->imagesAllChevalleyGenerators[i].ElementToVectorNegativeRootSpacesFirst(tempRoots[i]);
  }
  for (int i = 0; i < this->imagesAllChevalleyGenerators.size; i ++) {
    for (int j = 0; j < this->imagesAllChevalleyGenerators.size; j ++) {
      this->theRange().LieBracket(this->imagesAllChevalleyGenerators[i], this->imagesAllChevalleyGenerators[j], tempElt);
      tempElt.ElementToVectorNegativeRootSpacesFirst(tempRoot);
      if (!tempRoots.LinSpanContainsVector(tempRoot)) {
        return false;
      }
    }
  }
  return true;
}

void ChevalleyGenerator::CheckConsistencyWithOther(const ChevalleyGenerator& other) const {
  if (this->owner != other.owner) {
    global.fatal << "This is a programming error: attempting to compare Chevalley generators of different Lie algebras. " << global.fatal;
  }
}

bool ChevalleyGenerator::CheckInitialization() const {
  if (this->owner == nullptr) {
    global.fatal << "This is a programming error: attempting to use a non-initialized Chevalley generator. " << global.fatal;
    return false;
  }
  return true;
}

std::string ChevalleyGenerator::toString(FormatExpressions* inputFormat) const {
  this->CheckInitialization();
  return this->owner->GetStringFromChevalleyGenerator(this->theGeneratorIndex, inputFormat);
}

bool ChevalleyGenerator::operator>(const ChevalleyGenerator& other) const {
  return this->theGeneratorIndex>other.theGeneratorIndex;
}

std::string SemisimpleLieAlgebra::GetStringFromChevalleyGenerator(
  int theIndex, FormatExpressions* thePolynomialFormat
) const {
  std::stringstream out;
  MemorySaving<FormatExpressions> tempFormat;
  if (thePolynomialFormat == nullptr) {
    thePolynomialFormat = &tempFormat.GetElement();
  }
  if (this->IsGeneratorFromCartan(theIndex)) {
    out << thePolynomialFormat->chevalleyHgeneratorLetter << "_{" << theIndex-this->GetNumPosRoots() + 1 << "}";
  } else {
    out << thePolynomialFormat->chevalleyGgeneratorLetter << "_{";
    if (theIndex >= this->GetNumPosRoots()) {
      out << theIndex - this->GetNumPosRoots() - this->GetRank() + 1;
    } else {
      out << theIndex - this->GetNumPosRoots();
    }
    out << "}";
  }
  return out.str();
}

void SemisimpleLieAlgebra::OrderNilradicalFirstTotalWeightDescending(const Selection& parSelZeroMeansLeviPart) {
  MacroRegisterFunctionWithName("SemisimpleLieAlgebra::OrderNilradicalFirstTotalWeightDescending");
  Vector<Rational> tempVect;
  tempVect = parSelZeroMeansLeviPart;
  for (int i = 0; i < this->GetNumGenerators(); i ++) {
    if (this->GetWeightOfGenerator(i).ScalarEuclidean(tempVect) < 0) {
      this->UEGeneratorOrderIncludingCartanElts[i] = - i - this->GetNumGenerators() * 5;
    }
  }
}

void SemisimpleLieAlgebra::OrderNilradicalFirstTotalWeightAscending(const Selection& parSelZeroMeansLeviPart) {
  MacroRegisterFunctionWithName("SemisimpleLieAlgebra::OrderNilradicalFirstTotalWeightDescending");
  Vector<Rational> tempVect;
  tempVect = parSelZeroMeansLeviPart;
  for (int i = 0; i < this->GetNumGenerators(); i ++) {
    if (this->GetWeightOfGenerator(i).ScalarEuclidean(tempVect) < 0) {
      this->UEGeneratorOrderIncludingCartanElts[i] = i - this->GetNumGenerators() * 5;
    }
  }
}

void SemisimpleLieAlgebra::OrderNilradicalNilWeightAscending(const Selection& parSelZeroMeansLeviPart) {
  Vector<Rational> tempVect;
  tempVect = parSelZeroMeansLeviPart;
  for (int i = 0; i < this->GetNumGenerators(); i ++) {
    Rational translationCoeff = this->GetWeightOfGenerator(i).ScalarEuclidean(tempVect) * this->GetNumPosRoots();
    if (translationCoeff < 0) {
      this->UEGeneratorOrderIncludingCartanElts[i] = i + translationCoeff.NumShort * this->GetNumGenerators() * 5;
    }
  }
}

void SemisimpleLieAlgebra::OrderNilradicalNilWeightDescending(const Selection& parSelZeroMeansLeviPart) {
  Vector<Rational> tempVect;
  tempVect = parSelZeroMeansLeviPart;
  for (int i = 0; i < this->GetNumGenerators(); i ++) {
    Rational translationCoeff = this->GetWeightOfGenerator(i).ScalarEuclidean(tempVect) * this->GetNumPosRoots();
    if (translationCoeff < 0) {
      this->UEGeneratorOrderIncludingCartanElts[i] = - i + translationCoeff.NumShort * this->GetNumGenerators() * 5;
    }
  }
}

void SemisimpleLieAlgebra::OrderNilradical(const Selection& parSelZeroMeansLeviPart, bool useNilWeight, bool ascending) {
  MacroRegisterFunctionWithName("SemisimpleLieAlgebra::OrderNilradical");
  if (useNilWeight) {
    if (ascending) {
      this->OrderNilradicalNilWeightAscending(parSelZeroMeansLeviPart);
    } else {
      this->OrderNilradicalNilWeightDescending(parSelZeroMeansLeviPart);
    }
  } else {
    if (ascending) {
      this->OrderNilradicalFirstTotalWeightAscending(parSelZeroMeansLeviPart);
    } else {
      this->OrderNilradicalFirstTotalWeightDescending(parSelZeroMeansLeviPart);
    }
  }
}

bool SemisimpleLieAlgebra::HasComputedStructureConstants() {
  return this->ChevalleyConstants.NumRows == this->theWeyl.theDynkinType.GetRootSystemSize();
}

void SemisimpleLieAlgebra::OrderSSalgebraForHWbfComputation() {
  int numPosRoots = this->GetNumPosRoots();
  for (int i = 0; i < numPosRoots; i ++) {
    this->UEGeneratorOrderIncludingCartanElts[i] = - 1;
  }
}

void SemisimpleLieAlgebra::OrderStandardAscending() {
  int numGens = this->GetNumGenerators();
  for (int i = 0; i < numGens; i ++) {
    this->UEGeneratorOrderIncludingCartanElts[i] = i;
  }
}

void SemisimpleLieAlgebra::OrderStandardDescending() {
  int numGens = this->GetNumGenerators();
  for (int i = 0; i < numGens; i ++) {
    this->UEGeneratorOrderIncludingCartanElts[i] = numGens - i - 1;
  }
}

bool SemisimpleLieAlgebra::AreOrderedProperly(int leftIndex, int rightIndex) {
  return this->UEGeneratorOrderIncludingCartanElts[leftIndex] <= this->UEGeneratorOrderIncludingCartanElts[rightIndex];
}

int SemisimpleLieAlgebra::GetRootIndexFromDisplayIndex(int theIndex) {
  int numPosRoots = this->theWeyl.RootsOfBorel.size;
  if (theIndex < 0) {
    return theIndex + numPosRoots;
  }
  if (theIndex > 0) {
    return theIndex + numPosRoots - 1;
  }
  return - 1;
}

int SemisimpleLieAlgebra::GetDisplayIndexFromRootIndex(int theIndex) const {
  int numPosRoots = this->theWeyl.RootsOfBorel.size;
  if (theIndex >= numPosRoots) {
    return theIndex - numPosRoots + 1;
  }
  if (theIndex < numPosRoots) {
    return theIndex - numPosRoots;
  }
  return - 10000000;
}

int SemisimpleLieAlgebra::GetGeneratorFromRootIndex(int theIndex) const {
  if (theIndex < 0 || theIndex >= this->theWeyl.RootSystem.size) {
    return - 1;
  }
  int theDimension = this->theWeyl.CartanSymmetric.NumRows;
  int numPosRoots = this->theWeyl.RootsOfBorel.size;
  if (theIndex >= numPosRoots) {
    return theIndex + theDimension;
  }
  return theIndex;
}

int SemisimpleLieAlgebra::GetRootIndexFromGenerator(int theIndex) const {
  int numPosRoots = this->theWeyl.RootsOfBorel.size;
  int theDimension = this->theWeyl.CartanSymmetric.NumRows;
  if (theIndex < numPosRoots) {
    return theIndex;
  }
  if (theIndex >= numPosRoots + theDimension) {
    return theIndex - theDimension;
  }
  return - 1;
}

void HtmlRoutines::MakeSureWeylGroupIsSane(char& theWeylLetter, int& theRank) {
  if (theWeylLetter == 'a') {
    theWeylLetter = 'A';
  }
  if (theWeylLetter == 'b') {
    theWeylLetter = 'B';
  }
  if (theWeylLetter == 'c') {
    theWeylLetter = 'C';
  }
  if (theWeylLetter == 'd') {
    theWeylLetter = 'D';
  }
  if (theWeylLetter == 'e') {
    theWeylLetter = 'E';
  }
  if (theWeylLetter == 'f') {
    theWeylLetter = 'F';
  }
  if (theWeylLetter == 'g') {
    theWeylLetter = 'G';
  }
  if (!(
    theWeylLetter == 'A' ||
    theWeylLetter == 'B' ||
    theWeylLetter == 'C' ||
    theWeylLetter == 'D' ||
    theWeylLetter == 'E' ||
    theWeylLetter == 'F' ||
    theWeylLetter == 'G'
  )) {
    theWeylLetter = 'A';
  }
  if (theRank > 8 || theRank < 1) {
    theRank = 1;
  }
  if (theWeylLetter != 'A' && theRank == 1) {
    theRank = 2;
  }
  if (theWeylLetter == 'E' && theRank < 6) {
    theRank = 6;
  }
  if (theWeylLetter == 'F') {
    theRank = 4;
  }
  if (theWeylLetter == 'G') {
    theRank = 2;
  }
  if (theWeylLetter == 'D' && theRank < 4) {
    theRank = 4;
  }
}

void HtmlRoutines::ReplaceEqualitiesAndAmpersandsBySpaces(std::string& inputOutput) {
  for (unsigned i = 0; i < inputOutput.size(); i ++) {
    if (inputOutput[i] == '=' || inputOutput[i] == '&') {
      inputOutput[i] = ' ';
    }
  }
}

bool VectorPartition::init(const Vectors<Rational>& inputPartitioningRoots, const Vector<Rational>& inputRoot) {
  MacroRegisterFunctionWithName("VectorPartition::init");
  for (int i = 0; i < inputPartitioningRoots.size; i ++) {
    if (!inputPartitioningRoots[i].IsPositive()) {
      return false;
    }
  }
  this->PartitioningRoots = inputPartitioningRoots;
  if (this->PartitioningRoots.size == 0) {
    return false;
  }
  if (this->goalVector.IsEqualToZero()) {
    return false;
  }
  this->goalVector = inputRoot;
  this->currentPartition.initializeFillInObject(this->PartitioningRoots.size, 0);
  this->currentPartitionSum.makeZero(this->goalVector.size);
  return true;
}

Vector<Rational> VectorPartition::GetPartitionSum() {
  Vector<Rational> result;
  result.makeZero(this->goalVector.size);
  for (int i = 0; i < this->currentPartition.size; i ++) {
    result += this->PartitioningRoots[i] * this->currentPartition[i];
  }
  return result;
}

void VectorPartition::BeefUpPartition() {
  MacroRegisterFunctionWithName("VectorPartition::BeefUpPartition");
  Vector<Rational> remainder = this->goalVector-this->currentPartitionSum;
  while ((remainder-*this->PartitioningRoots.LastObject()).IsPositiveOrZero()) {
    (*this->currentPartition.LastObject()) ++;
    this->currentPartitionSum += *(this->PartitioningRoots.LastObject());
    remainder -= *this->PartitioningRoots.LastObject();
  }
}

bool VectorPartition::NudgePartition() {
  MacroRegisterFunctionWithName("VectorPartition::NudgePartition");
  int indexFirstNonZero = - 1;
  for (int i = this->currentPartition.size - 1; i >= 0; i --) {
    if (this->currentPartition[i] != 0) {
      indexFirstNonZero = i;
      break;
    }
  }
  if (indexFirstNonZero == - 1) {
    global.fatal << "Error: an internal check has failed in VectorPartition::IncrementReturnFalseIfPastLast." << global.fatal;
  }
  if (indexFirstNonZero == 0) {
    return false;
  }
  this->currentPartition[indexFirstNonZero - 1] ++;
  this->currentPartitionSum += this->PartitioningRoots[indexFirstNonZero - 1];
  this->currentPartitionSum -= this->PartitioningRoots[indexFirstNonZero] * this->currentPartition[indexFirstNonZero];
  this->currentPartition[indexFirstNonZero] = 0;
  return true;
}

bool VectorPartition::IncrementReturnFalseIfPastLast() {
  MacroRegisterFunctionWithName("VectorPartition::IncrementReturnFalseIfPastLast");
  if (this->currentPartitionSum == this->goalVector) {
    this->NudgePartition();
  }
  while (true) {
    this->BeefUpPartition();
    if (this->currentPartitionSum == this->goalVector) {
      return true;
    }
    if (!this->NudgePartition()) {
      return false;
    }
  }
  // return false;
}

std::string VectorPartition::ToStringPartitioningVectors() {
  MacroRegisterFunctionWithName("VectorPartition::ToStringPartitioningVectors");
  std::stringstream out;
  for (int i = 0; i < this->PartitioningRoots.size; i ++) {
    out << "e_{" << i + 1 << "}=" << this->PartitioningRoots[i].toString() << "<br>";
  }
  out << "<hr>";
  out << "Looking for partitions of: " << this->goalVector.toString();
  out << "<hr>";
  return out.str();
}

std::string VectorPartition::ToStringOnePartition(const List<int>& currentPartition) {
  Vector<Rational> theV;
  theV = currentPartition;
  return theV.ToStringLetterFormat("e");
}

std::string VectorPartition::ToStringAllPartitions(bool useHtml) {
  MacroRegisterFunctionWithName("VectorPartition::toString");
  std::stringstream out;
  out << this->goalVector.toString() << "\n\n";
  if (useHtml) {
    out << "<br>";
  }
  for (int i = 0; i < this->thePartitions.size; i ++) {
    out << "=";
    out << this->ToStringOnePartition(this->thePartitions[i]);
    out << "\n\n";
    if (useHtml) {
      out << "<br>\n";
    }
  }
  return out.str();
}

bool RationalFunction::ConvertToType(int theType) {
  if (theType < this->expressionType) {
    return false;
  }
  if (theType == this->expressionType) {
    return true;
  }
  if (this->expressionType == this->typeRational && this->expressionType < theType) {
    this->expressionType = this->typePoly;
    this->Numerator.GetElement().MakeConst(this->ratValue);
  }
  if (this->expressionType == this->typePoly && this->expressionType < theType) {
    this->expressionType = this->typeRationalFunction;
    this->Denominator.GetElement().MakeConst(1);
  }
  return true;
}

void RationalFunction::invert() {
  if (!this->checkConsistency()) {
    global.fatal << "Inconsistent rational functoin. " << global.fatal;
  }
  if (this->expressionType == this->typeRational) {
    if (this->ratValue.IsEqualToZero()) {
      global.fatal  << "This is a programming error: division by zero. Division by zero errors must be caught earlier in the program and "
      << "handled gracefully. Crashing ungracefully. " << global.fatal;
    }
    this->ratValue.invert();
    return;
  }
  if (this->expressionType == this->typePoly) {
    this->ConvertToType(this->typeRationalFunction);
  }
  if (this->Numerator.GetElement().IsEqualToZero()) {
    global.fatal << "Cannot invert rational function with zero numerator. " << global.fatal;
  }
  MathRoutines::swap(this->Numerator.GetElement(), this->Denominator.GetElement());
  this->expressionType = this->typeRationalFunction;
  this->ReduceMemory();
  this->simplifyLeadingCoefficientOnly();
  if (!this->checkConsistency()) {
    global.fatal << "Consistency check failed. " << global.fatal;
  }
}

bool RationalFunction::checkConsistency() const {
  if (this->expressionType == this->typePoly) {
    if (this->Numerator.IsZeroPointer()) {
      global.fatal << "This is a programming error: a rational function is flagged as being a non-constant polynomial, but the numerator pointer is zero. " << global.fatal;
      return false;
    }
    if (this->Numerator.GetElementConst().IsConstant()) {
      global.fatal << "This is a programming error: a rational function is flagged as "
      << "having a non-constant numerator, but the numerator is constant. " << global.fatal;
      return false;
    }
  }
  if (this->expressionType == this->typeRationalFunction) {
    if (this->Numerator.IsZeroPointer() || this->Denominator.IsZeroPointer()) {
      global.fatal << "This is a programming error: a rational function is flagged as "
      << "having non-constant denominator, but either the numerator or the denominator pointer is zero. "
      << global.fatal;
      return false;
    }
    if (this->Denominator.GetElementConst().IsConstant()) {
      global.fatal << "This is a programming error: a rational function is flagged as "
      << "having non-constant denominator, but the denominator is constant. " << global.fatal;
      return false;
    }
  }
  if (
    this->expressionType != this->typeRational &&
    this->expressionType != this->typePoly &&
    this->expressionType != this->typeRationalFunction
  ) {
    global.fatal << "This is a programming error: a rational function is not initialized properly: its type is "
    << this->expressionType
    << " which is not allowed. " << global.fatal;
    return false;
  }
  return true;
}

void RationalFunction::operator/=(int other) {
  RationalFunction tempRF;
  tempRF.MakeConst(other);
  *this /= tempRF;
}

void RationalFunction::Minus() {
  this->operator*= (Rational(- 1));
  if (!this->checkConsistency()) {
    global.fatal << "Failed to take the negative sign of a rational function. " << global.fatal;
  }
}

void RationalFunction::operator-=(const RationalFunction& other) {
  if (!this->checkConsistency()) {
    global.fatal << "Corrupt rational function in operator -=. " << global.fatal;
  }
  if (!other.checkConsistency()) {
    global.fatal << "Corrupt other rational function in operator -=. " << global.fatal;
  }
  RationalFunction tempRF;
  tempRF = other;
  tempRF.Minus();
  this->operator+=(tempRF);
  if (!this->checkConsistency()) {
    global.fatal << "Corrupt output in rational function operator -=." << global.fatal;
  }
}

void RationalFunction::operator-=(const Rational& other) {
  if (!this->checkConsistency()) {
    global.fatal << "Corrupt rational function in operator-=(Rational). " << global.fatal;
  }
  RationalFunction tempRF;
  tempRF.MakeConst(other);
  tempRF.Minus();
  this->operator+=(tempRF);
  if (!(this->checkConsistency())) {
    global.fatal << "Corrupt output in rational function operator-=(Rational)." << global.fatal;
  }
}

void RationalFunction::makeOne() {
  this->MakeConst(1);
}

void RationalFunction::makeZero() {
  this->expressionType = this->typeRational;
  this->ratValue.makeZero();
  this->Numerator.FreeMemory();
  this->Denominator.FreeMemory();
  if (!this->checkConsistency()) {
    global.fatal << "makeZero produced corrupt output in rational function old. " << global.fatal;
  }
}

void RationalFunction::operator+=(int theConstant) {
  RationalFunction tempRF;
  tempRF.MakeConst(Rational(theConstant));
  (*this) += tempRF;
}

Rational RationalFunction::RationalValue() const {
  switch(this->expressionType) {
    case RationalFunction::typeRational:
      return this->ratValue;
    case RationalFunction::typeError:
      return 0;
    default:
      return this->Numerator.GetElementConst().GetConstantTerm();
  }
}

RationalFunction::RationalFunction() {
  this->expressionType = this->typeError;
  this->ratValue.makeZero();
}

RationalFunction::RationalFunction(int other) {
  this->expressionType = this->typeRational;
  this->operator=(other);
}

RationalFunction::RationalFunction(const Rational& other) {
  this->expressionType = this->typeRational;
  this->operator=(other);
}

RationalFunction::RationalFunction(const RationalFunction& other): expressionType(RationalFunction::typeError) {
  this->operator=(other);
}

RationalFunction RationalFunction::zero() {
  RationalFunction tempRat;
  tempRat.makeZero();
  return tempRat;
}

RationalFunction RationalFunction::one() {
  RationalFunction tempRat;
  tempRat.MakeConst(1);
  return tempRat;
}

bool RationalFunction::FindOneVariableRationalRoots(List<Rational>& output) {
  if (this->expressionType == this->typeRational) {
    output.setSize(0);
    return true;
  }
  Polynomial<Rational> tempP;
  this->GetNumerator(tempP);
  return tempP.findOneVariableRationalRoots(output);
}

bool RationalFunction::NeedsParenthesisForMultiplication(FormatExpressions* unused) const {
  (void) unused;
  switch (this->expressionType) {
    case RationalFunction::typeRational:
      return false;
    case RationalFunction::typePoly:
      return this->Numerator.GetElementConst().NeedsParenthesisForMultiplication();
    case RationalFunction::typeRationalFunction:
      return false;
  }
  return false;
}

std::string RationalFunction::toString(FormatExpressions* theFormat) const {
  if (this->expressionType == this->typeError) {
    return "[error]";
  }
  if (this->expressionType == this->typeRational) {
    return this->ratValue.toString();
  }
  if (this->expressionType == this->typePoly) {
    return this->Numerator.GetElementConst().toString(theFormat);
  }
  std::stringstream out;
  bool useFrac = theFormat == nullptr ? false : theFormat->flagUseFrac;
  bool needParenthesis = false;
  if (!useFrac) {
    needParenthesis = this->Numerator.GetElementConst().NeedsParenthesisForMultiplication();
  }
  if (useFrac) {
    out << "\\frac{";
  }
  if (needParenthesis) {
    out << "(";
  }
  out << this->Numerator.GetElementConst().toString(theFormat);
  if (needParenthesis) {
    out << ")";
  }
  if (useFrac) {
    out << "}{";
  } else {
    out << "/(";
  }
  out << this->Denominator.GetElementConst().toString(theFormat);
  if (useFrac) {
    out << "}";
  } else {
    out << ")";
  }
  //out << " Num vars: " << this->GetNumVars();
  return out.str();
}

void RationalFunction::gcd(
  const Polynomial<Rational>& left,
  const Polynomial<Rational>& right,
  Polynomial<Rational>& output
) {
  if (RationalFunction::gcdQuick(left, right, output)) {
    return;
  }
  MacroRegisterFunctionWithName("RationalFunctionOld::gcd");
  Polynomial<Rational> leastCommonMultipleBuffer, productBuffer, remainderBuffer;
  RationalFunction::lcm(left, right, leastCommonMultipleBuffer);
  productBuffer = left;
  productBuffer *= right;
  productBuffer.DivideBy(
    leastCommonMultipleBuffer,
    output,
    remainderBuffer,
    &MonomialP::orderForGCD()
  );
  if (!remainderBuffer.IsEqualToZero() || output.IsEqualToZero()) {
    global.fatal
    << "This is a programming error. <br>While computing the gcd of left = "
    << left.toString() << " <br>and right = "
    << right.toString() << " <br>I got that left * right = "
    << productBuffer.toString()
    << "<br>and that lcm(left, right) = "
    << leastCommonMultipleBuffer.toString()
    << " <br>but at the same time right * left divided by lcm (left, right) equals<br>"
    << output.toString()
    << "<br> with remainder " << remainderBuffer.toString()
    << ", which is imposible."
    << global.fatal;
  }
  output.scaleNormalizeLeadingMonomial();
}

void RationalFunction::MakeOneLetterMoN(
  int theIndex, const Rational& theCoeff, int ExpectedNumVars
) {
  if (theIndex < 0) {
    global.fatal << "This is a programming error: I am asked to create "
    << "Monomial which has a variable of negative index " << theIndex << ". " << global.fatal;
  }
  this->expressionType = this->typePoly;
  ExpectedNumVars = MathRoutines::Maximum(theIndex + 1, ExpectedNumVars);
  this->Numerator.GetElement().makeDegreeOne(ExpectedNumVars, theIndex, theCoeff);
}

void RationalFunction::makeMonomial(
  int LetterIndex, const Rational& Power, const Rational& Coeff, int ExpectedNumVars
) {
  if (LetterIndex < 0) {
    global.fatal << "This is a programming error: I am asked to create Monomial which has a variable of negative index "
    << LetterIndex << ". " << global.fatal;
  }
  this->expressionType = this->typePoly;
  this->Numerator.GetElement().makeMonomial(LetterIndex, Power, Coeff, ExpectedNumVars);
}

void RationalFunction::SetNumVariablesSubDeletedVarsByOne(int newNumVars) {
  int oldNumVars = this->minimalNumberOfVariables();
  this->Numerator.GetElement().SetNumVariablesSubDeletedVarsByOne(newNumVars);
  this->Denominator.GetElement().SetNumVariablesSubDeletedVarsByOne(newNumVars);
  if (newNumVars < oldNumVars) {
    this->simplify();
  }
}

void RationalFunction::operator=(const RationalFunction& other) {
  this->expressionType = other.expressionType;
  switch (this->expressionType) {
    case RationalFunction::typeRational:
      this->ratValue = other.ratValue;
      break;
    case RationalFunction::typePoly:
      if (other.Numerator.IsZeroPointer()) {
        global.fatal << "Zero pointer in numerator of other. " << global.fatal;
      }
      this->Numerator.GetElement() = other.Numerator.GetElementConst();
      break;
    case RationalFunction::typeRationalFunction:
      if (other.Numerator.IsZeroPointer() || other.Denominator.IsZeroPointer()) {
        global.fatal << "Zero pointer in numerator or denominator of other. " << global.fatal;
      }
      this->Numerator.GetElement() = other.Numerator.GetElementConst();
      this->Denominator.GetElement() = other.Denominator.GetElementConst();
      break;
    default:
      break;
  }
}

void RationalFunction::lcm(
  const Polynomial<Rational>& left,
  const Polynomial<Rational>& right,
  Polynomial<Rational>& output
) {
  std::stringstream commentsOnFailure;
  bool success = Polynomial<Rational>::leastCommonMultiple(
    left, right, output, Rational::one(), &commentsOnFailure
  );
  if (!success) {
    global.fatal
    << "Failure of least common multiple "
    << "computation not allowed here. " << global.fatal;
  }
}

void RationalFunction::operator*=(const MonomialP& other) {
  Polynomial<Rational> otherP;
  otherP.makeZero();
  otherP.AddMonomial(other, 1);
  *this *= otherP;
}

void RationalFunction::operator*=(const Polynomial<Rational>& other) {
  if (other.IsEqualToZero()) {
    this->makeZero();
    return;
  }
  if (this->expressionType == this->typeRational) {
    this->ConvertToType(this->typePoly);
  }
  if (this->expressionType == this->typePoly) {
    this->Numerator.GetElement() *= other;
    this->ReduceMemory();
    return;
  }
  Polynomial<Rational> theGCD, theResult, tempP;
  ProgressReport theReport;
  if (theReport.TickAndWantReport()) {
    std::stringstream out;
    out << "Multiplying " << this->toString(&global.theDefaultFormat.GetElement()) << " by "
    << other.toString(&global.theDefaultFormat.GetElement());
    theReport.Report(out.str());
  }
  RationalFunction::gcd(this->Denominator.GetElement(), other, theGCD);
  this->Numerator.GetElement() *= other;
  List<MonomialP>::Comparator* monomialOrder = &MonomialP::orderForGCD();
  this->Numerator.GetElement().DivideBy(theGCD, theResult, tempP, monomialOrder);
  if (!tempP.IsEqualToZero()) {
    global.fatal << "Polynomial equal to zero not allowed here. " << global.fatal;
  }
  this->Numerator.GetElement() = theResult;
  this->Denominator.GetElement().DivideBy(theGCD, theResult, tempP, monomialOrder);
  if (!tempP.IsEqualToZero()) {
    global.fatal << "Polynomial not equal to zero. " << global.fatal;
  }
  this->Denominator.GetElement() = theResult;
  this->ReduceMemory();
  this->simplifyLeadingCoefficientOnly();
  if (theReport.TickAndWantReport()) {
    std::stringstream out;
    out << "Multiplying " << this->toString(&global.theDefaultFormat.GetElement()) << " by "
    << other.toString(&global.theDefaultFormat.GetElement());
    out << " and the result is:\n" << this->toString();
    theReport.Report(out.str());
  }
}

void RationalFunction::operator/=(const RationalFunction& other) {
  this->checkConsistency();
  RationalFunction tempRF;
  tempRF = other;
  tempRF.checkConsistency();
  tempRF.invert();
  tempRF.checkConsistency();
  *this *= tempRF;
  if (!this->checkConsistency()) {
    global.fatal << "Incosistent rational function. " << global.fatal;
  }
}

void RationalFunction::operator*=(const Rational& other) {
  if (other.IsEqualToZero()) {
    this->makeZero();
    return;
  }
  switch(this->expressionType) {
    case RationalFunction::typeRational:
      this->ratValue *= other;
      return;
    case RationalFunction::typePoly:
      this->Numerator.GetElement() *= other;
      return;
    case RationalFunction::typeRationalFunction:
      this->Numerator.GetElement() *= other;
      this->simplifyLeadingCoefficientOnly();
      return;
  }
}

void RationalFunction::operator*=(const RationalFunction& other) {
 // int commentChecksWhenDoneDebugging= - 1;
  this->checkConsistency();
  other.checkConsistency();
  if (this == &other) {
    this->RaiseToPower(2);
    return;
  }
  if (other.IsEqualToZero() || this->IsEqualToZero()) {
    this->makeZero();
    return;
  }
  if (other.expressionType == this->typeRational) {
    this->operator*=(other.ratValue);
    return;
  }
  if (other.expressionType == this->typePoly) {
    this->operator*=(other.Numerator.GetElementConst());
    return;
  }
  if (this->expressionType == this->typeRational) {
    Rational tempRat;
    tempRat = this->ratValue;
    this->operator=(other);
    this->operator*=(tempRat);
    return;
  }
  if (this->expressionType == this->typePoly) {
    Polynomial<Rational>  tempP;
    tempP = this->Numerator.GetElement();
    this->operator=(other);
    this->operator*=(tempP);
    return;
  }
  Polynomial<Rational> theGCD1, theGCD2, tempP1, tempP2;
  //this->ComputeDebugString();
  //  RationalFunctionOld tempde_Bugger;
  //  tempde_Bugger = other;
  //  tempde_Bugger.ComputeDebugString();
  ProgressReport theReport;
  if (theReport.TickAndWantReport()) {
    std::stringstream out;
    out << "Multiplying " << this->toString() << " by " << other.toString();
    theReport.Report(out.str());
  }
  RationalFunction::gcd(other.Denominator.GetElementConst(), this->Numerator.GetElement(), theGCD1);
  RationalFunction::gcd(this->Denominator.GetElement(), other.Numerator.GetElementConst(), theGCD2);
  List<MonomialP>::Comparator* monomialOrder = &MonomialP::orderForGCD();
  this->Numerator.GetElement().DivideBy(theGCD1, tempP1, tempP2, monomialOrder);
  this->Numerator.GetElement() = tempP1;
  if (!tempP2.IsEqualToZero()) {
    global.fatal << "Polynomial equal to zero not allowed here. " << global.fatal;
  }
  other.Denominator.GetElementConst().DivideBy(theGCD1, tempP1, tempP2, monomialOrder);
  if (!tempP2.IsEqualToZero()) {
    global.fatal << "Polynomial must not be zero here. " << global.fatal;
  }
  this->Denominator.GetElement() *= tempP1;
  this->Denominator.GetElement().DivideBy(theGCD2, tempP1, tempP2, monomialOrder);
  if (!tempP2.IsEqualToZero()) {
    global.fatal << "Polynomial must not be zero here. " << global.fatal;
  }
  this->Denominator.GetElement() = tempP1;
  other.Numerator.GetElementConst().DivideBy(theGCD2, tempP1, tempP2, monomialOrder);
  if (!tempP2.IsEqualToZero()) {
    global.fatal << "Polynomial must not be zero here. " << global.fatal;
  }
  this->Numerator.GetElement() *= tempP1;
  this->ReduceMemory();
  this->simplifyLeadingCoefficientOnly();
  if (theReport.TickAndWantReport()) {
    std::stringstream out;
    out << "Multiplying " << this->toString() << " by " << other.toString();
    out << " and the result is:\n" << this->toString();
    theReport.Report(out.str());
  }
}

void RationalFunction::operator+=(const RationalFunction& other) {
  if (this == &other) {
    *this *= Rational(2);
    return;
  }
  if (!this->checkConsistency()) {
    global.fatal << "Corrupt rational function. " << global.fatal;
  }
  if (!other.checkConsistency()) {
    global.fatal << "Corrupt other rational function. " << global.fatal;
  }
  if (other.expressionType < this->expressionType) {
    RationalFunction tempRF;
    tempRF = other;
    tempRF.ConvertToType(this->expressionType);
    this->AddSameTypes(tempRF);
    if (!this->checkConsistency()) {
      global.fatal << "Output of rational function addition is corrupt. " << global.fatal;
    }
    return;
  }
  if (this->expressionType == other.expressionType) {
    this->AddSameTypes(other);
    if (!this->checkConsistency()) {
      global.fatal << "Output of rational function addition is corrupt "
      << "for same type of rational functions." << global.fatal;
    }
    return;
  }
  if (this->expressionType < other.expressionType) {
    this->ConvertToType(other.expressionType);
    this->AddSameTypes(other);
    if (!this->checkConsistency()) {
      global.fatal << "Corrupt outputs of rational "
      << "function addition, different expression types. "
      << global.fatal;
    }
  }
  if (!this->checkConsistency()) {
    global.fatal <<  "Corrupt final output of rational function addition. " << global.fatal;
  }
}

void RationalFunction::simplify() {
  MacroRegisterFunctionWithName("RationalFunctionOld::simplify");
  List<MonomialP>::Comparator* monomialOrder = &MonomialP::orderForGCD();
  if (this->expressionType == this->typeRationalFunction) {
    if (!this->Numerator.GetElement().IsEqualToZero()) {
      Polynomial<Rational> theGCD, tempP, tempP2;
      this->gcd(this->Numerator.GetElement(), this->Denominator.GetElement(), theGCD);
      if (theGCD.IsEqualToZero()) {
        global.fatal << "This is a programing error: "
        << " while fetching the gcd of " << this->Numerator.GetElement().toString()
        << " and " << this->Denominator.GetElement().toString()
        << " I got 0, which is impossible. " << global.fatal;
      }
      this->Numerator.GetElement().DivideBy(theGCD, tempP, tempP2, monomialOrder);
      this->Numerator.GetElement() = tempP;
      this->Denominator.GetElement().DivideBy(theGCD, tempP, tempP2, monomialOrder);
      this->Denominator.GetElement() = tempP;
    }
  }
  this->ReduceMemory();
  this->simplifyLeadingCoefficientOnly();
}

Rational RationalFunction::scaleToIntegral() {
  if (this->IsEqualToZero()) {
    return Rational::one();
  }
  if (this->expressionType == this->typeRational) {
    Rational result = this->ratValue;
    result.invert();
    this->ratValue.makeOne();
    return result;
  }
  if (this->expressionType == this->typePoly) {
    return this->Numerator.GetElement().scaleNormalizeLeadingMonomial();
  }
  if (this->expressionType != this->typeRationalFunction) {
    return Rational::one();
  }
  Rational result;
  result = this->Numerator.GetElement().scaleNormalizeLeadingMonomial();
  result /= this->Denominator.GetElement().scaleNormalizeLeadingMonomial();
  return result;
}

void RationalFunction::simplifyLeadingCoefficientOnly() {
  if (this->expressionType != this->typeRationalFunction) {
    return;
  }
  Rational scaleNumerator = this->Numerator.GetElement().scaleNormalizeLeadingMonomial();
  Rational scaleDenominator = this->Denominator.GetElement().scaleNormalizeLeadingMonomial();
  Rational scale = scaleDenominator / scaleNumerator;
  this->Denominator.GetElement() *= scale.GetDenominator();
  this->Numerator.GetElement() *= scale.GetNumerator();
}

void RootIndexToPoly(int theIndex, SemisimpleLieAlgebra& theAlgebra, Polynomial<Rational>& output) {
  int theRank = theAlgebra.theWeyl.CartanSymmetric.NumRows;
  int numPosRoots = theAlgebra.theWeyl.RootsOfBorel.size;
  output.makeDegreeOne(theRank + numPosRoots, theIndex + theRank, Rational(1));
}

template <class coefficient>
void ElementUniversalEnveloping<coefficient>::AssignFromCoordinateFormWRTBasis(
  List<ElementUniversalEnveloping<coefficient> >& theBasis, Vector<coefficient>& input, SemisimpleLieAlgebra& owner
) {
  this->makeZero(owner);
  ElementUniversalEnveloping<coefficient> tempElt;
  for (int i = 0; i < input.size; i ++) {
    if (!input[i].IsEqualToZero()) {
      tempElt.operator=(theBasis[i]);
      tempElt.operator*=(input[i]);
      this->operator+=(tempElt);
    }
  }
}

bool RationalFunction::IsConstant(Rational* whichConstant) const {
  if (this->expressionType != this->typeRational) {
    return false;
  }
  if (whichConstant != nullptr) {
    *whichConstant = this->ratValue;
  }
  return true;
}

bool RationalFunction::IsInteger() const {
  return this->expressionType == this->typeRational && this->ratValue.IsInteger();
}

bool RationalFunction::IsSmallInteger(int* whichInteger) const {
  return this->expressionType == this->typeRational &&
  this->ratValue.IsSmallInteger(whichInteger);
}


RationalFunction RationalFunction::scaleNormalizeIndex(
  List<RationalFunction>& input, int indexNonZeroElement
) {
  if (input.size == 0) {
    return 1;
  }
  List<Rational> scales;
  Rational scale;
  Polynomial<Rational> currentNumerator, currentDenominator;
  for (int i = 0; i < input.size; i ++) {
    RationalFunction& current = input[i];
    current.GetNumerator(currentNumerator);
    current.GetDenominator(currentDenominator);
    scale = currentNumerator.scaleNormalizeLeadingMonomial();
    scale /= currentDenominator.scaleNormalizeLeadingMonomial();
    scales.addOnTop(scale);
  }
  LargeIntegerUnsigned numeratorContentGreatestCommonDivisor = scales[0].GetNumerator().value;
  LargeIntegerUnsigned denominatorContentLeastCommonMultiple = scales[0].GetDenominator();
  for (int i = 1; i < scales.size; i ++) {
    numeratorContentGreatestCommonDivisor = LargeIntegerUnsigned::lcm(
      scales[i].GetNumerator().value,
      numeratorContentGreatestCommonDivisor
    );
    denominatorContentLeastCommonMultiple = LargeIntegerUnsigned::gcd(
      denominatorContentLeastCommonMultiple,
      scales[i].GetDenominator()
    );
  }
  scale = numeratorContentGreatestCommonDivisor;
  scale /= denominatorContentLeastCommonMultiple;
  if (scales[indexNonZeroElement] < 0) {
    scale *= -1;
  }
  for (int i = 0; i < input.size; i ++) {
    input[i] *= scale;
  }
  return scale;
}

bool SemisimpleLieAlgebraOrdered::CheckInitialization() const {
  if (this->theOwner == nullptr) {
    global.fatal << "Use of semisimple Lie algebra without an owner. " << global.fatal;
  }
  if (this->theOwner->flagDeallocated) {
    global.fatal << "Use after free of semisimple Lie algebra. ";
  }
  return true;
}

void SemisimpleLieAlgebraOrdered::GetLinearCombinationFrom(
  ElementSemisimpleLieAlgebra<Rational>& input, Vector<Rational>& theCoeffs
) {
  this->CheckInitialization();
  theCoeffs.makeZero(this->theOwner->GetNumGenerators());
  for (int i = 0; i < input.size(); i ++) {
    int theIndex = input[i].theGeneratorIndex;
    theCoeffs[this->theOwner->GetGeneratorFromRootIndex(theIndex)] = input.coefficients[i];
  }
  int numPosRoots = this->theOwner->GetNumPosRoots();
  Vector<Rational> tempH = input.GetCartanPart();
  for (int i = 0; i < this->theOwner->GetRank(); i ++) {
    theCoeffs[numPosRoots + i] = tempH[i];
  }
  this->ChevalleyGeneratorsInCurrentCoords.ActOnVectorColumn(theCoeffs);
}

int SemisimpleLieAlgebraOrdered::GetDisplayIndexFromGeneratorIndex(int GeneratorIndex) {
  int numPosRoots = this->theOwner->GetNumPosRoots();
  int posRootsPlusRank = numPosRoots + this->theOwner->GetRank();
  if (GeneratorIndex >= posRootsPlusRank) {
    return GeneratorIndex - posRootsPlusRank + 1;
  }
  if (GeneratorIndex >= numPosRoots) {
    return GeneratorIndex + 1;
  }
  return - numPosRoots + GeneratorIndex;
}

void SemisimpleLieAlgebraOrdered::init(
  List<ElementSemisimpleLieAlgebra<Rational> >& inputOrder, SemisimpleLieAlgebra& owner
) {
  global.fatal << "not implemented" << global.fatal;
  if (inputOrder.size != owner.GetNumGenerators()) {
    return;
  }
  this->theOwner = &owner;
  this->theOrder = inputOrder;
  this->ChevalleyGeneratorsInCurrentCoords.init(owner.GetNumGenerators(), owner.GetNumGenerators());
  this->ChevalleyGeneratorsInCurrentCoords.makeZero();
  Vector<Rational> coordsInCurrentBasis;
  ElementSemisimpleLieAlgebra<Rational> currentElt;
  for (int i = 0; i < owner.GetNumGenerators(); i ++) {
    currentElt.MakeGenerator(i, owner);
    currentElt.GetCoordsInBasis(this->theOrder, coordsInCurrentBasis);
    for (int j = 0; j < coordsInCurrentBasis.size; j ++) {
      this->ChevalleyGeneratorsInCurrentCoords.elements[j][i] = coordsInCurrentBasis[j];
    }
  }
}

void SemisimpleLieAlgebraOrdered::initDefaultOrder(SemisimpleLieAlgebra& owner) {
  List<ElementSemisimpleLieAlgebra<Rational> > defaultOrder;
  defaultOrder.setSize(owner.GetNumGenerators());
  for (int i = 0; i < defaultOrder.size; i ++) {
    ElementSemisimpleLieAlgebra<Rational>& currentElt = defaultOrder[i];
    currentElt.MakeGenerator(i, owner);
  }
  this->init(defaultOrder, owner);
}

template <class coefficient>
bool ElementSemisimpleLieAlgebra<coefficient>::MustUseBracketsWhenDisplayingMeRaisedToPower() {
  if (this->size == 1) {
    if (this->coefficients[0] == 1) {
      return false;
    }
  }
  return true;
}

template <class coefficient>
bool ElementSemisimpleLieAlgebra<coefficient>::IsACoeffOneChevalleyGenerator() {
  if (this->size == 1) {
    return this->coefficients[0] == 1;
  }
  return false;
}

void HomomorphismSemisimpleLieAlgebra::GetWeightsWrtKInSimpleCoordsK(
  Vectors<Rational>& outputWeights, List<ElementSemisimpleLieAlgebra<Rational> >& inputElts
) {
  outputWeights.setSize(inputElts.size);
  Rational tempRat;
  ElementSemisimpleLieAlgebra<Rational> tempLieElement;
  for (int i = 0; i < inputElts.size; i ++) {
    Vector<Rational>& currentWeight = outputWeights[i];
    currentWeight.makeZero(this->theDomain().GetRank());
    ElementSemisimpleLieAlgebra<Rational>& currentLieElt = inputElts[i];
    for (int j = 0; j < this->theDomain().GetRank(); j ++) {
      this->theRange().LieBracket(
        this->imagesAllChevalleyGenerators[j + this->theDomain().GetNumPosRoots()],
        currentLieElt,
        tempLieElement
      );
      if (!currentLieElt.IsProportionalTo(tempLieElement, tempRat)) {
        global.fatal << "Lie algebra elements not proportional as expected. " << global.fatal;
      }
      currentWeight[j] = tempRat;
    }
  }
  Matrix<Rational> tempMat = this->theDomain().theWeyl.CartanSymmetric;
  tempMat.Invert();
  tempMat.ActOnVectorsColumn(outputWeights);
}

template <class coefficient>
void ElementSemisimpleLieAlgebra<coefficient>::GetBasisFromSpanOfElements(
  List<ElementSemisimpleLieAlgebra>& theElements,
  List<ElementSemisimpleLieAlgebra>& outputTheBasis
) {
  Vectors<Rational> theRootForm;
  theRootForm.setSize(theElements.size);
  for (int i = 0; i < theElements.size; i ++) {
    ElementSemisimpleLieAlgebra& currentElt = theElements[i];
    currentElt.ElementToVectorNegativeRootSpacesFirst(theRootForm[i]);
  }
//  int theRank = 0; int numRoots = 0;
//  if (theElements.size > 0)
//  { theRank = theElements.theObjects[0].Hcomponent.size;
//    numRoots = theElements.theObjects[0].coeffsRootSpaces.size;
//  }
  theRootForm.ChooseABasis();
  outputTheBasis.setSize(theRootForm.size);
  for (int i = 0; i < theRootForm.size; i ++) {
    ElementSemisimpleLieAlgebra& currentElt = outputTheBasis[i];
    currentElt.AssignVectorNegRootSpacesCartanPosRootSpaces(
      theRootForm[i], (*currentElt.ownerArray)[currentElt.indexOfOwnerAlgebra]
    );
  }

}

bool RationalFunction::gcdQuick(
  const Polynomial<Rational>& left,
  const Polynomial<Rational>& right,
  Polynomial<Rational>& output
) {
  if (left.totalDegree() > 1 && right.totalDegree() > 1) {
    return false;
  }
  Polynomial<Rational> quotient, remainder;
  List<MonomialP>::Comparator* monomialOrder = &MonomialP::orderDefault();
  if (left.totalDegree() > right.totalDegree()) {
    left.DivideBy(right, quotient, remainder, monomialOrder);
    if (remainder.IsEqualToZero()) {
      output = right;
    } else {
      output.makeOne(left.minimalNumberOfVariables());
    }
  } else {
    right.DivideBy(left, quotient, remainder, monomialOrder);
    if (remainder.IsEqualToZero()) {
      output = left;
    } else {
      output.makeOne(left.minimalNumberOfVariables());
    }
  }
  return true;
}

void RationalFunction::RaiseToPower(int thePower) {
  MacroRegisterFunctionWithName("RationalFunctionOld::RaiseToPower");
  this->checkConsistency();
  if (thePower < 0) {
    this->invert();
    thePower = - thePower;
  }
  if (thePower == 0) {
    this->makeOne();
    return;
  }
  switch (this->expressionType) {
    case RationalFunction::typeRational:
      this->ratValue.RaiseToPower(thePower);
      break;
    case RationalFunction::typePoly:
      this->Numerator.GetElement().RaiseToPower(thePower);
      break;
    case RationalFunction::typeRationalFunction:
      this->Numerator.GetElement().RaiseToPower(thePower);
      this->Denominator.GetElement().RaiseToPower(thePower);
      break;
  }
  this->checkConsistency();
}

void RationalFunction::ClearDenominators(RationalFunction& outputWasMultipliedBy) {
  //outputWasMultipliedBy.MakeConst(this->NumVars, (Rational) 1, this->context);
  Rational tempRat;
  switch(this->expressionType) {
    case RationalFunction::typeRational:
      tempRat = this->ratValue.GetDenominator();
      outputWasMultipliedBy.MakeConst(tempRat);
      this->ratValue *= tempRat;
    break;
    case RationalFunction::typePoly:
      this->Numerator.GetElement().ClearDenominators(tempRat);
      outputWasMultipliedBy.MakeConst(tempRat);
    break;
    case RationalFunction::typeRationalFunction:
      RationalFunction tempRF;
      outputWasMultipliedBy.operator=(this->Denominator.GetElement());
      *this *= outputWasMultipliedBy;
      this->ClearDenominators(tempRF);
      outputWasMultipliedBy *= tempRF;
      break;
  }
}

template <class coefficient>
bool ElementSemisimpleLieAlgebra<coefficient>::NeedsParenthesisForMultiplication() const {
  return this->size > 1;
}

void slTwoInSlN::ClimbDownFromHighestWeightAlongSl2String(
  Matrix<Rational>& input, Matrix<Rational>& output, Rational& outputCoeff, int generatorPower
) {
  MacroRegisterFunctionWithName("slTwoInSlN::ClimbDownFromHighestWeightAlongSl2String");
  if (&input == &output) {
    global.fatal << "Input coincides with output. " << global.fatal;
  }
  Rational currentWeight;
  Matrix<Rational>::LieBracket(this->theH, input, output);
  bool tempBool = input.IsProportionalTo(output, currentWeight);
  if (!tempBool) {
    global.Comments << "<br>Climbing down does not work as expected!";
  }
  Rational RaiseCoeff;
  RaiseCoeff.makeZero();
  outputCoeff.makeOne();
  output = input;
  for (int i = 0; i < generatorPower; i ++) {
    RaiseCoeff += currentWeight;
    currentWeight -= 2;
    outputCoeff *= RaiseCoeff;
    Matrix<Rational>::LieBracket(this->theF, output, output);
  }
}

std::string slTwoInSlN::ElementModuleIndexToString(int input, bool useHtml) {
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class =\"math\">";
    endMath = "</span>";
    newLine = "<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  Matrix<Rational>& currentHW = this->theHighestWeightVectors.theObjects[input];
  int currentEtaHw = this->theGmodKModules.theObjects[input].size - 1;
  //currentEtaHw-= currentEtaHw/2;
  int firstNonZeroRow = - 1, firstNonZeroColumn = - 1;
  bool found = false;
  for (int i = 0; i < currentHW.NumRows; i ++) {
    if (found) {
      break;
    }
    for (int j = 0; j < currentHW.NumCols; j ++) {
      if (!currentHW.elements[i][j].IsEqualToZero()) {
        firstNonZeroColumn = j;
        firstNonZeroRow = i;
        found = true;
        break;
      }
    }
  }
  int sRow, kRow, sColumn, kColumn;
  this->GetIsPlusKIndexingFrom(firstNonZeroRow, sRow, kRow);
  this->GetIsPlusKIndexingFrom(firstNonZeroColumn, sColumn, kColumn);
  std::stringstream out;
  out << "V_{";
  if (currentEtaHw != 0) {
    if (currentEtaHw != 1) {
      out << currentEtaHw;
    }
    out << "\\frac\\eta 2";
  }
  if (sRow != sColumn) {
    out << "-\\zeta_" << sColumn << "+\\zeta_" << sRow;
  }
  out << "}";
  return out.str();
}

void slTwoInSlN::GetIsPlusKIndexingFrom(int input, int& s, int& k) {
  s = 0;
  k = input;
  if (input >= this->theDimension || input < 0) {
    return;
  }
  for (int offset = 0; offset <= input; offset += this->thePartition[s - 1]) {
    k = input - offset;
    s ++;
  }
}

std::string slTwoInSlN::ElementMatrixToTensorString(const Matrix<Rational>& input, bool useHtml) {
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class =\"math\">";
    endMath = "</span>";
    newLine ="<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  std::stringstream out;
  std::string tempS;
  bool found = false;
  for (int i = 0; i < input.NumRows; i ++) {
    for (int j = 0; j < input.NumCols; j ++) {
      if (!input.elements[i][j].IsEqualToZero()) {
        tempS = input.elements[i][j].toString();
        if (tempS == "- 1" || tempS == "-1") {
          tempS = "-";
        }
        if (tempS == "1") {
          tempS = "";
          if (found) {
            out << "+";
          }
        } else {
          if (found) {
            if (tempS[0] != '-') {
              out << "+";
            }
          }
        }
        found = true;
        out << tempS;
        int sI, kI, sJ, kJ;
        this->GetIsPlusKIndexingFrom(i, sI, kI);
        this->GetIsPlusKIndexingFrom(j, sJ, kJ);
        out << "v_{i_{" << sI << "}";
        if (kI != 0) {
          out << "+" << kI;
        }
        out << "}\\otimes v^*_{i_{" << sJ << "}";
        if (kJ != 0) {
          out  << "+" << kJ;
        }
        out << "}";
      }
    }
  }
  return out.str();
}

void slTwoInSlN::ExtractHighestWeightVectorsFromVector(
  Matrix<Rational>& input, List<Matrix<Rational> >& outputDecompositionOfInput, List<Matrix<Rational> >& outputTheHWVectors
) {
  outputDecompositionOfInput.size = 0;
  outputTheHWVectors.size = 0;
  Matrix<Rational> remainder;
  remainder = input;
  Matrix<Rational> component, highestWeightVector, tempMat;
  Rational theCoeff, tempRat;
  int largestPowerNotKillingInput;
  while (!remainder.IsEqualToZero() ) {
    this->ClimbUpFromVector(remainder, highestWeightVector, largestPowerNotKillingInput);
    this->ClimbDownFromHighestWeightAlongSl2String(highestWeightVector, component, theCoeff, largestPowerNotKillingInput);
    for (int i = 0; i < this->theProjectors.size; i ++) {
      Matrix<Rational>& currentProjector = this->theProjectors[i];
      tempMat = highestWeightVector;
      tempMat.MultiplyOnTheLeft(currentProjector);
      if (!tempMat.IsEqualToZero()) {
        tempMat.FindFirstNonZeroElementSearchEntireRow(tempRat);
        tempMat /= tempRat;
        outputTheHWVectors.addOnTop(tempMat);
      }
    }
    global.fatal << "Extract highest vector not fully implemented yet. " << global.fatal;
    component /= theCoeff;
    outputDecompositionOfInput.addOnTop(component);
    remainder -= component;
  }
  //remainder.makeZero();
//  for (int i = 0; i <outputVectors.size; i ++)
//    remainder.Add(outputVectors.theObjects[i]);

}

void slTwoInSlN::ClimbUpFromVector(Matrix<Rational>& input, Matrix<Rational>& outputLastNonZero, int& largestPowerNotKillingInput) {
  Matrix<Rational>  tempMat;
  if (&input == &outputLastNonZero) {
    global.fatal << "Input not allowed to coincide with the output. " << global.fatal;
  }
  outputLastNonZero = input;
  largestPowerNotKillingInput = 0;
  for (
    Matrix<Rational>::LieBracket(this->theE, outputLastNonZero, tempMat);
    !tempMat.IsEqualToZero();
    Matrix<Rational>::LieBracket(this->theE, outputLastNonZero, tempMat)
  ) {
    largestPowerNotKillingInput ++;
    outputLastNonZero = tempMat;
  }
}

std::string slTwoInSlN::GetNotationString(bool useHtml) {
  std::stringstream out;
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class =\"math\">";
    endMath = "</span>";
    newLine ="<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  out << newLine << "Let the starting index of the j-th block be " << beginMath << "i_j" << endMath;
  out << "." << newLine << "In particular let: ";
  int offset = 1;
  for (int i = 0; i < this->thePartition.size; i ++) {
    out << beginMath << "i_" << i + 1 << "=" << offset << endMath << " ";
    out << " (size of block = " << this->thePartition[i] << "), ";
    offset += this->thePartition[i];
  }
  out << newLine << "Let " << beginMath << "\\eta" << endMath << " be the weight corresponding to h.";
  out << newLine << "Let " << beginMath << "\\zeta_{j}" << endMath << " be the weight corresponding to the j-th block";
  return out.str();
}

std::string slTwoInSlN::initFromModuleDecomposition(List<int>& decompositionDimensions, bool useHtml, bool computePairingTable) {
  std::stringstream out;
  this->thePartition = decompositionDimensions;
  this->thePartition.QuickSortDescending();
  this->theDimension = 0;
  for (int i = 0; i < this->thePartition.size; i ++) {
    this->theDimension += this->thePartition[i];
  }
  theH.init(this->theDimension, this->theDimension);
  theH.makeZero();
  theE.init(this->theDimension, this->theDimension);
  theE.makeZero();
  theF.init(this->theDimension, this->theDimension);
  theF.makeZero();
  this->theProjectors.setSize(this->thePartition.size);
  int currentOffset = 0;
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class =\"math\">";
    endMath = "</span>";
    newLine = "<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  for (int i = 0; i < this->thePartition.size; i ++) {
    this->theProjectors[i].init(this->theDimension, this->theDimension);
    this->theProjectors[i].makeZero();
    for (int j = 0; j < this->thePartition[i]; j ++) {
      theH.elements[currentOffset + j][currentOffset + j] = this->thePartition[i] - 1 - 2 * j;
      this->theProjectors[i].elements[currentOffset + j][currentOffset + j] = 1;
      if (j != this->thePartition[i] - 1) {
        theF.elements[currentOffset + j + 1][currentOffset + j] = 1;
        theE.elements[currentOffset + j][currentOffset + j + 1] = (j + 1) * (this->thePartition[i] - j - 1);
      }
    }
    currentOffset += this->thePartition[i];
  }
  out << newLine << beginMath << "h =" << this->ElementMatrixToTensorString(this->theH, useHtml) << "="
  << this->theH.ElementToStringWithBlocks(this->thePartition) << endMath;
  out << newLine << beginMath << "e =" << this->ElementMatrixToTensorString(this->theE, useHtml) << "="
  << this->theE.ElementToStringWithBlocks(this->thePartition) << endMath;
  out << newLine << beginMath << "f =" << this->ElementMatrixToTensorString(this->theF, useHtml) << "="
  << this->theF.ElementToStringWithBlocks(this->thePartition) << endMath;
  Matrix<Rational>  tempMat;
  tempMat.init(this->theDimension, this->theDimension);
  List<Matrix<Rational> > Decomposition, theHwCandidatesBeforeProjection, theHwCandidatesProjected;
  this->theHighestWeightVectors.size = 0;
  this->theGmodKModules.size = 0;
  for (int i = 0; i < this->theDimension; i ++) {
    for (int j = 0; j < this->theDimension; j ++) {
      tempMat.makeZero();
      tempMat.elements[i][j] = 1;
      this->ExtractHighestWeightVectorsFromVector(tempMat, Decomposition, theHwCandidatesBeforeProjection);
      theHwCandidatesProjected.size = 0;
      for (int k = 0; k < theHwCandidatesBeforeProjection.size; k ++) {
        for (int l = 0; l < this->theProjectors.size; l ++) {
          tempMat = theHwCandidatesBeforeProjection[k];
          tempMat.MultiplyOnTheLeft(this->theProjectors[l]);
          if (!tempMat.IsEqualToZero()) {
            theHwCandidatesProjected.addOnTop(tempMat);
          }
        }
      }
      for (int k = 0; k < theHwCandidatesProjected.size; k ++) {
        if (this->GetModuleIndexFromHighestWeightVector(theHwCandidatesProjected[k]) == - 1) {
          Matrix<Rational>& currentHighest = theHwCandidatesProjected[k];
          this->theHighestWeightVectors.addOnTop(currentHighest);
          this->theGmodKModules.ExpandOnTop(1);
          List<Matrix<Rational> >& currentMod = *this->theGmodKModules.LastObject();
          currentMod.size = 0;
          for (
            tempMat = currentHighest;
            !tempMat.IsEqualToZero();
            Matrix<Rational>::LieBracket(this->theF, tempMat, tempMat)
          ) {
            currentMod.addOnTop(tempMat);
          }
        }
      }
    }
  }
  out << this->GetNotationString(useHtml);
  out << newLine << "...and the highest weights of the module decomposition are ("
  << this->theHighestWeightVectors.size << " modules):";
  for (int i = 0; i < this->theHighestWeightVectors.size; i ++) {
    out << newLine << beginMath << this->ElementMatrixToTensorString(theHighestWeightVectors[i], useHtml)
    << endMath << ", highest weight of ";
    out << beginMath << this->ElementModuleIndexToString(i, useHtml) << endMath;
  }
  if (computePairingTable) {
    out << this->initPairingTable(useHtml);
  }
  return out.str();
}

std::string slTwoInSlN::initPairingTable(bool useHtml) {
  std::stringstream out;
  this->PairingTable.setSize(this->theHighestWeightVectors.size);
  for (int i = 0; i < this->PairingTable.size; i ++) {
    this->PairingTable[i].setSize(this->theHighestWeightVectors.size);
    for (int j = 0; j < this->PairingTable[i].size; j ++) {
      List<int>& currentPairing = this->PairingTable[i][j];
      out << this->PairTwoIndices(currentPairing, i, j, useHtml);
    }
  }
  return out.str();
}

std::string slTwoInSlN::PairTwoIndices(List<int>& output, int leftIndex, int rightIndex, bool useHtml) {
  std::string beginMath, endMath, newLine;
  FormatExpressions latexFormat;
  latexFormat.flagUseLatex = true;
  latexFormat.flagUseHTML = false;
  if (useHtml) {
    beginMath = "<span class =\"math\">";
    endMath = "</span>";
    newLine = "<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  std::stringstream out;
  output.size = 0;
  List<Matrix<Rational> >& leftElements = this->theGmodKModules[leftIndex];
  List<Matrix<Rational> >& rightElements = this->theGmodKModules[rightIndex];
  Matrix<Rational> tempMat;
  List<Matrix<Rational> > HighestWeightsContainingModules;
  List<Matrix<Rational> > tempDecomposition;
  for (int i = 0; i < leftElements.size; i ++) {
    for (int j = 0; j < rightElements.size; j ++) {
      Matrix<Rational>& leftElt = leftElements[i];
      Matrix<Rational>& rightElt = rightElements[j];
      Matrix<Rational>::LieBracket(leftElt, rightElt, tempMat);
      if (!tempMat.IsEqualToZero()) {
        this->ExtractHighestWeightVectorsFromVector(tempMat, tempDecomposition, HighestWeightsContainingModules);
        for (int k = 0; k < HighestWeightsContainingModules.size; k ++) {
          output.addOnTopNoRepetition(this->GetModuleIndexFromHighestWeightVector(HighestWeightsContainingModules[k]));
          if (this->GetModuleIndexFromHighestWeightVector(HighestWeightsContainingModules[k]) == - 1) {
            global.Comments << newLine << beginMath << "[" << leftElt.toString(&latexFormat) << ", "
            << rightElt.toString(&latexFormat) << "] =" << tempMat.toString(&latexFormat) << endMath;
          }
        }
      }
    }
  }
  out << newLine << beginMath << this->ElementModuleIndexToString(leftIndex, useHtml) << endMath << " and "
  << beginMath << this->ElementModuleIndexToString(rightIndex, useHtml) << endMath << " pair to: ";
  for (int i = 0; i <output.size; i ++) {
    out << beginMath << this->ElementModuleIndexToString(output[i], useHtml) << endMath;
    if (i != output.size - 1) {
      out << beginMath << "\\oplus" << endMath;
    }
  }
  if (output.size > 0) {
    out << "  hw vectors: ";
    for (int i = 0; i < output.size; i ++) {
      out << beginMath << this->ElementMatrixToTensorString(this->theHighestWeightVectors[output[i]], useHtml)
      << endMath << ",";
    }
  }
  return out.str();
}

void RationalFunction::AddSameTypes(const RationalFunction& other) {
  switch (this->expressionType) {
    case RationalFunction::typeRational:
      this->ratValue += other.ratValue;
      break;
    case RationalFunction::typePoly:
      this->Numerator.GetElement() += other.Numerator.GetElementConst();
      break;
    case RationalFunction::typeRationalFunction:
      this->AddHonestRF(other);
      break;
  }
  this->ReduceMemory();
  if (!this->checkConsistency()) {
    global.fatal << "Bad rational function. " << global.fatal;
  }
}

void RationalFunction::ReducePolyToRational() {
  if (this->expressionType == this->typePoly) {
    if (this->Numerator.GetElement().IsConstant()) {
      this->expressionType = this->typeRational;
      if (this->Numerator.GetElement().IsEqualToZero()) {
        this->ratValue.makeZero();
      } else {
        this->ratValue = this->Numerator.GetElement().coefficients[0];
      }
      this->Numerator.FreeMemory();
    }
  }
}

void RationalFunction::AddHonestRF(const RationalFunction& other) {
  MacroRegisterFunctionWithName("RationalFunctionOld::AddHonestRF");
  Rational tempRat;
  if (!this->Denominator.GetElement().IsProportionalTo(other.Denominator.GetElementConst(), tempRat, Rational(1))) {
    Polynomial<Rational> buffer;
//    RationalFunctionOld debugger;
//    debugger = other;
//    debugger.ComputeDebugString();
//    this->ComputeDebugString();
    buffer = this->Denominator.GetElement();
    this->Numerator.GetElement() *= other.Denominator.GetElementConst();
    buffer *= other.Numerator.GetElementConst();
    this->Numerator.GetElement() += buffer;
    this->Denominator.GetElement() *= other.Denominator.GetElementConst();
    if (this->Denominator.GetElement().IsEqualToZero())
      global.fatal << "Denominator of rational function is zero." << global.fatal;
    this->simplify();
//    this->ComputeDebugString();
  } else {
    this->Numerator.GetElement() *= tempRat;
    this->Denominator.GetElement() *= tempRat;
    this->Numerator.GetElement() += other.Numerator.GetElementConst();
    this->ReduceMemory();
    this->simplifyLeadingCoefficientOnly();
  }
  if (!this->checkConsistency()) {
    global.fatal << "Inconsistent rational function. " << global.fatal;
  }
}

bool RationalFunction::IsEqualTo(const RationalFunction& other) const {
  if (this->expressionType != other.expressionType) {
    return false;
  }
  switch (this->expressionType) {
    case RationalFunction::typeRationalFunction:
      return this->Numerator.GetElementConst().IsEqualTo(other.Numerator.GetElementConst()) &&
      this->Denominator.GetElementConst().IsEqualTo(other.Denominator.GetElementConst());
    case RationalFunction::typePoly:
      return this->Numerator.GetElementConst().IsEqualTo(other.Numerator.GetElementConst());
    case RationalFunction::typeRational:
      return this->ratValue == other.ratValue;
  }
  global.fatal << "This line of code is supposed to be unreachable. " << global.fatal;
  return false;
}

void RationalFunction::TimesConstant(const Rational& theConst) {
  this->operator*=(theConst);
}

void RationalFunction::ReduceMemory() {
  this->ReduceRFToPoly();
  this->ReducePolyToRational();
  if (!this->checkConsistency()) {
    global.fatal << "Corrupt rational function. " << global.fatal;
  }
}

void RationalFunction::operator=(const Polynomial<Rational>& other) {
  this->expressionType = this->typePoly;
  this->Numerator.GetElement() = other;
  this->ReduceMemory();
}

unsigned int RationalFunction::hashFunction() const {
  switch (this->expressionType) {
    case RationalFunction::typeRational:
      return this->ratValue.hashFunction();
    case RationalFunction::typePoly:
      return this->Numerator.GetElementConst().hashFunction();
    case RationalFunction::typeRationalFunction:
      return this->Numerator.GetElementConst().hashFunction() * SomeRandomPrimes[0] +
      this->Denominator.GetElementConst().hashFunction() * SomeRandomPrimes[1];
    default:
      return static_cast<unsigned int>(- 1);
  }
}

unsigned int RationalFunction::hashFunction(const RationalFunction& input) {
  return input.hashFunction();
}

void RationalFunction::operator=(int other) {
  this->MakeConst(other);
}

void RationalFunction::operator=(const Rational& other) {
  this->MakeConst(other);
}

void RationalFunction::SetNumVariables(int GoalNumVars) {
  this->SetNumVariablesSubDeletedVarsByOne(GoalNumVars);
}

void RationalFunction::GetNumerator(Polynomial<Rational>& output) const {
  switch (this->expressionType) {
    case RationalFunction::typeRational:
      output.MakeConst(this->ratValue);
      return;
    default:
      output = this->Numerator.GetElementConst();
      return;
  }
}

bool RationalFunction::IsNegative() {
  if (this->expressionType == this->typeRational) {
    return this->ratValue.IsNegative();
  }
  return false;
}

void RationalFunction::GetDenominator(Polynomial<Rational>& output) const {
  switch (this->expressionType) {
    case RationalFunction::typeRationalFunction:
      if (this->Denominator.IsZeroPointer()) {
        global.fatal << "This is a programming error: the rational function is "
        << "supposed to be honest, but the denominator pointer is zero. " << global.fatal;
      }
      output = this->Denominator.GetElementConst();
      return;
    default:
      output.MakeConst(Rational(1));
      return;
  }
}

void RationalFunction::operator+=(const Polynomial<Rational>& other) {
  RationalFunction tempOther;
  tempOther = other;
  *this += tempOther;
}

bool RationalFunction::operator==(int other) const {
  if (other == 0) {
    return this->IsEqualToZero();
  } else {
    return this->expressionType == this->typeRational && (this->ratValue == other);
  }
}

bool RationalFunction::operator!=(int other) {
  return !(this->operator==(other));
}

bool RationalFunction::operator==(const RationalFunction& other) const {
  return this->IsEqualTo(other);
}

bool RationalFunction::operator>(const RationalFunction& other) const {
  if (this->expressionType < other.expressionType) {
    return false;
  }
  if (this->expressionType > other.expressionType) {
    return true;
  }
  switch (this->expressionType) {
    case RationalFunction::typeRational:
      return this->ratValue > other.ratValue;
    case RationalFunction::typePoly:
      return this->Numerator.GetElementConst() > other.Numerator.GetElementConst();
    case RationalFunction::typeRationalFunction:
      if (other.Denominator.GetElementConst() > this->Denominator.GetElementConst()) {
        return true;
      }
      if (this->Denominator.GetElementConst() > other.Denominator.GetElementConst()) {
        return false;
      }
      return this->Numerator.GetElementConst() > other.Numerator.GetElementConst();
    default:
      return false;
  }
}

void RationalFunction::operator*=(int other) {
  *this *= Rational(other);
}

bool RationalFunction::operator<(const RationalFunction& other) const {
  return other > *this;
}

bool RationalFunction::operator<=(const RationalFunction& other) const {
  if (*this == other) {
    return true;
  }
  return other > *this;
}

void MonomialP::MakeEi(int LetterIndex, int Power, int ExpectedNumVars) {
  this->makeOne(ExpectedNumVars);
  if (Power == 0) {
    return;
  }
  this->setVariable(LetterIndex, Power);
}

void MonomialP::setVariable(int variableIndex, const Rational& power) {
  if (variableIndex >= this->monBody.size) {
    this->setSize(variableIndex + 1);
  }
  this->monBody[variableIndex] = power;
  this->trimTrailingZeroes();
}

void MonomialP::multiplyByVariable(int variableIndex, const Rational& variablePower) {
  if (variablePower.IsEqualToZero()) {
    return;
  }
  if (variableIndex >= this->monBody.size) {
    this->setSize(variableIndex);
  }
  this->monBody[variableIndex] += variablePower;
  this->trimTrailingZeroes();
}

const Rational& MonomialP::operator[](int i) const {
  if (i < 0 || i >= this->monBody.size) {
    global.fatal << "This is a programming error: requested exponent "
    << "of monomial variable with index "
    << i << " which is out of range (size = "
    << this->monBody.size
    << "). " << global.fatal;
  }
  return this->monBody[i];
}

Rational MonomialP::operator()(int i) const {
  if (i < 0) {
    global.fatal << "This is a programming error: "
    << "requested exponent of monomial variable "
    << "with index " << i << " which is negative. " << global.fatal;
  }
  if (i >= this->monBody.size) {
    return 0;
  }
  return this->monBody[i];
}

bool MonomialP::HasPositiveOrZeroExponents() const {
  for (int i = 0; i < this->monBody.size; i ++) {
    if (this->monBody[i].IsNegative()) {
      return false;
    }
  }
  return true;
}

void MonomialP::ExponentMeBy(const Rational& theExp) {
  for (int i = 0; i < this->monBody.size; i ++) {
    this->monBody[i] *= theExp;
  }
}

bool MonomialP::operator>(const MonomialP& other) const {
  return MonomialP::greaterThan_totalDegree_leftLargerWins(*this, other);
}

bool MonomialP::IsDivisibleBy(const MonomialP& other) const {
  for (int i = other.monBody.size - 1; i >= this->monBody.size; i --) {
    if (other.monBody[i] > 0) {
      return false;
    }
  }
  int upperLimit = MathRoutines::Minimum(this->monBody.size, other.monBody.size);
  for (int i = 0; i < upperLimit; i ++) {
    if (this->monBody[i] < other.monBody[i]) {
      return false;
    }
  }
  return true;
}

bool MonomialP::operator==(const MonomialP& other) const {
  for (int i = other.monBody.size - 1; i >= this->monBody.size; i --) {
    if (other.monBody[i] != 0) {
      return false;
    }
  }
  for (int i = this->monBody.size - 1; i >= other.monBody.size; i --) {
    if (this->monBody[i] != 0) {
      return false;
    }
  }
  int highestIndex = MathRoutines::Minimum(this->minimalNumberOfVariables(), other.minimalNumberOfVariables()) - 1;
  for (int i = highestIndex; i >= 0; i --) {
    if (this->monBody[i] != other.monBody[i]) {
      return false;
    }
  }
  return true;
}

bool MonomialP::greaterThan_totalDegree_rightSmallerWins(
  const MonomialP& left, const MonomialP& right
) {
  if (left == right) {
    return false;
  }
  if (left.TotalDegree() > right.TotalDegree()) {
    return true;
  }
  if (left.TotalDegree() < right.TotalDegree()) {
    return false;
  }
  return !MonomialP::greaterThan_rightLargerWins(left, right);
}

// "Graded lexicographic" order.
bool MonomialP::greaterThan_totalDegree_leftLargerWins(
  const MonomialP& left, const MonomialP& right
) {
  if (left.TotalDegree() > right.TotalDegree()) {
    return true;
  }
  if (left.TotalDegree() < right.TotalDegree()) {
    return false;
  }
  return left.greaterThan_leftLargerWins(right);
}


bool MonomialP::greaterThan_rightLargerWins(const MonomialP& other) const {
  for (int i = other.monBody.size - 1; i >= this->monBody.size; i --) {
    if (other.monBody[i] > 0) {
      return false;
    }
    if (other.monBody[i] < 0) {
      return true;
    }
  }
  for (int i = this->monBody.size - 1; i >= other.monBody.size; i --) {
    if (this->monBody[i] > 0) {
      return true;
    }
    if (this->monBody[i] < 0) {
      return false;
    }
  }
  int highestIndex = MathRoutines::Minimum(
    this->minimalNumberOfVariables(), other.minimalNumberOfVariables()
  ) - 1;
  for (int i = highestIndex; i >= 0; i --) {
    if (this->monBody[i] > other.monBody[i]) {
      return true;
    }
    if (this->monBody[i] < other.monBody[i]) {
      return false;
    }
  }
  return false;
}

List<MonomialP>::Comparator& MonomialP::orderDefault() {
  static List<MonomialP>::Comparator result(MonomialP::greaterThan_totalDegree_leftLargerWins);
  return result;
}

List<MonomialP>::Comparator& MonomialP::orderForGCD() {
  static List<MonomialP>::Comparator result(MonomialP::greaterThan_rightLargerWins);
  return result;
}

List<MonomialP>::Comparator& MonomialP::orderDegreeThenLeftLargerWins() {
  static List<MonomialP>::Comparator result(MonomialP::greaterThan_totalDegree_leftLargerWins);
  return result;
}

bool MonomialP::greaterThan_leftLargerWins(const MonomialP &other) const {
  int commonSize = MathRoutines::Minimum(
    this->minimalNumberOfVariables(), other.minimalNumberOfVariables()
  );
  for (int i = 0; i < commonSize; i ++) {
    if (this->monBody[i] > other.monBody[i]) {
      return true;
    }
    if (this->monBody[i] < other.monBody[i]) {
      return false;
    }
  }
  for (int i = this->monBody.size; i < other.monBody.size; i ++) {
    if (other.monBody[i] > 0) {
      return false;
    }
    if (other.monBody[i] < 0) {
      return true;
    }
  }
  for (int i = other.monBody.size; i < this->monBody.size; i ++) {
    if (this->monBody[i] > 0) {
      return true;
    }
    if (this->monBody[i] < 0) {
      return false;
    }
  }
  return false;
}

void MonomialP::trimTrailingZeroes() {
  for (int i = this->monBody.size - 1; i >= 0; i --) {
    if (this->monBody[i] != 0) {
      break;
    }
    this->monBody.setSize(this->monBody.size - 1);
  }
}

bool MonomialP::hasSmallIntegralPositivePowers(int* whichTotalDegree) const {
  for (int i = 0; i < this->monBody.size; i ++) {
    if (!this->monBody[i].IsIntegerFittingInInt(nullptr)) {
      return false;
    }
    if (this->monBody[i] < 0) {
      return false;
    }
  }
  return this->TotalDegree().IsIntegerFittingInInt(whichTotalDegree);
}

void MonomialP::RaiseToPower(const Rational& thePower) {
  for (int i = 0; i < this->monBody.size; i ++) {
    this->monBody[i] *= thePower;
  }
  this->trimTrailingZeroes();
}

void MonomialP::operator*=(const MonomialP& other) {
  this->setSize(MathRoutines::Maximum(this->monBody.size, other.monBody.size));
  for (int i = 0; i < other.monBody.size; i ++) {
    this->monBody[i] += other.monBody[i];
  }
  this->trimTrailingZeroes();
}

void MonomialP::operator/=(const MonomialP& other) {
  this->setSize(MathRoutines::Maximum(this->monBody.size, other.monBody.size));
  for (int i = 0; i < other.monBody.size; i ++) {
    this->monBody[i] -= other.monBody[i];
  }
  this->trimTrailingZeroes();
}

void MonomialP::setSize(int variableCount) {
  if (variableCount < 0) {
    variableCount = 0;
  }
  int oldSize = this->monBody.size;
  this->monBody.setSize(variableCount);
  for (int i = oldSize; i < this->monBody.size; i ++) {
    this->monBody[i] = 0;
  }
}

bool Cone::IsInCone(const Vector<Rational>& point) const {
  if (this->flagIsTheZeroCone) {
    return point.IsEqualToZero();
  }
  Rational tempRat;
  for (int i = 0; i < this->Normals.size; i ++) {
    tempRat = point.ScalarEuclidean(this->Normals[i]);
    if (tempRat.IsNegative()) {
      return false;
    }
  }
  return true;
}

std::string MonomialP::toString(FormatExpressions* theFormat) const {
  std::stringstream out;
  MemorySaving<FormatExpressions> tempFormat;
  if (theFormat == nullptr) {
    theFormat = &tempFormat.GetElement();
  }
  if (this->IsConstant()) {
    return "1";
  }
  for (int i = 0; i < this->monBody.size; i ++) {
    if (!(this->monBody[i].IsEqualToZero())) {
      out << theFormat->GetPolyLetter(i);
      if (!(this->monBody[i] == 1)) {
        out << "^{" << this->monBody[i] << "}";
      } else {
        out << " ";
      }
    }
  }
  return out.str();
}
