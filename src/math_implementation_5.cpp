#include "general_lists.h"
#include "math_general_implementation.h"
#include "math_general.h"
#include "math_general_polynomial_computations_basic_implementation.h"
#include "math_extra_algebraic_numbers.h"
#include "math_extra_universal_enveloping.h"
#include "math_rational_function_implementation.h"
#include "math_extra_semisimple_lie_algebras_root_subalgebras.h"
#include "math_extra_semisimple_lie_algebras_implementation.h"
#include "math_extra_finite_groups_implementation.h"
#include "math_extra_universal_enveloping_implementation.h" // undefined reference to `ElementUniversalEnveloping<RationalFunctionOld>::makeZero(SemisimpleLieAlgebra&)'
#include "math_extra_differential_operators.h"

std::string DrawingVariables::typeCircleAtVector = "circleAtVector";
std::string DrawingVariables::typePath = "path";
std::string DrawingVariables::typeSegment = "segment";
std::string DrawingVariables::typeSegment2DFixed = "segment2DFixed";
std::string DrawingVariables::typeTextAtVector = "text";
std::string DrawingVariables::typeText2DFixed = "text2DFixed";
std::string DrawingVariables::typeFilledShape = "filledShape";
std::string DrawingVariables::typeHighlightGroup = "highlightGroup";
std::string DrawingVariables::fieldColor = "color";
std::string DrawingVariables::fieldOperation = "operation";
std::string DrawingVariables::fieldPoints = "points";
std::string DrawingVariables::fieldLocation = "location";
std::string DrawingVariables::fieldRadius = "radius";
std::string DrawingVariables::fieldPenStyle = "penStyle";
std::string DrawingVariables::fieldText = "text";
std::string DrawingVariables::fieldLabels = "labels";
std::string DrawingVariables::fieldLineWidth = "lineWidth";
std::string DrawingVariables::fieldFrameId = "frameId";
std::string DrawingVariables::fieldFrameIndex = "frameIndex";

std::string MonomialWeylAlgebra::toString(FormatExpressions* format) const {
  if (this->isConstant()) {
    return "1";
  }
  std::stringstream out;
  FormatExpressions tempFormat;
  if (format == nullptr) {
    tempFormat.polynomialDefaultLetter = "\\partial";
  } else {
    tempFormat.polynomialDefaultLetter = format->weylAlgebraDefaultLetter;
    tempFormat.polynomialAlphabet = format->weylAlgebraLetters;
  }
  std::string firstS = this->polynomialPart.toString(format);
  std::string secondS = this->differentialPart.toString(&tempFormat);
  if (firstS != "1") {
    out << firstS;
  }
  if (secondS != "1") {
    out << secondS;
  }
  return out.str();
}

std::string QuasiDifferentialMononomial::toString(FormatExpressions* format)
const {
  std::stringstream out;
  out << this->weylMonomial.toString(format) << "\\otimes ";
  out << this->matrixMonomial.toString(format);
  return out.str();
}

Vector<Rational>
SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms::
getRho() {
  Vector<Rational> result;
  this->rootsOfBorel.sum(result, this->ambientWeyl->getDimension());
  result /= 2;
  return result;
}

void SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms::
getMatrixOfElement(
  const
  ElementSubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms
  & input,
  Matrix<Rational>& outputMatrix
) const {
  Vectors<Rational> startBasis, imageBasis;
  startBasis.makeEiBasis(this->ambientWeyl->getDimension());
  this->actByElement(input, startBasis, imageBasis);
  outputMatrix.assignVectorsToRows(imageBasis);
  outputMatrix.transpose();
}

bool SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms::
computeSubGroupFromGeneratingReflections(
  Vectors<Rational>* inputRoots,
  List<Vectors<Rational> >* inputExternalAutos,
  int upperLimitNumberOfElements,
  bool recomputeAmbientRho
) {
  STACK_TRACE(
    "SubgroupWeylGroupAutomorphisms::"
    "SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms"
  );
  this->checkInitialization();
  HashedList<Vector<Rational> > orbitRho;
  this->truncated = false;
  this->allElements.clear();
  orbitRho.clear();
  if (this->ambientWeyl->cartanSymmetric.numberOfRows < 1) {
    return false;
  }
  if (recomputeAmbientRho) {
    this->ambientWeyl->computeRho(false);
  }
  this->simpleRootsInner.setSize(0);
  if (inputRoots != nullptr) {
    this->simpleRootsInner = *inputRoots;
  }
  if (inputExternalAutos != nullptr) {
    this->externalAutomorphisms = *inputExternalAutos;
  }
  this->ambientWeyl->transformToSimpleBasisGenerators(
    this->simpleRootsInner, this->ambientWeyl->rootSystem
  );
  this->computeRootSubsystem();
  ElementSubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms
  currentElement;
  currentElement.owner = this;
  Vector<Rational> vectorGeneratingFaithfulOrbit;
  vectorGeneratingFaithfulOrbit = this->ambientWeyl->rho;
  // We desire that the stabilizer of vectorGeneratingFaithfulOrbit
  // is trivial, i.e., the orbit generated by that vector will have as many
  // elements as the subgroup.
  // This is guaranteed if the vector has trivial stabilizer in the
  // ambient Weyl group + outer automorphisms.
  // The rho element (half sum of positive roots divided by 2)
  // almost meets the requirements: it has no stabilizer in the Weyl group
  // but unfortunately is not stabilized by the outer automorphisms.
  // To circumvent the issue, we make the following dirty hack
  // which will work on any simple Weyl group. A proper fix
  // requires some math work and we postpone it to the future.
  vectorGeneratingFaithfulOrbit *= 50;
  // scale rho by 50
  vectorGeneratingFaithfulOrbit[0].addInteger(1);
  // <- slightly perturb the first coordinate.
  // This perturbation breaks the outer automorphism invariance for all
  // simple Weyl group of simple Lie algebras.
  // This needs needs improvement for non-simple groups.
  orbitRho.addOnTop(vectorGeneratingFaithfulOrbit);
  this->allElements.addOnTop(currentElement);
  Vector<Rational> currentRoot;
  for (int i = 0; i < this->allElements.size; i ++) {
    for (int j = 0; j < this->simpleRootsInner.size; j ++) {
      this->ambientWeyl->reflectBetaWithRespectToAlpha(
        this->simpleRootsInner[j], orbitRho[i], false, currentRoot
      );
      if (!orbitRho.contains(currentRoot)) {
        orbitRho.addOnTop(currentRoot);
        currentElement = this->allElements[i];
        currentElement.multiplyOnTheRightBySimpleRootInner(j);
        this->allElements.addOnTop(currentElement);
      }
    }
    for (int j = 1; j < this->externalAutomorphisms.size; j ++) {
      orbitRho[i].getCoordinatesInBasis(
        this->externalAutomorphisms[j], currentRoot
      );
      if (!orbitRho.contains(currentRoot)) {
        orbitRho.addOnTop(currentRoot);
        currentElement = this->allElements[i];
        currentElement.multiplyOnTheRightByOuterAutomorphism(j);
        this->allElements.addOnTop(currentElement);
      }
    }
    if (upperLimitNumberOfElements > 0) {
      if (this->allElements.size >= upperLimitNumberOfElements) {
        this->truncated = true;
        return false;
      }
    }
  }
  return true;
}

void DrawingVariables::drawCircleAtVectorBufferRational(
  const Vector<Rational>& input,
  const std::string& color,
  double radius,
  const std::string& frameId,
  int frameIndex
) {
  DrawGeneric drawObject;
  JSData& operation = drawObject.content;
  operation[DrawingVariables::fieldOperation] =
  DrawingVariables::typeCircleAtVector;
  operation[DrawingVariables::fieldLocation] = input.getVectorDouble();
  operation[DrawingVariables::fieldRadius] = radius;
  operation[DrawingVariables::fieldColor] = color;
  if (frameId != "") {
    operation[DrawingVariables::fieldFrameId] = frameId;
    operation[DrawingVariables::fieldFrameIndex] = frameIndex;
  }
  this->operations.addOnTop(drawObject);
}

void DrawingVariables::drawCircleAtVectorBufferDouble(
  const Vector<double>& input, const std::string& color, double radius
) {
  DrawGeneric drawObject;
  JSData& operation = drawObject.content;
  operation[DrawingVariables::fieldOperation] =
  DrawingVariables::typeCircleAtVector;
  operation[DrawingVariables::fieldLocation] = input;
  operation[DrawingVariables::fieldRadius] = radius;
  operation[DrawingVariables::fieldColor] = color;
  this->operations.addOnTop(drawObject);
}

void DrawingVariables::drawLineBetweenTwoVectorsBufferRational(
  const Vector<Rational>& vector1,
  const Vector<Rational>& vector2,
  const std::string& color,
  double lineWidth
) {
  this->drawLineBetweenTwoVectorsBufferDouble(
    vector1.getVectorDouble(),
    vector2.getVectorDouble(),
    color,
    lineWidth
  );
}

void DrawingVariables::drawPath(
  const Vectors<Rational>& vectors,
  const std::string& color,
  double lineWidth,
  const std::string& frameId,
  int frameIndex
) {
  DrawGeneric drawObject;
  JSData& operation = drawObject.content;
  operation[DrawingVariables::fieldOperation] = DrawingVariables::typePath;
  Vectors<double> vectorsDouble;
  vectors.getVectorsDouble(vectorsDouble);
  operation[DrawingVariables::fieldPoints] = vectorsDouble;
  operation[DrawingVariables::fieldFrameId] = frameId;
  operation[DrawingVariables::fieldFrameIndex] = frameIndex;
  if (color != "") {
    operation[DrawingVariables::fieldColor] = color;
  }
  if (lineWidth != 1.0) {
    operation[DrawingVariables::fieldLineWidth] = lineWidth;
  }
  this->operations.addOnTop(drawObject);
}

void DrawOptions::writeJSON(JSData& output) const {
  if (this->color != "") {
    output[DrawingVariables::fieldColor] = this->color;
  }
  if (this->lineWidth != 1.0) {
    output[DrawingVariables::fieldLineWidth] = this->lineWidth;
  }
}

void DrawSegment::toJSON(JSData& output, const DrawingVariables& owner) const {
  (void) owner;
  output[DrawingVariables::fieldOperation] = DrawingVariables::typeSegment;
  output[DrawingVariables::fieldPoints] = JSData::token::tokenArray;
  output[DrawingVariables::fieldPoints][0] = this->vector1;
  output[DrawingVariables::fieldPoints][1] = this->vector2;
  this->drawOptions.writeJSON(output);
}

void DrawSegment::toLatexPsTricks(
  std::stringstream& out, const DrawingVariables& owner
) const {
  double x1 = 0;
  double y1 = 0;
  double x2 = 0;
  double y2 = 0;
  owner.getCoordinatesForDrawingProjectionsComputed(
    this->vector1, this->vector2, x1, y1, x2, y2
  );
  out
  << "\\psline("
  << FloatingPoint::doubleToString(x1)
  << ","
  << FloatingPoint::doubleToString(y1)
  << ")"
  << "("
  << FloatingPoint::doubleToString(x2)
  << ","
  << FloatingPoint::doubleToString(y2)
  << ")";
}

void DrawSegment::accountBoundingBox(DrawingVariables& owner) const {
  owner.accountBoundingBox(owner.getCoordinates(this->vector1));
  owner.accountBoundingBox(owner.getCoordinates(this->vector2));
}

void DrawOptions::set(const std::string& inputColor, int inputLineWidth) {
  this->color = inputColor;
  this->lineWidth = inputLineWidth;
}

void HtmlRoutines::replaceEqualitiesAndAmpersandsBySpaces(
  std::string& inputOutput
) {
  for (unsigned i = 0; i < inputOutput.size(); i ++) {
    if (inputOutput[i] == '=' || inputOutput[i] == '&') {
      inputOutput[i] = ' ';
    }
  }
}

bool VectorPartition::initialize(
  const Vectors<Rational>& inputPartitioningVectors,
  const Vector<Rational>& inputTarget
) {
  STACK_TRACE("VectorPartition::initialize");
  for (int i = 0; i < inputPartitioningVectors.size; i ++) {
    if (!inputPartitioningVectors[i].isPositive()) {
      return false;
    }
  }
  this->partitioningVectors = inputPartitioningVectors;
  if (this->partitioningVectors.size == 0) {
    return false;
  }
  if (this->partitioningVectors[0].size != inputTarget.size) {
    return false;
  }
  if (inputTarget.isEqualToZero()) {
    return false;
  }
  this->targetSum = inputTarget;
  this->currentPartition.initializeFillInObject(
    this->partitioningVectors.size, 0
  );
  this->currentPartitionSum.makeZero(this->targetSum.size);
  return true;
}

void VectorPartition::addIndex(int index, int quantity) {
  this->currentPartition[index] += quantity;
  this->currentPartitionSum += this->partitioningVectors[index] * quantity;
}

bool VectorPartition::addOne() {
  STACK_TRACE("VectorPartition::addOne");
  for (int i = this->numberOfVectors() - 1; i >= 0; i --) {
    if (this->addOneAtIndex(i)) {
      return true;
    }
  }
  return false;
}

bool VectorPartition::addOneAtIndex(int atIndex) {
  STACK_TRACE("VectorPartition::addOneAtIndex");
  this->addIndex(atIndex, 1);
  if (!this->currentPartitionSumExceedsGoal()) {
    return true;
  }
  this->addIndex(atIndex, - this->currentPartition[atIndex]);
  return false;
}

bool VectorPartition::incrementReturnFalseIfPastLast() {
  STACK_TRACE("VectorPartition::incrementReturnFalseIfPastLast");
  ProgressReport report(10000);
  while (true) {
    if (report.tickAndWantReport()) {
      std::stringstream reportStream;
      reportStream
      << "Still seeking for the target: "
      << this->targetSum
      << ". Current value: "
      << this->currentPartition;
      report.report(reportStream.str());
    }
    if (!this->addOne()) {
      return false;
    }
    if (this->currentPartitionSum == this->targetSum) {
      return true;
    }
  }
}

int VectorPartition::numberOfPartitionsByEnumeration() {
  STACK_TRACE("VectorPartition::numberOfPartitionsByEnumeration");
  int count = 0;
  while (this->incrementReturnFalseIfPastLast()) {
    count ++;
  }
  return count;
}

bool VectorPartition::currentPartitionSumExceedsGoal() const {
  STACK_TRACE("VectorPartition::currentPartitionSumExceedsGoal");
  int dimension = this->getDimension();
  for (int i = 0; i < dimension; i ++) {
    if (this->targetSum[i] < this->currentPartitionSum[i]) {
      return true;
    }
  }
  return false;
}

std::string VectorPartition::toStringPartitioningVectors() {
  STACK_TRACE("VectorPartition::toStringPartitioningVectors");
  std::stringstream out;
  for (int i = 0; i < this->partitioningVectors.size; i ++) {
    out
    << "e_{"
    << i + 1
    << "}="
    << this->partitioningVectors[i].toString()
    << "<br>";
  }
  out << "<hr>";
  out << "Looking for partitions of: " << this->targetSum.toString();
  out << "<hr>";
  return out.str();
}

std::string VectorPartition::toStringOnePartition(
  const List<int>& currentPartition
) {
  Vector<Rational> vector;
  vector = currentPartition;
  return vector.toStringLetterFormat("e");
}

std::string VectorPartition::toStringAllPartitions(bool useHtml) {
  STACK_TRACE("VectorPartition::toStringAllPartitions");
  std::stringstream out;
  out << this->targetSum.toString() << "\n\n";
  if (useHtml) {
    out << "<br>";
  }
  for (int i = 0; i < this->partitions.size; i ++) {
    out << "=";
    out << this->toStringOnePartition(this->partitions[i]);
    out << "\n\n";
    if (useHtml) {
      out << "<br>\n";
    }
  }
  return out.str();
}

template <class Coefficient>
void ElementUniversalEnveloping<Coefficient>::
assignFromCoordinateFormWithRespectToBasis(
  List<ElementUniversalEnveloping<Coefficient> >& basis,
  Vector<Coefficient>& input,
  SemisimpleLieAlgebra& owner
) {
  this->makeZero(owner);
  ElementUniversalEnveloping<Coefficient> element;
  for (int i = 0; i < input.size; i ++) {
    if (!input[i].isEqualToZero()) {
      element.operator=(basis[i]);
      element.operator*=(input[i]);
      this->operator+=(element);
    }
  }
}

bool SemisimpleLieAlgebraOrdered::checkInitialization() const {
  if (this->ownerSemisimpleLieAlgebra == nullptr) {
    global.fatal
    << "Use of semisimple Lie algebra without an owner. "
    << global.fatal;
  }
  if (this->ownerSemisimpleLieAlgebra->flagDeallocated) {
    global.fatal << "Use after free of semisimple Lie algebra. ";
  }
  return true;
}

void SemisimpleLieAlgebraOrdered::getLinearCombinationFrom(
  ElementSemisimpleLieAlgebra<Rational>& input,
  Vector<Rational>& coefficients
) {
  this->checkInitialization();
  coefficients.makeZero(
    this->ownerSemisimpleLieAlgebra->getNumberOfGenerators()
  );
  for (int i = 0; i < input.size(); i ++) {
    int index = input[i].generatorIndex;
    coefficients[
      this->ownerSemisimpleLieAlgebra->getGeneratorFromRootIndex(index)
    ] =
    input.coefficients[i];
  }
  int numPosRoots =
  this->ownerSemisimpleLieAlgebra->getNumberOfPositiveRoots();
  Vector<Rational> tempH = input.getCartanPart();
  for (int i = 0; i < this->ownerSemisimpleLieAlgebra->getRank(); i ++) {
    coefficients[numPosRoots + i] = tempH[i];
  }
  this->chevalleyGeneratorsInCurrentCoordinates.actOnVectorColumn(
    coefficients
  );
}

int SemisimpleLieAlgebraOrdered::getDisplayIndexFromGeneratorIndex(
  int generatorIndex
) {
  int numberOfPositiveRoots =
  this->ownerSemisimpleLieAlgebra->getNumberOfPositiveRoots();
  int positiveRootsPlusRank =
  numberOfPositiveRoots + this->ownerSemisimpleLieAlgebra->getRank();
  if (generatorIndex >= positiveRootsPlusRank) {
    return generatorIndex - positiveRootsPlusRank + 1;
  }
  if (generatorIndex >= numberOfPositiveRoots) {
    return generatorIndex + 1;
  }
  return - numberOfPositiveRoots + generatorIndex;
}

void SemisimpleLieAlgebraOrdered::initialize(
  List<ElementSemisimpleLieAlgebra<Rational> >& inputOrder,
  SemisimpleLieAlgebra& owner
) {
  global.fatal << "not implemented" << global.fatal;
  if (inputOrder.size != owner.getNumberOfGenerators()) {
    return;
  }
  this->ownerSemisimpleLieAlgebra = &owner;
  this->elementOrder = inputOrder;
  this->chevalleyGeneratorsInCurrentCoordinates.initialize(
    owner.getNumberOfGenerators(), owner.getNumberOfGenerators()
  );
  this->chevalleyGeneratorsInCurrentCoordinates.makeZero();
  Vector<Rational> coordsInCurrentBasis;
  ElementSemisimpleLieAlgebra<Rational> currentElt;
  for (int i = 0; i < owner.getNumberOfGenerators(); i ++) {
    currentElt.makeGenerator(i, owner);
    currentElt.getCoordinatesInBasis(
      this->elementOrder, coordsInCurrentBasis
    );
    for (int j = 0; j < coordsInCurrentBasis.size; j ++) {
      this->chevalleyGeneratorsInCurrentCoordinates.elements[j][i] =
      coordsInCurrentBasis[j];
    }
  }
}

void SemisimpleLieAlgebraOrdered::initDefaultOrder(
  SemisimpleLieAlgebra& owner
) {
  List<ElementSemisimpleLieAlgebra<Rational> > defaultOrder;
  defaultOrder.setSize(owner.getNumberOfGenerators());
  for (int i = 0; i < defaultOrder.size; i ++) {
    ElementSemisimpleLieAlgebra<Rational>& currentElt = defaultOrder[i];
    currentElt.makeGenerator(i, owner);
  }
  this->initialize(defaultOrder, owner);
}

template <class Coefficient>
bool ElementSemisimpleLieAlgebra<Coefficient>::
isCoefficientOneChevalleyGenerator() {
  if (this->size == 1) {
    return this->coefficients[0] == 1;
  }
  return false;
}

void HomomorphismSemisimpleLieAlgebra::
getWeightsRelativeToKInSimpleKCoordinates(
  Vectors<Rational>& outputWeights,
  List<ElementSemisimpleLieAlgebra<Rational> >& inputElements
) {
  outputWeights.setSize(inputElements.size);
  Rational scalar;
  ElementSemisimpleLieAlgebra<Rational> tempLieElement;
  for (int i = 0; i < inputElements.size; i ++) {
    Vector<Rational>& currentWeight = outputWeights[i];
    currentWeight.makeZero(this->domainAlgebra().getRank());
    ElementSemisimpleLieAlgebra<Rational>& currentElement = inputElements[i];
    for (int j = 0; j < this->domainAlgebra().getRank(); j ++) {
      this->coDomainAlgebra().lieBracket(
        this->imagesAllChevalleyGenerators[
          j + this->domainAlgebra().getNumberOfPositiveRoots()
        ],
        currentElement,
        tempLieElement
      );
      if (!currentElement.isProportionalTo(tempLieElement, scalar)) {
        global.fatal
        << "Lie algebra elements not "
        << "proportional as expected. "
        << global.fatal;
      }
      currentWeight[j] = scalar;
    }
  }
  Matrix<Rational> invertedCartan =
  this->domainAlgebra().weylGroup.cartanSymmetric;
  invertedCartan.invert();
  invertedCartan.actOnVectorsColumn(outputWeights);
}

template <class Coefficient>
void ElementSemisimpleLieAlgebra<Coefficient>::getBasisFromSpanOfElements(
  List<ElementSemisimpleLieAlgebra>& elements,
  List<ElementSemisimpleLieAlgebra>& outputBasis
) {
  Vectors<Rational> rootForm;
  rootForm.setSize(elements.size);
  for (int i = 0; i < elements.size; i ++) {
    ElementSemisimpleLieAlgebra& currentElt = elements[i];
    currentElt.toVectorNegativeRootSpacesFirst(rootForm[i]);
  }
  rootForm.chooseABasis();
  outputBasis.setSize(rootForm.size);
  for (int i = 0; i < rootForm.size; i ++) {
    ElementSemisimpleLieAlgebra& currentElt = outputBasis[i];
    currentElt.assignVectorNegativeRootSpacesCartanPosistiveRootSpaces(
      rootForm[i], (*currentElt.ownerArray)[currentElt.indexOfOwnerAlgebra]
    );
  }
}

template <class Coefficient>
bool ElementSemisimpleLieAlgebra<Coefficient>::
needsParenthesisForMultiplication() const {
  return this->size > 1;
}

void SlTwoInSlN::climbDownFromHighestWeightAlongSl2String(
  Matrix<Rational>& input,
  Matrix<Rational>& output,
  Rational& outputCoeff,
  int generatorPower
) {
  STACK_TRACE("SlTwoInSlN::climbDownFromHighestWeightAlongSl2String");
  if (&input == &output) {
    global.fatal << "Input coincides with output. " << global.fatal;
  }
  Rational currentWeight;
  Matrix<Rational>::lieBracket(this->hElement, input, output);
  bool tempBool = input.isProportionalTo(output, currentWeight);
  if (!tempBool) {
    global.comments << "<br>Climbing down does not work as expected!";
  }
  Rational raiseCoeff;
  raiseCoeff.makeZero();
  outputCoeff.makeOne();
  output = input;
  for (int i = 0; i < generatorPower; i ++) {
    raiseCoeff += currentWeight;
    currentWeight -= 2;
    outputCoeff *= raiseCoeff;
    Matrix<Rational>::lieBracket(this->fElement, output, output);
  }
}

std::string SlTwoInSlN::ElementModuleIndexToString(int input, bool useHtml) {
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class ='mathcalculator'>";
    endMath = "</span>";
    newLine = "<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  Matrix<Rational>& currentHW = this->highestWeightVectors.objects[input];
  int currentEtaHw = this->gModKModules.objects[input].size - 1;
  // currentEtaHw-= currentEtaHw/2;
  int firstNonZeroRow = - 1, firstNonZeroColumn = - 1;
  bool found = false;
  for (int i = 0; i < currentHW.numberOfRows; i ++) {
    if (found) {
      break;
    }
    for (int j = 0; j < currentHW.numberOfColumns; j ++) {
      if (!currentHW.elements[i][j].isEqualToZero()) {
        firstNonZeroColumn = j;
        firstNonZeroRow = i;
        found = true;
        break;
      }
    }
  }
  int sRow, kRow, sColumn, kColumn;
  this->getIsPlusKIndexingFrom(firstNonZeroRow, sRow, kRow);
  this->getIsPlusKIndexingFrom(firstNonZeroColumn, sColumn, kColumn);
  std::stringstream out;
  out << "V_{";
  if (currentEtaHw != 0) {
    if (currentEtaHw != 1) {
      out << currentEtaHw;
    }
    out << "\\frac\\eta 2";
  }
  if (sRow != sColumn) {
    out << "-\\zeta_" << sColumn << "+\\zeta_" << sRow;
  }
  out << "}";
  return out.str();
}

void SlTwoInSlN::getIsPlusKIndexingFrom(int input, int& s, int& k) {
  s = 0;
  k = input;
  if (input >= this->dimension || input < 0) {
    return;
  }
  for (
    int offset = 0; offset <= input; offset += this->partition[s - 1]
  ) {
    k = input - offset;
    s ++;
  }
}

std::string SlTwoInSlN::elementMatrixToTensorString(
  const Matrix<Rational>& input, bool useHtml
) {
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class ='mathcalculator'>";
    endMath = "</span>";
    newLine = "<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  std::stringstream out;
  std::string coefficient;
  bool found = false;
  for (int i = 0; i < input.numberOfRows; i ++) {
    for (int j = 0; j < input.numberOfColumns; j ++) {
      if (!input.elements[i][j].isEqualToZero()) {
        coefficient = input.elements[i][j].toString();
        if (coefficient == "- 1" || coefficient == "-1") {
          coefficient = "-";
        }
        if (coefficient == "1") {
          coefficient = "";
          if (found) {
            out << "+";
          }
        } else {
          if (found) {
            if (coefficient[0] != '-') {
              out << "+";
            }
          }
        }
        found = true;
        out << coefficient;
        int sI, kI, sJ, kJ;
        this->getIsPlusKIndexingFrom(i, sI, kI);
        this->getIsPlusKIndexingFrom(j, sJ, kJ);
        out << "v_{i_{" << sI << "}";
        if (kI != 0) {
          out << "+" << kI;
        }
        out << "}\\otimes v^*_{i_{" << sJ << "}";
        if (kJ != 0) {
          out << "+" << kJ;
        }
        out << "}";
      }
    }
  }
  return out.str();
}

void SlTwoInSlN::extractHighestWeightVectorsFromVector(
  Matrix<Rational>& input,
  List<Matrix<Rational> >& outputDecompositionOfInput,
  List<Matrix<Rational> >& outputTheHWVectors
) {
  outputDecompositionOfInput.size = 0;
  outputTheHWVectors.size = 0;
  Matrix<Rational> remainder;
  remainder = input;
  Matrix<Rational> component;
  Matrix<Rational> highestWeightVector;
  Matrix<Rational> matrix;
  Rational coefficient;
  Rational scalar;
  int largestPowerNotKillingInput;
  while (!remainder.isEqualToZero()) {
    this->climbUpFromVector(
      remainder, highestWeightVector, largestPowerNotKillingInput
    );
    this->climbDownFromHighestWeightAlongSl2String(
      highestWeightVector,
      component,
      coefficient,
      largestPowerNotKillingInput
    );
    for (int i = 0; i < this->projectors.size; i ++) {
      Matrix<Rational>& currentProjector = this->projectors[i];
      matrix = highestWeightVector;
      matrix.multiplyOnTheLeft(currentProjector);
      if (!matrix.isEqualToZero()) {
        matrix.findFirstNonZeroElementSearchEntireRow(scalar);
        matrix /= scalar;
        outputTheHWVectors.addOnTop(matrix);
      }
    }
    global.fatal
    << "Extract highest vector not fully implemented yet. "
    << global.fatal;
    component /= coefficient;
    outputDecompositionOfInput.addOnTop(component);
    remainder -= component;
  }
}

void SlTwoInSlN::climbUpFromVector(
  Matrix<Rational>& input,
  Matrix<Rational>& outputLastNonZero,
  int& largestPowerNotKillingInput
) {
  Matrix<Rational> matrix;
  if (&input == &outputLastNonZero) {
    global.fatal
    << "Input not allowed to coincide with the output. "
    << global.fatal;
  }
  outputLastNonZero = input;
  largestPowerNotKillingInput = 0;
  for (
    Matrix<Rational>::lieBracket(this->eElement, outputLastNonZero, matrix); !
    matrix.isEqualToZero(); Matrix<Rational>::lieBracket(
      this->eElement, outputLastNonZero, matrix
    )
  ) {
    largestPowerNotKillingInput ++;
    outputLastNonZero = matrix;
  }
}

std::string SlTwoInSlN::GetNotationString(bool useHtml) {
  std::stringstream out;
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class ='mathcalculator'>";
    endMath = "</span>";
    newLine = "<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  out
  << newLine
  << "Let the starting index of the j-th block be "
  << beginMath
  << "i_j"
  << endMath;
  out << "." << newLine << "In particular let: ";
  int offset = 1;
  for (int i = 0; i < this->partition.size; i ++) {
    out << beginMath << "i_" << i + 1 << "=" << offset << endMath << " ";
    out << " (size of block = " << this->partition[i] << "), ";
    offset += this->partition[i];
  }
  out
  << newLine
  << "Let "
  << beginMath
  << "\\eta"
  << endMath
  << " be the weight corresponding to h.";
  out
  << newLine
  << "Let "
  << beginMath
  << "\\zeta_{j}"
  << endMath
  << " be the weight corresponding to the j-th block";
  return out.str();
}

std::string SlTwoInSlN::initFromModuleDecomposition(
  List<int>& decompositionDimensions,
  bool useHtml,
  bool computePairingTable
) {
  std::stringstream out;
  this->partition = decompositionDimensions;
  this->partition.quickSortDescending();
  this->dimension = 0;
  for (int i = 0; i < this->partition.size; i ++) {
    this->dimension += this->partition[i];
  }
  hElement.initialize(this->dimension, this->dimension);
  hElement.makeZero();
  eElement.initialize(this->dimension, this->dimension);
  eElement.makeZero();
  fElement.initialize(this->dimension, this->dimension);
  fElement.makeZero();
  this->projectors.setSize(this->partition.size);
  int currentOffset = 0;
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class ='mathcalculator'>";
    endMath = "</span>";
    newLine = "<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  for (int i = 0; i < this->partition.size; i ++) {
    this->projectors[i].initialize(this->dimension, this->dimension);
    this->projectors[i].makeZero();
    for (int j = 0; j < this->partition[i]; j ++) {
      hElement.elements[currentOffset + j][currentOffset + j] =
      this->partition[i] - 1 - 2 * j;
      this->projectors[i].elements[currentOffset + j][currentOffset + j] = 1;
      if (j != this->partition[i] - 1) {
        fElement.elements[currentOffset + j + 1][currentOffset + j] = 1;
        eElement.elements[currentOffset + j][currentOffset + j + 1] = (j + 1) *
        (this->partition[i] - j - 1);
      }
    }
    currentOffset += this->partition[i];
  }
  out
  << newLine
  << beginMath
  << "h ="
  << this->elementMatrixToTensorString(this->hElement, useHtml)
  << "="
  << this->hElement.toStringWithBlocks(this->partition)
  << endMath;
  out
  << newLine
  << beginMath
  << "e ="
  << this->elementMatrixToTensorString(this->eElement, useHtml)
  << "="
  << this->eElement.toStringWithBlocks(this->partition)
  << endMath;
  out
  << newLine
  << beginMath
  << "f ="
  << this->elementMatrixToTensorString(this->fElement, useHtml)
  << "="
  << this->fElement.toStringWithBlocks(this->partition)
  << endMath;
  Matrix<Rational> matrix;
  matrix.initialize(this->dimension, this->dimension);
  List<Matrix<Rational> >
  Decomposition,
  highestWeightCandidatesBeforeProjection,
  highestWeightCandidatesProjected;
  this->highestWeightVectors.size = 0;
  this->gModKModules.size = 0;
  for (int i = 0; i < this->dimension; i ++) {
    for (int j = 0; j < this->dimension; j ++) {
      matrix.makeZero();
      matrix.elements[i][j] = 1;
      this->extractHighestWeightVectorsFromVector(
        matrix, Decomposition, highestWeightCandidatesBeforeProjection
      );
      highestWeightCandidatesProjected.size = 0;
      for (
        int k = 0; k < highestWeightCandidatesBeforeProjection.size; k ++
      ) {
        for (int l = 0; l < this->projectors.size; l ++) {
          matrix = highestWeightCandidatesBeforeProjection[k];
          matrix.multiplyOnTheLeft(this->projectors[l]);
          if (!matrix.isEqualToZero()) {
            highestWeightCandidatesProjected.addOnTop(matrix);
          }
        }
      }
      for (int k = 0; k < highestWeightCandidatesProjected.size; k ++) {
        if (
          this->getModuleIndexFromHighestWeightVector(
            highestWeightCandidatesProjected[k]
          ) ==
          - 1
        ) {
          Matrix<Rational>& currentHighest =
          highestWeightCandidatesProjected[k];
          this->highestWeightVectors.addOnTop(currentHighest);
          this->gModKModules.expandOnTop(1);
          List<Matrix<Rational> >& currentMod =
          *this->gModKModules.lastObject();
          currentMod.size = 0;
          for (
            matrix = currentHighest; !matrix.isEqualToZero(); Matrix<Rational>
            ::lieBracket(this->fElement, matrix, matrix)
          ) {
            currentMod.addOnTop(matrix);
          }
        }
      }
    }
  }
  out << this->GetNotationString(useHtml);
  out
  << newLine
  << "...and the highest weights of the module decomposition are ("
  << this->highestWeightVectors.size
  << " modules):";
  for (int i = 0; i < this->highestWeightVectors.size; i ++) {
    out
    << newLine
    << beginMath
    << this->elementMatrixToTensorString(highestWeightVectors[i], useHtml)
    << endMath
    << ", highest weight of ";
    out
    << beginMath
    << this->ElementModuleIndexToString(i, useHtml)
    << endMath;
  }
  if (computePairingTable) {
    out << this->initPairingTable(useHtml);
  }
  return out.str();
}

std::string SlTwoInSlN::initPairingTable(bool useHtml) {
  std::stringstream out;
  this->pairingTable.setSize(this->highestWeightVectors.size);
  for (int i = 0; i < this->pairingTable.size; i ++) {
    this->pairingTable[i].setSize(this->highestWeightVectors.size);
    for (int j = 0; j < this->pairingTable[i].size; j ++) {
      List<int>& currentPairing = this->pairingTable[i][j];
      out << this->pairTwoIndices(currentPairing, i, j, useHtml);
    }
  }
  return out.str();
}

std::string SlTwoInSlN::pairTwoIndices(
  List<int>& output, int leftIndex, int rightIndex, bool useHtml
) {
  std::string beginMath, endMath, newLine;
  FormatExpressions latexFormat;
  latexFormat.flagUseLatex = true;
  latexFormat.flagUseHTML = false;
  if (useHtml) {
    beginMath = "<span class ='mathcalculator'>";
    endMath = "</span>";
    newLine = "<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  std::stringstream out;
  output.size = 0;
  List<Matrix<Rational> >& leftElements = this->gModKModules[leftIndex];
  List<Matrix<Rational> >& rightElements = this->gModKModules[rightIndex];
  Matrix<Rational> matrix;
  List<Matrix<Rational> > HighestWeightsContainingModules;
  List<Matrix<Rational> > tempDecomposition;
  for (int i = 0; i < leftElements.size; i ++) {
    for (int j = 0; j < rightElements.size; j ++) {
      Matrix<Rational>& leftElt = leftElements[i];
      Matrix<Rational>& rightElt = rightElements[j];
      Matrix<Rational>::lieBracket(leftElt, rightElt, matrix);
      if (!matrix.isEqualToZero()) {
        this->extractHighestWeightVectorsFromVector(
          matrix, tempDecomposition, HighestWeightsContainingModules
        );
        for (int k = 0; k < HighestWeightsContainingModules.size; k ++) {
          output.addOnTopNoRepetition(
            this->getModuleIndexFromHighestWeightVector(
              HighestWeightsContainingModules[k]
            )
          );
          if (
            this->getModuleIndexFromHighestWeightVector(
              HighestWeightsContainingModules[k]
            ) ==
            - 1
          ) {
            global.comments
            << newLine
            << beginMath
            << "["
            << leftElt.toString(&latexFormat)
            << ", "
            << rightElt.toString(&latexFormat)
            << "] ="
            << matrix.toString(&latexFormat)
            << endMath;
          }
        }
      }
    }
  }
  out
  << newLine
  << beginMath
  << this->ElementModuleIndexToString(leftIndex, useHtml)
  << endMath
  << " and "
  << beginMath
  << this->ElementModuleIndexToString(rightIndex, useHtml)
  << endMath
  << " pair to: ";
  for (int i = 0; i < output.size; i ++) {
    out
    << beginMath
    << this->ElementModuleIndexToString(output[i], useHtml)
    << endMath;
    if (i != output.size - 1) {
      out << beginMath << "\\oplus" << endMath;
    }
  }
  if (output.size > 0) {
    out << "  hw vectors: ";
    for (int i = 0; i < output.size; i ++) {
      out
      << beginMath
      << this->elementMatrixToTensorString(
        this->highestWeightVectors[output[i]], useHtml
      )
      << endMath
      << ",";
    }
  }
  return out.str();
}

void MonomialPolynomial::makeEi(
  int letterIndex, int power, int expectedNumberOfVariables
) {
  (void) expectedNumberOfVariables;
  this->makeOne();
  if (power == 0) {
    return;
  }
  this->setVariable(letterIndex, power);
}

void MonomialPolynomial::setVariable(
  int variableIndex, const Rational& power
) {
  if (variableIndex >= this->monomialBody.size) {
    this->setSize(variableIndex + 1);
  }
  this->monomialBody[variableIndex] = power;
  this->trimTrailingZeroes();
}

void MonomialPolynomial::makeFromPowers(
  const Vector<Rational>& inputMonomialBody
) {
  this->monomialBody = inputMonomialBody;
  this->trimTrailingZeroes();
}

void MonomialPolynomial::multiplyByVariable(
  int variableIndex, const Rational& variablePower
) {
  if (variablePower.isEqualToZero()) {
    return;
  }
  if (variableIndex >= this->monomialBody.size) {
    this->setSize(variableIndex);
  }
  this->monomialBody[variableIndex] += variablePower;
  this->trimTrailingZeroes();
}

MonomialPolynomial::MonomialPolynomial(const Vector<Rational>& exponents) {
  this->monomialBody = exponents;
  this->trimTrailingZeroes();
}

const Rational& MonomialPolynomial::operator[](int i) const {
  if (i < 0 || i >= this->monomialBody.size) {
    global.fatal
    << "Requested exponent "
    << "of monomial variable with index "
    << i
    << " which is out of range (size = "
    << this->monomialBody.size
    << "). "
    << global.fatal;
  }
  return this->monomialBody[i];
}

Rational MonomialPolynomial::operator()(int i) const {
  if (i < 0) {
    global.fatal
    << "Requested exponent of monomial variable "
    << "with index "
    << i
    << " which is negative. "
    << global.fatal;
  }
  if (i >= this->monomialBody.size) {
    return 0;
  }
  return this->monomialBody[i];
}

bool MonomialPolynomial::hasPositiveOrZeroExponents() const {
  for (int i = 0; i < this->monomialBody.size; i ++) {
    if (this->monomialBody[i].isNegative()) {
      return false;
    }
  }
  return true;
}

bool MonomialPolynomial::operator>(const MonomialPolynomial& other) const {
  return
  MonomialPolynomial::greaterThan_totalDegree_leftLargerWins(*this, other);
}

bool MonomialPolynomial::isDivisibleBy(const MonomialPolynomial& other) const {
  for (
    int i = other.monomialBody.size - 1; i >= this->monomialBody.size; i --
  ) {
    if (other.monomialBody[i] > 0) {
      return false;
    }
  }
  int upperLimit =
  MathRoutines::minimum(
    this->monomialBody.size, other.monomialBody.size
  );
  for (int i = 0; i < upperLimit; i ++) {
    if (this->monomialBody[i] < other.monomialBody[i]) {
      return false;
    }
  }
  return true;
}

bool MonomialPolynomial::operator==(const MonomialPolynomial& other) const {
  for (
    int i = other.monomialBody.size - 1; i >= this->monomialBody.size; i --
  ) {
    if (other.monomialBody[i] != 0) {
      return false;
    }
  }
  for (
    int i = this->monomialBody.size - 1; i >= other.monomialBody.size; i --
  ) {
    if (this->monomialBody[i] != 0) {
      return false;
    }
  }
  int highestIndex =
  MathRoutines::minimum(
    this->minimalNumberOfVariables(), other.minimalNumberOfVariables()
  ) -
  1;
  for (int i = highestIndex; i >= 0; i --) {
    if (this->monomialBody[i] != other.monomialBody[i]) {
      return false;
    }
  }
  return true;
}

bool MonomialPolynomial::greaterThan_totalDegree_rightSmallerWins(
  const MonomialPolynomial& left, const MonomialPolynomial& right
) {
  if (left == right) {
    return false;
  }
  if (left.totalDegree() > right.totalDegree()) {
    return true;
  }
  if (left.totalDegree() < right.totalDegree()) {
    return false;
  }
  return !MonomialPolynomial::greaterThan_rightLargerWins(left, right);
}

// "Graded lexicographic" order.
bool MonomialPolynomial::greaterThan_totalDegree_leftLargerWins(
  const MonomialPolynomial& left, const MonomialPolynomial& right
) {
  if (left.totalDegree() > right.totalDegree()) {
    return true;
  }
  if (left.totalDegree() < right.totalDegree()) {
    return false;
  }
  return left.greaterThan_leftLargerWins(right);
}

bool MonomialPolynomial::greaterThan_rightLargerWins(
  const MonomialPolynomial& other
) const {
  for (
    int i = other.monomialBody.size - 1; i >= this->monomialBody.size; i --
  ) {
    if (other.monomialBody[i] > 0) {
      return false;
    }
    if (other.monomialBody[i] < 0) {
      return true;
    }
  }
  for (
    int i = this->monomialBody.size - 1; i >= other.monomialBody.size; i --
  ) {
    if (this->monomialBody[i] > 0) {
      return true;
    }
    if (this->monomialBody[i] < 0) {
      return false;
    }
  }
  int highestIndex =
  MathRoutines::minimum(
    this->minimalNumberOfVariables(), other.minimalNumberOfVariables()
  ) -
  1;
  for (int i = highestIndex; i >= 0; i --) {
    if (this->monomialBody[i] > other.monomialBody[i]) {
      return true;
    }
    if (this->monomialBody[i] < other.monomialBody[i]) {
      return false;
    }
  }
  return false;
}

List<MonomialPolynomial>::Comparator& MonomialPolynomial::orderDefault() {
  static List<MonomialPolynomial>::Comparator result(
    MonomialPolynomial::greaterThan_totalDegree_leftLargerWins
  );
  return result;
}

List<MonomialPolynomial>::Comparator& MonomialPolynomial::
orderForGreatestCommonDivisor() {
  static List<MonomialPolynomial>::Comparator result(
    MonomialPolynomial::greaterThan_rightLargerWins
  );
  return result;
}

List<MonomialPolynomial>::Comparator& MonomialPolynomial::
orderDegreeThenLeftLargerWins() {
  static List<MonomialPolynomial>::Comparator result(
    MonomialPolynomial::greaterThan_totalDegree_leftLargerWins
  );
  return result;
}

bool MonomialPolynomial::greaterThan_leftLargerWins(
  const MonomialPolynomial& other
) const {
  int commonSize =
  MathRoutines::minimum(
    this->minimalNumberOfVariables(), other.minimalNumberOfVariables()
  );
  for (int i = 0; i < commonSize; i ++) {
    if (this->monomialBody[i] > other.monomialBody[i]) {
      return true;
    }
    if (this->monomialBody[i] < other.monomialBody[i]) {
      return false;
    }
  }
  for (
    int i = this->monomialBody.size; i < other.monomialBody.size; i ++
  ) {
    if (other.monomialBody[i] > 0) {
      return false;
    }
    if (other.monomialBody[i] < 0) {
      return true;
    }
  }
  for (
    int i = other.monomialBody.size; i < this->monomialBody.size; i ++
  ) {
    if (this->monomialBody[i] > 0) {
      return true;
    }
    if (this->monomialBody[i] < 0) {
      return false;
    }
  }
  return false;
}

void MonomialPolynomial::trimTrailingZeroes() {
  for (int i = this->monomialBody.size - 1; i >= 0; i --) {
    if (this->monomialBody[i] != 0) {
      break;
    }
    this->monomialBody.setSize(this->monomialBody.size - 1);
  }
}

bool MonomialPolynomial::hasNonNegativeIntegralExponents() const {
  for (Rational& power : this->monomialBody) {
    if (!power.isInteger() || power.isNegative()) {
      return false;
    }
  }
  return true;
}

bool MonomialPolynomial::hasSmallIntegralPositivePowers(int* whichtotalDegree)
const {
  for (int i = 0; i < this->monomialBody.size; i ++) {
    if (!this->monomialBody[i].isIntegerFittingInInt(nullptr)) {
      return false;
    }
    if (this->monomialBody[i] < 0) {
      return false;
    }
  }
  return this->totalDegree().isIntegerFittingInInt(whichtotalDegree);
}

void MonomialPolynomial::raiseToPower(const Rational& power) {
  for (int i = 0; i < this->monomialBody.size; i ++) {
    this->monomialBody[i] *= power;
  }
  this->trimTrailingZeroes();
}

void MonomialPolynomial::operator*=(const MonomialPolynomial& other) {
  this->setSize(
    MathRoutines::maximum(
      this->monomialBody.size, other.monomialBody.size
    )
  );
  for (int i = 0; i < other.monomialBody.size; i ++) {
    this->monomialBody[i] += other.monomialBody[i];
  }
  this->trimTrailingZeroes();
}

void MonomialPolynomial::operator/=(const MonomialPolynomial& other) {
  this->setSize(
    MathRoutines::maximum(
      this->monomialBody.size, other.monomialBody.size
    )
  );
  for (int i = 0; i < other.monomialBody.size; i ++) {
    this->monomialBody[i] -= other.monomialBody[i];
  }
  this->trimTrailingZeroes();
}

void MonomialPolynomial::setSize(int variableCount) {
  if (variableCount < 0) {
    variableCount = 0;
  }
  int oldSize = this->monomialBody.size;
  this->monomialBody.setSize(variableCount);
  for (int i = oldSize; i < this->monomialBody.size; i ++) {
    this->monomialBody[i] = 0;
  }
}

bool Cone::isInCone(const Vectors<Rational>& vertices) const {
  for (int i = 0; i < vertices.size; i ++) {
    if (!this->isInCone(vertices[i])) {
      return false;
    }
  }
  return true;
}

bool Cone::isInCone(const Vector<Rational>& point) const {
  if (this->flagIsTheZeroCone) {
    return point.isEqualToZero();
  }
  for (const Wall& wall : this->walls) {
    if (!wall.isInClosedHalfSpace(point)) {
      return false;
    }
  }
  return true;
}

std::string MonomialPolynomial::toString(FormatExpressions* polynomialFormat)
const {
  std::stringstream out;
  MemorySaving<FormatExpressions> tempFormat;
  if (polynomialFormat == nullptr) {
    polynomialFormat = &tempFormat.getElement();
  }
  if (this->isConstant()) {
    return "1";
  }
  for (int i = 0; i < this->monomialBody.size; i ++) {
    if ((this->monomialBody[i].isEqualToZero())) {
      continue;
    }
    out << polynomialFormat->getPolynomialLetter(i);
    if (this->monomialBody[i] == 1) {
      out << " ";
    } else {
      std::string exponentString = this->monomialBody[i].toString();
      if (exponentString.size() == 1) {
        out << "^" << exponentString;
      } else {
        out << "^{" << exponentString << "}";
      }
    }
  }
  return out.str();
}
