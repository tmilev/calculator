(()=>{
let theJSContent = {
"/calculator-html/" : function(require, module, exports){

},
"/calculator-html/browserifier" : function(require, module, exports){
// The present file is the entry point of the entire
// javascript library.
"use strict";
class Browserifier {
  constructor() {
    // theJSContent is closure variable that is constructed by the calculator builder
    // and contains an object whose keys are the file names of the scripts.
    // The values of the object are functions that enclose the contents of each script.
    /**@type{Object<string,Function>} */
    this.theJSContent = theJSContent;
    document.onreadystatechange = () => {
      if (document.readyState !== 'complete') {
        return;
      }
      this.browserifyAndRun();
    }
    window.calculator = {
      browserifier: this,
    };
    this.allModules = {};
    this.sanitizedFileNameContents = {};
    this.calculatorHtmlBaseFolder = "/calculator-html/";
  }

  require(
    /**@type{string} */
    inputFileName,
  ) {
    let currentSource = this.sanitizedFileNameContents[inputFileName];
    if (!(inputFileName in this.allModules)) {
      this.allModules[inputFileName] = {};
    }
    let currentModule = this.allModules[inputFileName];
    if (!currentModule.flagLoaded) {
      currentModule.flagLoaded = true;
      currentSource(this.require.bind(this), currentModule);
    }
    return currentModule.exports;
  }

  browserifyAndRun() {
    let expectedStart = "/calculator-html/";
    for (let fileName in this.theJSContent) {
      let newFileName = "";
      if (!fileName.startsWith(expectedStart)) {
        continue;
      }
      var fileEnd = fileName.slice(expectedStart.length);
      newFileName = `./${fileEnd}`;
      this.sanitizedFileNameContents[newFileName] = theJSContent[fileName];
    }
    this.require('./app');
  }
}

// This is the first and only function call that will be executed by loading the javascript library.
new Browserifier();
},
"/calculator-html/pathnames" : function(require, module, exports){
"use strict";

const urls = {
  calculatorAPI: "/cgi-bin/calculator",
  appNoCache: "/appNoCache",
  appWithCache: "/app",
};

const urlFields = {
  activationToken: "activationToken",
  request: "request",
  requests: {
    forgotLogin: "forgotLogin",
    toggleMonitoring: "toggleMonitoring",
    userInfoJSON: "userInfoJSON",
    loginDisabledEveryoneIsAdmin: "loginDisabledEveryoneIsAdmin",
    useFallbackDatabase: "useFallbackDatabase",
    httpsSupport: "httpsSupport",
    indicator: "indicator",
    pause: "pause",
    unpause: "unpause",
    slidesFromSource: "slidesFromSource",
    homeworkFromSource: "homeworkFromSource",
    sourceSlides: "slidesSource",
    sourceHomework: "homeworkSource",
    clonePage: "clonePageJSON",
    modifyPage: "modifyPage",
    setProblemWeight: "setProblemWeight",
    setProblemDeadline: "setProblemDeadline",
    setTeacher: "setTeacher",
    database: "database",
    serverStatusJSON: "serverStatusJSON",
    workerId: "workerId",
    monitoring: "monitoring",
    calculatorInput: "calculatorInput",
    fileContent: "fileContent",
    calculatorExamplesJSON: "calculatorExamplesJSON",
    solveJSON: "solveJSON",
    compareExpressions: "compareExpressions",
    expressionGiven: "compareExpressionsGiven",
    expressionDesired: "compareExpressionsDesired",
    calculatorCompute: "compute",
    mainInput: "mainInput",
  },
  result: {
    result: "result",
    resultHtml: "resultHtml",
    crashReport: "crashReport",
    error: "error",
    syntaxErrors: "syntaxErrors",
    syntaxErrorsExtra: "syntaxErrorsExtra",
    // Comments on performance.
    performance: "performance",
    // Computation time. Excludes https traffic.
    computationTime: "computationTime",
    // Comments for the specific task.
    comments: "comments",
    // Global comments, usually used for debugging.
    commentsGlobal: "commentsGlobal",
    solution: {
      steps: "solutionSteps",
    },
    comparison: {
      errorEvaluation: "errorEvaluation",
      errorInAnswer: "errorInAnswer",
      areEqual: "areEqual",
      areEqualAsAnswers: "areEqualAsAnswers",
    },
  },
  problem: {
    failedToLoadProblem: "Failed to load problem.",
    problemLabel: "problemLabel",
    content: "content",
    debugInformation: "debugInformation",
    fileName: "fileName",
    courseHome: "courseHome",
    fileNameTarget: "fileNameTarget",
    topicList: "topicList",
    answerWasHardCoded: "answerWasHardCoded",
  },
  teachersAndSections: "teachersAndSections",
  requestEditPage: "editPageJSON",
  calculatorCompute: "compute",
  mainInput: "mainInput",
  database: {
    operation: "databaseOperation",
    fetch: "databaseFetch",
    labels: "databaseLabels",
  },
  debugFlag: "debugFlag",
  selectCourse: "selectCourseJSON",
  scoredQuizJSON: "scoredQuizJSON",
  changePassword: "changePassword",
  password: "password",
  newPassword: "newPassword",
  reenteredPassword: "reenteredPassword",
  exerciseJSON: "exerciseJSON",
  problemGiveUp: "problemGiveUp",
  problemGiveUpNoLogin: "problemGiveUpNoLogin",
  randomSeed: "randomSeed",
  problemSolution: "problemSolution",
  problemSolutionNoLogin: "problemSolutionNoLogin",
  submitAnswers: "submitAnswers",
  submitExercise: "submitExercise",
  submitExerciseNoLogin: "submitExerciseNoLogin",
  submitAnswersPreview: "submitAnswersPreview",
  submitExercisePreviewNoLogin: "submitExercisePreviewNoLogin",
  submitExercisePreview: "submitExercisePreview",
  accountsJSON: "accountsJSON",
  signUp: "signUp",
  username: "username",
  email: "email",
  recaptchaToken: "recaptchaToken",
  userRole: "userRole",
}

class Addresses {
  constructor() { }

  /** @returns{string} */
  calculatorComputation(
    /**@type{string} */
    input,
  ) {
    let url = {
      "currentPage": "calculator",
      "calculatorInput": input,
    };
    let encoded = encodeURIComponent(JSON.stringify(url));
    return `${urls.appWithCache}#${encoded}`;
  }

  /** @returns{string} */
  solveJSON(
    /**@type{string} */
    problem,
    /**@type{boolean} */
    debug,
  ) {
    let result = `${urls.calculatorAPI}?`;
    result += `${urlFields.request}=${urlFields.requests.solveJSON}&`;
    let encodedProblem = encodeURIComponent(problem);
    result += `${urlFields.requests.calculatorInput}=${encodedProblem}&`;
    if (debug) {
      result += `${urlFields.debugFlag}=true&`;
    }
    return result;
  }

  compareExpressions(
    /**@type{string} */
    given,
    /**@type{string} */
    desired,
    /**@type{boolean} */
    debug,
  ) {
    let result = `${urls.calculatorAPI}?`;
    result += `${urlFields.request}=${urlFields.requests.compareExpressions}&`;
    let encodedGiven = encodeURIComponent(given);
    let encodedDesired = encodeURIComponent(desired);
    result += `${urlFields.requests.expressionGiven}=${encodedGiven}&`;
    result += `${urlFields.requests.expressionDesired}=${encodedDesired}&`;
    if (debug) {
      result += `${urlFields.debugFlag}=true&`;
    }
    return result;
  }
}

let addresses = new Addresses();

module.exports = {
  urls,
  urlFields,
  addresses,
};
},
"/calculator-html/server_information" : function(require, module, exports){
"use strict"; //This file is automatically generated, please do not modify.
var serverInformation = {
    version:"5641",
};
module.exports = {
serverInformation,
};

},
"/calculator-html/ids_dom_elements" : function(require, module, exports){
"use strict";

let stringResources = {
  prefixDeadlineContainer: "deadlinesContainer"
};

let domElements = {
  calculatorDefaultsEnabled: "calculatorDefaultsEnabled",
  pages: {
    solve: {
      div: "divSolvePage",
      buttonSelectSolvePage: "buttonSelectSolvePage",
      buttonSolve: "buttonSolve",
      editor: "editorSolveProblem",
      editorButtonPanel: "editorSolveButtonPanel",
      editorSolveProblemDebug: "editorSolveProblemDebug",
      solutionBox: "solutionBox",
    },
    solveSocratic: {
      div: "divSolveSocraticPage",
      link: "socraticLink",
    },
    privacyPolicy: {
      div: "divPrivacyPolicy",
      button: "buttonPrivacyPolicy",
    },
    themes: {
      div: "divThemes",
      button: "buttonThemes",
    },
    editPage: {
      div: "divEditPage",
      button: "buttonEditPage",
    },
    calculator: {
      inputMain: "mainInputID",
      monitoring: {
        progressTimer: "idProgressReportTimer",
        spanStatus: "spanMonitoringStatus",
        buttonPauseToggle: "buttonPauseToggle",
      },
      progress: "calculatorInputProgress",
    },
    compareExpressions: {
      div: "divCompareExpressionsPage",
      buttonCompare: "buttonCompareExpressions",
      givenEquationEditor: "divGivenEquationEditor",
      desiredEquationEditor: "divDesiredEquationEditor",
      givenPanel: "divGivenPanel",
      desiredPanel: "divDesiredPanel",
      givenRawInput: "inputGivenRawInput",
      desiredRawInput: "inputDesiredRawInput",
      resultUserFriendly: "compareExpressionsResultUserFriendly",
      resultRaw: "divCompareExpressionsResultRaw",
      resultFormatted: "divCompareExpressionsResultFormatted",
      calculatorLink: "divCompareExpressionsCalculatorLink",
      progress: "progressReportCompareExpressions",
    },
    login: {
      divLoginCalculatorPanel: "divLoginCalculatorPanel",
      userNameReport: "divLoginPanelUsernameReport"
    },
  },
  applicationIdentifiers: {
    default: "divDefaultApplication",
    compareExpressions: "divCompareExpressions",
  },
  compareExpressions: {
    mainPage: "divCompareExpressionsMainPage",
  },
  themeRadioButtons: {
    radioThemeExperimental: "radioThemeExperimental",
    radioThemeDefault: "radioThemeDefault",
  },
  spanOldEmail: "spanOldEmail",
  buttonChangeEmail: "buttonChangeEmail",
  inputUsername: "inputUsername",
  inputEmail: "inputEmail",
  inputPassword: "inputPassword",
  labelNewEmail: "labelNewEmail",
  switch: {
    monitoring: "sliderMonitoring",
  },
  calculatorExamples: "divCalculatorExamples",
  spanCalculatorMainOutput: "spanCalculatorMainOutput",
  spanProgressReportGeneral: "spanProgressReportGeneral",
  spanUserIdInActivateAccountPage: "spanUserIdInActivateAccountPage",
  spanUserIdInAccountsPage: "spanUserIdInAccountsPage",
  spanCurrentActivationEmail: "spanCurrentActivationEmail",
  spanCurrentActivationToken: "spanCurrentActivationToken",
  spanVerificationActivation: "spanVerificationActivation",
  spanProblemLinkWithRandomSeed: "spanProblemLinkWithRandomSeed",
  inputNewPasswordInActivationAccount: "inputNewPasswordInActivationAccount",
  inputReenteredPasswordInActivationAccount: "inputReenteredPasswordInActivationAccount",
  sliderMathJaxFlag: "mathJaxFlag",
  sliderDebugFlag: "sliderDebugFlag",
  sliderStudentView: "sliderStudentView",
  spanErrorsEditPage: "spanErrorEditPage",
  spanDatabaseComments: "spanDatabaseComments",
  spanMathJaxFlag: "spanMathJaxFlag",
  spanDebugFlagToggleReport: "spanDebugFlagToggleReport",
  spanStudentViewFlagToggleReport: "spanStudentViewToggleReport",
  spanUserExtraInfo: "spanUserExtraInfo",
  spanStudentViewPanel: "spanStudentViewPanel",
  spanStudentViewSectionSelectPanel: "spanStudentViewSectionSelectPanel",
  divPerformance: "divPerformance",
  divCurrentCourse: "divCurrentCourse",
  divCurrentCourseBody: "divCurrentCourseBody",
  divMathjaxProblematicRender: "divMathjaxProblematicRender",
  divLoginPanelExtraInfo: "divLoginPanelExtraInfo",
  divLoginPanelDatabaseInfo: "divLoginPanelDatabaseInfo",
  courseEditPanel: "divCurrentCourseEditPanel",
  classSpanDeadlineContainer: "spanDeadlineContainer",
  calculatorBuildVersion: "anchorCalculatorBuildVersion",
  divDatabaseOutput: "divDatabaseOutput",
  problemPageContentContainer: "divProblemPageContentContainer",
  divProblemInfoBar: "divProblemInfoBar",
  textAreaTopicListEntry: "textareaTopicListEntry",
  divEditorAce: "divEditorAce",
  buttonSaveEdit: "buttonSaveEdit",
  spanButtonPreviousEdit: "spanButtonPreviousEdit",
  spanButtonNextEdit: "spanButtonNextEdit",
  spanSubmitEditPageReport: "spanSubmitEditPageReport",
  serverStatus: "idServerStatus",
};

module.exports = {
  domElements,
  stringResources
};
},
"/calculator-html/styles" : function(require, module, exports){
"use strict";

var classNames = {
  containers: {
    hexStandard: "hexContainerStandard",
    hexStandardWidth: "hexContainerStandardWidth",
  },
  table: {
    borderStandard: "tableBorderStandard",
  },
};

module.exports = {
  classNames,
};
},
"/calculator-html/modifiable_database_fields" : function(require, module, exports){
//File automatically generated. Please do not modify.
"use strict";
var modifiableDatabaseData = {
  "modifiableFields":[
    [
      "users",
      "${number}",
      "problemDataJSON",
      "${any}"
    ],
    [
      "users",
      "${number}"
    ],
    [
      "emailInfo",
      "${number}"
    ]
  ]
};
module.exports = {modifiableDatabaseData};
},
"/calculator-html/json_to_html" : function(require, module, exports){
"use srict";
const miscellaneous = require("./miscellaneous_frontend");
const modifiableDatabaseData = require('./modifiable_database_fields').modifiableDatabaseData;
const panels = require('./panels');
const BufferCalculator = require('./buffer').BufferCalculator;

var modifiableFields = {};
for (var i = 0; i < modifiableDatabaseData.modifiableFields.length; i++) {
  var incomingLabel = modifiableDatabaseData.modifiableFields[i].join("");
  modifiableFields[incomingLabel] = true;
}

var transformersStandard = {
  shortener: {
    transformer: miscellaneous.shortenString.bind(null, 4),
  },
};

function writeJSONtoDOMComponent(
  /**@type{Object} */
  inputObject,
  /**@type{HTMLElement|string} */
  theDomComponent,
) {
  if (typeof theDomComponent === "string") {
    theDomComponent = document.getElementById(theDomComponent);
  }
  let transformer = new JSONToHTML();
  let copy = miscellaneous.deepCopy(inputObject);
  theDomComponent.innerHTML = transformer.getTableFromObject(copy, null, { forceRowLayout: true });
}

var counterToggleButtons = 0;

function getToggleButton(
  /**@type {JSONToHTML} */
  transformer,
  /**@type {String} */
  panelId,
  input,
  label,
) {
  transformer.panelInformation.push({
    panelId: panelId,
    label: label,
    content: input,
  });
  return `<div id = "${panelId}"></div>`;
}

function getDeleteButtonFromLabels(theLabels, selector, containerLabel) {
  return `<button onclick = 'window.calculator.database.deleteDatabaseItem("${containerLabel}", ${JSON.stringify(theLabels)}, ${JSON.stringify(selector)})'>Delete</button>`;
}

var counterDatabaseTables = 0;
var numberOfButtonsGenerated = 0;

class JSONToHTML {
  constructor() {
    /** @type {Array.<{panelId: string, label: string, content: string}>} */
    this.panelInformation = [];
    /** @type {String} */
    this.tableName = "";
    /**@type {Object.<string,{clickHandler: Function, labels: String[], panelId: String}>} */
    this.buttonBindings = {};
    /**@type {String[]} */
    this.buttonIdsInOrderOfCreation = [];
    this.ambientObject = null;
    this.labelsRows = null;
    this.optionsConstant = {};
    this.inputParsed = null;
  }

  getOptionFromLabel(
    /**@type {String[]} */
    currentLabelsGeneralized,
  ) {
    if (this.optionsConstant.transformers === null || this.optionsConstant.transformers === undefined) {
      return null;
    }
    for (let i = - 1; i < currentLabelsGeneralized.length; i++) {
      let labelTry = currentLabelsGeneralized.slice();
      if (i >= 0) {
        labelTry[i] = "${any}";
      }
      let currentLabel = labelTry.join(".");
      if (currentLabel in this.optionsConstant.transformers) {
        return this.optionsConstant.transformers[currentLabel];
      }
    }
  }

  getButtonFromLabels(
    input,
    /**@type {String} */
    panelId,
    inputTransformed,
    /**@type {String[]} */
    currentLabels,
    /**@type {Function} */
    clickHandler,
  ) {
    numberOfButtonsGenerated++;
    let result = "";
    let id = `buttonClickHandler${numberOfButtonsGenerated}`;
    result += `<button id = "${id}">${inputTransformed}</button>`;
    this.buttonBindings[id] = {
      clickHandler: clickHandler,
      labels: currentLabels.slice(),
      panelId: panelId,
    };
    this.buttonIdsInOrderOfCreation.push(id);
    return result;
  }

  getSingleEntry(
    input,
    /**@type {String[]} */
    currentLabels,
    /**@type {String[]} */
    currentLabelsGeneralized,
  ) {
    let currentOption = this.getOptionFromLabel(currentLabelsGeneralized);
    if (currentOption === null || currentOption === undefined) {
      return `${input}`;
    }
    let inputTransformed = input;
    if (typeof currentOption.transformer === "function") {
      inputTransformed = currentOption.transformer(input);
    }
    counterToggleButtons++;
    let panelId = `panelFromJSONFormatter${counterToggleButtons}`;
    if (typeof currentOption.clickHandler === "function") {
      inputTransformed = this.getButtonFromLabels(
        input, panelId, inputTransformed, currentLabels, currentOption.clickHandler
      );
    }
    if (inputTransformed === input) {
      return `${input}`;
    }
    return getToggleButton(this, panelId, input, inputTransformed);
  }

  getTableHorizontallyLaidFromJSON(
    input,
    /**@type {String[]} */
    currentLabels,
    /**@type {String[]} */
    currentLabelsGeneralized,
    /**@type {BufferCalculator} */
    output,
  ) {
    let inputType = typeof input;
    if (inputType === "string" || inputType === "number" || inputType === "boolean") {
      output.write(this.getSingleEntry(input, currentLabels, currentLabelsGeneralized));
      return;
    }
    if (Array.isArray(input)) {
      this.getTableHorizontallyLaidFromArray(input, currentLabels, currentLabelsGeneralized, output);
      return;
    } if (inputType === "object") {
      this.getTableHorizontallyLaidFromObject(input, currentLabels, currentLabelsGeneralized, output);
      return;
    } else {
      output.write(typeof input);
      return;
    }
  }

  getTableHorizontallyLaidFromArray(
    input,
    /**@type {String[]} */
    currentLabels,
    /**@type {String[]} */
    currentLabelsGeneralized,
    /**@type {BufferCalculator} */
    output,
  ) {
    if (!Array.isArray(input)) {
      return;
    }
    let hasLabels = (currentLabels !== undefined && currentLabels !== null);
    let newLabels = null;
    let newLabelsGeneralized = null;
    if (hasLabels) {
      newLabels = currentLabels.slice();
      newLabelsGeneralized = currentLabelsGeneralized.slice();
      newLabels.push("");
      newLabelsGeneralized.push("");
    }
    output.write("<table class = 'tableJSONItem'>");
    for (let counterInput = 0; counterInput < input.length; counterInput++) {
      if (hasLabels) {
        newLabels[newLabels.length - 1] = "${number}";
      }
      let item = input[counterInput];
      output.write(`<tr><td><tiny>${counterInput}</tiny></td><td>`);
      this.getTableHorizontallyLaidFromJSON(item, newLabels, newLabelsGeneralized, output);
      output.write(`</td></tr>`);
    }
    output.write("</table>");
  }

  getTableHorizontallyLaidFromObject(
    input,
    /**@type {String[]} */
    currentLabels,
    /**@type {String[]} */
    currentLabelsGeneralized,
    /**@type {BufferCalculator} */
    output,
  ) {
    if (typeof input !== "object") {
      return;
    }
    let hasLabels = (currentLabels !== undefined && currentLabels !== null);
    let newLabels = null;
    let newLabelsGeneralized = null;
    if (hasLabels) {
      newLabels = currentLabels.slice();
      newLabelsGeneralized = currentLabelsGeneralized.slice();
      newLabels.push("");
    }
    output.write("<table class = 'tableJSONItem'>");
    for (let item in input) {
      if (hasLabels) {
        newLabels[newLabels.length - 1] = item;
      }
      let flagIsDeleteable = false;
      if (flagIsDeleteable) {
        counterDatabaseTables++;
        let tableLabel = `databaseItem${counterDatabaseTables}`;
        output.write(`<tr id='${tableLabel}'>`);
      } else {
        output.write(`<tr>`);
      }
      output.write(`<td>${item}</td><td>`);
      this.getTableHorizontallyLaidFromJSON(input[item], newLabels, newLabelsGeneralized, output);
      output.write(`</td>`);
      if (flagIsDeleteable) {
        output.write(`<td>`);
        output.write(getDeleteButtonFromLabels(newLabels, tableName, tableLabel));
        output.write(`</td>`);
      }
      output.write(`</tr>`);
    }
    output.write("</table>");
  }

  bindButtons() {
    for (let i = this.panelInformation.length - 1; i >= 0; i--) {
      let currentInfo = this.panelInformation[i];
      let currentPanel = new panels.PanelExpandable(currentInfo.panelId);
      currentPanel.initialize(true);
      currentPanel.setPanelContent(currentInfo.content);
      currentPanel.setPanelLabel(currentInfo.label);
    }
    for (let i = this.buttonIdsInOrderOfCreation.length - 1; i >= 0; i--) {
      let currentId = this.buttonIdsInOrderOfCreation[i];
      let currentBinding = this.buttonBindings[currentId];
      let currentButton = document.getElementById(currentId);
      currentButton.addEventListener('click', currentBinding.clickHandler);
      currentButton.setAttribute("labels", JSON.stringify(currentBinding.labels));
      currentButton.setAttribute("panelId", currentBinding.panelId);
    }
    for (let i = 0; i < this.panelInformation.length; i++) {
      let currentInfo = this.panelInformation[i];
      let currentPanel = new panels.PanelExpandable(currentInfo.panelId);
      currentPanel.initialize(false);
      currentPanel.matchPanelStatus();
    }
  }

  transformObjectToRows(input) {
    let result = [];
    for (let labelRow in input) {
      let currentInputItem = input[labelRow];
      let typeOf = typeof currentInputItem;
      if (typeOf !== "object") {
        input[labelRow] = { "x": currentInputItem };
        currentInputItem = input[labelRow];
      }
      currentInputItem["_rowLabel"] = labelRow;
      result.push(currentInputItem);
    }
    return result;
  }

  getTableFromObject(
    input,
    optionsConstant,
    /**@type {{table: String, forceRowLayout: Boolean}} */
    optionsModified,
  ) {
    this.inputParsed = input;
    this.optionsConstant = {};
    if ((typeof optionsConstant) === "object" && optionsConstant !== null) {
      this.optionsConstant = optionsConstant;
    }
    if (optionsModified === null || typeof optionsModified !== "object") {
      optionsModified = {};
    }
    if (typeof optionsModified.table === "string") {
      this.tableName = optionsModified.table;
    }
    let forceRowLayout = false;
    if (optionsModified.forceRowLayout === true) {
      forceRowLayout = true;
    }
    if (typeof this.inputParsed === "string") {
      this.inputParsed = input.replace(/[\r\n]/g, " ");
      if (this.inputParsed[0] !== "{" && this.inputParsed[0] !== "[" && input[0] !== "\"") {
        this.inputParsed = `"${this.inputParsed}"`;
      }
      try {
        this.inputParsed = JSON.parse(this.inputParsed);
      } catch (e) {
        return `<b style = 'color:red'>Error while parsing ${escape(this.inputParsed)}: ${e}</b>`;
      }
    }
    if (forceRowLayout && typeof this.inputParsed === "object" && !Array.isArray(this.inputParsed)) {
      this.inputParsed = this.transformObjectToRows(this.inputParsed);
    }
    let resultBuffer = new BufferCalculator();
    if (typeof this.inputParsed === "object" && !Array.isArray(this.inputParsed)) {
      this.inputParsed = [this.inputParsed];
    }
    if (Array.isArray(this.inputParsed)) {
      this.getHtmlFromArray(this.inputParsed, resultBuffer);
    } else {
      resultBuffer.write(this.inputParsed + "<br>");
    }
    return resultBuffer.toString();
  }

  getHtmlFromArray(
    inputJSON,
    /**@type {BufferCalculator} */
    output,
  ) {
    if (!Array.isArray(inputJSON)) {
      return;
    }
    this.labelsRows = getLabelsRows(inputJSON);
    if (this.labelsRows === null) {
      this.getTableHorizontallyLaidFromJSON(inputJSON, [], [], output);
      return;
    }
    output.write("<table class = 'tableJSON'>");
    output.write("<tr>");
    output.write("<th></th>");
    for (let counterColumn = 0; counterColumn < this.labelsRows.labels.length; counterColumn++) {
      output.write(`<th>${this.labelsRows.labels[counterColumn]}</th>`);
    }
    output.write("</tr>");
    let id = "";
    for (let counterRow = 0; counterRow < this.labelsRows.rows.length; counterRow++) {
      if (this.labelsRows.idRow != - 1) {
        id = this.labelsRows.rows[counterRow][this.labelsRows.idRow]["$oid"];
        output.write(`<tr id = "trOid${id}">`);
      } else {
        output.write("<tr>");
        id = counterRow;
      }
      output.write(`<td><tiny>${counterRow}</tiny></td>`);
      for (let counterColumn = 0; counterColumn < this.labelsRows.labels.length; counterColumn++) {
        let labelsGeneralized = [];
        let labels = [];
        if (this.tableName !== "") {
          labels.push(this.tableName);
          labelsGeneralized.push(this.tableName);
        }
        labels.push(id, this.labelsRows.labels[counterColumn]);
        labelsGeneralized.push("${number}", this.labelsRows.labels[counterColumn]);
        output.write("<td>");
        this.getTableHorizontallyLaidFromJSON(this.labelsRows.rows[counterRow][counterColumn], labels, labelsGeneralized, output);
        output.write("</td>");
      }
      output.write("</tr>");
    }
    output.write("</table>");
  }
}

function getLabelsRows(input) {
  let result = {
    labels: [],
    rows: [],
    idRow: - 1,
  };
  let labelFinder = {};
  for (let counterRow = 0; counterRow < input.length; counterRow++) {
    if (typeof input[counterRow] !== "object") {
      return null;
    }
    for (let label in input[counterRow]) {
      labelFinder[label] = true;
    }
  }
  result.labels = Object.keys(labelFinder).sort();
  for (let counterLabel = 0; counterLabel < result.labels.length; counterLabel++) {
    if (result.labels[counterLabel] === "_id") {
      result.idRow = counterLabel;
      break;
    }
  }
  for (let counterRow = 0; counterRow < input.length; counterRow++) {
    let currentInputItem = input[counterRow];
    result.rows.push([]);
    let currentOutputItem = result.rows[result.rows.length - 1];
    for (let counterLabel = 0; counterLabel < result.labels.length; counterLabel++) {
      let label = result.labels[counterLabel];
      if (label in currentInputItem) {
        currentOutputItem.push(currentInputItem[label]);
      } else {
        currentOutputItem.push("");
      }
    }
  }
  return result;
}

module.exports = {
  JSONToHTML,
  writeJSONtoDOMComponent,
  getToggleButton,
  transformersStandard,
};
},
"/calculator-html/buffer" : function(require, module, exports){
"use strict";

class BufferCalculator {
  constructor() {
    this.internal = [];
  }

  write(any) {
    for (var i = 0; i < any.length; i++) {
      this.internal.push(any[i]);
    }
  }

  toString() {
    return this.internal.join("");
  }
}

module.exports = {
  BufferCalculator
};
},
"/calculator-html/date_picker" : function(require, module, exports){
"use strict";

class DatePicker {
  constructor() {
  }
  createDatePicker(
    /**@type{string} */
    id,
  ) {

  }
}

let datePicker = new DatePicker();

module.exports = {
  datePicker,
};

},
"/calculator-html/math_typeset" : function(require, module, exports){
const equationEditor = require("./equation_editor");
// const mathjaxSetup = require("./mathjax-calculator-setup");

class TypeSetter {
  constructor() {
    this.defaultStyle = "vertical-align:text-bottom; font-family:'Times New Roman'; font-size:120%; display:inline-block; margin-bottom:-0.1em";
    this.logTiming = false;
  }

  typesetSoft(
    /**@type {HTMLElement|string} */
    element,
    /**@type {string} */
    styleOverride,
  ) {
    if (typeof element === "string") {
      element = document.getElementById(element);
    }
    if (styleOverride === "") {
      styleOverride = this.defaultStyle;
    }
    equationEditor.typeset(element, styleOverride, false, true, this.logTiming);
  }

  typesetHard(
    /**@type {HTMLElement|string} */
    element,
    /**@type {string} */
    styleOverride,
  ) {
    if (typeof element === "string") {
      element = document.getElementById(element);
    }
    // Style overrides works only when transforming \(\) to mathcalculator tags.
    // Mathcalculator tags are not affected by styleOverride.
    if (styleOverride === "") {
      styleOverride = this.defaultStyle;
    }
    equationEditor.typeset(element, styleOverride, false, true, this.logTiming);
  }
}

let typesetter = new TypeSetter();

module.exports = {
  typesetter,
}
},
"/calculator-html/miscellaneous_frontend" : function(require, module, exports){
"use strict";
let pathnames = require("./pathnames");

function switchMenu(obj) {
  let el = document.getElementById(obj);
  if (el.classList.contains("hiddenClass")) {
    el.classList.remove("hiddenClass");
  } else {
    el.classList.add("hiddenClass");
  }
}

function appendHtml(
  /** @type{HTMLElement}*/
  targetToAppendTo,
  /** @type{HTMLElement|HTMLElement[]}*/
  contentToAppend,
) {
  if (contentToAppend === null) {
    return;
  }
  if (!(targetToAppendTo instanceof HTMLElement)) {
    throw ("appendHtml called with non-html element target. ");
  }
  if (contentToAppend instanceof HTMLElement) {
    targetToAppendTo.appendChild(contentToAppend);
    return;
  }
  if (Array.isArray(contentToAppend)) {
    for (let i = 0; i < contentToAppend.length; i++) {
      appendHtml(targetToAppendTo, contentToAppend[i]);
    }
    return;
  }
  throw (`Could not recognize the html content ${contentToAppend}`);
}

function appendHtmlToArray(
  /** @type{HTMLElement[]}*/
  targetArray,
  /** @type{HTMLElement|HTMLElement[]}*/
  contentToAppend,
) {
  if (contentToAppend === null) {
    return;
  }
  if (!Array.isArray(targetArray)) {
    throw ("appendHtmlToArray called with non-array target. ");
  }
  if (contentToAppend instanceof HTMLElement) {
    targetArray.push(contentToAppend);
    return;
  }
  if (Array.isArray(contentToAppend)) {
    for (let i = 0; i < contentToAppend.length; i++) {
      appendHtmlToArray(targetArray, contentToAppend[i]);
    }
    return;
  }
  throw (`Could not recognize the html content ${contentToAppend}`);
}

/**@returns{string} */
function htmlFromCommentsAndErrors(input) {
  let extraTags = [
    pathnames.urlFields.result.comments,
    pathnames.urlFields.result.error,
    pathnames.urlFields.result.commentsGlobal,
    pathnames.urlFields.result.crashReport,
  ];
  let resultHTML = "";
  for (let i = 0; i < extraTags.length; i++) {
    let current = input[extraTags[i]];
    if (current === undefined || current === null || current === "") {
      continue;
    }
    resultHTML += "<hr>" + current;
  }
  return resultHTML;
}

/**@returns{HTMLElement[]} */
function htmlElementsFromCommentsAndErrors(input) {
  let extraTags = [
    pathnames.urlFields.result.comments,
    pathnames.urlFields.result.error,
    pathnames.urlFields.result.commentsGlobal,
    pathnames.urlFields.result.crashReport,
  ];
  let result = [];
  for (let i = 0; i < extraTags.length; i++) {
    let current = input[extraTags[i]];
    if (current === undefined || current === null || current === "") {
      continue;
    }
    let incoming = document.createElement("div");
    incoming.textContent = current;
    result.push(incoming);
    result.push(document.createElement("br"));
  }
  return result;
}

function shortenString(charsOnEachSide, input) {
  if (charsOnEachSide * 2 + 3 > input.length) {
    return input;
  }
  return `${input.slice(0, charsOnEachSide)}...${input.slice(input.length - charsOnEachSide, input.length)}`;
}

function deepCopy(from) {
  if (typeof from !== "object") {
    return from;
  }
  let result = {};
  for (let label in from) {
    if (typeof from[label] === "object") {
      result[label] = deepCopy(from[label])
      continue;
    }
    result[label] = from[label];
  }
  return result;
}

/**@returns{string} */
function jsonParseGetHtmlStandard(input) {
  let parsed = jsonUnescapeParse(input);
  let result = "";
  if (parsed[pathnames.urlFields.result.resultHtml] !== undefined) {
    result += parsed[pathnames.urlFields.result.resultHtml];
  }
  if (parsed[pathnames.urlFields.result.commentsGlobal] !== undefined) {
    result += parsed[pathnames.urlFields.result.commentsGlobal];
  }
  let lookForComments = false;
  if (parsed[pathnames.urlFields.result.error] !== undefined) {
    result += `<b style='color:red'>Error.</b> ${parsed[pathnames.urlFields.result.error]}`;
    lookForComments = true;
  }
  if (parsed[pathnames.urlFields.result.crashReport] !== undefined) {
    result += parsed[pathnames.urlFields.result.crashReport];
    lookForComments = true;
  }
  if (lookForComments) {
    let comments = parsed[pathnames.urlFields.result.comments];
    if (comments !== undefined && comments !== "") {
      result += `<hr><b>Additional comments.</b><br>${comments}`;
    }
  }
  return result;
}

/**@returns{string} */
function unescapeInequalitiesAmpersands(input) {
  input = input.replace(/&lt;/g, "<");
  input = input.replace(/&gt;/g, ">");
  return input.replace(/&amp;/g, "&");
}

/**@returns{Object} */
function jsonUnescapeParse(input) {
  let unescaped = unescapeInequalitiesAmpersands(input);
  return JSON.parse(unescaped);
}

module.exports = {
  switchMenu,
  appendHtml,
  appendHtmlToArray,
  htmlFromCommentsAndErrors,
  htmlElementsFromCommentsAndErrors,
  shortenString,
  deepCopy,
  jsonParseGetHtmlStandard,
  unescapeInequalitiesAmpersands,
  jsonUnescapeParse,
};
},
"/calculator-html/cookies" : function(require, module, exports){
"use strict"
function getCookie(cookieName) {
  let cookie = document.cookie.split(";");
  for (let i = 0; i < cookie.length; i++) {
    let x = cookie[i].substr(0, cookie[i].indexOf("="));
    let y = cookie[i].substr(cookie[i].indexOf("=") + 1);
    x = x.replace(/^\s+|\s+$/g, "");
    if (x === cookieName) {
      return unescape(y);
    }
  }
  return "";
}

function setCookie(theName, theValue, expiryDays, secure) {
  let expiryDate = new Date();
  expiryDate.setDate(expiryDate.getDate() + expiryDays);
  if (theValue === true) {
    theValue = "true";
  }
  if (theValue === false) {
    theValue = "false";
  }
  let cookieValue = escape(theValue) + ((expiryDays === null) ? "" : "; expires =" + expiryDate.toUTCString());
  if (secure === undefined || secure === null || secure == "") {
    secure = true;
  }
  if (secure) {
    cookieValue += "; Secure";
  }
  cookieValue += "; SameSite=Strict";
  document.cookie = `${theName}=${cookieValue}; Path=/;`;
}

module.exports = {
  setCookie,
  getCookie,
};
},
"/calculator-html/crypto" : function(require, module, exports){
"use strict";
const miscellaneous = require("./miscellaneous_frontend");
const styles = require('./styles');
const jsonToHtml = require('./json_to_html');

function attachTooltip(
  /**@type {HTMLElement} */
  element,
  /**@string {string} */
  tooltipHTML,
) {
  var tooltip = document.createElement("SPAN");
  tooltip.innerHTML = tooltipHTML;
  tooltip.classList.add("tooltiptext");
  element.appendChild(tooltip);
  element.addEventListener("mouseover", showToolTip.bind(element, tooltip));
  element.addEventListener("mouseout", hideToolTip.bind(element, tooltip));
}

function showToolTip(
  /**@type {HTMLElement} */
  tooltipElement,
) {
  tooltipElement.style.visibility = "visible";
}

function hideToolTip(
  /**@type {HTMLElement} */
  tooltipElement,
) {
  tooltipElement.style.visibility = "hidden";
}


function abstractSyntaxNotationAnnotate(binaryHex, interpretation, id) {
  var annotation = new AbstractSyntaxOne();
  annotation.initializeAnnotation(binaryHex, interpretation, id);
  annotation.annotate();
}

function displayTransportLayerSecurity(
  /**@type {string} */
  outputId,
  input,
) {
  var theServer = new TransportLayerSecurityServer();
  theServer.displayMessages(outputId, input);
}

function writeSessionToDOM(
  session,
  /**@type {HTMLElement} */
  outputElement,
) {
  var htmlContent = "";
  htmlContent += `<table class = '${styles.classNames.table.borderStandard}'>`;
  var labelsToIgnore = {
    "cipherSuites": true,
    "algorithmSpecifications": true,
  };
  for (var label in session) {
    if (label in labelsToIgnore) {
      continue;
    }
    htmlContent += `<tr><td>${label}</td><td>${session[label]}</td></tr>`;
  }
  htmlContent += "</table>";
  htmlContent += `<table class = '${styles.classNames.table.borderStandard}'><tr><th>id</th><th>interpretation</th></tr>`;
  for (var label in session.cipherSuites) {
    htmlContent += `<tr>`;
    htmlContent += `<td>${label}</td>`;
    htmlContent += `<td>${session.cipherSuites[label]}</td>`;
    htmlContent += `</tr>`;
  }
  htmlContent += "</table>";
  var newChild = document.createElement("SPAN");
  newChild.innerHTML = htmlContent;
  outputElement.appendChild(newChild);
  var algorithmSpecs = document.createElement("SPAN");
  jsonToHtml.writeJSONtoDOMComponent(session.algorithmSpecifications, algorithmSpecs);
  outputElement.appendChild(algorithmSpecs);
}

function displaySSLRecord(
  /**@type {string} */
  outputId,
  input,
) {
  var outputElement = document.getElementById(outputId);
  var annotation = new AnnotatedBytes();
  outputElement.className = styles.classNames.containers.hexStandardWidth;
  annotation.writeMessageToDOM(input, outputElement);
  var extraAnnotation = "";
  var content = input.content;
  writeSessionToDOM(input.session, outputElement);
  var flagNames = ["renegotiate", "OCSPrequest", "signedCertificateTimestampRequest"];
  for (var counter = 0; counter < flagNames.length; counter++) {
    var flagName = flagNames[counter];
    if (content[flagName] !== undefined) {
      extraAnnotation += `<br>${flagName}: ${content[flagName]}`;
    }
  }
  extraAnnotation += `<br>Session id: ${content.sessionId}`;
  extraAnnotation += `<br>Cipher spec length: ${content.cipherSpecLength}`;
  extraAnnotation += `<br>Renegotiation characters: ${content.renegotiationCharacters}`;
  extraAnnotation += `<table class = '${styles.classNames.table.borderStandard}'><tr><th>type</th><th>name</th><th width = '50%'>data</th></tr>`;
  for (var counter = 0; counter < content.extensions.length; counter++) {
    var label = content.extensions[counter].name;
    var type = content.extensions[counter].type;
    var data = content.extensions[counter].data;
    extraAnnotation += `<tr>`;
    extraAnnotation += `<td>${type}</td>`;
    extraAnnotation += `<td>${label}</td>`;
    extraAnnotation += `<td>${data}</td>`;
    extraAnnotation += `</tr>`;
  }
  extraAnnotation += "</table>";
  // extraAnnotation += JSON.stringify(content);
  var annotationAnnotation = document.createElement("SPAN");
  annotationAnnotation.innerHTML += extraAnnotation;
  outputElement.appendChild(annotationAnnotation);
}

/**
 * @typedef {{
 *  body: string,
 *  children: Array,
 *  error: string,
 *  lengthEncoding: string,
 *  lengthPromised: number,
 *  type: string,
 *  tag: string,
 *  startByteOriginal: string,
 *  numberOfChildren: number,
 *  offsetLastRead: number,
 *  offsetLastWrite: number,
 *  offset: number,
 * }} ASNElement
*/

class AbstractSyntaxOne {
  constructor() {
    /**@type {string} */
    this.idAnnotation = null;
    /**@type {HTMLElement} */
    this.DOMElementAnnotationContainer = null;
    /**@type {HTMLElement} */
    this.DOMElementAnnotation = null;
    /**@type {HTMLElement} */
    this.DOMElementAnnotationTree = null;
    /**@type {string} */
    this.binaryHex = "";
    /**@type {Object} */
    this.interpretation = null;
    this.positionInBinary = 0;
  }

  initializeAnnotation(
    inputBinaryHex,
    inputInterpretation,
    /**@type {string} */
    inputIdAnnotation,
  ) {
    this.idAnnotation = inputIdAnnotation;
    this.binaryHex = inputBinaryHex;
    this.interpretation = inputInterpretation;
    this.DOMElementAnnotationContainer = document.getElementById(inputIdAnnotation);
    if (this.DOMElementAnnotationContainer === null) {
      throw (`Element of id ${inputIdAnnotation} is missing. `);
    }
  }

  appendAnnotation(
    /**@type {HTMLElement} */
    container,
    /**@type  {ASNElement}*/
    currentInterpretation,
  ) {
    var currentElement = document.createElement("SPAN");
    currentInterpretation.dom = {};
    currentInterpretation.dom.element = currentElement;
    currentElement.classList.add("abstractSyntaxOneElement");
    var elementLeadingByte = document.createElement("SPAN");
    currentInterpretation.dom.leadingByte = elementLeadingByte;
    elementLeadingByte.classList.add("abstractSyntaxOneLeadingByte");
    elementLeadingByte.innerHTML = currentInterpretation.startByteOriginal;
    var tooltipLeadingByte = `Type: ${currentInterpretation.type}`;
    tooltipLeadingByte += `<br>Leading byte: ${currentInterpretation.startByteOriginal}`;
    // offsetLastWrite is the offset in the recoded stream.
    // offsetLastRead is the offset in the original stream.
    // offset: general offset, not clear whether in the original or recoded stream.
    let offset = currentInterpretation.offsetLastWrite;
    if (offset === undefined) {
      offset = currentInterpretation.offset;
    }
    if (offset !== undefined) {
      tooltipLeadingByte += `<br>Offset: ${offset}`;
    }
    if (currentInterpretation.numberOfChildren) {
      tooltipLeadingByte += `<br># of sub-elements: ${currentInterpretation.numberOfChildren}`;
    }
    if (currentInterpretation.value !== undefined) {
      tooltipLeadingByte += `<br>Value: ${currentInterpretation.value}`;
    }
    if (currentInterpretation.comment !== undefined) {
      tooltipLeadingByte += "<br>";
      tooltipLeadingByte += `Comment: ${currentInterpretation.comment}`;
    }
    attachTooltip(
      elementLeadingByte,
      tooltipLeadingByte,
    );

    var elementLength = document.createElement("SPAN");
    currentInterpretation.dom.length = elementLength;
    elementLength.classList.add("abstractSyntaxOneLength");
    elementLength.innerHTML = currentInterpretation.lengthEncoding;
    var lengthTooltipContent = `Length: ${currentInterpretation.lengthPromised}`;
    attachTooltip(elementLength, lengthTooltipContent);

    var elementHeader = document.createElement("SPAN");
    currentInterpretation.dom.header = elementHeader;
    elementHeader.classList.add("abstractSyntaxOneHeader");
    elementHeader.appendChild(elementLeadingByte);
    elementHeader.appendChild(elementLength);
    currentElement.appendChild(elementHeader);
    var elementBody = document.createElement("SPAN");
    currentInterpretation.dom.body = elementBody;
    var foundContent = false;
    if (currentInterpretation.children !== undefined) {
      foundContent = true;
      for (var i = 0; i < currentInterpretation.children.length; i++) {
        var interpretation = currentInterpretation.children[i];
        this.appendAnnotation(elementBody, interpretation);
      }
    } else if (currentInterpretation.body !== undefined && currentInterpretation.body !== null) {
      var elementHex = document.createElement("SPAN");
      elementHex.innerHTML = currentInterpretation.body;
      elementHex.classList.add("abstractSyntaxOneContent");
      elementBody.appendChild(elementHex);
      foundContent = true;
      var tooltipBody = "";
      if (currentInterpretation.interpretation !== undefined) {
        tooltipBody += `Interpretation: ${currentInterpretation.interpretation}`;
      }
      if (currentInterpretation.comment !== undefined) {
        if (tooltipBody !== "") {
          tooltipBody += "<br>";
        }
        tooltipBody += `Comment: ${currentInterpretation.comment}`;
      }

      if (tooltipBody !== "") {
        attachTooltip(elementBody, tooltipBody);
      }
    }
    if (
      currentInterpretation.error !== null &&
      currentInterpretation.error !== undefined
    ) {
      var errorElement = document.createElement("SPAN");
      errorElement.style.color = "red";
      errorElement.innerHTML = currentInterpretation.error;
      elementBody.appendChild(noContent);
    }
    if (!foundContent) {
      var errorElement = document.createElement("SPAN");
      errorElement.innerHTML = `[no content] ${JSON.stringify(currentInterpretation)}`;
      elementBody.appendChild(noContent);
    }
    currentElement.appendChild(elementBody);
    container.appendChild(currentElement);
  }

  mouseOverAbstractSyntaxOneElement(
    annotation,
    /**@type {HTMLElement} */
    annotationTreeElement,
  ) {
    annotation.leadingByte.style.backgroundColor = "gray";
    annotation.length.style.backgroundColor = "lightskyblue";
    annotation.body.style.backgroundColor = "lightgreen";
    annotationTreeElement.style.backgroundColor = "lightgray";
  }

  mouseOutAbstractSyntaxOneElement(
    annotation,
    /**@type {HTMLElement} */
    annotationTreeElement,
  ) {
    annotation.leadingByte.style.backgroundColor = "";
    annotation.length.style.backgroundColor = "";
    annotation.body.style.backgroundColor = "";
    annotationTreeElement.style.backgroundColor = "";
  }

  appendAnnotationTree(
    /**@type {HTMLElement} */
    container,
    /**@type  {ASNElement}*/
    currentInterpretation,
  ) {
    var currentElement = document.createElement("DIV");
    currentElement.classList.add("abstractSyntaxOneElementTree");
    var currentHead = document.createElement("SPAN");
    var headHTML = `<b>${currentInterpretation.type}</b>`;
    if (
      currentInterpretation.numberOfChildren !== undefined &&
      currentInterpretation.numberOfChildren !== 0
    ) {
      headHTML += ` [${currentInterpretation.numberOfChildren} elements]`;
    }
    if (currentInterpretation.interpretation !== undefined) {
      headHTML += " " + miscellaneous.shortenString(15, currentInterpretation.interpretation);
    }
    currentHead.innerHTML = headHTML;
    currentElement.appendChild(currentHead);
    var annotationElementPeer = currentInterpretation.dom;
    var elementsToAttachTo = [currentHead, annotationElementPeer.header];
    if (currentInterpretation.children !== undefined) {
      for (var counter = 0; counter < currentInterpretation.children.length; counter++) {
        this.appendAnnotationTree(currentElement, currentInterpretation.children[counter]);
      }
    } else {
      elementsToAttachTo.push(annotationElementPeer.body);
    }
    for (var counter = 0; counter < elementsToAttachTo.length; counter++) {
      var theElement = elementsToAttachTo[counter];
      theElement.addEventListener(
        'mouseover',
        this.mouseOverAbstractSyntaxOneElement.bind(
          this,
          annotationElementPeer,
          currentElement,
        )
      );
      theElement.addEventListener(
        'mouseout',
        this.mouseOutAbstractSyntaxOneElement.bind(
          this,
          annotationElementPeer,
          currentElement,
        )
      );
    }
    container.appendChild(currentElement);
  }

  annotate() {
    this.DOMElementAnnotationContainer.innerHTML = "";
    this.DOMElementAnnotation = document.createElement("SPAN");
    this.DOMElementAnnotation.classList.add("abstractSyntaxOneAnnotation");
    this.DOMElementAnnotation.innerHTML = "";
    this.DOMElementAnnotationTree = document.createElement("SPAN");
    this.DOMElementAnnotation.classList.add("abstractSyntaxOneAnnotationTree");
    this.DOMElementAnnotation.innerHTML = "";
    var theTable = document.createElement("TABLE");
    var row = theTable.insertRow(0);
    var cellLeft = row.insertCell(- 1);
    var cellRight = row.insertCell(- 1);
    cellLeft.appendChild(this.DOMElementAnnotationTree);
    cellRight.appendChild(this.DOMElementAnnotation);
    this.DOMElementAnnotationContainer.appendChild(theTable);
    this.positionInBinary = 0;
    this.appendAnnotation(
      this.DOMElementAnnotation,
      this.interpretation
    );
    this.appendAnnotationTree(
      this.DOMElementAnnotationTree,
      this.interpretation
    );
  }
}

class TransportLayerSecurityServer {
  constructor() {
  }

  displayMessages(
    /**@type {string} */
    outputId,
    input,
  ) {
    var outputElement = document.getElementById(outputId);
    outputElement.className = "hexContainerStandardWidth";
    writeSessionToDOM(input.session, outputElement);
    var inputHeader = document.createElement("span");
    inputHeader.innerHTML = "<br>";
    outputElement.appendChild(inputHeader);
    for (var i = 0; i < input.spoofer.inputMessages.length; i++) {
      var currentStringHeader = document.createElement("SPAN");
      currentStringHeader.innerHTML = `<br><b>Input ${i + 1}:</b><br>`;
      outputElement.appendChild(currentStringHeader);
      var nextInput = document.createElement("span");
      nextInput.className = "hexContainerStandard";
      var annotation = new AnnotatedBytes();
      annotation.writeMessageToDOM(input.spoofer.inputMessages[i], nextInput);
      outputElement.appendChild(nextInput);
    }
    if (input.spoofer.errorsOnInput.length > 0) {
      var inputErrors = document.createElement("span");
      var errorHTML = "<br><b style = 'color:red'>Input errors:</b>";
      for (var i = 0; i < input.spoofer.errorsOnInput.length; i++) {
        errorHTML += "<br>" + input.spoofer.errorsOnInput[i];
      }
      inputErrors.innerHTML = errorHTML;
      outputElement.appendChild(inputErrors);
    }
    var outputHeader = document.createElement("span");
    outputHeader.innerHTML = "<br>";
    outputElement.appendChild(outputHeader);
    for (var i = 0; i < input.spoofer.outputMessages.length; i++) {
      var outputHeader = document.createElement("span");
      outputHeader.innerHTML = `<br><b>Output ${i + 1}:</b><br>`;
      outputElement.appendChild(outputHeader);
      var currentOutputContainer = document.createElement("span");
      currentOutputContainer.className = "hexContainerStandard";
      for (var j = 0; j < input.spoofer.outputMessages[i].length; j++) {
        var nextOutput = document.createElement("span");
        var annotation = new AnnotatedBytes();
        annotation.writeMessageToDOM(input.spoofer.outputMessages[i][j], nextOutput);
        currentOutputContainer.appendChild(nextOutput);
        if (j < input.spoofer.outputMessages[i].length - 1) {
          var separator = document.createElement("span");
          separator.innerHTML = "<span style = 'background-color:red;display:inline-block;'>&nbsp;</span>";
          currentOutputContainer.appendChild(separator);
        }
      }
      outputElement.appendChild(currentOutputContainer);
    }
    if (input.spoofer.errorsOnOutput.length > 0) {
      var outputErrors = document.createElement("span");
      var errorHTML = "Output errors:<br>";
      for (var i = 0; i < input.spoofer.errorsOnOutput.length; i++) {
        errorHTML += input.spoofer.errorsOnOutput[i] + "<br>";
      }
      outputErrors.innerHTML = errorHTML;
      outputElement.appendChild(outputErrors);
    }
    if (input.spoofer.errorsOnOutput.length > 0) {
      var inputErrors = document.createElement("span");
      var errorHTML = "<br><b style = 'color:red'>Output errors:</b><br>";
      for (var i = 0; i < input.spoofer.errorsOnOutput.length; i++) {
        errorHTML += "<br>" + input.spoofer.errorsOnOutput[i];
      }
      inputErrors.innerHTML = errorHTML;
      outputElement.appendChild(inputErrors);
    }
    var sessionStatusElement = document.createElement("SPAN");
    if (outputElement.style.height < 800) {
      outputElement.style.height = 800;
    }
    if (outputElement.style.width < 1000) {
      outputElement.style.width = 1000;
    }
  }
}

class AnnotatedBytes {
  constructor() {

  }

  writeMessageToDOM(
    input,
    /**@type {HTMLElement} */
    outputComponent,
  ) {
    var serialization = input.serialization;
    this.bodyHex = serialization.body;
    this.byteLength = this.bodyHex.length / 2;
    this.stack = [new StackElement(
      0,
      this.byteLength,
      "allMessages",
      outputComponent,
      [],
    )];
    this.nextByteOffset = 0;
    this.nextMarkerOffset = 0;
    this.markers = serialization.markers;
    this.top = this.stack[0];
    while (this.nextByteOffset < this.byteLength) {
      this.getStackTop();
      if (this.top == null) {
        break;
      }
      this.stackOnTop();
      if (this.top == null) {
        break;
      }
      this.top.currentBody.push(this.bodyHex.slice(this.nextByteOffset * 2, this.nextByteOffset * 2 + 2));
      this.nextByteOffset++;
    }
    if (this.top.currentBody.length > 0) {
      this.top.flushBody();
    }
    var inputStringifiedElement = document.createElement("SPAN");
    // inputStringifiedElement.innerHTML = "<br>" + JSON.stringify(input);
    outputComponent.appendChild(inputStringifiedElement);
  }

  getStackTop() {
    while (true) {
      if (this.stack.length == 0) {
        this.top = null;
        return;
      }
      this.top = this.stack[this.stack.length - 1];
      if (this.nextByteOffset < this.top.offset + this.top.length) {
        return;
      }
      this.top.flushBody();
      this.stack.pop();
    }
    // return null;
  }

  stackOnTop() {
    while (this.nextMarkerOffset < this.markers.length) {
      var nextMarker = this.markers[this.nextMarkerOffset];
      if (nextMarker.offset > this.nextByteOffset) {
        break;
      }
      if (nextMarker.offset == this.nextByteOffset) {
        this.top.flushBody();
        var newElement = document.createElement("SPAN");
        this.top.dom.appendChild(newElement);
        this.stack.push(
          new StackElement(
            this.nextByteOffset,
            nextMarker.length,
            nextMarker.label,
            newElement,
            [],
          )
        );
        this.top = this.stack[this.stack.length - 1];
      }
      this.nextMarkerOffset++;
    }
  }
}

class StackElement {
  constructor(
    /** @type {number} */
    offset,
    /** @type {number} */
    length,
    /** @type {string} */
    label,
    /** @type {HTMLElement} */
    dom,
    /** @type {Array<string>} */
    currentBody
  ) {
    this.offset = offset;
    this.length = length;
    this.label = label;
    this.dom = dom;
    this.currentBody = currentBody;
  }

  flushBody() {
    if (this.currentBody === null) {
      return;
    }
    if (this.currentBody.length <= 0) {
      return;
    }
    var bodyElement = document.createElement("SPAN");
    bodyElement.innerHTML = this.currentBody.join("");
    bodyElement.className = "byteAnnotationBody";
    var tooltipContent = "";
    tooltipContent += `Offset: ${this.offset}, length: ${this.length}`
    if (this.label !== "" && this.label !== undefined) {
      tooltipContent += `<br>label: ${this.label}`;
    }
    attachTooltip(bodyElement, tooltipContent);
    this.dom.appendChild(bodyElement);
  }
}

module.exports = {
  abstractSyntaxNotationAnnotate,
  displayTransportLayerSecurity,
  displaySSLRecord,
};
},
"/calculator-html/submit_requests" : function(require, module, exports){
"use srict";
const pathnames = require("./pathnames");
const miscellaneous = require("./miscellaneous_frontend");
const ids = require("./ids_dom_elements");
const panels = require('./panels');

function recordProgressDone(
  /**@type{HTMLElement|string} */
  progress,
  /**@type{number} */
  timeFinished,
  /**@type{{dontCollapsePanel:boolean, width:number}|null} */
  panelOptions,
) {
  if (progress === null || progress === undefined || progress === "") {
    return;
  }
  if (typeof progress === "string") {
    progress = document.getElementById(progress);
  }
  if (progress === null) {
    return;
  }
  let timeTotal = timeFinished - progress.getAttribute("timeStarted");
  let panelLabel = `<b style = 'color:green'>Received</b> ${timeTotal} ms`;
  let panel = new panels.PanelExpandable(progress);
  panel.initialize(false);
  panel.setPanelLabel(panelLabel);
  if (panelOptions !== null) {
    if (panelOptions.dontCollapsePanel === true) {
      panel.doToggleContent();
    }
  }
}

function convertStringToHtml(input) {
  let result = "";
  for (let counter = 0; counter < input.length; counter++) {
    if (input[counter] === '&') {
      result += '&amp;';
      continue;
    }
    result += input[counter];
  }
  return result;
}

/**@returns {String} */
getLatexLink = function () {
  let firstPart = window.location.href.split("#")[0];
  let hash = window.location.hash;
  if (hash.startsWith('#')) {
    hash = hash.substring(1);
  }
  if (hash.indexOf("%22") !== - 1) {
    hash = decodeURIComponent(hash);
  }
  if (hash.indexOf("{") !== - 1) {
    hash = encodeURIComponent(hash);
  }
  let theURL = `${firstPart}#${hash}`;
  return latexifyLink(theURL);
}

/**@returns {String} */
latexifyLink = function (inputURL) {
  let result = "";
  result += "\\href{";
  for (let i = 0; i < inputURL.length; i++) {
    if (inputURL[i] == '%') {
      result += "\\%";
    } else if (inputURL[i] == '_') {
      result += "\\_";
    } else {
      result += inputURL[i];
    }
  }
  result += "}{Click-able sample algebraic computation}";
  return result;
}

function recordProgressStarted(
  /**@returns{HTMLElement} */
  progress,
  address,
  isPost,
  timeStarted,
) {
  if (progress === "" || progress === null || progress === undefined) {
    return;
  }
  if (isPost === undefined || isPost === null) {
    isPost = false;
  }
  if (typeof progress === "string") {
    progress = document.getElementById(progress);
  }
  if (progress === null) {
    return;
  }
  let panelWithButton = new panels.PanelExpandable(progress);
  panelWithButton.initialize(true);
  panelWithButton.initialize
  progress.setAttribute("timeStarted", timeStarted);
  panelWithButton.setPanelLabel(`<b style = "color:orange">Sent</b>`)

  censoredAddressStarts = [
    pathnames.urlFields.newPassword,
    pathnames.urlFields.reenteredPassword,
    pathnames.urlFields.password,
  ];
  for (let i = 0; i < censoredAddressStarts.length; i++) {
    let addressPassSplit = address.split(censoredAddressStarts[i]);
    if (addressPassSplit.length > 1) {
      let indexAmpersand = addressPassSplit[1].search("&");
      addressPassSplit[1] = addressPassSplit[1].substr(indexAmpersand);
      addressPassSplit[1] = "***" + addressPassSplit[1];
      address = addressPassSplit.join(censoredAddressStarts[i] + "=");
    }
  }
  let content = "";
  if (!isPost) {
    content += `<a href='${address}' target ='_blank' class = 'linkProgressReport'>${convertStringToHtml(address)}</a>`;
  } else {
    content += address;
  }
  if (window.calculator.mainPage.storage.variables.flagDebug.isTrue()) {
    content += `<br> <b>LaTeX link:</b> `;
    content += getLatexLink();
  }
  panelWithButton.setPanelContent(content);
  panelWithButton.matchPanelStatus();
}

function recordResult(resultText, resultSpan) {
  if (resultSpan === null || resultSpan === undefined) {
    return;
  }
  if (typeof resultSpan === "string") {
    resultSpan = document.getElementById(resultSpan);
  }
  resultSpan.innerHTML = miscellaneous.jsonParseGetHtmlStandard(resultText);
}

function correctAddress(inputURL) {
  if (
    inputURL.startsWith("http://") ||
    inputURL.startsWith("https://")
  ) {
    return inputURL;
  }
  if (window.calculator.hardCodedServerAddress !== "") {
    if (window.calculator.hardCodedServerAddress.endsWith("/") && inputURL.startsWith("/")) {
      return window.calculator.hardCodedServerAddress + inputURL.slice(1);
    } else {
      return window.calculator.hardCodedServerAddress + inputURL;
    }
  }
  return inputURL;
}

/**
 * Fires up a get requests.
 * Expected input: an object with the following fields filled in.
 *
 * inputObject.url: url of the address to get. If omitted, service must be specified.
 *
 * inputObject.callback: function to callback. The function will be passed on
 *   as arguments the received result.
 *   The result may in addition be displayed in the component inputObject.result, should
 *   this object be provided.
 *   The function will be called only if the get operation was successful.
 *
 * inputObject.progress: id or handle of an object to display the progress of the operation.
 *   Indended for developer use.
 *   Will create a button whose label shows progress of the operation and
 *   clicking which will show/hide the address.
 *   Pass null or undefined if you don't want any progress report.
 *
 * inputObject.result: id or handle of an object to dump the html-escaped
 *   but otherwise non-processed final result.
 *   Pass null or undefined if you don't want to show the result.
 */
function submitGET(
  /** @type {{url: string, callback: Function, progress: string, result: HTMLElement|string, panelOptions:{dontCollapsePanel:boolean, width:number}}}*/
  inputObject,
) {
  let theAddress = correctAddress(inputObject.url);
  let progress = inputObject.progress;
  let result = inputObject.result;
  let callback = inputObject.callback;
  let panelOptions = null;
  if (inputObject.panelOptions !== undefined) {
    panelOptions = inputObject.panelOptions;
  }
  let xhr = new XMLHttpRequest();
  recordProgressStarted(progress, theAddress, false, (new Date()).getTime());
  xhr.open('GET', theAddress, true);
  xhr.setRequestHeader('Accept', 'text/html');
  xhr.onload = responseStandard.bind(null, xhr, callback, result, progress, panelOptions);
  xhr.send();
}

function responseStandard(
  /**@type {XMLHttpRequest} */
  request,
  /**@type {Function} */
  callback,
  /**@type {String|HTMLElement} */
  result,
  /**@type {String|HTMLElement} */
  progress,
  /**@type{{dontCollapsePanel:boolean, width:number}} */
  panelOptions,
) {
  recordProgressDone(progress, (new Date()).getTime(), panelOptions);
  if (callback !== undefined && callback !== null) {
    callback(request.responseText, result);
  } else {
    recordResult(request.responseText, result);
  }
}

function submitPOST(
  /** @type {{url: string, parameters: string, callback: Function, progress: string, result: string}}*/
  inputObject,
) {
  let theAddress = correctAddress(inputObject.url);
  let progress = inputObject.progress;
  let result = inputObject.result;
  let callback = inputObject.callback;
  let https = new XMLHttpRequest();
  let parameters = inputObject.parameters;
  https.open("POST", theAddress, true);
  https.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
  if (progress === undefined) {
    progress = ids.domElements.spanProgressReportGeneral;
  }
  timeOutCounter = 0;

  let postRequest = `POST ${pathnames.urls.calculatorAPI}<br>message: ${miscellaneous.shortenString(200, parameters)}`;
  recordProgressStarted(progress, postRequest, true, (new Date()).getTime());

  https.onload = responseStandard.bind(null, https, callback, result, progress);
  ////////////////////////////////////////////
  https.send(parameters);
  ////////////////////////////////////////////
}

module.exports = {
  submitGET,
  submitPOST,
};
},
"/calculator-html/autocomplete_keywords" : function(require, module, exports){
"use strict"; //This file is automatically generated, please do not modify.
  var theAutocompleteDictionary = [
  "if=", "mod", "and", "\\times", "\\otimes", "\\oplus", "\\binom", "\\sqrt", "\\in", "\\circ", "\\geq", "\\leq", "===", "\\cup", "\\sqcup", "\\cap", "Error", "Sequence", "Matrix", "Context", "PolyVars", "DiffOpVars", "\\to", "\\lim", "LogBase", "\\int", "Rational", "EltZmodP", "Double", "AlgebraicNumber", "PolynomialRational", "PolynomialOverANs", "PolynomialModuloInteger", "PolynomialModuloPolynomialModuloInteger", "RationalFunction", "RationalFunctionAlgebraicCoefficients", "RationalFunctionModuloInteger", "string", "JSON", "ElementUEoverRF", "ElementTensorGVM", "CharSSAlgMod", "SemisimpleLieAlg", "LittelmannPath", "LRO", "MatrixRational", "MatrixDouble", "MatrixAlgebraic", "MatrixTensorRational", "MatrixRF", "MatrixPolynomialRational", "CalculusPlot", "SemisimpleSubalgebras", "CandidateSSsubalgebra", "WeylGroup", "ElementWeylGroup", "HyperoctahedralGroupRepresentation", "ElementHyperoctahedral", "WeylGroupRep", "WeylGroupVirtualRep", "ElementWeylAlgebra", "weightLieAlg", "weightLieAlgPoly", "ellipticCurveElementsRational", "ellipticCurveElementsZmodP", "userInputTextBox", "RulesOff", "RulesOn", "Freeze", "\\infty", "\\phantom", "CommandEnclosure", "MonomialPoly", "Melt", "Bind", "\\limits", "IntervalClosed", "IntervalOpen", "IndefiniteIndicator", "\\log", "\\emptyset", "\\pi", "\\arctan", "\\neq", "CommandEnclosureStart", "CommandEnclosureFinish", "ExpressionHistory", "ExpressionHistorySet", "ExpressionHistorySetChild", "SetRandomSeed", "SelectAtRandom", "RandomInteger", "TurnOffRules", "TurnOnRules", "TurnOnApproximations", "TurnOffApproximations", "EvaluateSymbols", "IfStandard", "ConvertElementZmodPToInteger", "URLStringToNormalString", "ConvertStringToURL", "URLKeyValuePairsDecode", "LoadFileIntoString", "InterpretProblem", "ProblemGiveUp", "MakeInputBox", "ExtractCalculatorExpressionFromHtml", "TestCalculatorIndicator", "TestTopCommand", "Crash", "CrashListOutOfBounds", "CrashVectorOutOfBounds", "PlotExpressionTree", "Thaw", "LogEvaluationStepsDebug", "LogEvaluationSteps", "PlotExpressionTreeFull", "Lispify", "FlattenCommandEnclosuresOneLayer", "LispifyFull", "ChildExpression", "ToString", "ToUTF8String", "StringToAtom", "TestBase64", "EllipticCurveOrderNIST", "EllipticCurveGeneratorNIST", "StringDifference", "Slice", "ConvertIntegerToBase58", "ConvertBase58ToHex", "AESCBCEncrypt", "AESCBCDecrypt", "AppendDoubleSha256Check", "ConvertHexToBase58", "CharToBase64", "ConvertBase64ToString", "loadKnownCertificates", "TestLoadPEMCertificate", "TestLoadPEMPrivateKey", "TestTLSMessageSequence", "TestTLSDecodeSSLRecord", "TestASN1Decode", "X509CertificateServerBase64", "X509CertificateDecode", "ShowKnownASNObjectIds", "JWTVerifyAgainstKnownKeys", "JWTVerifyRSA256", "Sha1", "Sha224", "LogarithmBaseNCeiling", "TestRSASign", "GenerateRandomPrime", "RSAEncrypt", "Ripemd160", "ShaThree256", "Keccak256", "Sha256", "Sha512", "Sha256Verbose", "TestJSON", "ConvertBase64ToHex", "ConvertStringToHex", "ConvertHexToInteger", "ConvertIntegerToHex", "ConvertHexToString", "FormatCPPCode", "formatCPPDirectory", "TestCalculatorAll", "TestTopicListProblems", "TestProblemInterpretation", "RepresentElementHyperoctahedral", "HyperOctahedralIrreps", "SpechtModule", "HyperOctahedralRepresentation", "HyperOctahedralGeneratorPrint", "Numerator", "ApplyToSubexpressionsRecurseThroughCalculusFunctions", "SubList", "ApplyToList", "Denominator", "Product", "\\sum", "MakeExpression", "Polynomial", "PolynomialAlgebraicNumbers", "PolynomialModP", "SylvesterMatrix", "ConvertAlgebraicNumberToMatrix", "PrintAlgebraicClosureStatus", "AlgebraicNumberFromPolynomial", "PrincipalSlTwoIndex", "DynkinIndicesSlTwoSubalgebras", "CartanSymmetric", "GrowDynkinType", "IsDifferentialOneFormOneVariable", "Polynomialize", "IsAlgebraicRadical", "IsReal", "IsConstant", "\\sin", "\\cos", "Differentiate", "ElementWeylAlgebraDO", "ElementWeylAlgebraPoly", "MakeRationalFunction", "MakeMatrix", "MakeMatrixTensorForm", "MakeMatrixRFs", "FourierTransformDO", "MinPolyMatrix", "PrintRuleStack", "Crawl", "BuildFreecalc", "BuildFreecalcWithSlides", "BuildSlidesInTopicList", "EnsureExpressionDependsOnlyOn", "EnsureExpressionDependsMandatoryVariables", "EnsureExpressionDependsMandatoryVariablesIncludeNamedConstants", "\\arcsin", "\\arccos", "\\tan", "\\cot", "\\csc", "\\sec", "Floor", "Round", "DoubleValue", "ModP", "IsPrimeMillerRabin", "IsPossiblyPrime", "GCD", "LCM", "GCDPoly", "LCMPoly", "Interpolate", "PolyDivRemainder", "PolyDivQuotient", "PolyDivSlidesGrLex", "PolyDivStringGrLex", "PolyDivStringGrLexRev", "PolyDivStringLex", "PolyDivStringLexRev", "SuffixNotationForPostScript", "MakeJavascriptExpression", "DFQEuler", "NewtonsMethod", "FetchKnownPublicKeys", "PlotDirectionField", "PlotPolar", "PlotPolarExtended", "GaussianElimination", "UnivariatePartialFractionAlgrithm", "UnivariatePartialFractions", "EqualityToArithmeticExpression", "PointsImplicitly", "PlotImplicit", "PlotImplicitShowGrid", "PlotCoordinateSystem", "PlotSetProjectionScreen", "PlotSurface", "PlotCurve", "PlotSegment", "PlotMarkSegment", "PlotPath", "PlotSetId", "MatchesPattern", "GetVariablesExcludeNamedConstants", "GetVariablesIncludeNamedConstants", "PlotPoint", "Plot2D", "IsPlot", "PlotFill", "PlotRectangle", "PlotGrid", "PlotRemoveCoordinateAxes", "PlotLabel", "PlotViewRectangle", "PlotWindow", "Plot2DWithBars", "CompareFunctionsNumerically", "CompareExpressionsNumerically", "CompareExpressionsNumericallyAtPoints", "IsInteger", "IsEven", "IsSquareFree", "IsSquareFreePolynomial", "IsPower", "IsSquare", "IsNonEmptySequence", "IsRational", "not", "AllPartitions", "AllVectorPartitions", "AllSelectionsFixedRank", "KostkaNumber", "PrintNonNegativeVectorsLevel", "FunctionToMatrix", "Transpose", "\\det", "DeterminantPolynomial", "Length", "GetMultiplicandList", "NormalizeIntervals", "CompareIntervalsNumerically", "GetOpandList", "GetSummandList", "GetSummand", "GetFirstSummandContaining", "RemoveDuplicates", "Sort", "SortDescending", "BlocksOfCommutativity", "IsNilpotent", "InvertMatrixVerbose", "InvertMatrix", "Trace", "ReverseBytes", "Reverse", "ReverseRecursively", "SolveFor", "SolveJSON", "CompareExpressionsJSON", "FindOneSolutionSerreLikePolynomialSystem", "FindOneSolutionSerreLikePolynomialSystemUpperLimit", "FindOneSolutionSerreLikePolynomialSystemAlgebraic", "FindOneSolutionSerreLikePolynomialSystemAlgebraicUpperLimit", "GroebnerLexUpperLimit", "PolynomialRelationsUpperLimit", "GroebnerLexOppositeUpperLimit", "GroebnerGrLexUpperLimit", "FactorOutNumberContent", "FactorOneVarPolyOverRationals", "FactorUnivariatePolynomialOverRationals", "FactorPolynomialOverRationals", "FactorOneVariablePolynomialModPrime", "FactorInteger", "CoefficientsPowersOf", "ConstantTerm", "CoefficientOf", "IsLinearOrConstantIn", "IsProductLinearOrConstantTermsIn", "IsProductTermsUpToPower", "ScaleToLeadingUnit", "AugmentMatrixToTheRight", "AugmentMatrixBelow", "ElementEllipticCurveNormalForm", "Value", "\\setminus", "Differential", "Max", "Min", "Contains", "ExpressionLeafs", "Last", "RemoveLast", "SemisimpleLieAlgebra", "WriteSemisimpleLieAlgebra", "PrintSemisimpleLieAlgebra", "PrecomputeSemisimpleLieAlgebraStructure", "GetChevalleyGenerator", "GetCartanGenerator", "AdCommonEigenspace", "AttemptExtendingEtoHEFwithHinCartan", "PrintMacdonaldPolys", "CharPoly", "MakeCharacterLieAlg", "GetLinks", "ConesIntersection", "HeighestWeightVector", "PrintModule", "HighestWeightTAAbf", "WeylDimFormula", "AnimateLittelmannPaths", "DecomposeInducingRepGenVermaModule", "Casimir", "CasimirWRTLevi", "HmmG2inB3", "DrawRootSystem", "DrawWeightSupportWithMults", "DrawWeightSupport", "SplitFDpartB3overG2CharsOnly", "SplitFDpartB3overG2", "PrintB3G2branchingTableCharsOnly", "PrintB3G2branchingTable", "SplitFDTensorGenericGeneralizedVerma", "WriteGenVermaAsDiffOperatorsUpToWeightLevel", "MapSemisimpleLieAlgebraInWeylAlgebraGeneratorOrder", "MapSemisimpleLieAlgebraInWeylAlgebra", "MapSemisimpleLieAlgebraInWeylAlgebraAllGens", "KLcoeffs", "RootSubsystem", "PrintRootSubalgebras", "PrintRootSubalgebrasRecompute", "PrintSlTwoSubalgebras", "ParabolicsInfoBruhatGraph", "TestMonomialBasisConjecture", "LSpath", "LROdefine", "PrintProductDistancesModN", "SolveProductSumEquationOverSetModN", "ComputeFKFT", "ComputeSemisimpleSubalgebras", "CentralizerChains", "PrintSemisimpleSubalgebras", "PrintSemisimpleSubalgebrasRecompute", "PrintSemisimpleSubalgebrasNoCentralizers", "PrintSemisimpleSubalgebrasFull", "CanBeExtendedParabolicallyTo", "EmbedSemisimpleInSemisimple", "LoadSemisimpleSubalgebras", "SltwoSubalgebra", "Freudenthal", "Killing", "FreudenthalFull", "PerturbSplittingNormal", "TestSpechtModules", "MakeElementWeylGroup", "MakeElementHyperOctahedral", "WeylGroupClassicalSignMultiplicities", "WeylGroupTauSignatures", "WeylGroupConjugacyClassesFromAllElements", "WeylGroupOuterConjugacyClassesFromAllElements", "WeylGroupConjugacyClassesRepresentatives", "WeylGroupConjugacyClasses", "WeylGroupCharTable", "WeylGroupIrrepsAndCharTableComputeFromScratch", "WeylOrbitSize", "WeylOrbitSimpleCoords", "WeylGroupOrbitOuterSimple", "WeylOrbitFundCoords", "WeylOrbitFundRho", "WeylRaiseToMaximallyDominant", "MakeWeight", "MakeRho", "IsOuterAuto", "WeylOuterRaiseToMaximallyDominant", "GenerateFiniteMultiplicativelyClosedSet", "CartanSA", "GenerateVectorSpaceClosedWithRespectToLieBracket", "WeylGroupNaturalRep", "WeylGroupGetOuterAutoGenerators", "MakeVirtualWeylGroupRepresentation", "MongoFind", "orIdentical", "QuoteToString", "Factorial", "DefiniteIntegral", "IntegrateAfterPolynomialization", "IntegratePowerRule", "IntegrateEpowerX", "IntegratePullConstant", "IntegrateSqrtOneminusXsquared", "IntegrateSqrtXsquaredMinusOne", "IntegrateXpowerNePowerAx", "EulerFormula", "PowerImaginaryUnit", "TrigSumToTrigProduct", "SineOfAngleSum", "CosineOfAngleSum", "ExpressSinViaExponent", "ExpressCosViaExponent", "ExploitCosEvenness", "ExploitSinOddness", "IntegrateSinPowerNCosPowerM", "IntegrateTanPowerNSecPowerM", "IntegrateSum", "IntegratePullOutImaginaryUnit", "DifferentiateSqrt", "IntegrateBlockIa", "IntegrateBlockIb", "IntegrateBlockIIaIIIa", "IntegrateBlockIIIb", "IntegrateBlockIIb", "IntegratePartialFractions", "DifferentiateTrigAndInverseTrig", "DifferentiateChainRule", "DifferentiateProductRule", "DifferentiateQuotientRule", "DifferentiateSum", "DifferentiateConstant", "DifferentiateIdentity", "DifferentiateConstPower", "DifferentiateApowerB", "crossProduct", "LogBaseNaturalToLn", "LogBaseSimpleCases", "arcsinAlgebraic", "arccosAlgebraic", "AbsoluteValue", "Sine", "Cosine", "ExpressTanViaSineCosine", "ExpressCotViaSineCosine", "ExpressCscViaSine", "ExpressSecViaCosine", "DegreesToRadians", "Plot2DoverIntervals", "Determinant", "UnionUnionIntervals", "UnionIntervals", "UnionEmptySet", "IntersectUnion", "InersectEmptySet", "InersectIntervals", "sqrt", "MeltBrackets", "CheckAutoEquality", "AddStrings", "AddRationals", "AddRationalToElementZmodP", "AddElementZmodPToRational", "AddElementZmodPToElementZmodP", "AddPolynomialZmodPToPolynomialZmodP", "AddPolynomialZmodPToInteger", "AddPolynomialModPolynomialModPToPolynomialModPolynomialModP", "AddAlgebraicNumberToAlgebraicNumber", "AddAlgebraicNumberToRational", "AddRationalToAlgebraicNumber", "AddDoubleToRational", "AddPlots", "SortTerms", "AddTerms", "CommonDenominator", "CommonDenominatorSimple", "CommonDenominatorOneNonFraction", "AddElementTensorGeneralizedVermaModuleToElementTensorGeneralizedVermaModule", "AddRationalToPolynomial", "AddPolynomialToRational", "AddPolynomialToPolynomial", "AddPolynomialOverAlgebraicNumbersToPolynomialOverAlgebraicNumbers", "AddAlgebraicNumberToPolynomialOverAlgebraicNumbers", "AddPolynomialOverAlgebraicNumbersToAlgebraicNumber", "AddRationalToPolynomialAlgebraicNumbers", "AddPolynomialAlgebraicNumbersToRational", "AddPolynomialToAlgebraicNumber", "AddPolynomialToPolynomialAlgebraicNumbers", "AddPolynomialAlgebraicNumbersToPolynomial", "AddAlgebraicNumberToPolynomial", "AddRationalToElementWeylAlgebra", "AddPolynomialToElementWeylAlgebra", "AddElementWeylAlgebraToPolynomial", "AddElementWeylAlgebraToElementWeylAlgebra", "AddRationalFunctionToRationalFunction", "AddRationalToDouble", "AddDoubleToDouble", "AddWeightLieAlgebraPolynomialToWeightLieAlgebraPolynomial", "AddElementUniversalEnvelopingRationalFunctionCoefficientsToElementUniversalEnvelopingRationalFunctionCoefficients", "AddMatrices", "DirectSumMatrices", "MultiplyMatrixByMatrix", "MultiplySequenceByMatrix", "AddSequences", "AddMatrixTensorToMatrixTensor", "Minus", "InterpretAsDifferential", "IntegralOperatorFromProduct", "SumProductNotationToOperator", "SumProductNotationToOperatorRelativeToDivision", "LimitBoundaryNotationPower", "LimitBoundaryNotationUnderscore", "DifferentiateWithRespectToXTimeAny", "MultiplyElementHyperOctahedralByElementHyperOctahedral", "MultiplyRationalByElementZmodP", "MultiplyElementZmodPByElementZModP", "MultiplyAlgebraicNumberByAlgebraicNumber", "MultiplyRationalByAlgebraicNumber", "MultiplyRationals", "MultiplyRationalByDouble", "MultiplyDoubleByRational", "MultiplyDoubleByDouble", "MultiplyWeylGroupElementByWeylGroupElement", "MultiplyCharacterSemisimpleLieAlgebraModuleBy", "MultiplyRationalByElementWeylAlgebra", "MultiplyPolynomialByElementWeylAlgebra", "MultiplyElementWeylAlgebraByElementWeylAlgebra", "MultiplyElementWeylAlgebraByPolynomial", "MultiplyPolynomialByRational", "MultiplyRationalByPolynomial", "MultiplyPolynomialByPolynomial", "MultiplyPolynomialAlgebraicNumbersByPolynomialAlgebraicNumbers", "MultiplyPolynomialModPByPolynomialModP", "MultiplyPolynomialModPolynomialModPToPolynomialModPolynomialModP", "MultiplyPolynomialAlgebraicNumbersByAlgebraicNumber", "MultiplyAlgebraicNumberByPolynomialAlgebraicNumbers", "MultiplyRationalByPolynomialAlgebraicNumbers", "MultiplyPolynomialByAlgebraicNumber", "MultiplyAlgebraicNumberByPolynomial", "MultiplyMatrixTensorByMatrixTensor", "MultiplyRationalByMatrixTensor", "TensorAndDecomposeWeylGroupRepresentations", "CombineExponents", "MultiplyByOne", "CommuteConstants", "MergeConstantRadicals", "AssociativeRule", "CommuteAtimesBtimesCifUnivariate", "CommuteIfUnivariate", "ConstantExtraction", "AssociateTimesDivision", "CancelMultiplicativeInverse", "DistributeMultiplication", "DistributeMultiplicationConstants", "DivideAdivBpowerItimesBpowerJ", "MultiplyRationalByUE", "MultiplyUEByUE", "MultiplyRatOrPolyOrRFByRF", "MultiplyAnyByEltTensor", "MultiplyPolynomialByElementTensorGeneralVermaModule", "MultiplyEllipticCurveElementsRational", "MultiplyEllipticCurveElementsOverZmodP", "MultiplyAnyByTensor", "MultiplyElementUniversalEnvelopingRationalFunctionByElementTensorGeneralizedVermaModule", "ScalarTimesSequence", "ScalarTimesMatrix", "MultiplyDoubleBySequence", "MultiplyAlgebraicNumberBySequence", "MultiplyPolynomialBySequence", "MultiplyWeylGroupElementByWeightLieAlgebraPolynomial", "MultiplyPolynomialByWeightLieAlgebraPolynomial", "MultiplyRaitonalByWeightLieAlgebraPolynomial", "Binom", "moduloPolynomial", "DifferentialStandardHandler", "DifferentialOfPolynomial", "IntegralOperatorFromQuotient", "DivideElementZmodPByElementZModP", "LeibnizDifferentialOperatorToDifferentialOperator", "LeibnizDifferentialOperatorNotation", "DivideAlgebraicByAlgebraic", "DivideRationalByAlgebraic", "DivideAlgebraicByRational", "DivideByNumber", "DivideByNumberTrivial", "DivideZeroDivideByAnything", "DivideCancellations", "AssociateDivisionDivision", "AssociateAdividedByBdividedByCpowerD", "ConvertShortDenominatorToNegativePower", "DivideRationalByRational", "DivideRationalByDouble", "DivideDoubleByDouble", "DivideRationalByPolynomial", "DividePolynomialByPolynomial", "DividePolynomialModPByPolynomialModP", "DivideExpressionsAsIfPolynomial", "PowerIntegerByInteger", "PowerRationalByRational", "PowerRationalByRationalOutputAlgebraic", "PowerDoubleToDouble", "TransposePowerNotation", "PowerMatrixNumbersByInteger", "PowerMatrixNumbersByLargeIntegerIfPossible", "PowerMatrixNumbersBySmallIntegerIfPossible", "PowerElementZmodPToInteger", "PowerToLog", "PowerAnyToZero", "PowerPolynomialBySmallInteger", "PowerPolynomialAlgebraicNumbersBySmallInteger", "PowerPolynomialModuloIntegerBySmallInteger", "PowerPolynomialModPModuloPolynomialModPBySmallInteger", "PowerEllipticCurveElementRationalByInteger", "PowerEllipticCurveElementZmodPByInteger", "PowerAlgebraicNumberBySmallInteger", "RadicalAlgebraicNumberPositiveDefault", "PowerElementWeylAlgebraBySmallInteger", "PowerElementUniversalEnvelopingBySmallInteger", "PowerUEelementToPolyPower", "PowerUEelementToRFPower", "PowerFloatingToPower", "PowerPowerToPower", "DistributeExponent", "innerDistributeSqrt", "PowerToOne", "OperatorBoundsSuperscript", "OperatorBoundsUnderscore", "DereferenceSequenceOrMatrix", "DereferenceInterval", "DereferenceSequenceStatements", "MatrixTensorMatrix", "TensorElementGeneralizedVermaModuleByElementGeneralizedVermaModule", "LieBracketDistribute", "LieBracketConstants", "LieBracketWeylAlgebraElements", "LieBracketSemisimpleLieAlgebras", "LieBracketSwapTermsIfNeeded", "LieBracketJacobiIfNeeded", "TensorWeylGroupRepresentationByWeylGroupRepresentation", "TensorMatrixTensorByMatrixTensor", "TensorProductStandard", "standardIsDenotedBy", "LessThan", "GreaterThan", "greaterThanOrEqualTo", "lessThanOrEqualTo", "IsEqualTo", "IsEqualExpressionTree", "SumAsOperator", "MatrixTypeDeduction", "ConstantFunction", "RationalFunctionSubstitution", "CompositeArithmeticOperationEvaluatedOnArgumentAddition", "CompositeArithmeticOperationEvaluatedOnArgumentMultiplication", "CompositeArithmeticOperationEvaluatedOnArgumentDivision", "ConstantFunctionAlgebraicNumber", "EWAactOnPoly", "ConstTimesAnyAction", "ApowerBevaluatedAtC", "DifferentiateLog", "Variable", "Expression", "Integer", "infty", "infinity", "log", "sin", "cos", "tan", "cot", "csc", "sec", "arcsin", "arccos", "arctan", "SequenceStatements", "MakeSequence", "MatrixEnd", "array", "pmatrix", "NoFrac", "ShowContext", "NoLogarithmExponentShortcut", "LogParsing", "LogEvaluation", "HidePolynomialDataStructure", "NumberColors", "LogRules", "LogCache", "LogFull", "UseBracketForIntervals", "DontUsePredefinedWordSplits", "PlotShowJavascriptOnly", "PlotDetails", "UseLnInsteadOfLog", "UseLnAbsInsteadOfLog", "CalculatorStatus", "FullTree", "HideLHS", "EndProgram"];
module.exports = {theAutocompleteDictionary};
},
"/calculator-html/themes" : function(require, module, exports){
"use strict";
const ids = require("./ids_dom_elements");
const storage = require("./storage");

class Theme {
  constructor() {
    let themeIds = ids.domElements.themeRadioButtons;
    this.currentTheme = themeIds.radioThemeDefault;
    this.themes = {};
    this.themes[themeIds.radioThemeDefault] = {
      "--main-border-radius": "3px",
      "--main-background-color": "white",
      "--box-shadow-buttonSelectPage": "none",
      "--box-shadow-tableCalculatorOutputs": "none",
      "--box-shadow-buttonPreview": "none",
      "--box-shadow-buttonDefault": "none",
      "--box-shadow-buttonAnswer": "none",
      "--box-shadow-buttonMQ": "none",
    };
    this.themes[themeIds.radioThemeExperimental] = {
      "--main-border-radius": "0px",
      "--main-background-color": "white",
      "--box-shadow-buttonSelectPage": "5px 5px 5px grey",
      "--box-shadow-tableCalculatorOutputs": "none",
      "--box-shadow-buttonPreview": "5px 5px 5px grey",
      "--box-shadow-buttonDefault": "5px 5px 5px grey",
      "--box-shadow-buttonAnswer": "5px 5px 5px grey",
      "--box-shadow-buttonMQ": "3px 3px 3px grey",
    };
  }

  setFromRadioButton() {
    let value = null;
    for (let label in ids.domElements.themeRadioButtons) {
      let currentId = ids.domElements.themeRadioButtons[label];
      let currentElement = document.getElementById(currentId);
      if (currentElement.checked) {
        value = currentId;
      }
    }
    if (value === null) {
      return;
    }
    if (value === this.currentTheme) {
      return;
    }
    storage.storage.variables.theme.setAndStore(value);
  }

  doChangeTheme(themeId) {
    if (themeId === this.currentTheme) {
      return;
    }
    this.currentTheme = themeId;
    let currentSpec = this.themes[this.currentTheme];
    let root = document.documentElement;
    for (let label in currentSpec) {
      root.style.setProperty(label, currentSpec[label]);
    }
    document.getElementById(this.currentTheme).checked = true;
  }
}

let theme = new Theme();

module.exports = {
  theme,
};
},
"/calculator-html/autocomplete" : function(require, module, exports){
"use strict";
const ids = require("./ids_dom_elements");
var theAutocompleteDictionary = require("./autocomplete_keywords").theAutocompleteDictionary;

var minLengthAutocompleteTrigger = 2;
var DebugCounter = 0;
var AutocompleteIsInitialized = false;

var theAutocompleteDictionaryLowerCase;
var theAutocompleteDictionaryByKey;
var theText;
var theSuggestions;
var theSuggestionsHighlighted;
var theAutoComplete;
var theAutoCompleteHints;
var indexInAutocomplete;
var autocompleteDebugWindow;
var theLastWord;
var oldLastWord;
var lastWordStart;
var ignoreOninput;

function initializeAutocomplete() {
  if (AutocompleteIsInitialized) {
    return true;
  }
  if (theAutocompleteDictionary === undefined) {
    return false;
  }
  AutocompleteIsInitialized = true;
  theAutocompleteDictionaryLowerCase = new Array;
  theAutocompleteDictionaryByKey = new Array;
  theText = document.getElementById(ids.domElements.pages.calculator.inputMain);
  theSuggestions = new Array;
  theSuggestionsHighlighted = new Array;
  theAutoComplete = document.getElementById('idAutocompleteSpan');
  theAutoCompleteHints = document.getElementById('idAutocompleteHints');
  indexInAutocomplete = - 1;
  autocompleteDebugWindow = document.getElementById('idAutocompleteDebug');
  theLastWord = new String;
  ignoreOninput = false;
  DebugCounter = 0;
  //theAutoCompleteHints.style.visibility ="hidden";
  for (var i = 0; i < theAutocompleteDictionary.length; i++) {
    theAutocompleteDictionaryLowerCase.push(theAutocompleteDictionary[i].toLowerCase());
  }
  for (i = 0; i < theAutocompleteDictionary.length; i++) {
    theAutocompleteDictionaryByKey[theAutocompleteDictionary[i]] = 1;
  }
  return true;
}

//displayDictionary();
function displayDictionary() {
  var result;
  result = "";
  counter = 0;
  for (var i in theAutocompleteDictionaryByKey) {
    result += i + " " + theAutocompleteDictionaryByKey[i] + " <br />";
    counter++;
    if (counter >= 15) {
      result += "... displaying first 15 out of a total of " + Object.keys(theAutocompleteDictionaryByKey).length + " words in the dictionary.";
      break;
    }
  }
  autocompleteDebugWindow.innerHTML = result;
}

function isSeparator(theChar) {
  switch (theChar) {
    case '+':
    case ' ':
    case ',':
    case '(':
    case ')':
    case '%':
    case '\n':
    case '\r':
    case '\"':
    case '=':
      return true;
    default: return false;
  }
}

function getLastWord() {
  var theLastWordReversed;
  theLastWordReversed = "";
  var cursorPosition = theText.selectionEnd;
  lastWordStart = - 1;
  for (var i = cursorPosition - 1; i >= 0; i--) {
    if (isSeparator(theText.value[i])) {
      break;
    }
    theLastWordReversed += theText.value[i];
  }
  theLastWord = "";
  lastWordStart = i;
  for (i = theLastWordReversed.length - 1; i >= 0; i--) {
    theLastWord += theLastWordReversed[i];
  }
  for (i = cursorPosition; i < theText.value.length; i++) {
    if (isSeparator(theText.value[i])) {
      break;
    } else {
      theLastWord += theText.value[i];
    }
  }
  DebugCounter++;
  //  autocompleteDebugWindow.innerHTML= theLastWord+ "<br>cursorPosition ="+ cursorPosition + "<br>theText.selectionEnd =" +theText.selectionEnd+  "theText.selectionStart ="+theText.selectionStart + "<br>DebugCounter ="+DebugCounter;
}

function clearAutocompleteTab() {
  theAutoComplete.innerHTML = "";
  //  theAutoCompleteHints.style.visibility ="hidden";
  indexInAutocomplete = - 1;
  theSuggestions.length = 0;
  theSuggestionsHighlighted.length = 0;
}

function suggestWord() {
  if (!initializeAutocomplete()) {
    return;
  }
  getLastWord();
  if (oldLastWord === theLastWord) {
    return;
  }
  oldLastWord = theLastWord;
  theSuggestions.length = 0;
  theSuggestionsHighlighted.length = 0;
  if (theLastWord == "") {
    clearAutocompleteTab();
    return;
  }
  if (theLastWord.length < minLengthAutocompleteTrigger) {
    clearAutocompleteTab();
    return;
  }
  for (var i = 0; i < theAutocompleteDictionary.length; i++) {
    if (theLastWord == theAutocompleteDictionary[i]) {
      clearAutocompleteTab();
      return;
    }
    var lastWordLowerCase = theLastWord.toLowerCase();
    var startpos = theAutocompleteDictionaryLowerCase[i].indexOf(lastWordLowerCase);
    if (startpos === - 1) {
      continue;
    }
    var currentString = theAutocompleteDictionary[i].substr(0, startpos);
    currentString += "<b>" + theLastWord + "</b>" + theAutocompleteDictionary[i].substr(startpos + theLastWord.length);
    theSuggestions.push(theAutocompleteDictionary[i]);
    theSuggestionsHighlighted.push(currentString);
  }
  if (theSuggestions.length > 0)
    theAutoCompleteHints.style.visibility = "visible";
  indexInAutocomplete = 0;
  displaySuggestions();
}

function displaySuggestions() {
  theAutoComplete.innerHTML = "";
  if (theSuggestionsHighlighted.length > 0) {
    if (indexInAutocomplete < 0) {
      indexInAutocomplete = theSuggestionsHighlighted.length - 1;
    }
    if (indexInAutocomplete >= theSuggestionsHighlighted.length) {
      indexInAutocomplete = 0;
    }
  }
  for (var i = 0; i < theSuggestionsHighlighted.length; i++) {
    if (i === indexInAutocomplete) {
      theAutoComplete.innerHTML += "<span style ='background:silver'>" + theSuggestionsHighlighted[i] + "</span><br>";
    } else {
      theAutoComplete.innerHTML += theSuggestionsHighlighted[i] + "<br>";
    }
  }
  //theAutoComplete.innerHTML+="theindex: " + indexInAutocomplete;
}

function replaceLastWord() {
  if (theSuggestions.length <= 0) {
    return;
  }
  if (indexInAutocomplete < 0 || indexInAutocomplete >= theSuggestions.length) {
    return;
  }
  theText.value = theText.value.substring(0, lastWordStart + 1) + theSuggestions[indexInAutocomplete] +
    theText.value.substring(1 + lastWordStart + theLastWord.length);
  setCursorPosition(lastWordStart + theSuggestions[indexInAutocomplete].length + 1);
}

function arrowAction(event) {
  if (event.ctrlKey !== true) {
    return;
  }
  if (event.keyCode === 32) {//32-space bar, 13-enter key, 9-tab key
    replaceLastWord();
  }
  if (event.keyCode === 38) {//up arrow
    indexInAutocomplete--;
  } else if (event.keyCode === 40) {//down arrow
    indexInAutocomplete++;
  } else {
    return;
  }
  displaySuggestions();
  //  event.stopPropagation();
  event.preventDefault();
  //  event.cancelBubble = true;
}

function accountWordAtCursor(amount) {
  getLastWord();
  if (theLastWord === "" || theLastWord === null) {
    return;
  }
  theAutoComplete.textContent = theLastWord;
  if (typeof (theAutocompleteDictionary[theLastWord]) !== "number") {
    theAutocompleteDictionary[theLastWord] = amount;
  } else {
    theAutocompleteDictionary[theLastWord] += amount;
  }
  displayDictionary();
}

function setCursorPosition(caretPos) {
  if (theText.createTextRange) {
    var range = theText.createTextRange();
    range.move('character', caretPos);
    range.select();
  } else {
    if (theText.selectionStart) {
      theText.focus();
      theText.setSelectionRange(caretPos, caretPos);
    } else {
      theText.focus();
    }
  }
}

module.exports = {
  suggestWord,
  arrowAction,
};
},
"/calculator-html/panels" : function(require, module, exports){
/**
 * This file needs to function as stand-alone javascript
 * as well be used as a commonJS module included via
 * require('panels.js')).
 * Please don't require(...) any modules from this file.
 **/
"use strict";

var module;
if (module === undefined) {
  module = {};
}

function modifyHeightForTimeout(currentButtonPanel, newHeight) {
  currentButtonPanel.style.maxHeight = newHeight;
  currentButtonPanel.style.height = newHeight;
}

function toggleHeight(currentButton, currentPanelID) {
  let currentPanel = document.getElementById(currentPanelID);
  if (currentPanel === null) {
    return;
  }
  currentPanel.buttonThatModifiesMe = currentButton;
  if (currentPanel.startingMaxHeight === undefined || currentPanel.startingMaxHeight === null) {
    currentPanel.startingMaxHeight = window.getComputedStyle(currentPanel).height;
    currentPanel.style.maxHeight = currentPanel.startingMaxHeight;
    currentPanel.style.height = currentPanel.startingMaxHeight;
  }
  let currentContainer = currentPanel;
  while (true) {
    currentContainer = currentContainer.parentNode;
    //console.log("processing "+ currentContainer.tagName +"."+ currentContainer.className);
    if (!currentContainer.className.startsWith("body")) {
      break;
    }
    currentContainer.style.maxHeight = "";
    currentContainer.style.height = "";
    currentContainer.startingMaxHeight = null;
  }
  if (currentPanel.style.display === "none" || currentPanel.transitionState === "collapsed") {
    currentPanel.style.display = "";
  }
  if (currentPanel.transitionState === "collapsing" ||
    currentPanel.transitionState === "collapsed") {
    currentPanel.transitionState = "expanding";
    currentButton.innerHTML = "&#9660;";
  } else if (
    currentPanel.transitionState === null || currentPanel.transitionState === undefined ||
    currentPanel.transitionState === "expanding" || currentPanel.transitionState === "expanded"
  ) {
    currentPanel.transitionState = "collapsing";
    currentButton.innerHTML = "&#9656;";
  }
  currentPanel.addEventListener("transitionend", transitionDone);
  setTimeout(
    function () {
      toggleHeightForTimeout(currentPanel);
    }, 0
  );
}

function transitionDone(event) {
  this.removeEventListener("transitionend", transitionDone);
  if (this.transitionState === "collapsing") {
    this.style.display = "none";
    this.transitionState = "collapsed";
    window.frontend.thePage.storeOneCollapsiblePanelSettings(this, true);
  } else if (this.transitionState === "expanding") {
    this.style.display = "";
    this.transitionState = "expanded";
    window.frontend.thePage.storeOneCollapsiblePanelSettings(this, false);
  }
}

function toggleHeightForTimeout(currentPanel) {
  if (currentPanel.transitionState === "expanding") {
    currentPanel.style.maxHeight = currentPanel.startingMaxHeight;
    currentPanel.style.height = currentPanel.startingMaxHeight;
    currentPanel.style.opacity = "1";
  } else if (currentPanel.transitionState === "collapsing") {
    currentPanel.style.opacity = "0";
    currentPanel.style.maxHeight = "0px";
    currentPanel.style.height = "0px";
  }
}

let mainMenuIsHidden = false;
let mainMenuExpandedLength = null;
function toggleMenu() {
  let theMenuDiv = document.getElementById("divTheMainMenuPanel");
  let theToggleButton = document.getElementById("buttonToggleTheMainMenu");
  if (!mainMenuIsHidden) {
    if (mainMenuExpandedLength === null) {
      mainMenuExpandedLength = theMenuDiv.style.width;
    }
    for (let counterDiv = 3; counterDiv < theMenuDiv.childNodes.length; counterDiv++) {
      let currentNode = theMenuDiv.childNodes[counterDiv];
      if (currentNode.nodeName === "DIV" || currentNode.nodeName === "div") {
        currentNode.style.display = "none";
      }
    }
    theMenuDiv.classList.add("divMainMenuCollapsed");
    mainMenuIsHidden = true;
    theToggleButton.innerHTML = "&#9656;";
    document.getElementById("divProfilePicture").classList.add("divProfilePictureContainerCollapsed");
  } else {
    for (let counterDiv = 3; counterDiv < theMenuDiv.childNodes.length; counterDiv++) {
      let currentNode = theMenuDiv.childNodes[counterDiv];
      if (currentNode.nodeName === "DIV" || currentNode.nodeName === "div") {
        currentNode.style.display = "";
      }
    }
    theMenuDiv.classList.remove("divMainMenuCollapsed");
    mainMenuIsHidden = false;
    theToggleButton.innerHTML = "&#9660;";
    document.getElementById("divProfilePicture").classList.remove("divProfilePictureContainerCollapsed");
  }
}

function PanelExpandableData(
  /** @type {string} */
  content,
  /** @type {string} */
  id,
  /** @type {number} */
  minimalCharacterLengthForPanel,
  /** @type {boolean} */
  startHidden,
  /** @type {string} */
  label,
) {
  this.content = content;
  this.id = id;
  this.minimalCharacterLengthForPanel = minimalCharacterLengthForPanel;
  this.startHidden = startHidden;
  this.label = label;
  if (this.startHidden === undefined) {
    this.startHidden = false;
  }
  if (this.label === undefined) {
    this.label = "";
  }
}

class PanelExpandable {
  constructor(
    container,
  ) {
    this.attributes = {
      buttonId: null,
      panelId: null,
      expandedMarkerId: null,
      panelLabelId: null,
      panelStatus: null,
      originalHeight: "0px",
      originalWidth: "0px",
    }
    this.containerId = "";
    this.container = container;
    if (typeof container === "string") {
      this.containerId = container;
      this.container = document.getElementById(this.containerId);
    } else {
      this.containerId = this.container.id;
    }
  }

  matchPanelStatus() {
    let thePanel = document.getElementById(this.attributes.panelId);
    thePanel.style.maxHeight = "";
    thePanel.style.maxWidth = "";
    if (this.attributes.panelStatus === "collapsed") {
      thePanel.style.maxHeight = "0px";
      thePanel.style.maxWidth = "0px";
    } else {
      thePanel.style.maxHeight = this.attributes.originalHeight;
      thePanel.style.maxWidth = this.attributes.originalWidth;
    }
  }

  setPanelContent(input) {
    let thePanel = document.getElementById(this.attributes.panelId);
    thePanel.style.maxHeight = "";
    thePanel.style.maxWidth = "";
    thePanel.innerHTML = input;
    let originalHeight = window.getComputedStyle(thePanel).height;
    let originalWidth = window.getComputedStyle(thePanel).width;
    this.container.setAttribute("originalHeight", originalHeight);
    this.container.setAttribute("originalWidth", originalWidth);
  }

  setPanelLabel(input) {
    let panelLabel = document.getElementById(this.attributes.panelLabelId);
    panelLabel.innerHTML = input;
  }

  initialize(
    /** @type {boolean} */
    resetPanel,
  ) {
    if (this.container === null || this.container === undefined || this.container === "") {
      return this;
    }
    if (typeof this.container === "string") {
      this.container = document.getElementById(this.container);
    }
    this.containerId = this.container.id;
    if (resetPanel !== true) {
      for (let label in this.attributes) {
        let incoming = this.container.getAttribute(label);
        this.attributes[label] = incoming;
        if (incoming === null || incoming === undefined || incoming === undefined) {
          resetPanel = true;
          break;
        }
      }
    }
    if (resetPanel === true) {
      numberOfButtonToggleProgressReport++;
      for (let label in this.attributes) {
        this.attributes[label] = `progressReport${label}${numberOfButtonToggleProgressReport}`;
      }
      this.attributes.panelStatus = "collapsed";
      this.initializeProgressPanel();
    }
  }

  setStatusToBeCalledThroughTimeout() {
    let panel = document.getElementById(this.attributes.panelId);
    if (this.attributes.panelStatus === "expanded") {
      panel.style.maxHeight = this.attributes.originalHeight;
      panel.style.maxWidth = this.attributes.originalWidth;
    } else {
      panel.style.maxHeight = "0px";
      panel.style.maxWidth = "0px";
    }
  }

  doToggleContent() {
    if (this.attributes.panelStatus === "collapsed") {
      document.getElementById(this.attributes.expandedMarkerId).innerHTML = "&#9662;";
      this.attributes.panelStatus = "expanded";
    } else {
      document.getElementById(this.attributes.expandedMarkerId).innerHTML = "&#9666;";
      this.attributes.panelStatus = "collapsed";
    }
    this.container.setAttribute("panelStatus", this.attributes.panelStatus);
    setTimeout(this.setStatusToBeCalledThroughTimeout.bind(this), 0);
  }

  initializeProgressPanel() {
    for (let label in this.attributes) {
      this.container.setAttribute(label, this.attributes[label]);
    }
    let spanContainer = document.createElement("span");
    let spanContent = "";
    spanContent += `<span id = "${this.attributes.panelLabelId}"></span><button id = "${this.attributes.buttonId}" `;
    spanContent += `class = "buttonProgress accordionLikeIndividual" `;
    spanContent += `onclick = "window.calculator.panels.doToggleContent('${this.containerId}');">`;
    spanContent += `<span id = "${this.attributes.expandedMarkerId}">&#9666;</span>`;
    spanContent += "</button>";
    spanContent += `<div id = "${this.attributes.panelId}" class = "PanelExpandable"></div>`;
    spanContainer.innerHTML = spanContent;
    while (this.container.firstChild) {
      this.container.removeChild(this.container.firstChild);
    }
    this.container.appendChild(spanContainer);
  }
}

function makePanelFromData(
  /** @type {PanelExpandableData} */
  data,
) {
  let doCreatePanel = false;
  if (data.content.length > data.minimalCharacterLengthForPanel) {
    doCreatePanel = true;
  }
  if (doCreatePanel) {
    let inputPanel = new PanelExpandable(data.id);
    inputPanel.initialize(true);
    inputPanel.setPanelContent(data.content);
    inputPanel.setPanelLabel(data.label);
    if (!data.startHidden) {
      inputPanel.doToggleContent();
    }
    inputPanel.matchPanelStatus();
  } else {
    let element = document.getElementById(data.id);
    if (element != null) {
      element.innerHTML = data.content;
    }
  }
}

function doToggleContent(progressId) {
  let thePanel = new PanelExpandable(progressId);
  thePanel.initialize(false);
  thePanel.doToggleContent();
}

let numberOfButtonToggleProgressReport = 0;

if (window.calculator === undefined) {
  window.calculator = {};
}

if (window.calculator.panels === undefined) {
  window.calculator.panels = {};
}

if (window.calculator.panels.doToggleContent === undefined) {
  window.calculator.panels.doToggleContent = doToggleContent;
}

module.exports = {
  modifyHeightForTimeout,
  toggleMenu,
  doToggleContent,
  PanelExpandable,
  PanelExpandableData,
  makePanelFromData,
  toggleHeight
};
},
"/calculator-html/solve" : function(require, module, exports){
"use strict";
const ids = require("./ids_dom_elements");
const pathnames = require("./pathnames");
const submit = require("./submit_requests");
const calculator = require("./calculator_page");
const miscellaneous = require("./miscellaneous_frontend");
const equationEditor = require("./equation_editor");
const EquationEditor = require("./equation_editor").EquationEditor;
const storage = require("./storage").storage;
const InputPanelData = require("./initialize_buttons").InputPanelData;

class Solver {
  constructor() {
    /**@type{EquationEditor|null} */
    this.equationEditor = null;
    /**@type{InputPanelData|null} */
    this.panel = null;
    /**@type{string|null} */
    this.pendingTypeset = null;
    /**@type{HTMLElement} */
    this.debugDiv = document.getElementById(ids.domElements.pages.solve.editorSolveProblemDebug);
    /**@type{HTMLElement} */
    this.flagPendingSolutionTypeset = false;
    /**@type{HTMLElement} */
    this.solutionBox = document.getElementById(ids.domElements.pages.solve.solutionBox);
  }

  selectPage() {
    if (this.equationEditor !== null) {
      return;
    }
    this.panel = new InputPanelData({
      idEquationEditorElement: ids.domElements.pages.solve.editor,
      problemId: "",
      idButtonContainer: ids.domElements.pages.solve.editorButtonPanel,
      flagCalculatorPanel: true,
      buttonsPerLine: 8,
    });
    this.panel.initialize();

    this.equationEditor = this.panel.equationEditor;
    this.setDebugLogContainer();
    this.equationEditor.updateDOM();
    this.equationEditor.rootNode.focus(0);
    let solveButton = document.getElementById(ids.domElements.pages.solve.buttonSolve);
    solveButton.addEventListener("click", (e) => {
      this.solve();
    });
    this.processPendingTypeset();
  }

  setDebugLogContainer() {
    let doDebug = storage.variables.flagDebug.isTrue();
    if (doDebug) {
      this.debugDiv.style.display = "";
    } else {
      this.debugDiv.style.display = "none";
    }
    if (this.equationEditor === null) {
      return;
    }
    if (doDebug) {
      this.equationEditor.options.debugLogContainer = this.debugDiv;
    } else {
      this.equationEditor.options.debugLogContainer = null;
    }
  }

  processPendingTypeset() {
    if (storage.variables.currentPage.getValue() !== "solve") {
      return;
    }
    if (this.flagPendingSolutionTypeset) {
      this.flagPendingSolutionTypeset = false;
      equationEditor.typeset(this.solutionBox);
    }
    if (this.pendingTypeset === null) {
      return;
    }
    if (this.equationEditor === null) {
      return;
    }
    let input = this.pendingTypeset;
    this.pendingTypeset = null;
    if (input === "") {
      if (this.equationEditor.rootNode.toLatex() === "") {
        return;
      }
    }
    this.setDebugLogContainer();
    this.equationEditor.writeLatex(input);
  }

  setAutoSolveProblemBox(
    /**@type{string} */
    input,
  ) {
    this.pendingTypeset = input;
    this.processPendingTypeset();
  }

  solve() {
    let input = this.equationEditor.rootNode.toLatex();
    let inputCalculator = `SolveJSON(${input})`;
    document.getElementById(ids.domElements.pages.calculator.inputMain).value = inputCalculator;
    calculator.calculator.submitComputation();
    // Will trigger solveFromStorage; 
    // injection of the method happens in Page.initializeStorageCallbacks.
    storage.variables.solve.problemToAutoSolve.setAndStore(input, true, false);
  }

  solveFromStorage(
    /**@type{string} */
    input,
  ) {
    if (document.getElementById(ids.domElements.pages.solve.div) === null) {
      return;
    }
    let debug = storage.variables.flagDebug.isTrue();
    submit.submitGET({
      url: pathnames.addresses.solveJSON(input, debug),
      callback: (input) => {
        this.solveCallback(input);
      },
      progress: ids.domElements.spanProgressReportGeneral,
    });
  }

  solveCallback(
    /**@type{string} */
    input,
  ) {
    try {
      let solution = miscellaneous.jsonUnescapeParse(input);
      let steps = solution["solution"]["solution"][pathnames.urlFields.result.solution.steps];
      this.solutionBox.textContent = `${steps}`;
      this.flagPendingSolutionTypeset = true;
      this.processPendingTypeset();
    } catch (e) {
      this.solutionBox.innerHTML = `<b style='color:red'>${e}</b><br>${input}`;
    }
  }
}

const solver = new Solver();

function selectSolverPage() {
  solver.selectPage();
}

module.exports = {
  Solver,
  solver,
  selectSolverPage,
};

},
"/calculator-html/solve_socratic" : function(require, module, exports){
"use strict";
const ids = require("./ids_dom_elements");
const equationEditor = require("./equation_editor");
const EquationEditor = require("./equation_editor").EquationEditor;
const storage = require("./storage").storage;
const InputPanelData = require("./initialize_buttons").InputPanelData;

class SolverSocratic {
  constructor() {
    /**@type{EquationEditor|null} */
    this.equationEditor = null;
    /**@type{InputPanelData|null} */
    this.panel = null;
    /**@type{string|null} */
    this.pendingTypeset = null;
    /**@type{HTMLElement} */
    this.debugDiv = document.getElementById(ids.domElements.pages.solve.editorSolveProblemDebug);
    /**@type{HTMLElement} */
    this.flagPendingSolutionTypeset = false;
  }

  selectPage() {
    if (this.equationEditor !== null) {
      return;
    }
    this.panel = new InputPanelData({
      idEquationEditorElement: ids.domElements.pages.solve.editor,
      problemId: "",
      idButtonContainer: ids.domElements.pages.solve.editorButtonPanel,
      flagCalculatorPanel: true,
      buttonsPerLine: 8,
      valueChangeHandler: (text) => {
        this.valueChange(text);
      }
    });
    this.panel.initialize();
    this.equationEditor = this.panel.equationEditor;
    this.setDebugLogContainer();
    this.equationEditor.updateDOM();
    this.equationEditor.rootNode.focus(0);
    this.processPendingTypeset();
  }

  setDebugLogContainer() {
    let doDebug = storage.variables.flagDebug.isTrue();
    if (doDebug) {
      this.debugDiv.style.display = "";
    } else {
      this.debugDiv.style.display = "none";
    }
    if (this.equationEditor === null) {
      return;
    }
    if (doDebug) {
      this.equationEditor.options.debugLogContainer = this.debugDiv;
    } else {
      this.equationEditor.options.debugLogContainer = null;
    }
  }

  processPendingTypeset() {
    if (storage.variables.currentPage.getValue() !== "solveSocratic") {
      return;
    }
    if (this.flagPendingSolutionTypeset) {
      this.flagPendingSolutionTypeset = false;
      equationEditor.typeset(this.solutionBox);
    }
    if (this.pendingTypeset === null) {
      return;
    }
    if (this.equationEditor === null) {
      return;
    }
    let input = this.pendingTypeset;
    this.pendingTypeset = null;
    if (input === "") {
      if (this.equationEditor.rootNode.toLatex() === "") {
        return;
      }
    }
    this.setDebugLogContainer();
    this.equationEditor.writeLatex(input);
  }

  valueChange(
    /**@type{string} */
    text,
  ) {
    let anchor = document.getElementById(ids.domElements.pages.solveSocratic.link);
    anchor.textContent = text;
    let encoded = encodeURIComponent(text);
    anchor.setAttribute("href", `https://bloom-autopush.sandbox.google.com/math/solver?q=${encoded}`);
  }
}

const solver = new SolverSocratic();

module.exports = {
  solver,
};

},
"/calculator-html/initialize_buttons" : function(require, module, exports){
"use strict";
const submitRequests = require("./submit_requests");
const panels = require("./panels");
const pathnames = require("./pathnames");
const ids = require("./ids_dom_elements");
const miscellaneous = require("./miscellaneous_frontend");
const equation_editor = require("./equation_editor");
const storage = require("./storage");
const EquationEditorAction = require("./equation_editor").EquationEditorAction;
const EquationEditor = require("./equation_editor").EquationEditor;
const EquationEditorButtonFactory = require("./equation_editor").EquationEditorButtonFactory;
const EquationEditorOptions = require("./equation_editor").EquationEditorOptions;
const datePicker = require("./date_picker").datePicker;

let keyWordsKnownToMathQuill = [
  'sqrt',
  'frac',
  'cdot',
  'left',
  'right',
  'infty',
  'otimes',
  'times',
  'oplus',
  'pmatrix',
  'int',
  'begin',
  'end',
  'alpha',
  'pi',
  'beta',
  'cup',
  'cap',
];

let charsToSplit = ['x', 'y'];
let panelsCollapseStatus = {};
let calculatorSeparatorLeftDelimiters = {
  '(': true,
  '{': true
};

function processMathQuillLatex(theText) {
  for (let i = 0; i < theText.length; i++) {
    if (i + 1 < theText.length) {
      if ((theText[i] === '_' || theText[i] === '^') && theText[i + 1] !== '{') {
        theText = theText.slice(0, i + 1) + '{' + theText[i + 1] + '}' + theText.slice(i + 2);
      }
      if (theText[i] === '\\' && theText[i + 1] === '\\') {
        theText = theText.slice(0, i + 2) + ' ' + theText.slice(i + 2);
      }
    }
  }
  if (charsToSplit !== undefined) {
    for (let i = 0; i < theText.length - 1; i++) {
      for (let j = 0; j < charsToSplit.length; j++) {
        if (
          theText[i] === charsToSplit[j] && theText[i + 1] !== ' ' &&
          theText[i + 1] !== '\\' && theText[i + 1] !== '+' &&
          theText[i + 1] !== '*' && theText[i + 1] !== '/' &&
          theText[i + 1] !== '-' && theText[i + 1] !== '='
        ) {
          if (theText[i] === 'x') {
            if (theText.slice(i - 5, i + 1) === 'matrix') {
              continue;
            }
          }
          theText = theText.slice(0, i + 1) + " " + theText.slice(i + 1);
        }
      }
    }
  }
  return theText;
}

function accountCalculatorDelimiterReturnMustEndSelection(character, calculatorSeparatorCounts) {
  if (character in calculatorSeparatorLeftDelimiters) {
    calculatorSeparatorCounts.leftSeparators++;
  }
  if (character in calculatorSeparatorLeftDelimiters) {
    calculatorSeparatorCounts.rightSeparators++;
  }
  return calculatorSeparatorCounts.leftSeparators > calculatorSeparatorCounts.rightSeparators;
}

function initializeAccordionButtons() {
  ///initializing accordions
  if (localStorage !== undefined) {
    if (localStorage.panels !== undefined) {
      panelsCollapseStatus = JSON.parse(localStorage.panels)
      let theProps = Object.getOwnPropertyNames(panelsCollapseStatus);
      for (let i = 0; i < theProps.length; i++) {
        let current = panelsCollapseStatus[theProps[i]];
        if (current.isCollapsed) {
          panels.toggleHeight(document.getElementById(current.button), theProps[i]);
        }
      }
    }
  }
  let acc = document.getElementsByClassName("accordion");
  for (let i = 0; i < acc.length; i++) {
    acc[i].onclick = function () {
      if (this.firstLoad === undefined) {
        this.firstLoad = true;
        let theDeadlines = this.nextElementSibling.getElementsByClassName("modifyDeadlineInput");
        for (let j = 0; j < theDeadlines.length; j++) {
          datePicker.createDatePicker(theDeadlines[j].id);
        }
        this.nextElementSibling.style.display = "inline-block";
      }
      this.classList.toggle("active");
      this.nextElementSibling.classList.toggle("show");
    }
  }
}

function initializeButtons() {
  initializeAccordionButtons();
}

class ButtonCollection {
  constructor(
    /**@type {Object} */
    keywords
  ) {
    this.selected = false;
    this.keywords = keywords;
  }
  updateFlags(
    /** @type{Object.<string, string} */
    allFlags,
  ) {
    for (let keyword in this.keywords) {
      if (keyword in allFlags) {
        this.selected = true;
        return;
      }
    }
  }
}

class InputPanelData {
  constructor(input) {
    /** @type{string} Id of component where the editor is placed.*/
    this.idEquationEditorElement = input.idEquationEditorElement;
    if (this.idEquationEditorElement === "") {
      this.idEquationEditorElement = "";
    }
    /**@type{HTMLElement|null} */
    this.equationEditorContainer = null;
    if (input.equationEditorContainer !== undefined) {
      this.equationEditorContainer = input.equationEditorContainer;
    }
    this.idEditorComments = input.idEditorComments;
    if (this.idEditorComments === "") {
      this.idEditorComments = "";
    }
    this.problemId = input.problemId;
    if (this.problemId === "") {
      this.problemId = "";
    }
    this.idPureLatex = input.idPureLatex;
    /**@type{HTMLElement|null} */
    this.pureLatexElement = null;
    if (input.pureLatexElement !== undefined && input.pureLatexElement !== null) {
      this.pureLatexElement = input.pureLatexElement;
    }
    /**@type{EquationEditorButtonFactory[]} */
    this.buttonFactories = [];
    this.valueChangeHandler = null;
    if (input.valueChangeHandler !== undefined) {
      this.valueChangeHandler = input.valueChangeHandler;
    }
    this.buttonsPerLine = input.buttonsPerLine;
    if (this.buttonsPerLine === null || this.buttonsPerLine === undefined) {
      this.buttonsPerLine = 4;
    }
    this.flagRendered = false;

    this.requestedButtons = [];
    this.flagButtons = {
      noPreference: new ButtonCollection({}),
      all: new ButtonCollection({
        "all": true,
      }),
      none: new ButtonCollection({
        "none": true,
      }),
      trigonometry: new ButtonCollection({
        "trig": true,
        "trigonometry": true,
      }),
      algebra: new ButtonCollection({
        "algebra": true,
      }),
      inverseTrigonometry: new ButtonCollection({
        "inversetrig": true,
        "inverse_trig": true,
        "inverse-trig": true,
        "inversetrigonometry": true,
        "inverse_trigonometry": true,
        "inverse-trigonometry": true,
        "inverse trigonometry": true,
      }),
      comma: new ButtonCollection({
        "brackets": true,
        "comma": true,
        "commas": true,
        "intervals": true,
      }),
      logarithms: new ButtonCollection({
        "logarithms": true,
        "logarithm": true,
      }),
      brackets: new ButtonCollection({
        "brackets": true,
        "intervals": true,
      }),
      variables: new ButtonCollection({
        "variables": true,
      }),
      complex: new ButtonCollection({
        "complex": true,
        "imaginary": true,
      }),
      infinity: new ButtonCollection({
        "infinity": true,
        "infty": true,
        "\\infty": true,
        "interval": true,
        "intervals": true,
        "limits": true,
        "limit": true,
      }),
      limits: new ButtonCollection({
        "limits": true,
        "limit": true,
      }),
      series: new ButtonCollection({
        "sum": true,
        "series": true,
      }),
      angles: new ButtonCollection({
        "angle": true,
        "angles": true,
      }),
      newtonsMethod: new ButtonCollection({
        "newtonsmethod": true,
        "newton": true,
        "newton's method": true,
        "newtons method": true,
      }),
      logical: new ButtonCollection({
        "interval": true,
        "intervals": true,
        "or": true,
      }),
      setOperations: new ButtonCollection({
        "interval": true,
        "intervals": true,
      }),
      matrix: new ButtonCollection({
        "matrix": true,
        "matrices": true,
      }),
    };
    /**@type{HTMLElement|null} */
    this.buttonSubmitHardCoded = input.buttonSubmitHardCoded;
    if (this.buttonSubmitHardCoded === undefined) {
      this.buttonSubmitHardCoded = null;
    }
    /**@type{string} */
    this.idButtonContainer = input.idButtonContainer;
    /**@type{HTMLElement|null} */
    this.buttonContainer = input.buttonContainer;
    if (this.buttonContainer === undefined || this.buttonContainer === null) {
      this.buttonContainer = document.getElementById(this.idButtonContainer);
    }
    this.idButtonSubmit = input.idButtonSubmit;
    this.idButtonInterpret = input.idButtonInterpret;
    this.idButtonAnswer = input.idButtonAnswer;
    this.idButtonSolution = input.idButtonSolution;
    this.idVerificationSpan = input.idVerificationSpan;
    this.answerHighlight = input.answerHighlight;
    this.answerPanelId = input.answerPanelId;
    this.randomSeed = input.randomSeed;

    this.htmlPureLatex = "";
    this.htmlButtonContainer = "";
    this.htmlButtonSubmit = "";
    this.htmlButtonInterpret = ""
    this.htmlButtonAnswer = "";
    this.htmlButtonSolution = "";
    this.htmlVerificationSpan = "";
    this.htmlSolution = "";
    this.htmlAnswerHighlight = "";
    this.htmlMQFieldEnclosure = "";

    this.properties = input.properties;
    this.previousAnswers = input.previousAnswers;
    this.mathQuillPanelOptions = input.mathQuillPanelOptions;
    this.flagAnswerPanel = input.flagAnswerPanel;
    this.flagCalculatorPanel = input.flagCalculatorPanel;
    //just in case we forget some entry above:
    for (let key in input) {
      if (!(key in this)) {
        console.log("Missing key: " + key);
      }
    }
    /**@type{EquationEditor|null} */
    this.equationEditor = null;
    this.ignoreNextEditorEvent = false;
    this.flagAnswerPanel = input.flagAnswerPanel;
    this.flagInitialized = false;
    this.flagCalculatorPanel = input.flagCalculatorPanel;
    this.flagCalculatorMQStringIsOK = true;
    this.flagGenerateQuestionAndAnswerField = true;
    this.calculatorLeftString = "";
    this.calculatorRightString = "";
    this.theLaTeXString = null;
    this.selectionEnd = 0;
    this.javascriptInsertionAlreadyCalled = false;
    this.timerForPreviewAnswers = 0;

    if (this.flagCalculatorPanel === undefined) {
      this.flagCalculatorPanel = false;
    }
    if (this.idEditorComments === undefined) {
      this.idEditorComments = null;
    }
  }

  /**@returns{HTMLElement|null} */
  getButtonContainer() {
    if (this.buttonContainer !== null) {
      return this.buttonContainer;
    }
    this.buttonContainer = document.getElementById(this.idButtonContainer);
    return this.buttonContainer;
  }

  /**@returns{HTMLElement|null} */
  getEditorContainer() {
    if (this.equationEditorContainer !== null && this.equationEditorContainer !== undefined) {
      return this.equationEditorContainer;
    }
    this.equationEditorContainer = document.getElementById(this.idEquationEditorElement);
    return this.equationEditorContainer;
  }

  /**@returns{HTMLElement|null} */
  getPureLatexElement() {
    if (this.pureLatexElement !== null && this.pureLatexElement !== undefined) {
      return this.pureLatexElement;
    }
    this.pureLatexElement = document.getElementById(this.idPureLatex);
    return this.pureLatexElement;
  }

  editLaTeX() {
    // useful event handlers	
    this.ignoreNextEditorEvent = true;
    this.equationEditor.writeLatex(document.getElementById(this.idPureLatex).value + ' ');
    this.ignoreNextEditorEvent = false;
    this.submitPreviewWithTimeOut();
  }

  editorHelpCalculator() {
    this.getSemiColumnEnclosure();
    if (this.equationEditor === null) {
      return;
    }
    this.ignoreNextEditorEvent = true;
    if (this.flagCalculatorMQStringIsOK) {
      this.equationEditor.writeLatex(this.theLaTeXString);
    }
    this.ignoreNextEditorEvent = false;
  }

  editLatexHook(
    /**@type{EquationEditor} */
    editor,
    /**@type{equation_editor.MathNode} */
    unusedNode,
  ) {
    if (this.ignoreNextEditorEvent) {
      return;
    }
    if (this.valueChangeHandler !== null) {
      this.valueChangeHandler(editor.rootNode.toLatex());
    }
  }

  initialize() {
    if (this.flagInitialized) {
      return;
    }
    let currentMQspan = this.getEditorContainer();
    let latexInput = null;
    if (!this.flagCalculatorPanel && !this.flagAnswerPanel) {
      latexInput = this.getPureLatexElement();
    }
    this.equationEditor = new EquationEditor(currentMQspan, new EquationEditorOptions({
      latexInput: latexInput,
      editHandler: (editor, node) => {
        this.editLatexHook(editor, node);
      },
    }));
    let forceShowAll = false;
    let forceShowNone = false;
    if (this.idEquationEditorElement === ids.domElements.pages.solve.editor) {
      forceShowAll = storage.storage.variables.solve.panel.forceShowAll.isTrue();
      forceShowNone = storage.storage.variables.solve.panel.forceShowNone.isTrue();
    }
    this.initializePartTwo(forceShowAll, forceShowNone);
    this.renderIfVisible();
  }

  renderIfVisible() {
    if (this.flagRendered) {
      return;
    }
    if (this.equationEditor.container.offsetParent === null || this.equationEditor.container.offsetParent === undefined) {
      return;
    }
    this.flagRendered = true;
    this.equationEditor.updateDOM();
    this.equationEditor.updateAlignment();
  }

  chopStrings(
    /**@type{number} */
    calculatorLeftPosition,
    /**@type{number} */
    calculatorRightPosition,
  ) {
    let mqCommentsSpan = document.getElementById(this.idEditorComments);
    if (calculatorRightPosition - calculatorLeftPosition > 1000) {
      this.flagCalculatorMQStringIsOK = false;
      mqCommentsSpan.innerHTML = "<span style ='color:red'><b>Formula too big </b></span>";
      return;
    }
    this.flagCalculatorMQStringIsOK = true;
    mqCommentsSpan.innerHTML = "Equation assistant";
    this.getEditorContainer().style.visibility = "visible";
    let calculatorInput = this.getPureLatexElement();
    this.theLaTeXString = calculatorInput.value.substring(calculatorLeftPosition, calculatorRightPosition + 1);
    this.calculatorLeftString = calculatorInput.value.substring(0, calculatorLeftPosition);
    this.calculatorRightString = calculatorInput.value.substring(calculatorRightPosition + 1);
  }

  getSemiColumnEnclosure() {
    let startPos = this.selectionEnd;
    let calculatorInput = this.getPureLatexElement();
    for (; startPos > 0 && startPos < calculatorInput.value.length; startPos--) {
      if (isSeparatorCharacter(calculatorInput.value[startPos])) {
        break;
      }
    }
    if (startPos >= calculatorInput.value.length) {
      startPos = calculatorInput.value.length - 1;
    }
    let rightPos = startPos;
    let lastSeparator = startPos;
    let lastWord = '';
    let currentChar = 'a';
    for (; rightPos < calculatorInput.value.length - 1; rightPos++) {
      currentChar = calculatorInput.value[rightPos];
      if (currentChar === ';') {
        if (rightPos > 0) {
          rightPos--;
        }
        break;
      }
      if (isSeparatorCharacter(currentChar)) {
        lastWord = '';
        lastSeparator = rightPos;
      } else {
        lastWord += currentChar;
      }
      if (lastWord.length > 3) {
        if (!isKeyWordStartKnownToMathQuill(lastWord)) {
          rightPos = lastSeparator;
          break;
        }
      }
    }
    let calculatorSeparatorCounts = {
      leftSeparators: 0,
      rightSeparators: 0
    };
    let leftPos = rightPos - 1;
    lastWord = '';
    lastSeparator = rightPos;
    for (; leftPos > 0; leftPos--) {
      currentChar = calculatorInput.value[leftPos];
      if (currentChar === ';') {
        leftPos++;
        break;
      }
      if (accountCalculatorDelimiterReturnMustEndSelection(calculatorInput.value[leftPos], calculatorSeparatorCounts)) {
        leftPos++;
        break;
      }
      if (isSeparatorCharacter(currentChar)) {
        lastWord = '';
        lastSeparator = leftPos;
      } else {
        lastWord = currentChar + lastWord;
      }
      if (lastWord.length > 3) {
        if (!isKeyWordEndKnownToMathQuill(lastWord)) {
          leftPos = lastSeparator;
          break;
        }
      }
    }
    if (leftPos > rightPos) {
      leftPos = rightPos;
    }
    if (rightPos - leftPos > 1000) {
      mqProblemSpan.innerHTML = "<span style ='color:red'><b></b></span>"
    }
    let startingCharacterSectionUnderMathQuillEdit = '';
    if (calculatorInput.value[leftPos] === '\n' || calculatorInput.value[leftPos] === ' ' ||
      calculatorInput.value[leftPos] === '\t') {
      startingCharacterSectionUnderMathQuillEdit = calculatorInput.value[leftPos];
    }
    this.chopStrings(leftPos, rightPos);
  }

  computeFlags(
    /**@type {boolean} */
    forceShowAll,
  ) {
    let currentButtonPanel = this.getButtonContainer();
    let buttonsNonSplit = currentButtonPanel.getAttribute("buttons");
    if (buttonsNonSplit === null) {
      buttonsNonSplit = "";
    }
    let buttonArray = buttonsNonSplit.split(/(?:,| ) +/);
    this.flagButtons.noPreference.selected = false;
    this.flagButtons.all.selected = false;
    if (forceShowAll) {
      this.flagButtons.all.selected = true;
    }
    let allFlags = {};
    for (let i = 0; i < buttonArray.length; i++) {
      allFlags[buttonArray[i].toLowerCase()] = true;
    }
    if (buttonArray.length === 0) {
      this.flagButtons.noPreference.selected = true;
    }
    if (buttonArray.length === 1 && "" in allFlags) {
      this.flagButtons.noPreference.selected = true;
    }
    for (let key in this.flagButtons) {
      let flag = this.flagButtons[key];
      flag.updateFlags(allFlags);
    }
  }

  addLatexCommand(
    /**@type{string} */
    command,
    /**@type{string} */
    label,
    /**@type{string} */
    additionalStyle,
  ) {
    let buttonFactory = new EquationEditorButtonFactory(
      command, false, label, additionalStyle,
    );
    this.buttonFactories.push(buttonFactory);
  }

  addKeySequence(
    /**@type{string[]} */
    keys,
    /**@type{string} */
    label,
    /**@type{string} */
    additionalStyle,
  ) {
    let buttonFactory = new EquationEditorButtonFactory(
      "", true, label, additionalStyle,
    );
    for (let i = 0; i < keys.length; i++) {
      buttonFactory.addEditorAction(new EquationEditorAction(keys[i], true));
    }
    this.buttonFactories.push(buttonFactory);
  }

  addButtons(
    /**@type{boolean} */
    forceShowAll,
    /**@type{boolean} */
    forceShowNone,
  ) {
    this.buttonFactories = [];
    if (forceShowNone) {
      return;
    }
    let noOptions = this.flagButtons.noPreference.selected;
    let includeAll = this.flagButtons.all.selected || forceShowAll;
    if (this.flagButtons.algebra.selected || noOptions || includeAll) {
      this.addLatexCommand("+", "+");
      this.addLatexCommand("-", "-");
      this.addLatexCommand("\\cdot", "*");
      this.addLatexCommand("\\frac{\\caret}{}", "/");
      this.addKeySequence(["/"], "(\u2022)/(\u2022)", "font-size:10px"); // \u2022 = bullet.
      this.addLatexCommand("\\sqrt{\\caret}", "\u221A");
      this.addKeySequence(["^"], "^");
      this.addKeySequence(["("], "(");
      this.addKeySequence([")"], ")");
    }
    if (this.flagButtons.trigonometry.selected || includeAll) {
      this.addLatexCommand("\\sin", "sin", "font-size:10px; ");
      this.addLatexCommand("\\cos", "cos", "font-size:10px; ");
      this.addLatexCommand("\\tan", "tan", "font-size:10px; ");
      this.addLatexCommand("\\cot", "cot", "font-size:10px; ");
      this.addLatexCommand("\\sec", "sec", "font-size:10px; ");
      this.addLatexCommand("\\csc", "csc", "font-size:10px; ");
    }
    if (this.flagButtons.inverseTrigonometry.selected || includeAll) {
      this.addLatexCommand("\\arcsin", "asin", "font-size:7px");
      this.addLatexCommand("\\arccos", "acos", "font-size:7px");
      this.addLatexCommand("\\arctan", "atan", "font-size:7px");
    }
    if (this.flagButtons.comma.selected || includeAll) {
      this.addLatexCommand(",", ",");
    }
    if (this.flagButtons.brackets.selected || includeAll) {
      this.addKeySequence(["["], "[");
      this.addKeySequence(["]"], "]");
    }
    if (this.flagButtons.complex.selected || includeAll) {
      this.addLatexCommand("i", "i");
    }
    if (this.flagButtons.variables.selected || includeAll) {
      this.addLatexCommand("x", "x");
      this.addLatexCommand("y", "y");
      this.addLatexCommand("=", "=");
    }
    if (this.flagButtons.logarithms.selected || noOptions || includeAll) {
      this.addLatexCommand("\\log_{} ", "log_", "font-size:10px; ");
      this.addLatexCommand("{}_{}", "_");
      this.addLatexCommand("\\ln", "ln");
      this.addLatexCommand("e", "e");
    }
    if (this.flagButtons.infinity.selected || includeAll || noOptions) {
      this.addLatexCommand("\\infty", "\u221E");
    }
    if (this.flagButtons.limits.selected || includeAll) {
      this.addLatexCommand(" DNE ", "DNE", "font-size: 7px");
    }
    if (this.flagButtons.series.selected || noOptions || includeAll) {
      this.addLatexCommand("\\sum", "\u03A3");
      this.addLatexCommand("!", "!");
      this.addLatexCommand("\\binom{\\caret}{}", "binom", "font-size : 7px;");
    }
    if (noOptions || includeAll) {
      this.addLatexCommand("\\circ", "\u2218");
    }
    if (this.flagButtons.logical.selected || noOptions || includeAll) {
      this.addLatexCommand(" or ", "or");
    }
    if (this.flagButtons.setOperations.selected || noOptions || includeAll) {
      this.addLatexCommand("\\emptyset", "\u2205");
      this.addLatexCommand("\\cup", "\u222A");
      this.addLatexCommand("\\in", "\u2208");
    }
    if (this.flagButtons.matrix.selected || includeAll) {
      this.addLatexCommand("\\begin{pmatrix} \\\\ \\end{pmatrix}", "2x1", "font-size : 7px;", true);
      this.addLatexCommand("\\begin{pmatrix} \\\\ \\\\ \\end{pmatrix}", "3x1", "font-size : 7px;", true);
      this.addLatexCommand("\\begin{pmatrix} & \\\\ & \\end{pmatrix}", "2x2", "font-size : 7px;", true);
      this.addLatexCommand("\\begin{pmatrix} & & \\\\ & & \\\\ & & \\end{pmatrix}", "3x3", "font-size : 7px;", true);
    }
    if (this.flagButtons.angles.selected || noOptions || includeAll) {
      this.addLatexCommand("\\alpha", "\u03B1");
      this.addLatexCommand("\\beta", "\u03B2");
      this.addLatexCommand("\\gamma", "\u03B3");
      this.addLatexCommand("\\theta", "\u03B8");
      this.addLatexCommand("\\pi", "\u03C0");
      this.addKeySequence(["^", "\\circ"], "^\u2218");
    }
    if (this.flagButtons.newtonsMethod.selected || includeAll) {
      this.addLatexCommand(["NewtonsMethod(\\caret,,)"], "Newton", "font-size: 6px", false);
    }
  }

  initializePartTwo(
    /**@type{boolean} */
    forceShowAll,
    /**@type{boolean} */
    forceShowNone,
  ) {
    if (this.idEquationEditorElement === ids.domElements.pages.solve.editor) {
      storage.storage.variables.solve.panel.forceShowAll.setAndStore(forceShowAll);
      storage.storage.variables.solve.panel.forceShowNone.setAndStore(forceShowNone);
    }
    this.computeFlags(forceShowAll);
    this.addButtons(forceShowAll, forceShowNone);
    let currentButtonPanel = this.getButtonContainer();
    /** @type{HTMLTableElement} */
    let table = document.createElement("TABLE");
    table.style.margin = "auto";
    let currentRow = null;
    for (let j = 0; j < this.buttonFactories.length; j++) {
      if (j % this.buttonsPerLine === 0) {
        currentRow = table.insertRow();
      }
      let cell = currentRow.insertCell();
      let button = this.buttonFactories[j].getButton(this.equationEditor);
      button.className = "buttonMQ";
      cell.appendChild(button);
    }
    let toggles = [];
    if (!forceShowAll) {
      toggles.push(this.getShowAllToggle());
    }
    if (forceShowNone || forceShowAll) {
      toggles.push(this.getShowDefaultToggle());
    }
    if (!forceShowNone && !this.flagButtons.none.selected) {
      toggles.push(this.getShowNoneToggle());
    }
    let oldHeight = window.getComputedStyle(currentButtonPanel).height;
    currentButtonPanel.style.maxHeight = "";
    currentButtonPanel.style.height = "";
    currentButtonPanel.innerHTML = "";
    currentButtonPanel.appendChild(table);
    for (let i = 0; i < toggles.length; i++) {
      currentButtonPanel.appendChild(toggles[i]);
    }
    if (oldHeight !== 0 && oldHeight !== "0px") {
      let newHeight = window.getComputedStyle(currentButtonPanel).height;
      currentButtonPanel.style.maxHeight = oldHeight;
      currentButtonPanel.style.height = oldHeight;
      setTimeout(function () {
        panels.modifyHeightForTimeout(currentButtonPanel, newHeight)
      }, 0);
    }
    return false;
  }

  /**@returns{HTMLButtonElement} */
  getShowAllToggle() {
    let toggle = document.createElement("button");
    toggle.addEventListener(
      'click',
      () => {
        this.initializePartTwo(true, false);
      }
    );
    toggle.className = "buttonShowExpandMQPanel";
    toggle.style.fontSize = "x-small";
    toggle.textContent = "all";
    return toggle;
  }

  /**@returns{HTMLButtonElement} */
  getShowNoneToggle() {
    let toggle = document.createElement("button");
    toggle.addEventListener(
      'click',
      () => {
        this.initializePartTwo(false, true);
      }
    );
    toggle.className = "buttonShowExpandMQPanel";
    toggle.style.fontSize = "x-small";
    toggle.textContent = "none";
    return toggle;
  }

  /**@returns{HTMLButtonElement} */
  getShowDefaultToggle() {
    let toggle = document.createElement("button");
    toggle.addEventListener(
      'click',
      () => {
        this.initializePartTwo(false, false);
      }
    );
    toggle.className = "buttonShowExpandMQPanel";
    toggle.style.fontSize = "x-small";
    toggle.textContent = "default";
    return toggle;
  }
}

function isSeparatorCharacter(theChar) {
  if (theChar[0] >= 'a' && theChar[0] <= 'z') {
    return false;
  }
  if (theChar[0] >= 'A' && theChar[0] <= 'Z') {
    return false;
  }
  return true;
}

function isKeyWordStartKnownToMathQuill(input) {
  for (let i = 0; i < keyWordsKnownToMathQuill.length; i++) {
    if (keyWordsKnownToMathQuill[i].startsWith(input)) {
      return true;
    }
  }
  return false;
}

function isKeyWordEndKnownToMathQuill(input) {
  for (let i = 0; i < keyWordsKnownToMathQuill.length; i++) {
    if (keyWordsKnownToMathQuill[i].endsWith(input)) {
      return true;
    }
  }
  return false;
}

module.exports = {
  initializeAccordionButtons,
  initializeButtons,
  InputPanelData,
  processMathQuillLatex,
};
},
"/calculator-html/storage" : function(require, module, exports){
"use strict";
const ids = require("./ids_dom_elements");
const cookies = require("./cookies");
const configuration = require("./configuration");

class StorageVariable {
  constructor(
    /**@type @{{name: string, nameURL: string, nameCookie: string, nameLocalStorage: string, associatedDOMId: string, type: string, secure: string, showInURLByDefault: bool, showInURLOnPages: Object, callbackOnValueChange: function}} */
    inputs
  ) {
    this.value = "";
    this.name = inputs.name;
    this.nameURL = "";
    this.nameCookie = "";
    this.nameLocalStorage = "";
    this.associatedDOMId = "";
    this.type = "string";
    this.secure = true;
    this.showInURLByDefault = false;
    /**@type {Function|null} */
    this.callbackOnValueChange = null;
    /**@type {Function|null} */
    this.callbackSetValueFromStorage = null;
    let labelsToRead = [
      "nameURL",
      "nameCookie",
      "nameLocalStorage",
      "associatedDOMId",
      "type",
      "secure",
      "callbackOnValueChange",
      "showInURLByDefault",
      "showInURLOnPages",
    ];
    for (let counterLabel = 0; counterLabel < labelsToRead.length; counterLabel++) {
      let currentLabel = labelsToRead[counterLabel];
      let incoming = inputs[currentLabel];
      if (incoming !== "" && incoming !== null && incoming !== undefined) {
        this[currentLabel] = incoming;
      }
    }
  }

  /**@returns {boolean}  */
  isTrue() {
    if (this.value === "true" || this.value === true) {
      return true;
    }
    return false;
  }

  getValue() {
    return this.value;
  }

  /**@returns{string} */
  loadMe(hashParsed) {
    let candidate = "";
    if (Storage !== undefined || localStorage !== undefined && this.nameLocalStorage !== "") {
      let incoming = localStorage.getItem(this.nameLocalStorage);
      if (incoming !== "" && incoming !== null && incoming !== undefined) {
        candidate = incoming;
      }
    }
    if (this.nameCookie !== "") {
      let incoming = cookies.getCookie(this.nameCookie);
      if (incoming !== "" && incoming !== null && incoming !== undefined) {
        candidate = incoming;
      }
    }
    if (hashParsed !== null && hashParsed !== undefined) {
      if (this.nameURL !== "") {
        if (this.nameURL in hashParsed) {
          let incoming = hashParsed[this.nameURL];
          if (incoming !== null && incoming !== undefined) {
            candidate = incoming;
          }
        }
      }
    }
    this.setAndStore(candidate, false, true);
    return candidate;
  }

  storeMePersistent(
    /**@type {boolean} */
    updateURL,
  ) {
    if (Storage !== undefined || localStorage !== undefined) {
      if (this.nameLocalStorage !== "" && this.nameLocalStorage !== null && this.nameLocalStorage !== undefined) {
        localStorage[this.nameLocalStorage] = this.value;
      }
    }
    if (this.nameCookie !== "") {
      cookies.setCookie(this.nameCookie, this.value, 150, this.secure);
    }
    if (updateURL !== false) {
      storage.setURL();
    }
  }

  storeMe(
    /**@type {boolean} */
    updateURL,
    /**@type {boolean} */
    updateAssociatedInput,
  ) {
    this.storeMePersistent(updateURL);
    if (updateAssociatedInput !== true) {
      return;
    }
    if (this.associatedDOMId !== null && this.associatedDOMId !== undefined && this.associatedDOMId !== "") {
      let element = document.getElementById(this.associatedDOMId);
      if (element !== null) {
        element.value = this.value;
      }
    }
    if (this.callbackSetValueFromStorage !== null) {
      this.callbackSetValueFromStorage(this.value);
    }
  }

  setAndStore(
    newValue,
    /**@type {boolean} */
    updateURL,
    /**@type {boolean} */
    updateAssociatedInput,
  ) {
    if (updateURL === undefined) {
      updateURL = true;
    }
    let changed = (this.value !== newValue);
    this.value = newValue;
    if (!configuration.configuration.calculatorDefaultsEnabled) {
      return;
    }
    this.storeMe(updateURL, updateAssociatedInput);
    if (!changed) {
      return;
    }
    if (this.callbackOnValueChange === null || this.callbackOnValueChange === undefined) {
      return;
    }
    // Calling function with timeout ensures the current function sequence is finished first.
    setTimeout(() => {
      this.callbackOnValueChange(this.value);
    }, 0);
  }
}

class StorageCalculator {
  constructor() {
    let pageNamesOnWhichToShowProblemURLs = {
      selectCourse: true,
      currentCourse: true,
      problemPage: true,
      editPage: true,
    };
    this.variables = {
      currentPage: new StorageVariable({
        name: "currentPage",
        nameLocalStorage: "currentPage", //<- when given and non-empty, local storage will be used to store variable
        nameCookie: "", //<- when given and non-empty, cookies will be used to store variable
        nameURL: "currentPage", //<- when given and non-empty, url will be used to store variable
        showInURLByDefault: true, // <- when given and true, url will be added to the window hash
      }),
      database: {
        labels: new StorageVariable({
          name: "databaseLabels",
          nameLocalStorage: "databaseLabels"
        }),
      },
      editor: {
        currentlyEditedPage: new StorageVariable({
          name: "currentlyEditedPage",
          nameLocalStorage: "currentlyEditedPage"
        }),
      },
      solve: {
        problemToAutoSolve: new StorageVariable({
          name: "problemToAutoSolve",
          nameURL: "problemToAutoSolve",
          nameLocalStorage: "problemToAutoSolve",
        }),
        panel: {
          forceShowAll: new StorageVariable({
            name: "solvePanelForceShowAll",
            nameLocalStorage: "solvePanelForceShowAll",
          }),
          forceShowNone: new StorageVariable({
            name: "solvePanelForceShowNone",
            nameLocalStorage: "solvePanelForceShowNone",
          }),
        },
      },
      compare: {
        given: new StorageVariable({
          name: "given",
          nameURL: "compareGivenExpression",
          nameLocalStorage: "compareGivenExpression",
          showInURLOnPages: { "compareExpressions": true },
        }),
        desired: new StorageVariable({
          name: "desired",
          nameURL: "compareDesiredExpression",
          nameLocalStorage: "compareDesiredExpression",
          showInURLOnPages: { "compareExpressions": true },
        }),
      },
      currentSectionComputed: new StorageVariable({
        name: "currentSectionComputed",
        nameLocalStorage: "currentSectionComputed"
      }),
      currentCourse: {
        courseHome: new StorageVariable({
          name: "courseHome",
          nameCookie: "courseHome",
          nameURL: "courseHome",
          showInURLOnPages: pageNamesOnWhichToShowProblemURLs,
        }),
        topicList: new StorageVariable({
          name: "topicList",
          nameCookie: "topicList",
          nameURL: "topicList",
          showInURLOnPages: pageNamesOnWhichToShowProblemURLs,
        }),
        fileName: new StorageVariable({
          name: "fileName",
          nameCookie: "fileName",
          nameURL: "fileName",
          showInURLOnPages: pageNamesOnWhichToShowProblemURLs,
        }),
        problemFileName: new StorageVariable({
          name: "problemFileName",
          nameCookie: "problemFileName",
          nameURL: "problemFileName",
          showInURLOnPages: pageNamesOnWhichToShowProblemURLs,
        }),
        exerciseType: new StorageVariable({
          name: "exerciseType",
          nameLocalStorage: "exerciseType",
          nameURL: "exerciseType"
        }),
        randomSeed: new StorageVariable({
          name: "randomSeed",
          nameURL: "randomSeed",
          // Since this variable has no local storage outside of the URL,
          // to avoid wiping the variable while normalizing the URL,
          // we need to keep it displayed there by default.
          showInURLOnPages: pageNamesOnWhichToShowProblemURLs,
        }),
      },
      flagDebug: new StorageVariable({
        name: "debugFlag",
        nameURL: "debugFlag",
        nameCookie: "debugFlag",
        secure: true,
      }),
      flagStudentView: new StorageVariable({
        name: "studentView",
        nameURL: "studentView",
        nameCookie: "studentView",
        secure: true,
      }),
      calculator: {
        input: new StorageVariable({
          name: "calculatorInput",
          nameURL: "calculatorInput",
          associatedDOMId: ids.domElements.pages.calculator.inputMain,
          showInURLByDefault: true,
        }),
        request: new StorageVariable({
          name: "calculatorRequest",
          nameURL: "calculatorRequest",
          nameLocalStorage: "calculatorRequest",
        }),
        monitoring: new StorageVariable({
          name: "monitoring",
          nameLocalStorage: "monitoring",
          nameURL: "monitoring",
          nameCookie: "monitoring",
          showInURLByDefault: true,
        }),
      },
      user: {
        activationToken: new StorageVariable({
          name: "activationToken",
          nameURL: "activationToken",
        }),
        googleToken: new StorageVariable({
          name: "googleToken",
        }),
        name: new StorageVariable({
          name: "username",
          nameCookie: "username",
          nameURL: "username",
        }),
        authenticationToken: new StorageVariable({
          name: "authenticationToken",
          nameCookie: "authenticationToken",
          nameURL: "authenticationToken",
        }),
        role: new StorageVariable({
          name: "userRole",
          nameCookie: "userRole",
          nameURL: "userRole",
        }),
        email: new StorageVariable({
          name: "email",
          nameURL: "email",
        }),
      },
      theme: new StorageVariable({
        name: "theme",
        nameLocalStorage: "theme",
      }),
    };
    this.currentHashRaw = "";
    this.currenTHashDecoded = "";
    this.urlObject = {};
  }

  /**@returns {string} */
  getPercentEncodedURL(input) {
    return encodeURIComponent(JSON.stringify(input));
  }

  /**@returns {string} */
  getCleanedUpURL(input) {
    let stringifiedInput = JSON.stringify(input);
    let isGood = true;
    try {
      let decodedAsURL = decodeURIComponent(stringifiedInput);
      if (stringifiedInput !== decodedAsURL) {
        isGood = false;
      }
    } catch (e) {
      isGood = false;
    }
    if (!isGood) {
      stringifiedInput = encodeURIComponent(stringifiedInput);
    }
    return stringifiedInput;
  }

  parseURL() {
    try {
      if (
        this.currentHashRaw === window.location.hash
      ) {
        return;
      }
      this.currentHashRaw = window.location.hash;
      this.currenTHashDecoded = decodeURIComponent(this.currentHashRaw);
      if (this.currenTHashDecoded.startsWith('#')) {
        this.currenTHashDecoded = this.currenTHashDecoded.slice(1);
      }
      if (this.currenTHashDecoded === "") {
        this.urlObject = {
        };
      } else {
        this.urlObject = JSON.parse(this.currenTHashDecoded);
      }
    } catch (e) {
      console.log(`Failed to parse your url hash ${this.currenTHashDecoded} obtained from ${window.location.hash}.${e}.`);
    }
  }

  loadSettings() {
    if (!configuration.configuration.calculatorDefaultsEnabled) {
      return;
    }
    this.parseURL();
    this.loadSettingsRecursively(this.variables, this.urlObject);
  }

  loadSettingsRecursively(
    /**@type {StorageVariable} */
    currentStorage,
    inputHashParsed,
  ) {
    if (currentStorage instanceof StorageVariable) {
      currentStorage.loadMe(inputHashParsed);
      return;
    }
    if (typeof currentStorage === "object") {
      for (let subLabel in currentStorage) {
        this.loadSettingsRecursively(currentStorage[subLabel], inputHashParsed);
      }
    }
  }

  setURL() {
    this.urlObject = this.computeURLRecursively(this.variables);
    let incomingHashRaw = this.getPercentEncodedURL(this.urlObject);

    if (incomingHashRaw !== this.currentHashRaw) {
      window.location.hash = incomingHashRaw;
      this.currentHashRaw = incomingHashRaw;
    }
  }

  computeURLRecursively(currentStorage, recursionDepth) {
    if (recursionDepth === undefined) {
      recursionDepth = 0;
    }
    if (recursionDepth > 100) {
      throw ("Recursion is too deeply nested. This must be a programming error. ");
    }
    let result = {
    };
    if (currentStorage instanceof StorageVariable) {
      let urlName = currentStorage.nameURL;
      if (urlName === undefined || urlName === null || urlName === "") {
        return null;
      }
      let shouldShow = false;
      if (currentStorage.showInURLByDefault === true) {
        shouldShow = true;
      }
      if (currentStorage.showInURLOnPages !== null && currentStorage.showInURLOnPages !== undefined) {
        if (storage.variables.currentPage.value in currentStorage.showInURLOnPages) {
          shouldShow = true;
        }
      }
      if (!shouldShow) {
        return null;
      }
      if (currentStorage.value === null || currentStorage.value == undefined || currentStorage.value == "") {
        return null;
      }
      result[urlName] = currentStorage.value;
      return result;
    }
    if (typeof currentStorage !== "object") {
      throw (`Unexpected currentStorage input while computing url: ${currentStorage}`);
    }
    for (let label in currentStorage) {
      let incoming = this.computeURLRecursively(currentStorage[label], recursionDepth + 1);
      if (incoming === null) {
        continue;
      }
      Object.assign(result, incoming);
    }
    return result;
  }

  /**@returns{string} */
  toStringProblem() {
    let problemFileName = this.variables.currentCourse.problemFileName.getValue();
    let fileName = this.variables.currentCourse.p;
    let result = `problemFileName: ${problemFileName}. fileName: ${fileName}`;
    return result;
  }
}

let storage = new StorageCalculator();

module.exports = {
  storage,
};
},
"/calculator-html/page_navigation" : function(require, module, exports){
"use strict";
const selectCourse = require("./select_course");
const coursePage = require("./course_page");
const problemPage = require("./problem_page");
const editPage = require("./edit_page");
const database = require("./database");
const serverStatus = require("./server_status");
const accountPage = require("./account");
const activateAccount = require("./account_activation");
const accountManagement = require("./manage_accounts");
const cookies = require("./cookies");
const ids = require("./ids_dom_elements");
const serverInformation = require("./server_information");
const login = require("./login");
const initializeButtons = require("./initialize_buttons");
const calculatorPage = require("./calculator_page");
const signUp = require("./signup").signUp;
const mathTypeSet = require("./math_typeset");
const themes = require("./themes");
const solver = require("./solve");
const solve = require("./solve");
const compareExpressions = require("./compare_expressions").compareExpressions;
const storage = require("./storage").storage;
const solveSocratic = require("./solve_socratic");

class User {
  constructor() {
    this.flagLoggedIn = false;
    this.googleProfile = null;
    this.sectionsTaught = [];
    this.instructor = "";
    this.sectionInDB = "";
    this.deadlineSchema = "";
    this.sectionComputed = "";
    this.flagDatabaseInactiveEveryoneIsAdmin = false;
  }

  isLoggedIn() {
    return this.flagLoggedIn;
  }

  getRole() {
    return mainPage().storage.variables.user.role.getValue();
  }

  hasAdminRights() {
    return this.getRole() === "admin" && this.isLoggedIn();
  }

  hasProblemEditRights() {
    return this.getRole() === "admin" && this.isLoggedIn();
  }

  hasInstructorRights() {
    return this.getRole() === "admin" && this.isLoggedIn();
  }

  hideProfilePicture() {
    document.getElementById("divProfilePicture").classList.add("divInvisible");
    document.getElementById("divProfilePicture").classList.remove("divVisible");
  }

  makeFromUserInfo(inputData) {
    let thePage = window.calculator.mainPage;
    // Please note: the authentication token is silently set through the cookie headers.
    // Please do not take explicit action as
    // inputdata.authenticationToken may not contain the authentication token.
    // not ok: thePage.storage.variables.user.authenticationToken.setAndStore(inputData.authenticationToken);
    thePage.storage.variables.user.name.setAndStore(inputData.username);
    mainPage().storage.variables.user.role.setAndStore(inputData.userRole);
    this.flagLoggedIn = true;
    this.sectionsTaught = inputData.sectionsTaught;
    this.instructor = inputData.instructor;
    this.sectionInDB = inputData.studentSection;
    this.sectionComputed = inputData.studentSection;
    this.deadlineSchema = inputData.deadlineSchema;
    document.getElementById(ids.domElements.spanUserIdInAccountsPage).innerHTML = thePage.storage.variables.user.name.value;
    document.getElementById(ids.domElements.inputUsername).value = thePage.storage.variables.user.name.value;
  }
}

class Page {
  constructor() {
    window.calculator.mainPage = this;
    this.pages = {
      login: {
        name: "login", //<-for autocomplete
        id: "divLoginPage",
        menuButtonId: "buttonLoginPage",
        container: null,
        selectFunction: null,
        initialized: false,
      },
      solve: {
        name: "solve",
        menuButtonId: ids.domElements.pages.solve.buttonSelectSolvePage,
        id: ids.domElements.pages.solve.div,
        container: null,
        selectFunction: solver.selectSolverPage,
      },
      solveSocratic: {
        name: "solveSocratic",
        id: ids.domElements.pages.solveSocratic.div,
        selectFunction: () => {
          solveSocratic.solver.selectPage();
        }
      },
      selectCourse: {
        name: "selectCourse",
        id: "divSelectCourse",
        menuButtonId: "buttonSelectCourse",
        container: null,
        selectFunction: selectCourse.selectCoursePage,
      },
      currentCourse: {
        name: "currentCourse",
        id: "divCurrentCourse",
        menuButtonId: "buttonCurrentCourse",
        container: null,
        selectFunction: coursePage.selectCurrentCoursePage,
      },
      problemPage: {
        name: "problemPage",
        id: "divProblemPage",
        menuButtonId: "buttonProblemPage",
        container: null,
        selectFunction: problemPage.updateProblemPage,
        flagLoaded: false,
      },
      editPage: {
        name: "editPage",
        id: ids.domElements.pages.editPage.div,
        menuButtonId: ids.domElements.pages.editPage.button,
        container: null,
        selectFunction: editPage.selectEditPage,
        flagLoaded: false,
        editor: null,
      },
      calculator: {
        name: "calculator",
        id: "divCalculatorPage",
        menuButtonId: "buttonSelectCalculator",
        container: null,
        selectFunction: () => {
          calculatorPage.calculator.selectCalculatorPage();
        },
        scriptIds: [],
      },
      signUp: {
        name: "signUp",
        id: "divSignUpPage",
        container: null,
        selectFunction: signUp.signUp.bind(signUp),
      },
      forgotLogin: {
        name: "forgotLogin",
        id: "divForgotLogin",
        container: null,
        selectFunction: null,
      },
      about: {
        name: "about",
        id: "divAboutPage",
        menuButtonId: "buttonAboutPage",
        container: null,
        selectFunction: null,
      },
      privacyPolicy: {
        name: "privacyPolicy",
        id: ids.domElements.pages.privacyPolicy.div,
        menuButtonId: ids.domElements.pages.privacyPolicy.button,
      },
      themes: {
        name: "themes",
        id: ids.domElements.pages.themes.div,
        menuButtonId: ids.domElements.pages.themes.button,
        container: null,
      },
      database: {
        name: "database",
        id: "divDatabase",
        menuButtonId: "buttonSelectDatabase",
        container: null,
        selectFunction: database.updateDatabasePage,
      },
      server: {
        name: "server",
        id: "divServer",
        menuButtonId: "buttonSelectServer",
        container: null,
        selectFunction: serverStatus.updateServerStatus,
      },
      account: {
        name: "account",
        id: "divAccount",
        menuButtonId: "buttonSelectAccount",
        container: null,
        selectFunction: accountPage.updateAccountPage,
      },
      activateAccount: {
        name: "activateAccount",
        id: "divActivateAccount",
        container: null,
        selectFunction: activateAccount.updateAccountActivationPage,
      },
      accounts: {
        name: "accounts",
        id: "divAccounts",
        menuButtonId: "buttonSelectAccounts",
        container: null,
        selectFunction: accountManagement.updateAccountsPage,
      },
      compareExpressions: {
        name: "compareExpressions",
        id: ids.domElements.pages.compareExpressions.div,
        selectFunction: compareExpressions.selectPage.bind(compareExpressions),
      },
    };
    this.defaultPage = "calculator";
    if (document.getElementById(ids.domElements.applicationIdentifiers.compareExpressions)) {
      this.defaultPage = "compareExpressions";
    }
    this.storage = storage;
    this.initializeStorageCallbacks();
    this.scriptInjector = new AllScripts();
    this.flagProblemPageOnly = false;
  }

  initializeStorageCallbacks() {
    this.storage.variables.currentPage.callbackOnValueChange = (value) => {
      this.selectPage(value);
    };
    this.storage.variables.flagDebug.callbackOnValueChange = (value) => {
      this.onDebugValueChange();
    };
    this.storage.variables.flagStudentView.callbackOnValueChange = (value) => {
      this.onStudentViewChange();
    };
    this.storage.variables.calculator.input.callbackOnValueChange = (value) => {
      calculatorPage.calculator.submitComputationPartTwo(value);
    };
    this.storage.variables.calculator.monitoring.callbackOnValueChange = (value) => {
      this.setMonitoringComponent();
    };
    this.storage.variables.theme.callbackOnValueChange = (value) => {
      themes.theme.doChangeTheme(value);
    };
    this.storage.variables.solve.problemToAutoSolve.callbackOnValueChange = (value) => {
      solve.solver.solveFromStorage(value);
    };
    this.storage.variables.solve.problemToAutoSolve.callbackSetValueFromStorage = (value) => {
      solve.solver.setAutoSolveProblemBox(value);
    };
  }

  isLoggedIn() {
    if (this.flagProblemPageOnly) {
      return false;
    }
    return this.user.isLoggedIn();
  }

  initBuildVersion() {
    let buildVersion = document.getElementById(ids.domElements.calculatorBuildVersion);
    if (buildVersion === null) {
      return;
    }
    buildVersion.innerHTML = `Build version ${serverInformation.serverInformation.version}`;
  }

  serverIsOnLocalHost() {
    if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      return true;
    }
    return false;
  }

  initHandlers() {
    window.addEventListener("hashchange", this.storage.loadSettings.bind(this.storage));
  }

  initMenuBar() {
    for (let label in this.pages) {
      let page = this.pages[label];
      page.container = document.getElementById(page.id);
      if (page.menuButtonId === null || page.menuButtonId === undefined) {
        continue;
      }
      let currentButton = document.getElementById(page.menuButtonId);
      if (currentButton === null) {
        continue;
      }
      currentButton.pageToSelect = label;
      currentButton.addEventListener(
        "click", () => {
          this.selectPage(label);
        }
      );
    }
  }

  resetTopicProblems() {
    problemPage.allProblems.resetTopicProblems();
  }

  showProfilePicture() {
    document.getElementById("divProfilePicture").classList.remove("divInvisible");
    document.getElementById("divProfilePicture").classList.add("divVisible");
    if (this.user.googleProfile.picture === undefined) {
      return;
    }
    if (document.getElementById("divProfilePicture").children.length > 0) {
      return;
    }
    try {
      let theProfilePicElement = document.createElement("IMG");
      theProfilePicElement.setAttribute("src", this.user.googleProfile.picture);
      theProfilePicElement.setAttribute("alt", this.user.googleProfile.name);
      theProfilePicElement.setAttribute("id", "imgProfilePicture");
      theProfilePicElement.setAttribute("title", this.user.googleProfile.name);
      theProfilePicElement.setAttribute("className", "profilePicture");
      //theProfilePicElement.setAttribute("width", 50);
      document.getElementById("divProfilePicture").appendChild(theProfilePicElement);
    } catch (e) {
      console.log("Failed to set profile picture: " + e);
    }
  }

  initializeCalculatorPage() {
    this.initializeCalculatorPagePartOne();
    this.initializeCalculatorPagePartTwo();
  }

  /**@type {boolean} */
  loginAttemptDesired() {
    if (this.storage.variables.currentPage.getValue() === this.pages.activateAccount.name) {
      return false;
    }
    if (document.getElementById(ids.domElements.pages.login.divLoginCalculatorPanel) === null) {
      return false;
    }
    return true;
  }

  initializeCalculatorPagePartOne() {
    cookies.setCookie("useJSON", true, 300, false);
    this.initMenuBar();
    this.initBuildVersion();
    this.initHandlers();
    //////////////////////////////////////
    //////////////////////////////////////
    //Initialize global variables
    //////////////////////////////////////
    //////////////////////////////////////
    this.theCourses = {};
    this.logoutRequestFromUrl = null;
    this.locationRequestFromUrl = null;
    this.storage.loadSettings();
    this.hashHistory = [];
    this.lastKnownGoodProblemFileName = "";
    this.user = new User();
    this.aceEditorAutoCompletionWordList = [];
    this.flagDoSubmitCalculatorComputation = true;
    // Select page on first load
    this.selectPage(this.storage.variables.currentPage.getValue());
    if (this.loginAttemptDesired()) {
      login.loginTry();
    }
    let appElement = document.getElementById(ids.domElements.applicationIdentifiers.default);
    if (appElement === null) {
      return;
    }
    appElement.style.display = "";
    appElement.className = "divOnePageApp";
  }

  toStringProblem() {
    return this.storage.toStringProblem();
  }

  initializeCalculatorPagePartTwo() {
    initializeButtons.initializeButtons();
    mathTypeSet.typesetter.typesetHard(ids.domElements.divMathjaxProblematicRender);
  }

  sectionSelect(sectionNumber) {
    this.storage.variables.currentSectionComputed.setAndStore(sectionNumber);
    this.user.sectionComputed = this.user.sectionsTaught[sectionNumber];
    let deadlineSpans = document.getElementsByClassName(ids.domElements.classSpanDeadlineContainer);
    for (let i = 0; i < deadlineSpans.length; i++) {
      let currentDeadlineSpan = deadlineSpans[i];
      let currentDeadlineId = currentDeadlineSpan.id.substr(
        ids.stringResources.prefixDeadlineContainer.length
      );
      let currentProblem = problemPage.allProblems[currentDeadlineId];
      if (currentProblem === undefined) {
        continue;
      }
      currentDeadlineSpan.innerHTML = currentProblem.toStringDeadlinePanel();
    }
  }

  onDebugValueChange() {
    let sliderDebug = document.getElementById(ids.domElements.sliderDebugFlag);
    if (sliderDebug === null) {
      return;
    }
    let debugOn = this.storage.variables.flagDebug.isTrue();
    sliderDebug.checked = debugOn;
    let debugSpan = document.getElementById(ids.domElements.spanDebugFlagToggleReport);
    if (debugOn) {
      solve.solver.setDebugLogContainer();
      debugSpan.innerHTML = "Debug <b style = 'color:red'>on</b>";
    } else {
      solve.solver.setDebugLogContainer();
      debugSpan.innerHTML = "Debug <b style = 'color:green'>off</b>";
    }
  }

  setSwitchDebug() {
    let sliderDebug = document.getElementById(ids.domElements.sliderDebugFlag);
    this.storage.variables.flagDebug.setAndStore(sliderDebug.checked);
    this.pages.problemPage.flagLoaded = false;
    this.selectPage(this.storage.variables.currentPage.getValue());
  }

  setSwitchStudentView() {
    let sliderStudentView = document.getElementById(ids.domElements.sliderStudentView);
    this.storage.variables.flagStudentView.setAndStore(sliderStudentView.checked);
    this.pages.problemPage.flagLoaded = false;
    this.selectPage(this.storage.variables.currentPage.getValue());
  }

  studentView() {
    return this.storage.variables.flagStudentView.isTrue();
  }

  onStudentViewChange() {
    let studentView = this.storage.variables.flagStudentView.isTrue();
    let slider = document.getElementById(ids.domElements.sliderStudentView);
    if (slider === null) {
      return;
    }
    slider.checked = studentView;

    let spanView = document.getElementById(ids.domElements.spanStudentViewFlagToggleReport);
    let radioHTML = "";
    if (studentView) {
      spanView.innerHTML = "Student view";
      for (let counterSections = 0; counterSections < this.user.sectionsTaught.length; counterSections++) {
        radioHTML += `<br><label class = "containerRadioButton">`;
        radioHTML += `<input type = "radio" name = "radioSection" onchange = "window.calculator.mainPage.sectionSelect(${counterSections}); " `;
        let counterFromStorage = parseInt(this.storage.variables.currentSectionComputed.getValue());
        if (counterSections === counterFromStorage) {
          radioHTML += "checked = 'true'";
        }
        radioHTML += `>`;
        radioHTML += `<span class = "radioMark"></span>`;
        radioHTML += this.user.sectionsTaught[counterSections];
        radioHTML += `</label>`
      }
    } else {
      spanView.innerHTML = "Admin view";
    }
    login.resetPagesNeedingReload();
    login.setAdminPanels();
    document.getElementById(ids.domElements.spanStudentViewSectionSelectPanel).innerHTML = radioHTML;
  }

  removeOneScript(scriptId) {
    this.scriptInjector.removeOneScript(scriptId);
  }

  removeScripts(scriptIds) {
    this.scriptInjector.removeScripts(scriptIds);
  }

  injectScript(scriptId, scriptContent) {
    this.scriptInjector.injectScript(scriptId, scriptContent);
  }

  selectPage(
    /** @type{string} */
    inputPage,
  ) {
    if (!(inputPage in this.pages)) {
      inputPage = this.defaultPage;
    }
    this.storage.variables.currentPage.setAndStore(inputPage);
    if (this.flagProblemPageOnly) {
      this.selectPageFunction(inputPage);
      return;
    }
    for (let label in this.pages) {
      let page = this.pages[label];
      if (page.container === null) {
        continue;
      }
      page.container.style.display = "none";
      if (page.menuButtonId !== null && page.menuButtonId !== undefined) {
        let button = document.getElementById(page.menuButtonId);
        if (button !== null) {
          button.classList.remove("buttonSelectPageSelected");
        }
      }
    }
    let selectedPage = this.pages[inputPage];
    if (selectedPage.container === null) {
      return;
    }
    selectedPage.container.style.display = "";
    if (selectedPage.menuButtonId !== null && selectedPage.menuButtonId !== undefined) {
      let button = document.getElementById(selectedPage.menuButtonId);
      if (button !== null) {
        button.classList.add("buttonSelectPageSelected");
      }
    }
    this.selectPageFunction(inputPage);
  }

  selectPageFunction(
    /** @type{string} */
    inputPage,
  ) {
    let selectedPage = this.pages[inputPage];
    if (selectedPage.selectFunction !== null && selectedPage.selectFunction !== undefined) {
      selectedPage.selectFunction();
    }
  }

  getProblemByIdOrNull(label) {
    return problemPage.allProblems.getProblemByIdOrNull(label);
  }

  getProblemById(label) {
    let element = document.getElementById(ids.domElements.problemPageContentContainer);
    return problemPage.allProblems.getProblemByIdOrRegisterEmpty(label, element);
  }


  toggleMonitoring() {
    let monitoring = this.storage.variables.calculator.monitoring;
    if (monitoring.value !== "false") {
      monitoring.setAndStore("false")
    } else {
      monitoring.setAndStore("true")
    }
  }

  setMonitoringComponent() {
    let monitoring = this.storage.variables.calculator.monitoring.value;
    if (monitoring !== "false") {
      monitoring = "true";
    }
    let monitorResult = document.getElementById(ids.domElements.pages.calculator.monitoring.spanStatus);
    if (monitorResult === null) {
      return;
    }
    if (monitoring === "true") {
      monitorResult.innerHTML = "Monitor <b style = 'color:red'>on</b>";
      document.getElementById(ids.domElements.switch.monitoring).checked = true;
      document.getElementById(ids.domElements.pages.calculator.monitoring.buttonPauseToggle).style.display = "";
    } else {
      document.getElementById(ids.domElements.switch.monitoring).checked = false;
      monitorResult.innerHTML = "Monitor <b style = 'color:green'>off</b>";
      document.getElementById(ids.domElements.pages.calculator.monitoring.buttonPauseToggle).style.display = "none";
    }
  }
}

class Script {
  constructor() {
    this.id = "";
    this.content = "";
  }
}

class AllScripts {
  constructor() {
    /**@{Script[]} */
    this.scriptsInjected = {};
  }

  removeOneScript(scriptId) {
    let theScript = document.getElementById(scriptId);
    if (theScript === null) {
      return;
    }
    let parent = theScript.parentNode;
    parent.removeChild(theScript);
  }

  removeScripts(scriptIds) {
    for (let counter = 0; counter < scriptIds.length; counter++) {
      this.removeOneScript(scriptIds[counter]);
    }
  }

  injectScript(scriptId, scriptContent) {
    this.removeOneScript(scriptId);
    if (scriptContent !== undefined && scriptContent !== null) {
      this.scriptsInjected[scriptId] = new Script();
      let theScript = this.scriptsInjected[scriptId];
      theScript.id = scriptId;
      theScript.content = scriptContent;
    }
    let theScript = this.scriptsInjected[scriptId];
    let scriptChild = document.createElement('script');
    scriptChild.setAttribute('id', scriptId);
    scriptChild.innerHTML = theScript.content;
    scriptChild.type = 'text/javascript';
    document.getElementsByTagName('head')[0].appendChild(scriptChild);
  }
}

/**
 * @returns {Page}
 * */
function mainPage() {
  return window.calculator.mainPage;
}

/**@returns {String} */
function getCleanedUpURL(input) {
  return mainPage().storage.getCleanedUpURL(input);
}

module.exports = {
  Page,
  mainPage,
  getCleanedUpURL,
};

},
"/calculator-html/three-d" : function(require, module, exports){
"use strict";

var module;
var require;
if (require === undefined) {
  require = function () { };
}

if (module === undefined) {
  module = {};
}

function calculatorError(x) {
  console.log(x);
  if (firstCriticalRunTimeError !== "") {
    return;
  }
  firstCriticalRunTimeError = x;
  if (firstCriticalRunTimeError !== "" && firstCanvas !== undefined && firstCanvas !== null) {
    firstCanvas.textErrors = firstCriticalRunTimeError + " All further error messages are suppressed.";
    firstCanvas.showMessages();
  }
}

function vectorToString(vector) {
  let result = "[";
  for (let i = 0; i < vector.length; i++) {
    result += vector[i].toFixed(2);
    if (i != vector.length - 1) {
      result += ", ";
    }
  }
  result += "]";
  return result;
}

/**
 * Scalar product of two vectors.
 * @param {number[]} s
 * @param {number[]} t
 * @returns{number}
 */
function vectorScalarVector(s, t) {
  let result = 0;
  if (s.length !== t.length) {
    calculatorError(`Scalar product of vectors of different length: ${s} and ${t}.`);
  }
  for (let i = 0; i < s.length; i++) {
    result += s[i] * t[i];
  }
  return result;
}

function vectorTimesScalar(vector, s) {
  for (let i = 0; i < vector.length; i++) {
    vector[i] *= s;
  }
}

function vectorPlusVector(left, right) {
  let output = new Array(left.length);
  for (let i = 0; i < left.length; i++) {
    output[i] = left[i] + right[i];
  }
  return output;
}

function vectorCrossVector(left, right) {
  return [
    left[1] * right[2] - left[2] * right[1],
    -left[0] * right[2] + left[2] * right[0],
    left[0] * right[1] - left[1] * right[0]
  ];
}

function vectorMinusVector(left, right) {
  let output = new Array(left.length);
  for (let i = 0; i < left.length; i++) {
    output[i] = left[i] - right[i];
  }
  return output;
}

function vectorAddVectorTimesScalar(output, otherVector, scalar) {
  for (let i = 0; i < output.length; i++) {
    output[i] += otherVector[i] * scalar;
  }
}

function vectorLength(vector) {
  return Math.sqrt(vectorScalarVector(vector, vector));
}

function vectorRound(vector) {
  for (let i = 0; i < vector.length; i++) {
    vector[i] = Math.round(vector[i]);
  }
}

function vectorNormalize(vector) {
  vectorTimesScalar(vector, 1 / vectorLength(vector));
}

/**
 * Returns true if the vector is the zero vector,
 * false otherwise.
 * @returns {boolean}
 * */
function vectorIsZero(
  /**@type{number[]} */
  vector,
) {
  for (let i = 0; i < vector.length; i++) {
    if (vector[i] !== 0) {
      return false;
    }
  }
  return true;
}

function getPosXPosYObject(theObject, cx, cy) {
  let rectangle = theObject.getBoundingClientRect();
  return [cx - rectangle.left, cy - rectangle.top];
}

function getAngleChangeMathScreen(newX, newY, oldX, oldY) {
  let result = Math.atan2(newY, newX) - Math.atan2(oldY, oldX);
  if (result > Math.PI) {
    result -= Math.PI;
  } else if (result < - Math.PI) {
    result += Math.PI;
  }
  return result;
}

function testFunctionPlot(v) {
  return Math.sin(v);
}

function testFunctionPlot2(v) {
  return Math.sin(2 * v) + 2;
}

function testMoebiusStripEmbedding(u, v) {
  let z = v * Math.sin(u / 2);
  let x = (2 + (v) * Math.cos(u / 2)) * Math.cos(u);
  let y = (2 + (v) * Math.cos(u / 2)) * Math.sin(u);
  //let z=v/2;//*Math.sin(u);
  //let x = (u)/10+v/2;// (2+(v)*Math.cos(u))*Math.cos(u);
  //let y = (u/11);// (2+(v)*Math.cos(u))*Math.sin(u);
  return [x, y, z];
}

function testMoebiusStripEmbedding2(u, v) {
  let first = testMoebiusStripEmbedding(u, v);
  let x = first[0];
  let y = first[1];
  let z = first[2];
  return [x + 2, z, y];
}

function testGetMoebiusSurface() {
  let colors = {
    colorContour: "black",
    colorUV: "blue",
    colorVU: "cyan"
  };
  let result = new Surface(testMoebiusStripEmbedding, [[0, - 0.6], [Math.PI * 2, 0.6]], [22, 4], colors, 2);
  return result;
}

function testGetMoebiusSurface2() {
  let colors = {
    colorContour: "black",
    colorUV: "red",
    colorVU: "pink"
  };
  let result = new Surface(testMoebiusStripEmbedding2, [[0, - 0.6], [Math.PI * 2, 0.6]], [22, 4], colors, 0.5);
  return result;
}

function testVectorField2d(x, y) {
  return [- y, x];
}

function testGetTestPlane() {
  let colors = {
    colorContour: "black",
    colorUV: "blue",
    colorVU: "cyan"
  };
  let result = new Surface(function (u, v) {
    return [u, 0.9 * v, 1 + u + v];
  }, [[- 1.2, - 0.7], [1, 1]], [5, 5], colors);
  return result;
}

class CurveThreeD {
  constructor(
    inputCoordinateFunctions, inputLeftPt, inputRightPt,
    inputNumSegments, inputColor, inputLineWidth
  ) {
    this.coordinateFunctions = inputCoordinateFunctions;
    this.leftPt = inputLeftPt;
    this.rightPt = inputRightPt;
    this.color = colorToRGB(inputColor);
    this.numSegments = inputNumSegments;
    this.lineWidth = inputLineWidth;
  }

  accountBoundingBox(inputOutputBox) {
    let theT = this.leftPt;
    let theX = this.coordinateFunctions[0](theT);
    let theY = this.coordinateFunctions[1](theT);
    accountBoundingBox([theX, theY], inputOutputBox);
    for (let i = 0; i < this.numSegments; i++) {
      let theRatio = i / (this.numSegments - 1);
      theT = this.leftPt * (1 - theRatio) + this.rightPt * theRatio;
      theX = this.coordinateFunctions[0](theT);
      theY = this.coordinateFunctions[1](theT);
      accountBoundingBox([theX, theY], inputOutputBox);
    }
  }

  drawNoFinish(theCanvas, startByMoving) {
    let theSurface = theCanvas.surface;
    theSurface.strokeStyle = colorRGBToString(this.color);
    theSurface.fillStyle = colorRGBToString(this.color);
    let theT = this.leftPt;
    let theX = this.coordinateFunctions[0](theT);
    let theY = this.coordinateFunctions[1](theT);
    let theCoords = theCanvas.coordsMathToScreen([theX, theY]);
    if (startByMoving) {
      theSurface.moveTo(theCoords[0], theCoords[1]);
    } else {
      theSurface.lineTo(theCoords[0], theCoords[1]);
    }
    let skippedValues = false;
    for (let i = 0; i < this.numSegments; i++) {
      let theRatio = i / (this.numSegments - 1);
      theT = this.leftPt * (1 - theRatio) + this.rightPt * theRatio; //<- this way of
      //computing x introduces smaller numerical errors.
      //For example, suppose you plot sqrt(1-x^2) from - 1 to 1.
      //If not careful with rounding errors,
      //you may end up evaluating sqrt(1-x^2) for x =1.00000000000004
      //resulting in serious visual glitches.
      //Note: the remarks above were discovered the painful way (trial and error).
      theX = this.coordinateFunctions[0](theT);
      theY = this.coordinateFunctions[1](theT);
      if (!isFinite(theY) || !isFinite(theX))
        console.log('Failed to evaluate: ' + this.theFunction + ' at x = ' + theX);
      if (Math.abs(theY) > 100000 || Math.abs(theX) > 100000) {
        if (!skippedValues) {
          console.log('Curve point: ' + [theX, theY] + " is too large, skipping. Further errors suppressed.");
        }
        skippedValues = true;
        continue;
      }
      theCoords = theCanvas.coordsMathToScreen([theX, theY]);
      theSurface.lineTo(theCoords[0], theCoords[1]);
    }
  }

  draw(theCanvas) {
    let theSurface = theCanvas.surface;
    theSurface.beginPath();
    this.drawNoFinish(theCanvas, true);
    theSurface.stroke();
  }
}

class Surface {
  constructor(inputxyzFun, inputUVBox, inputPatchDimensions, inputColors, inputContourWidth) {
    this.xyzFun = inputxyzFun;
    this.uvBox = inputUVBox;
    this.patchDimensions = inputPatchDimensions;
    this.colors = inputColors;
    this.contourWidth = inputContourWidth;
    this.colors.colorUV = colorToHex(this.colors.colorUV);
    this.colors.colorVU = colorToHex(this.colors.colorVU);
    this.deltaU = (inputUVBox[1][0] - inputUVBox[0][0]) / this.patchDimensions[0];
    this.deltaV = (inputUVBox[1][1] - inputUVBox[0][1]) / this.patchDimensions[1];
    this.numSamplesUSegment = 10;
    this.numSamplesVSegment = 10;
  }
}

class Point {
  constructor(inputLocation, inputColor) {
    this.location = inputLocation;
    this.color = colorToRGB(inputColor);
  }
}

class Patch {
  constructor(inputBase, inputEdge1, inputEdge2, inputColorUV, inputColorVU) {
    this.base = inputBase.slice();
    this.edge1 = inputEdge1.slice();
    this.edge2 = inputEdge2.slice();
    this.colorUV = colorToRGB(inputColorUV);
    this.colorVU = colorToRGB(inputColorVU);
    this.v1 = vectorPlusVector(this.base, this.edge1);
    this.v2 = vectorPlusVector(this.base, this.edge2);
    this.vEnd = vectorPlusVector(this.v1, this.edge2);
    this.internalPoint = this.base.slice();
    vectorAddVectorTimesScalar(this.internalPoint, this.edge1, 0.5);
    vectorAddVectorTimesScalar(this.internalPoint, this.edge2, 0.5);
    this.normalVector = vectorCrossVector(inputEdge1, inputEdge2);
    this.adjacentContours = [];
    this.traversalOrder = [];
    this.patchesBelowMe = [];
    this.patchesAboveMe = [];
    this.index = - 1;
  }
}

class Contour {
  constructor(inputPoints, inputColor, inputLineWidth) {
    this.thePoints = inputPoints.slice();
    this.thePointsMathScreen = [];
    this.color = colorToRGB(inputColor);
    this.adjacentPatches = [];
    this.index = - 1;
    this.lineWidth = inputLineWidth;
  }
}

function colorRGBToHex(r, g, b) {
  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

function colorRGBToString(input) {
  return `rgb(${input[0].toString()},${input[1].toString()},${input[2].toString()})`;
}

function colorScale(inputRGB, theScale) {
  let result = [0, 0, 0];
  for (let i = 0; i < inputRGB.length; i++) {
    result[i] = Math.round(inputRGB[i] * theScale);
    if (result[i] < 0) {
      result[i] = 0;
    }
    if (result[i] > 255) {
      result[i] = 255;
    }
  }
  return result;
}

function colorToRGB(input) {
  if (input.length === 3 && (typeof input !== 'string')) {
    return input;
  }
  let hex = colorToHex(input);
  return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
}

function colorToHex(color) {
  let colors = {
    "aliceblue": "#f0f8ff",
    "antiquewhite": "#faebd7",
    "aqua": "#00ffff",
    "aquamarine": "#7fffd4",
    "azure": "#f0ffff",
    "beige": "#f5f5dc",
    "bisque": "#ffe4c4",
    "black": "#000000",
    "blanchedalmond": "#ffebcd",
    "blue": "#0000ff",
    "blueviolet": "#8a2be2",
    "brown": "#a52a2a",
    "burlywood": "#deb887",
    "cadetblue": "#5f9ea0",
    "chartreuse": "#7fff00",
    "chocolate": "#d2691e",
    "coral": "#ff7f50",
    "cornflowerblue": "#6495ed",
    "cornsilk": "#fff8dc",
    "crimson": "#dc143c",
    "cyan": "#00ffff",
    "darkblue": "#00008b",
    "darkcyan": "#008b8b",
    "darkgoldenrod": "#b8860b",
    "darkgray": "#a9a9a9",
    "darkgreen": "#006400",
    "darkkhaki": "#bdb76b",
    "darkmagenta": "#8b008b",
    "darkolivegreen": "#556b2f",
    "darkorange": "#ff8c00",
    "darkorchid": "#9932cc",
    "darkred": "#8b0000",
    "darksalmon": "#e9967a",
    "darkseagreen": "#8fbc8f",
    "darkslateblue": "#483d8b",
    "darkslategray": "#2f4f4f",
    "darkturquoise": "#00ced1",
    "darkviolet": "#9400d3",
    "deeppink": "#ff1493",
    "deepskyblue": "#00bfff",
    "dimgray": "#696969",
    "dodgerblue": "#1e90ff",
    "firebrick": "#b22222",
    "floralwhite": "#fffaf0",
    "forestgreen": "#228b22",
    "fuchsia": "#ff00ff",
    "gainsboro": "#dcdcdc",
    "ghostwhite": "#f8f8ff",
    "gold": "#ffd700",
    "goldenrod": "#daa520",
    "gray": "#808080",
    "green": "#008000",
    "greenyellow": "#adff2f",
    "honeydew": "#f0fff0",
    "hotpink": "#ff69b4",
    "indianred ": "#cd5c5c",
    "indigo": "#4b0082",
    "ivory": "#fffff0",
    "khaki": "#f0e68c",
    "lavender": "#e6e6fa",
    "lavenderblush": "#fff0f5",
    "lawngreen": "#7cfc00",
    "lemonchiffon": "#fffacd",
    "lightblue": "#add8e6",
    "lightcoral": "#f08080",
    "lightcyan": "#e0ffff",
    "lightgoldenrodyellow": "#fafad2",
    "lightgrey": "#d3d3d3",
    "lightgreen": "#90ee90",
    "lightpink": "#ffb6c1",
    "lightsalmon": "#ffa07a",
    "lightseagreen": "#20b2aa",
    "lightskyblue": "#87cefa",
    "lightslategray": "#778899",
    "lightsteelblue": "#b0c4de",
    "lightyellow": "#ffffe0",
    "lime": "#00ff00",
    "limegreen": "#32cd32",
    "linen": "#faf0e6",
    "magenta": "#ff00ff",
    "maroon": "#800000",
    "mediumaquamarine": "#66cdaa",
    "mediumblue": "#0000cd",
    "mediumorchid": "#ba55d3",
    "mediumpurple": "#9370d8",
    "mediumseagreen": "#3cb371",
    "mediumslateblue": "#7b68ee",
    "mediumspringgreen": "#00fa9a",
    "mediumturquoise": "#48d1cc",
    "mediumvioletred": "#c71585",
    "midnightblue": "#191970",
    "mintcream": "#f5fffa",
    "mistyrose": "#ffe4e1",
    "moccasin": "#ffe4b5",
    "navajowhite": "#ffdead",
    "navy": "#000080",
    "oldlace": "#fdf5e6",
    "olive": "#808000",
    "olivedrab": "#6b8e23",
    "orange": "#ffa500",
    "orangered": "#ff4500",
    "orchid": "#da70d6",
    "palegoldenrod": "#eee8aa",
    "palegreen": "#98fb98",
    "paleturquoise": "#afeeee",
    "palevioletred": "#d87093",
    "papayawhip": "#ffefd5",
    "peachpuff": "#ffdab9",
    "peru": "#cd853f",
    "pink": "#ffc0cb",
    "plum": "#dda0dd",
    "powderblue": "#b0e0e6",
    "purple": "#800080",
    "red": "#ff0000",
    "rosybrown": "#bc8f8f",
    "royalblue": "#4169e1",
    "saddlebrown": "#8b4513",
    "salmon": "#fa8072",
    "sandybrown": "#f4a460",
    "seagreen": "#2e8b57",
    "seashell": "#fff5ee",
    "sienna": "#a0522d",
    "silver": "#c0c0c0",
    "skyblue": "#87ceeb",
    "slateblue": "#6a5acd",
    "slategray": "#708090",
    "snow": "#fffafa",
    "springgreen": "#00ff7f",
    "steelblue": "#4682b4",
    "tan": "#d2b48c",
    "teal": "#008080",
    "thistle": "#d8bfd8",
    "tomato": "#ff6347",
    "turquoise": "#40e0d0",
    "violet": "#ee82ee",
    "wheat": "#f5deb3",
    "white": "#ffffff",
    "whitesmoke": "#f5f5f5",
    "yellow": "#ffff00",
    "yellowgreen": "#9acd32",
  };
  if (typeof colors[color.toLowerCase()] != 'undefined') {
    return colors[color.toLowerCase()];
  }
  if (color.length === 3) {
    return colorRGBToHex(color[0], color[1], color[2]);
  }
  return color;
}

class PointsTwoD {
  constructor(inputLocation, inputColor) {
    this.location = inputLocation.slice();
    this.color = colorToRGB(inputColor);
    this.type = "points";
  }

  accountBoundingBox(inputOutputBox) {
    for (let i = 0; i < this.location.length; i++) {
      accountBoundingBox(this.location[i], inputOutputBox);
    }
  }

  draw(theCanvas) {
    let theSurface = theCanvas.surface;
    for (let i = 0; i < this.location.length; i++) {
      theSurface.beginPath();
      theSurface.strokeStyle = colorRGBToString(this.color);
      theSurface.fillStyle = colorRGBToString(this.color);
      let theCoords = theCanvas.coordsMathToScreen(this.location[i]);
      theSurface.arc(theCoords[0], theCoords[1], 3, 0, Math.PI * 2);
      theSurface.fill();
    }
  }
}

function accountBoundingBox(inputPoint, outputBox) {
  for (let i = 0; i < inputPoint.length; i++) {
    if (inputPoint[i] < outputBox[0][i]) {
      outputBox[0][i] = inputPoint[i];
    }
  }
  for (let i = 0; i < inputPoint.length; i++) {
    if (inputPoint[i] > outputBox[1][i]) {
      outputBox[1][i] = inputPoint[i];
    }
  }
}

class CurveTwoD {
  constructor(
    inputCoordinateFunctions,
    inputLeftPt,
    inputRightPt,
    inputNumSegments,
    inputColor,
    inputLineWidth
  ) {
    this.coordinateFunctions = inputCoordinateFunctions;
    this.leftPt = inputLeftPt;
    this.rightPt = inputRightPt;
    this.color = colorToRGB(inputColor);
    this.numSegments = inputNumSegments;
    this.lineWidth = inputLineWidth;
  }

  accountBoundingBox(inputOutputBox) {
    let theT = this.leftPt;
    let theX = this.coordinateFunctions[0](theT);
    let theY = this.coordinateFunctions[1](theT);
    accountBoundingBox([theX, theY], inputOutputBox);
    for (let i = 0; i < this.numSegments; i++) {
      let theRatio = i / (this.numSegments - 1);
      theT = this.leftPt * (1 - theRatio) + this.rightPt * theRatio;
      theX = this.coordinateFunctions[0](theT);
      theY = this.coordinateFunctions[1](theT);
      accountBoundingBox([theX, theY], inputOutputBox);
    }
  }

  draw(theCanvas) {
    let theSurface = theCanvas.surface;
    theSurface.beginPath();
    this.drawNoFinish(theCanvas, true);
    theSurface.stroke();
  }

  drawNoFinish(theCanvas, startByMoving) {
    let theSurface = theCanvas.surface;
    theSurface.strokeStyle = colorRGBToString(this.color);
    theSurface.fillStyle = colorRGBToString(this.color);
    let theT = this.leftPt;
    let theX = this.coordinateFunctions[0](theT);
    let theY = this.coordinateFunctions[1](theT);
    let theCoords = theCanvas.coordsMathToScreen([theX, theY]);
    let alreadyMoved = false;
    if (startByMoving) {
      alreadyMoved = true;
    }
    theSurface.lineWidth = this.lineWidth;
    let skippedValues = false;
    for (let i = 0; i < this.numSegments; i++) {
      let theRatio = i / (this.numSegments - 1);
      theT = this.leftPt * (1 - theRatio) + this.rightPt * theRatio; //<- this way of
      //computing x introduces smaller numerical errors.
      //For example, suppose you plot sqrt(1-x^2) from - 1 to 1.
      //If not careful with rounding errors,
      //you may end up evaluating sqrt(1-x^2) for x =1.00000000000004
      //resulting in serious visual glitches.
      //Note: the remarks above were discovered the painful way (trial and error).
      theX = this.coordinateFunctions[0](theT);
      theY = this.coordinateFunctions[1](theT);
      if (!isFinite(theY) || !isFinite(theX)) {
        console.log(`Failed to evaluate: ${this.theFunction} at x = ${theX}`);
      }
      if (Math.abs(theY) > 100000 || Math.abs(theX) > 100000) {
        if (!skippedValues) {
          console.log(`Curve point: [${theX}, ${theY}] is too large, skipping. Further errors suppressed.`);
        }
        skippedValues = true;
        continue;
      }
      theCoords = theCanvas.coordsMathToScreen([theX, theY]);
      if (!alreadyMoved) {
        alreadyMoved = true;
        theSurface.moveTo(theCoords[0], theCoords[1]);
      } else {
        theSurface.lineTo(theCoords[0], theCoords[1]);
      }
    }
  }
}

class PathTwoD {
  constructor(inputPath, inputColor, inputFillColor, inputLineWidth) {
    this.path = inputPath;
    this.color = colorToRGB(inputColor);
    this.colorFill = colorToRGB(inputFillColor);
    this.isFilled = false;
    this.type = "path";
    this.lineWidth = inputLineWidth;
  }

  accountBoundingBox(inputOutputBox) {
    for (let i = 0; i < this.path.length; i++) {
      accountBoundingBox(this.path[i], inputOutputBox);
    }
  }

  drawNoFinish(theCanvas, startByMoving) {
    if (this.path.length < 1) {
      return;
    }
    let theSurface = theCanvas.surface;
    let theCoords = theCanvas.coordsMathToScreen(this.path[0]);
    if (startByMoving) {
      theSurface.moveTo(theCoords[0], theCoords[1]);
    } else {
      theSurface.lineTo(theCoords[0], theCoords[1]);
    }
    theSurface.lineWidth = this.lineWidth;
    for (let i = 1; i < this.path.length; i++) {
      theCoords = theCanvas.coordsMathToScreen(this.path[i]);
      theSurface.lineTo(theCoords[0], theCoords[1]);
    }
    theSurface.strokeStyle = colorRGBToString(this.color);
    theSurface.fillStyle = colorRGBToString(this.colorFill);
    if (this.isFilled) {
      theSurface.fill();
    }
  }

  draw(theCanvas) {
    if (this.path.length < 1) {
      return;
    }
    let theSurface = theCanvas.surface;
    theSurface.beginPath();
    this.drawNoFinish(theCanvas, true);
    theSurface.stroke();
  }
}

class DrawCoordinateAxesTwoD {
  constructor() {
  }

  draw(theCanvas) {
    this.drawNoFinish(theCanvas, true);
  }

  accountBoundingBox(inputOutputBox) {
    accountBoundingBox([0, 1], inputOutputBox);
    accountBoundingBox([1, 0], inputOutputBox);
  }

  drawNoFinish(theCanvas, startByMoving) {
    let lowLeft = theCanvas.coordsScreenToMathScreen([0, theCanvas.height]);
    let topRight = theCanvas.coordsScreenToMathScreen([theCanvas.width, 0]);
    let theSurface = theCanvas.surface;
    theSurface.strokeStyle = colorRGBToString([0, 0, 0]);
    theSurface.fillStyle = colorRGBToString([0, 0, 0]);
    theSurface.lineWidth = 1;
    let left = lowLeft[0];
    let right = topRight[0];
    let bottom = lowLeft[1];
    let top = topRight[1];
    theSurface.beginPath();
    let theCoords = theCanvas.coordsMathScreenToScreen([0, bottom]);
    theSurface.moveTo(theCoords[0], theCoords[1]);
    theCoords = theCanvas.coordsMathScreenToScreen([0, top]);
    theSurface.lineTo(theCoords[0], theCoords[1]);
    theSurface.stroke();
    theCoords = theCanvas.coordsMathScreenToScreen([left, 0]);
    theSurface.moveTo(theCoords[0], theCoords[1]);
    theCoords = theCanvas.coordsMathScreenToScreen([right, 0]);
    theSurface.lineTo(theCoords[0], theCoords[1]);
    theSurface.stroke();
    theCoords = theCanvas.coordsMathScreenToScreen([1, -0.1]);
    theSurface.moveTo(theCoords[0], theCoords[1]);
    theCoords = theCanvas.coordsMathScreenToScreen([1, 0.1]);
    theSurface.lineTo(theCoords[0], theCoords[1]);
    theSurface.stroke();
    theCoords = theCanvas.coordsMathScreenToScreen([1, 0]);
    theSurface.fillText("1", theCoords[0], theCoords[1] + 10);
  }
}

class AxesGrid {
  constructor() {
  }

  draw(theCanvas) {
    this.drawNoFinish(theCanvas, true);
  }

  drawNoFinish(theCanvas, startByMoving) {
    let lowLeft = theCanvas.coordsScreenToMathScreen([0, theCanvas.height]);
    let topRight = theCanvas.coordsScreenToMathScreen([theCanvas.width, 0]);
    let theSurface = theCanvas.surface;
    theSurface.strokeStyle = colorRGBToString([160, 160, 160]);
    theSurface.fillStyle = colorRGBToString([160, 160, 160]);
    theSurface.lineWidth = 0.1;
    let left = lowLeft[0];
    let right = topRight[0];
    let bottom = lowLeft[1];
    let top = topRight[1];
    let floorLeft = Math.floor(left);
    let ceilRight = Math.ceil(right);
    let floorBottom = Math.floor(bottom);
    let ceilTop = Math.ceil(top);
    let distanceBetweenMarks = 30;
    let DeltaHorizontal = Math.max(1, Math.floor((ceilRight - floorLeft) / (theCanvas.width / distanceBetweenMarks)));
    let DeltaVertical = Math.max(1, Math.floor((ceilTop - floorBottom) / (theCanvas.height / distanceBetweenMarks)));
    let Delta = Math.max(DeltaHorizontal, DeltaVertical);
    theSurface.beginPath();
    for (let i = floorLeft; i <= ceilRight; i += Delta) {
      let theCoords = theCanvas.coordsMathScreenToScreen([i, bottom]);
      theSurface.moveTo(theCoords[0], theCoords[1]);
      theCoords = theCanvas.coordsMathScreenToScreen([i, top]);
      theSurface.lineTo(theCoords[0], theCoords[1]);
      theSurface.stroke();
    }
    for (let i = floorBottom; i <= ceilTop; i += Delta) {
      let theCoords = theCanvas.coordsMathScreenToScreen([left, i]);
      theSurface.moveTo(theCoords[0], theCoords[1]);
      theCoords = theCanvas.coordsMathScreenToScreen([right, i]);
      theSurface.lineTo(theCoords[0], theCoords[1]);
      theSurface.stroke();
    }
    theSurface.strokeStyle = colorRGBToString([0, 0, 0]);
    theSurface.fillStyle = colorRGBToString([0, 0, 0]);
    let counter = 0;
    for (let i = floorLeft; i <= ceilRight; i += Delta) {
      counter++;
      //if (counter%2=== 0 && i !==1){
      let theCoords = theCanvas.coordsMathScreenToScreen([i, 0]);
      theSurface.fillText(i, theCoords[0], theCoords[1] + 10);
      //}
    }
    counter = 0;
    for (let i = floorBottom; i <= ceilTop; i += Delta) {
      counter++;
      //if (counter%2=== 0 && i !==1){
      let theCoords = theCanvas.coordsMathScreenToScreen([0, i]);
      theSurface.fillText(i, theCoords[0] - 10, theCoords[1]);
      //}
    }
  }
}

class PlotTwoD {
  constructor(inputTheFn, inputLeftPt, inputRightPt, inputNumSegments, inputColor, inputLineWidth) {
    this.theFunction = inputTheFn;
    this.leftPt = inputLeftPt;
    this.rightPt = inputRightPt;
    this.color = colorToRGB(inputColor);
    if (inputLineWidth === undefined) {
      this.lineWidth = 1;
    } else {
      this.lineWidth = inputLineWidth;
    }
    this.type = "plotFunction";
    this.numSegments = inputNumSegments;
    if (inputRightPt !== "infinity" && inputLeftPt !== "minusInfinity") {
      this.Delta = (inputRightPt - inputLeftPt) / inputNumSegments;
    }
  }

  accountBoundingBox(inputOutputBox) {
    for (let i = 0; i < this.numSegments; i++) {
      let theRatio = i / (this.numSegments - 1);
      let theX = this.leftPt * (1 - theRatio) + this.rightPt * theRatio;
      let theY = this.theFunction(theX);
      if (!isFinite(theY)) {
        continue;
      }
      if (Math.abs(theY) > 100000) {
        continue;
      }
      accountBoundingBox([theX, theY], inputOutputBox);
    }
  }

  drawNoFinish(theCanvas, startByMoving) {
    let theSurface = theCanvas.surface;
    theSurface.strokeStyle = colorRGBToString(this.color);
    theSurface.fillStyle = colorRGBToString(this.color);
    let realLeft = this.leftPt;
    let realRight = this.rightPt;
    if (realLeft === "minusInfinity") {
      realLeft = theCanvas.leftMostPlotPoint;
    }
    if (this.rightPt === "infinity" || this.leftPt === "minusInfinity") {
      if (realRight === "infinity") {
        realRight = theCanvas.rightMostPlotPoint;
      }
      this.Delta = (realRight - realLeft) / this.numSegments;
    }
    let theX = realLeft;
    let theY = this.theFunction(theX);
    let theCoords = theCanvas.coordsMathToScreen([theX, theY]);
    let alreadyMoved = false;
    if (startByMoving) {
      alreadyMoved = true;
    }
    theSurface.lineWidth = this.lineWidth;
    let skippedValues = false;
    for (let i = 0; i < this.numSegments; i++) {
      let theRatio = i / (this.numSegments - 1);
      theX = realLeft * (1 - theRatio) + realRight * theRatio; //<- this way of
      //computing x this way introduces smaller numerical errors.
      //For example, suppose you plot sqrt(1-x^2) from - 1 to 1.
      //If not careful with rounding errors,
      //you may end up evaluating sqrt(1-x^2) for x =1.00000000000004
      //resulting in serious visual glitches.
      //Note: the remarks above were discovered the painful way (trial and error).
      theY = this.theFunction(theX);
      if (!isFinite(theY)) {
        console.log('Failed to evaluate: ' + this.theFunction + ' at x = ' + theX);
      }
      if (Math.abs(theY) > 10000) {
        if (!skippedValues) {
          console.log('Function result: ' + theY + " is too large, skipping. Further errors suppressed.");
        }
        skippedValues = true;
        continue;
      }
      theCoords = theCanvas.coordsMathToScreen([theX, theY]);
      if (!alreadyMoved) {
        alreadyMoved = true;
        theSurface.moveTo(theCoords[0], theCoords[1]);
      } else {
        theSurface.lineTo(theCoords[0], theCoords[1]);
      }
    }
  }

  draw(theCanvas) {
    let theSurface = theCanvas.surface;
    theSurface.beginPath();
    this.drawNoFinish(theCanvas, true);
    theSurface.stroke();
  }
}

class TextPlotTwoD {
  constructor(inputLocation, inputText, inputColor) {
    this.location = inputLocation;
    this.text = inputText;
    this.color = colorToRGB(inputColor);
    this.type = "plotText";
  }

  accountBoundingBox(inputOutputBox) {
    accountBoundingBox(this.location, inputOutputBox);
  }

  drawNoFinish(theCanvas) {
    let theSurface = theCanvas.surface;
    theSurface.strokeStyle = colorRGBToString(this.color);
    theSurface.fillStyle = colorRGBToString(this.color);
    let theCoords = theCanvas.coordsMathToScreen(this.location);
    theSurface.fillText(this.text, theCoords[0], theCoords[1]);
  }

  draw(theCanvas) {
    let theSurface = theCanvas.surface;
    theSurface.beginPath();
    this.drawNoFinish(theCanvas);
    theSurface.stroke();
  }
}

class VectorFieldTwoD {
  constructor(
    inputField,
    inputIsDirectionField,
    inputLowLeft,
    inputHighRight,
    inputNumSegmentsXY,
    inputDesiredLengthDirectionVectors,
    inputColor,
    inputLineWidth,
  ) {
    this.theField = inputField;
    this.isDirectionField = inputIsDirectionField;
    this.lowLeft = inputLowLeft;
    this.highRight = inputHighRight;
    this.numSegmentsXY = inputNumSegmentsXY;
    this.desiredLengthDirectionVectors = inputDesiredLengthDirectionVectors;
    this.color = colorToRGB(inputColor);
    this.lineWidth = inputLineWidth;
  }

  accountBoundingBox(inputOutputBox) {
    accountBoundingBox(this.lowLeft, inputOutputBox);
    accountBoundingBox(this.highRight, inputOutputBox);
  }

  draw(theCanvas) {
    let theSurface = theCanvas.surface;
    theSurface.beginPath();
    theSurface.strokeStyle = colorRGBToString(this.color);
    theSurface.fillStyle = colorRGBToString(this.color);
    theSurface.lineWidth = this.lineWidth;
    for (let i = 0; i < this.numSegmentsXY[0]; i++) {
      let theRatioX = i / (this.numSegmentsXY[0] - 1);
      let theX = this.lowLeft[0] * (1 - theRatioX) + this.highRight[0] * theRatioX;
      for (let j = 0; j < this.numSegmentsXY[1]; j++) {
        let theRatioY = j / (this.numSegmentsXY[1] - 1);
        let theY = this.lowLeft[1] * (1 - theRatioY) + this.highRight[1] * theRatioY;
        let theV = this.theField(theX, theY);
        if (this.isDirectionField) {
          if (vectorLength(theV) !== 0) {
            vectorTimesScalar(theV, this.desiredLengthDirectionVectors * 1 / vectorLength(theV));
          }
        }
        let headMath = [theX + theV[0] / 2, theY + theV[1] / 2];
        let tailMath = [theX - theV[0] / 2, theY - theV[1] / 2];
        let headScreen = theCanvas.coordsMathToScreen(headMath);
        let tailScreen = theCanvas.coordsMathToScreen(tailMath);
        let baseScreen = theCanvas.coordsMathToScreen([theX, theY]);
        theSurface.moveTo(tailScreen[0], tailScreen[1]);
        theSurface.lineTo(headScreen[0], headScreen[1]);
        theSurface.stroke();
        //theSurface.moveTo(baseScreen[0], baseScreen[1]);
        //theSurface.arc(baseScreen[0], baseScreen[1],0.5, 0, Math.PI*2);
        //theSurface.fill();
      }
    }
  }
}

class SegmentTwoD {
  constructor(inputLeftPt, inputRightPt, inputColor, inputLineWidth) {
    this.leftPt = inputLeftPt;
    this.rightPt = inputRightPt;
    this.color = colorToRGB(inputColor);
    this.type = "segment";
    this.lineWidth = inputLineWidth;
  }

  accountBoundingBox(inputOutputBox) {
    accountBoundingBox(this.leftPt, inputOutputBox);
    accountBoundingBox(this.rightPt, inputOutputBox);
  }

  drawNoFinish(theCanvas, startByMoving) {
    let theSurface = theCanvas.surface;
    let theCoords = theCanvas.coordsMathToScreen(this.leftPt);
    theSurface.lineWidth = this.lineWidth;
    if (startByMoving) {
      theSurface.moveTo(theCoords[0], theCoords[1]);
    } else {
      theSurface.lineTo(theCoords[0], theCoords[1]);
    }
    theCoords = theCanvas.coordsMathToScreen(this.rightPt);
    theSurface.lineTo(theCoords[0], theCoords[1]);
  }

  draw(theCanvas) {
    let theSurface = theCanvas.surface;
    theSurface.beginPath();
    theSurface.strokeStyle = colorRGBToString(this.color);
    theSurface.fillStyle = colorRGBToString(this.color);
    this.drawNoFinish(theCanvas, true);
    theSurface.stroke();
  }
}

class PlotFillTwoD {
  constructor(inputCanvas, inputColor) {
    this.indexFillStart = inputCanvas.theObjects.length;
    this.color = colorToRGB(inputColor);
  }

  accountBoundingBox(inputOutputBox) {
  }

  draw(inputCanvas) {
    let theSurface = inputCanvas.surface;
    let theObs = inputCanvas.theObjects;
    let tempCounter = inputCanvas.numDrawnObjects;
    theSurface.beginPath();
    let firstRun = true;
    for (tempCounter++; tempCounter < theObs.length; tempCounter++) {
      let currentO = theObs[tempCounter];
      if (currentO.type === "plotFillFinish") {
        break;
      }
      currentO.drawNoFinish(inputCanvas, firstRun);
      firstRun = false;
    }
    theSurface.fillStyle = colorRGBToString(this.color);
    theSurface.fill();
    for (inputCanvas.numDrawnObjects++; inputCanvas.numDrawnObjects < theObs.length; inputCanvas.numDrawnObjects++) {
      let currentO = theObs[inputCanvas.numDrawnObjects];
      if (currentO.type === "plotFillFinish") {
        break;
      }
      currentO.draw(inputCanvas);
    }
  }
}

class CanvasTwoD {
  constructor(inputCanvas) {
    this.canvasResetFunction = null;
    this.theObjects = [];
    this.surface = null;
    this.canvasContainer = null;
    this.canvasId = null;
    this.screenBasisOrthonormal = [];
    this.spanMessages = null;
    this.spanCriticalErrors = null;
    this.spanControls = null;
    this.numDrawnObjects = 0;
    this.boundingBoxMath = [[- 0.1, - 0.1], [0.1, 0.1]];
    this.leftMostPlotPoint = "none";
    this.rightMostPlotPoint = "none";
    this.width = inputCanvas.width;
    this.height = inputCanvas.height;
    this.centerCanvasX = inputCanvas.width / 2;
    this.centerCanvasY = inputCanvas.height / 2;
    this.centerX = this.centerCanvasX;
    this.centerY = this.centerCanvasY;
    this.viewWindowDefault = [[- 5, - 5], [5, 5]];
    this.scale = 50;
    this.mousePosition = [];
    this.clickedPosition = [];
    this.positionDelta = [];
    this.spanMessages = undefined;
    this.textMouseInfo = "";
    this.textProjectionInfo = "";
    this.textPatchInfo = "";
    this.textErrors = "";
    this.textPerformance = "";
    this.selectedElement = "";
    this.redrawStart = 0;
    this.redrawFinish = 0;
    this.redrawTime = 0;
    this.defaultNumSegmentsPerContour = 10;
    this.flagShowPerformance = true;
    this.flagShowAxesTicks = false;
    this.flagShowGrid = false;
  }

  drawPoints(inputPoints, inputColor) {
    this.theObjects.push(new PointsTwoD(inputPoints, inputColor));
  }

  drawLine(inputLeftPt, inputRightPt, inputColor, inputLineWidth) {
    let newLine = new SegmentTwoD(inputLeftPt, inputRightPt, inputColor, inputLineWidth);
    this.theObjects.push(newLine);
  }

  drawGrid() {
    this.flagShowAxesTicks = true;
    this.flagShowGrid = true;
    this.theObjects.push(new AxesGrid());
  }

  drawCoordinateAxes() {
    this.theObjects.push(new DrawCoordinateAxesTwoD());
  }

  drawVectorField(
    inputField,
    inputIsDirectionField,
    inputLowLeft,
    inputHighRight,
    inputNumSegmentsXY,
    inputDesiredLengthDirectionVectors,
    inputColor,
    inputLineWidth,
  ) {
    let newLine = new VectorFieldTwoD(
      inputField,
      inputIsDirectionField,
      inputLowLeft,
      inputHighRight,
      inputNumSegmentsXY,
      inputDesiredLengthDirectionVectors,
      inputColor,
      inputLineWidth,
    );
    this.theObjects.push(newLine);
  }

  drawPath(inputPath, inputColor, inputLineWidth) {
    let newPath = new PathTwoD(inputPath, inputColor, inputColor, inputLineWidth);
    this.theObjects.push(newPath);
  }

  drawPathFilled(inputPath, inputContourColor, inputFillColor) {
    let newPath = new PathTwoD(inputPath, inputContourColor, inputFillColor);
    newPath.isFilled = true;
    this.theObjects.push(newPath);
  }

  drawFunction(inputFun, inputLeftPt, inputRightPt, inputNumSegments, inputColor, inputLineWidth) {
    let newPlot = new PlotTwoD(inputFun, inputLeftPt, inputRightPt, inputNumSegments, inputColor, inputLineWidth);
    if (inputLeftPt !== "minusInfinity" && inputRightPt !== "infinity") {
      if (this.leftMostPlotPoint === "none") {
        this.leftMostPlotPoint = inputLeftPt;
      } else {
        this.leftMostPlotPoint = Math.min(inputLeftPt, this.leftMostPlotPoint);
      }
      if (this.rightMostPlotPoint === "none") {
        this.rightMostPlotPoint = inputRightPt;
      } else {
        this.rightMostPlotPoint = Math.max(inputRightPt, this.rightMostPlotPoint);
      }
    }
    this.theObjects.push(newPlot);
  }

  drawCurve(inputCoordinateFuns, inputLeftPt, inputRightPt, inputNumSegments, inputColor, inputLineWidth) {
    let newPlot = new CurveTwoD(inputCoordinateFuns, inputLeftPt, inputRightPt, inputNumSegments, inputColor, inputLineWidth);
    this.theObjects.push(newPlot);
  }

  drawText(inputLocation, inputText, inputColor) {
    let newPlot = new TextPlotTwoD(inputLocation, inputText, inputColor);
    this.theObjects.push(newPlot);
  }

  plotFillStart(inputColor) {
    this.theObjects.push(new PlotFillTwoD(this, inputColor));
  }

  plotFillFinish() {
    this.theObjects.push({ type: "plotFillFinish" });
  }

  computeViewWindow() {
    this.boundingBoxMath = [[- 0.1, - 0.1], [0.1, 0.1]];
    for (let i = 0; i < this.theObjects.length; i++) {
      if (this.theObjects[i].accountBoundingBox === undefined) {
        continue;
      }
      this.theObjects[i].accountBoundingBox(this.boundingBoxMath);
    }
    vectorTimesScalar(this.boundingBoxMath[0], 1.05);
    vectorTimesScalar(this.boundingBoxMath[1], 1.05);
    this.setViewWindow(this.boundingBoxMath[0], this.boundingBoxMath[1]);
  };

  setViewWindow(leftLowPt, rightUpPt) {
    this.viewWindowDefault = [leftLowPt, rightUpPt];
    let leftLowScreen = this.coordsMathToScreen(leftLowPt);
    let rightUpScreen = this.coordsMathToScreen(rightUpPt);
    let desiredHeight = Math.abs(rightUpScreen[1] - leftLowScreen[1]);
    let desiredWidth = Math.abs(rightUpScreen[0] - leftLowScreen[0]);
    let candidateScaleHeight = this.scale * this.height / desiredHeight;
    let candidateScaleWidth = this.scale * this.width / desiredWidth;
    this.scale = Math.min(candidateScaleHeight, candidateScaleWidth);
    //console.log("new scale: "+ this.scale);
    let centerViewWindowMath = vectorPlusVector(leftLowPt, rightUpPt);
    vectorTimesScalar(centerViewWindowMath, 0.5);
    let centerViewWindowScreen = this.coordsMathToScreen(centerViewWindowMath);
    this.centerX += this.centerCanvasX - centerViewWindowScreen[0];
    this.centerY += this.centerCanvasY - centerViewWindowScreen[1];
  }

  redraw() {
    this.textPerformance = "";
    this.redrawStart = new Date().getTime();
    let theSurface = this.surface;
    theSurface.clearRect(0, 0, this.width, this.height);
    for (this.numDrawnObjects = 0; this.numDrawnObjects < this.theObjects.length; this.numDrawnObjects++) {
      this.theObjects[this.numDrawnObjects].draw(this);
    }
    let redrawTime = new Date().getTime();
    if (this.flagShowPerformance) {
      this.textPerformance = "Redraw time (ms): " + (redrawTime - this.redrawStart);
      this.showMessages();
    }
  }

  computeBasis() {
    this.screenBasisOrthonormal[0] = [1, 0];
    this.screenBasisOrthonormal[1] = [0, 1];
    this.textProjectionInfo = "";
    this.textProjectionInfo += `<br>e1: ${this.screenBasisOrthonormal[0]} <br>e2: ${this.screenBasisOrthonormal[1]}`;
  }

  initialize(inputCanvasId) {
    this.canvasId = inputCanvasId;
    this.canvasContainer = document.getElementById(inputCanvasId);
    this.surface = this.canvasContainer.getContext("2d");
    this.canvasContainer.addEventListener("DOMMouseScroll", drawing.mouseWheel.bind(drawing), false);
    this.canvasContainer.addEventListener("mousewheel", drawing.mouseWheel.bind(drawing), false);
    this.canvasContainer.addEventListener("mousedown", drawing.canvasClick.bind(drawing, this.canvasContainer), true);
    this.canvasContainer.addEventListener("mouseup", drawing.mouseUp.bind(drawing, this.canvasContainer), true);
    this.canvasContainer.addEventListener("mousemove", drawing.mouseMoveRedraw.bind(drawing, this.canvasContainer), true);

    this.theObjects = [];
    this.spanMessages = document.getElementById(this.canvasId + "Messages");
    this.spanCriticalErrors = document.getElementById(this.canvasId + "CriticalErrors");
    this.spanControls = document.getElementById(this.canvasId + "Controls");
    this.constructControls();
    this.computeBasis();
  }

  resetView() {
    this.setViewWindow(this.viewWindowDefault[0], this.viewWindowDefault[1]);
    this.redraw();
  }

  constructControls() {
    drawing.numberOfControlsConstructed++;
    let controlButtonId = `buttonControlCanvas${drawing.numberOfControlsConstructed}`;
    this.spanControls.innerHTML = `<button id = "${controlButtonId}" style = "border:none; background:none; color:blue; padding:0; text-decoration: underline; cursor:pointer" >reset view</button> `;
    document.getElementById(controlButtonId).addEventListener('click', this.resetView.bind(this));
  }

  coordsMathScreenToMath(theCoords) {
    let output = this.screenBasisOrthonormal[0].slice();
    vectorTimesScalar(output, theCoords[0]);
    vectorAddVectorTimesScalar(output, this.screenBasisOrthonormal[1], theCoords[1]);
    return output;
  }

  coordsMathToMathScreen(vector) {
    return [
      vectorScalarVector(vector, this.screenBasisOrthonormal[0]),
      vectorScalarVector(vector, this.screenBasisOrthonormal[1])
    ];
  }

  coordsMathToScreen(vector) {
    return [
      this.scale * vectorScalarVector(vector, this.screenBasisOrthonormal[0]) + this.centerX,
      (- 1) * this.scale * vectorScalarVector(vector, this.screenBasisOrthonormal[1]) + this.centerY
    ];
  }

  coordsScreenAbsoluteToScreen(screenX, screenY) {
    return getPosXPosYObject(this.canvasContainer, screenX, screenY);
  }

  coordsScreenToMathScreen(screenPos) {
    return [
      (screenPos[0] - this.centerX) / this.scale,
      (this.centerY - screenPos[1]) / this.scale
    ];
  }

  coordsScreenAbsoluteToMathScreen(screenX, screenY) {
    return this.coordsScreenToMathScreen(this.coordsScreenAbsoluteToScreen(screenX, screenY));
  }

  coordsMathScreenToScreen(theCoords) {
    return [this.scale * theCoords[0] + this.centerX, this.centerY - this.scale * theCoords[1]];
  }

  mouseWheel(wheelDelta, screenX, screenY) {
    let screenPos = this.coordsScreenAbsoluteToScreen(screenX, screenY);
    let mathScreenPos = this.coordsScreenToMathScreen(screenPos);
    if (wheelDelta / this.scale > 0.1) {
      wheelDelta = this.scale * 0.1;
    }
    if (wheelDelta / this.scale < - 0.1) {
      wheelDelta = - this.scale * 0.1;
    }
    this.scale += wheelDelta;
    if (this.scale <= 0) {
      this.scale = 1;
    }
    let intermediateScreenPos = this.coordsMathScreenToScreen(mathScreenPos);
    //console.log("start screen: "+[screenX, screenY]);
    //console.log("intermed. screen: "+ intermediateScreenPos);
    this.centerX = this.centerX + screenPos[0] - intermediateScreenPos[0];
    this.centerY = this.centerY + screenPos[1] - intermediateScreenPos[1];
    this.redraw();
  }

  mouseMove(screenX, screenY) {
    if (this.selectedElement === "") {
      return;
    }
    this.mousePosition = this.coordsScreenAbsoluteToMathScreen(screenX, screenY);
    if (this.selectedElement === "origin") {
      this.panAfterCursor();
    }
    this.redrawFinish = new Date().getTime();
    this.redrawTime = this.redrawFinish - this.redrawStart;
  }

  panAfterCursor() {
    let difference = vectorMinusVector(this.mousePosition, this.clickedPosition);
    this.centerX += difference[0] * this.scale;
    this.centerY -= difference[1] * this.scale;
    this.redraw();
  }

  pointsWithinClickTolerance(leftXY, rightXY) {
    let squaredDistance = (
      (leftXY[0] - rightXY[0]) * (leftXY[0] - rightXY[0]) +
      (leftXY[1] - rightXY[1]) * (leftXY[1] - rightXY[1])
    ) * this.scale;
    return squaredDistance < 1000;
  }

  canvasClick(screenX, screenY) {
    this.clickedPosition = this.coordsScreenAbsoluteToMathScreen(screenX, screenY);
    this.mousePosition = [];
    //if (this.pointsWithinClickTolerance(this.clickedPosition,[0,0]))
    this.selectedElement = "origin";
    //else
    //  this.selectedElement ="";
    if (this.flagShowPerformance) {
      this.logStatus();
    }
  }

  selectEmpty() {
    this.selectedElement = "";
  }

  showMessages() {
    if (this.spanMessages === null || this.spanMessages === undefined) {
      return;
    }
    let theHTML = "";
    if (this.textPerformance != "") {
      theHTML += this.textPerformance + "<hr>";
    }
    if (this.textErrors !== "") {
      theHTML += `<span style =\"red\"><b>${this.textErrors}</b></span><hr>`;
    }
    theHTML += `<span>${this.textMouseInfo}</span><hr>`;
    theHTML += `<span>${this.textProjectionInfo}</span>`;
    if (this.textPatchInfo !== "") {
      theHTML += `<hr><span>${this.textPatchInfo}</span>`;
    }
    this.spanMessages.innerHTML = theHTML;
  }

  logStatus() {
    this.textMouseInfo = "";
    this.textMouseInfo += `time last redraw: ${this.redrawTime}" ms `;
    this.textMouseInfo += `(~ ${(1000 / this.redrawTime).toFixed(1)} f.p.s.)`;
    this.textMouseInfo += `<br>mouse coordinates: ${this.mousePosition}`;
    this.textMouseInfo += `<br>clicked coordinates: ${this.clickedPosition}`;
    this.textMouseInfo += `<br>delta of position: ${this.positionDelta}`;
    this.showMessages();
  }
}

class Canvas {
  constructor(inputCanvas) {
    this.canvasResetFunction = null;
    this.theIIIdObjects = {
      thePatches: [],
      theContours: [],
      thePoints: [],
      theLabels: [],
    };
    this.screenXY = [0, 0];
    this.flagShowPerformance = true;
    this.rotationModesAvailable = {
      "rotateAfterCursorDefaultGreatNormalCircle": this.rotateAfterCursorDefaultGreatNormalCircle,
    };
    this.rotationMode = "rotateAfterCursorDefaultGreatNormalCircle";

    this.thePatchOrder = [];
    this.numAccountedPatches = 0;
    this.numCyclicallyOverlappingPatchTieBreaks = 0;
    this.numContourPoints = 0;
    this.numContourPaths = 0;
    this.patchIsAccounted = [];
    this.surface = null;
    this.canvasContainer = null;
    this.canvasId = null;
    this.screenBasisUserDefault = [[2, 1, 0], [0, 1, 1]];
    this.screenBasisUser = this.screenBasisUserDefault.slice();
    this.screenNormal = [];
    this.screenBasisOrthonormal = [];
    this.zBufferColCount = 20;
    this.zBufferRowCount = 20;
    this.zBuffer = [];
    this.zBufferIndexStrip = [];
    this.bufferDeltaX = 0;
    this.bufferDeltaY = 0;
    this.colorDepthFactor = 0.4;
    this.boundingBoxMathScreen = [[- 0.01, - 0.01], [0.01, 0.01]];
    this.boundingBoxMath = [[- 0.01, - 0.01, - 0.01], [0.01, 0.01, 0.01]];
    this.boundingSegmentZ = [-0.01, 0.01];
    this.lastCenterScreen = [0, 0];
    this.width = inputCanvas.width;
    this.height = inputCanvas.height;
    this.defaultCenterX = this.width / 2;
    this.defaultCenterY = this.height / 2;
    this.centerX = this.defaultCenterX;
    this.centerY = this.defaultCenterY;
    this.scaleDefault = 50;
    this.scale = this.scaleDefault;
    this.mousePosition = [];
    // position in math coordinates, 3d.
    this.clickedPosition = [];
    this.unitRay = [];
    this.zUnit = [];
    this.rayComponent = [];
    this.positionDelta = [];
    this.spanMessages = undefined;
    this.textMouseInfo = "";
    this.textProjectionInfo = "";
    this.textPatchInfo = "";
    this.textErrors = "";
    this.textPerformance = "";
    this.angleNormal = 0;
    this.oldAngleNormal = 0;
    this.newAngleNormal = 0;
    this.anglePolar = 0;
    this.selectedElement = "";
    this.selectedVector = [];
    this.selectedScreenBasisOrthonormal = [];
    this.selectedScreenProjectionNormalized = [];
    this.selectedScreenNormal = [];
    this.selectedPolarAngleChange = 0;
    this.redrawStart = 0;
    this.redrawFinish = 0;
    this.redrawTime = 0;
    this.defaultNumSegmentsPerContour = 10;
    this.flagRoundContours = false;
    this.flagRoundPatches = true;
  }

  initialize(inputCanvasId) {
    this.canvasId = inputCanvasId;
    this.canvasContainer = document.getElementById(inputCanvasId);
    this.surface = this.canvasContainer.getContext("2d");
    this.canvasContainer.addEventListener("DOMMouseScroll", drawing.mouseWheel.bind(drawing), true);
    this.canvasContainer.addEventListener("mousewheel", drawing.mouseWheel.bind(drawing), true);
    this.canvasContainer.addEventListener("mousedown", drawing.canvasClick.bind(drawing, this.canvasContainer), true);
    this.canvasContainer.addEventListener("mouseup", drawing.mouseUp.bind(drawing, this.canvasContainer), true);
    this.canvasContainer.addEventListener("mousemove", drawing.mouseMoveRedraw.bind(drawing, this.canvasContainer), true);
    this.spanMessages = document.getElementById(`${this.canvasId}Messages`);
    this.spanCriticalErrors = document.getElementById(`${this.canvasId}CriticalErrors`);
    this.spanControls = document.getElementById(`${this.canvasId}Controls`);
    this.theIIIdObjects.thePatches = [];
    this.theIIIdObjects.theContours = [];
    this.theIIIdObjects.thePoints = [];
    this.theIIIdObjects.theLabels = [];
    this.constructControls();
    this.computeBasis();
    if (this.zBuffer.length === 0) {
      this.allocateZbuffer();
    }
  }

  drawText(theText) {
    this.theIIIdObjects.theLabels.push(theText);
  }

  drawCurve(theCurve) {
    let contourPoints = new Array(theCurve.numSegments + 1);
    for (let i = 0; i < theCurve.numSegments + 1; i++) {
      let theRatio = i / theCurve.numSegments;
      let currentParam = theCurve.leftPt * (1 - theRatio) + theCurve.rightPt * theRatio;
      contourPoints[i] = theCurve.coordinateFunctions(currentParam);
    }
    this.theIIIdObjects.theContours.push(new Contour(contourPoints, theCurve.color, theCurve.lineWidth));
  }

  drawPatchStraight(base, edge1, edge2, color) {
    this.theIIIdObjects.thePatches.push(new Patch(base, edge1, edge2, color));
    let patchIndex = this.theIIIdObjects.thePatches.length - 1;
    let thePatch = this.theIIIdObjects.thePatches[patchIndex];
    thePatch.index = patchIndex;
    let theContours = this.theIIIdObjects.theContours;
    thePatch.adjacentContours.push(this.drawLine(thePatch.base, thePatch.v1));
    thePatch.traversalOrder.push(1);

    theContours[theContours.length - 1].adjacentPatches.push(patchIndex);
    thePatch.adjacentContours.push(this.drawLine(thePatch.v1, thePatch.vEnd));
    thePatch.traversalOrder.push(1);

    theContours[theContours.length - 1].adjacentPatches.push(patchIndex);
    thePatch.adjacentContours.push(this.drawLine(thePatch.vEnd, thePatch.v2));
    thePatch.traversalOrder.push(1);

    theContours[theContours.length - 1].adjacentPatches.push(patchIndex);
    thePatch.adjacentContours.push(this.drawLine(thePatch.v2, thePatch.base));
    thePatch.traversalOrder.push(1);

    theContours[theContours.length - 1].adjacentPatches.push(patchIndex);
  }

  drawPoints(inputPoints, inputColor) {
    for (let i = 0; i < inputPoints.length; i++) {
      this.theIIIdObjects.thePoints.push(new Point(inputPoints[i], inputColor));
    }
  }

  drawLine(leftPt, rightPt, inputColor, inputLineWidth) {
    let newContour = new Contour([], inputColor, inputLineWidth);
    let numSegments = this.defaultNumSegmentsPerContour;
    newContour.index = this.theIIIdObjects.theContours.length;
    let incrementVector = vectorMinusVector(rightPt, leftPt);
    if (vectorLength(incrementVector) * 10 > numSegments) {
      numSegments = Math.ceil(vectorLength(incrementVector) * 10);
    }
    newContour.thePoints = new Array(numSegments);
    let incrementScalar = 1 / numSegments;
    vectorTimesScalar(incrementVector, incrementScalar);
    let currentPoint = leftPt.slice();
    for (let i = 0; i < numSegments + 1; i++) {
      newContour.thePoints[i] = currentPoint;
      currentPoint = vectorPlusVector(currentPoint, incrementVector);
    }
    this.theIIIdObjects.theContours.push(newContour);
    return this.theIIIdObjects.theContours.length - 1;
  }

  computePatch(thePatch) {
    thePatch.normalScreen1 = vectorCrossVector(this.screenNormal, thePatch.edge1);
    thePatch.normalScreen2 = vectorCrossVector(this.screenNormal, thePatch.edge2);
    thePatch.normal = vectorCrossVector(thePatch.edge1, thePatch.edge2);
    thePatch.internalPoint = thePatch.base.slice();
    vectorAddVectorTimesScalar(thePatch.internalPoint, thePatch.edge1, 0.5);
    vectorAddVectorTimesScalar(thePatch.internalPoint, thePatch.edge2, 0.5);
  }

  computeContour(theContour) {
    if (theContour.thePointsMathScreen.length !== theContour.thePoints.length) {
      theContour.thePointsMathScreen = new Array(theContour.thePoints.length);
    }
    for (let i = 0; i < theContour.thePoints.length; i++) {
      theContour.thePointsMathScreen[i] = this.coordsProjectMathToMathScreen2d(theContour.thePoints[i]);
    }
  }

  pointRelativeToPatch(thePoint, thePatch) {
    if (
      vectorLength(thePatch.normalScreen1) < 0.00001 ||
      vectorLength(thePatch.normalScreen2) < 0.00001 ||
      vectorLength(thePatch.normal) < 0.00001
    ) {
      return 0;
    }
    if (
      vectorScalarVector(vectorMinusVector(thePoint, thePatch.base), thePatch.normalScreen1) *
      vectorScalarVector(vectorMinusVector(thePatch.internalPoint, thePatch.base), thePatch.normalScreen1) > 0
    ) {
      if (
        vectorScalarVector(vectorMinusVector(thePoint, thePatch.vEnd), thePatch.normalScreen1) *
        vectorScalarVector(vectorMinusVector(thePatch.internalPoint, thePatch.vEnd), thePatch.normalScreen1) > 0
      ) {
        if (
          vectorScalarVector(vectorMinusVector(thePoint, thePatch.base), thePatch.normalScreen2) *
          vectorScalarVector(vectorMinusVector(thePatch.internalPoint, thePatch.base), thePatch.normalScreen2) > 0
        ) {
          if (
            vectorScalarVector(vectorMinusVector(thePoint, thePatch.vEnd), thePatch.normalScreen2) *
            vectorScalarVector(vectorMinusVector(thePatch.internalPoint, thePatch.vEnd), thePatch.normalScreen2) > 0
          ) {
            if (
              vectorScalarVector(vectorMinusVector(thePoint, thePatch.base), thePatch.normal) *
              vectorScalarVector(this.screenNormal, thePatch.normal) <= 0
            ) {
              return - 1;
            }
            if (
              vectorScalarVector(vectorMinusVector(thePoint, thePatch.base), thePatch.normal) *
              vectorScalarVector(this.screenNormal, thePatch.normal) >= 0
            ) {
              return 1;
            }
          }
        }
      }
    }
    return 0;
  }

  pointIsBehindPatch(thePoint, thePatch) {
    return this.pointRelativeToPatch(thePoint, thePatch) === - 1;
  }

  pointIsInFrontOfPatch(thePoint, thePatch) {
    return this.pointRelativeToPatch(thePoint, thePatch) === 1;
  }

  pointIsInForeGround(thePoint, containerPatches) {
    let thePatches = this.theIIIdObjects.thePatches;
    for (let i = 0; i < thePatches.length; i++) {
      if (containerPatches.indexOf(i) !== - 1) {
        continue;
      }
      if (this.pointIsBehindPatch(thePoint, thePatches[i])) {
        return false;
      }
    }
    return true;
  }

  paintMouseInfo() {
    if (
      this.selectedElement !== "default" || this.selectedElement === undefined ||
      this.selectedVector === [] || this.selectedVector === undefined
    ) {
      return;
    }
    if (this.selectedVector.length === 0 || this.selectedVector.length === undefined) {
      return;
    }
    //    if (true)
    //      return;
    let currentPt;
    this.surface.beginPath();
    this.surface.setLineDash([4, 4]);
    this.surface.lineWidth = 2;
    this.surface.strokeStyle = "green";
    currentPt = this.coordsMathToSelectedScreen(this.selectedVector);
    this.surface.moveTo(currentPt[0], currentPt[1]);
    currentPt = this.coordsMathToSelectedScreen([0, 0, 0]);
    this.surface.lineTo(currentPt[0], currentPt[1]);
    this.surface.stroke();
    this.surface.beginPath();
    this.surface.setLineDash([]);
    this.surface.lineWidth = 2;
    this.surface.strokeStyle = "green";
    currentPt = this.coordsMathToScreen(this.selectedVector);
    this.surface.moveTo(currentPt[0], currentPt[1]);
    currentPt = this.coordsMathToScreen([0, 0, 0]);
    this.surface.lineTo(currentPt[0], currentPt[1]);
    this.surface.stroke();
  }

  paintOneContour(theContour) {
    if (theContour.thePoints.length < 2) {
      return;
    }
    let theSurface = this.surface;
    let thePts = theContour.thePoints;
    //console.log("line start\n");
    let currentPt = this.coordsMathToScreen(thePts[0]);
    if (this.flagRoundContours) {
      vectorRound(currentPt);
    }
    let oldIsInForeGround = this.pointIsInForeGround(theContour.thePoints[0], theContour.adjacentPatches);
    let newIsInForeground = true;
    let dashIsOn = false;
    theSurface.beginPath();
    theSurface.setLineDash([]);
    this.numContourPaths++;
    //    theSurface.setLineDash([]);
    theSurface.strokeStyle = colorRGBToString(theContour.color);
    if (theContour.lineWidth !== undefined) {
      theSurface.lineWidth = theContour.lineWidth;
    } else {
      theSurface.lineWidth = 1;
    }
    theSurface.moveTo(currentPt[0], currentPt[1]);
    this.numContourPoints += thePts.length;
    for (let i = 1; i < thePts.length; i++) {
      newIsInForeground = this.pointIsInForeGround(theContour.thePoints[i], theContour.adjacentPatches);
      if (!newIsInForeground && !oldIsInForeGround && !dashIsOn) {
        if (i > 1) {
          theSurface.stroke();
          theSurface.setLineDash([4, 4]);
          theSurface.beginPath();
          this.numContourPaths++;
          theSurface.moveTo(currentPt[0], currentPt[1]);
        }
        theSurface.setLineDash([4, 4]);
        dashIsOn = true;
      } else if (dashIsOn && newIsInForeground) {
        theSurface.stroke();
        theSurface.setLineDash([]);
        theSurface.beginPath();
        this.numContourPaths++;
        //theSurface.setLineDash([]);
        //console.log("removed dash\n");
        theSurface.moveTo(currentPt[0], currentPt[1]);
        dashIsOn = false;
      }
      currentPt = this.coordsMathToScreen(thePts[i]);
      if (this.flagRoundContours) {
        vectorRound(currentPt);
      }
      theSurface.lineTo(currentPt[0], currentPt[1]);
      oldIsInForeGround = newIsInForeground;
    }
    theSurface.stroke();
    /////////////////
    if (0) {
      currentPt = this.coordsMathToScreen(thePts[4]);
      if (this.flagRoundContours) {
        vectorRound(currentPt);
      }
      theSurface.font = "9pt sans-serif";
      theSurface.fillStyle = "black";
      theSurface.fillText(theContour.index, currentPt[0], currentPt[1]);
    }
    //console.log("line end\n");
  }

  paintOnePatch(thePatch) {
    let theSurface = this.surface;
    let visibilityScalarProd = vectorScalarVector(this.screenNormal, thePatch.normal);
    let depthScalarProd = vectorScalarVector(this.screenNormal, thePatch.internalPoint);
    let depthRatio = (depthScalarProd - this.boundingSegmentZ[0]) / (this.boundingSegmentZ[1] - this.boundingSegmentZ[0]) - 0.5;
    //depthRatio is a number between -0.5 and 0.5 measuring how deep is the patch
    //relative to the center of the picture
    let colorFactor = 1 + depthRatio * this.colorDepthFactor;
    if (visibilityScalarProd >= 0) {
      theSurface.fillStyle = colorRGBToString(colorScale(thePatch.colorUV, colorFactor));
    } else {
      theSurface.fillStyle = colorRGBToString(colorScale(thePatch.colorVU, colorFactor));
    }
    theSurface.beginPath();
    /*    if (0)
      { var
        theCoords = this.coordsMathToScreen(thePatch.base);
        theSurface.moveTo(Math.round(theCoords[0]), Math.round(theCoords[1]));
        theCoords = this.coordsMathToScreen(thePatch.v1);
        theSurface.lineTo(Math.round(theCoords[0]), Math.round(theCoords[1]));
        theCoords = this.coordsMathToScreen(thePatch.vEnd);
        theSurface.lineTo(Math.round(theCoords[0]), Math.round(theCoords[1]));
        theCoords = this.coordsMathToScreen(thePatch.v2);
        theSurface.lineTo(Math.round(theCoords[0]), Math.round(theCoords[1]));
        theCoords = this.coordsMathToScreen(thePatch.base);
        theSurface.lineTo(Math.round(theCoords[0]), Math.round(theCoords[1]));
        theSurface.fill();
        return;
      }*/
    let first = true;
    for (let i = 0; i < thePatch.adjacentContours.length; i++) {
      let currentContour = this.theIIIdObjects.theContours[thePatch.adjacentContours[i]];
      for (let j = 0; j < currentContour.thePoints.length; j++) {
        let theIndex = (thePatch.traversalOrder[i] === - 1) ? j : currentContour.thePoints.length - j - 1;
        let theCoords = this.coordsMathToScreen(currentContour.thePoints[theIndex]);
        if (this.flagRoundPatches) {
          vectorRound(theCoords);
        }
        if (first) {
          theSurface.moveTo(theCoords[0], theCoords[1]);
        } else {
          theSurface.lineTo(theCoords[0], theCoords[1]);
        }
        first = false;
      }
    }
    theSurface.closePath();
    //    theSurface.clip();
    theSurface.fill();
    if (false) {
      theCoords = this.coordsMathToScreen(thePatch.internalPoint);
      theSurface.fillStyle = "black";
      theSurface.font = "20pt sans-serif";
      theSurface.fillStyle = "cyan";
      //if (thePatch.index ===90)
      theSurface.fillText(thePatch.index, theCoords[0], theCoords[1]);
    }
    //    theSurface.stroke();
  }

  paintText(theText) {
    let theSurface = this.surface;
    let isInForeGround = this.pointIsInForeGround(theText.location, []);
    theSurface.beginPath();
    theSurface.strokeStyle = theText.color;
    let theCoords = this.coordsMathToScreen(theText.location);
    theSurface.font = "15pt sans-serif";
    theSurface.lineWidth = 1;
    if (isInForeGround) {
      theSurface.fillStyle = theText.color;
      theSurface.fillText(theText.text, theCoords[0], theCoords[1]);
    } else {
      theSurface.strokeStyle = theText.color;
      theSurface.strokeText(theText.text, theCoords[0], theCoords[1]);
    }
  }

  paintOnePoint(thePoint) {
    let theSurface = this.surface;
    let isInForeGround = this.pointIsInForeGround(thePoint.location, []);
    theSurface.beginPath();
    theSurface.strokeStyle = colorRGBToString(thePoint.color);
    theSurface.fillStyle = colorRGBToString(thePoint.color);
    let theCoords = this.coordsMathToScreen(thePoint.location);
    theSurface.arc(theCoords[0], theCoords[1], 3, 0, Math.PI * 2);
    if (isInForeGround) {
      theSurface.fill();
    } else {
      theSurface.stroke();
    }
  }

  getExtremePoint(indexToCompareBy, getLarger, pt1, pt2, pt3, pt4) {
    let result = pt1[indexToCompareBy];
    if (getLarger === 1) {
      if (result < pt2[indexToCompareBy]) {
        result = pt2[indexToCompareBy];
      }
      if (result < pt3[indexToCompareBy]) {
        result = pt3[indexToCompareBy];
      }
      if (result < pt4[indexToCompareBy]) {
        result = pt4[indexToCompareBy];
      }
    } else {
      if (result > pt2[indexToCompareBy]) {
        result = pt2[indexToCompareBy];
      }
      if (result > pt3[indexToCompareBy]) {
        result = pt3[indexToCompareBy];
      }
      if (result > pt4[indexToCompareBy]) {
        result = pt4[indexToCompareBy];
      }
    }
    return result;
  }

  coordsMathScreenToBufferIndicesROWSFloat(input) {
    return this.zBufferRowCount * (input - this.boundingBoxMathScreen[0][1]) / (this.boundingBoxMathScreen[1][1] - this.boundingBoxMathScreen[0][1]);
  }

  coordsMathScreenToBufferIndicesROWS(input) {
    let result = Math.floor(this.coordsMathScreenToBufferIndicesROWSFloat(input));
    if (result >= this.zBufferRowCount) {
      result--;
    }
    return result;
  }

  coordsMathScreenToBufferIndicesCOLSFloat(input) {
    return (this.zBufferColCount) * (input - this.boundingBoxMathScreen[0][0]) / (this.boundingBoxMathScreen[1][0] - this.boundingBoxMathScreen[0][0]);
  }

  coordsMathScreenToBufferIndicesCOLS(input) {
    let result = Math.floor(this.coordsMathScreenToBufferIndicesCOLSFloat(input));
    if (result >= this.zBufferColCount) {
      result--;
    }
    return result;
  }

  coordsMathScreenToBufferIndices(input) {
    let row = this.coordsMathScreenToBufferIndicesROWS(input[1]);
    let col = this.coordsMathScreenToBufferIndicesCOLS(input[0]);
    if (row < 0 || row >= this.zBufferRowCount || col < 0 || col >= this.zBufferColCount) {
      console.log("point with math-screen coords: " + input + " is out of the bounding box");
    }
    return [row, col];
  }

  accountOnePointMathCoordsInBufferStrip(row, thePoint, patchIndex) {
    if (row < 0 || row >= this.zBufferIndexStrip.length) {
      return;
    }
    let bufferCoords = this.coordsMathScreenToBufferIndices(this.coordsProjectMathToMathScreen2d(thePoint));
    // If there were no rounding errors, row would be equal
    // to bufferCoords[0]. However since there will be rounding errors,
    // the row is passed instead as an argument.
    if (this.zBufferIndexStrip[row][0] === - 1) {
      this.zBufferIndexStrip[row][1] = bufferCoords[1];
      this.zBufferIndexStrip[row][0] = bufferCoords[1];
      return;
    }
    if (bufferCoords[1] < this.zBufferIndexStrip[row][0]) {
      this.zBufferIndexStrip[row][0] = bufferCoords[1];
    }
    if (bufferCoords[1] > this.zBufferIndexStrip[row][1]) {
      this.zBufferIndexStrip[row][1] = bufferCoords[1];
    }
  }

  accountEdgeInBufferStrip(base, edgeVector, patchIndex) {
    let end = vectorPlusVector(base, edgeVector);
    let lowFloat = this.coordsMathScreenToBufferIndicesROWSFloat(this.coordsProjectMathToMathScreen2d(base)[1]);
    let highFloat = this.coordsMathScreenToBufferIndicesROWSFloat(this.coordsProjectMathToMathScreen2d(end)[1]);
    if (lowFloat > highFloat) {
      let minusEdge = edgeVector.slice();
      vectorTimesScalar(minusEdge, - 1);
      this.accountEdgeInBufferStrip(end, minusEdge, patchIndex);
      return;
    }
    this.accountOnePointMathCoordsInBufferStrip(Math.floor(lowFloat), base, patchIndex);
    this.accountOnePointMathCoordsInBufferStrip(Math.floor(highFloat), end, patchIndex);
    if (lowFloat === highFloat) {
      return;
    }
    let currentPoint;
    for (let i = Math.ceil(lowFloat); i < highFloat; i++) {
      currentPoint = base.slice();
      vectorAddVectorTimesScalar(currentPoint, edgeVector, (i - lowFloat) / (highFloat - lowFloat));
      this.accountOnePointMathCoordsInBufferStrip(i, currentPoint, patchIndex);
      this.accountOnePointMathCoordsInBufferStrip(i - 1, currentPoint, patchIndex);
    }
  }

  accountOnePatch(patchIndex) {
    let thePatch = this.theIIIdObjects.thePatches[patchIndex];
    let pt1 = this.coordsProjectMathToMathScreen2d(thePatch.base);
    let pt2 = this.coordsProjectMathToMathScreen2d(thePatch.v1);
    let pt3 = this.coordsProjectMathToMathScreen2d(thePatch.v2);
    let pt4 = this.coordsProjectMathToMathScreen2d(thePatch.vEnd);
    let lowFloat = this.getExtremePoint(1, 0, pt1, pt2, pt3, pt4);
    let highFloat = this.getExtremePoint(1, 1, pt1, pt2, pt3, pt4);
    let low = this.coordsMathScreenToBufferIndicesROWS(lowFloat);
    let high = this.coordsMathScreenToBufferIndicesROWS(highFloat);
    for (let i = low; i <= high; i++) {
      this.zBufferIndexStrip[i][0] = - 1;
      this.zBufferIndexStrip[i][1] = - 1;
    }
    this.accountEdgeInBufferStrip(thePatch.base, thePatch.edge1, patchIndex);
    this.accountEdgeInBufferStrip(thePatch.base, thePatch.edge2, patchIndex);
    this.accountEdgeInBufferStrip(thePatch.v1, thePatch.edge2, patchIndex);
    this.accountEdgeInBufferStrip(thePatch.v2, thePatch.edge1, patchIndex);
    for (let i = low; i <= high; i++) {
      for (let j = this.zBufferIndexStrip[i][0]; j <= this.zBufferIndexStrip[i][1]; j++) {
        if (i === - 1 || j === - 1) {
          continue;
        }
        this.zBuffer[i][j].push(patchIndex);
      }
    }
  }

  computeBoundingBoxAccountPoint(input) {
    let theV = this.coordsProjectMathToMathScreen2d(input);
    for (let i = 0; i < 2; i++) {
      if (theV[i] < this.boundingBoxMathScreen[0][i]) {
        this.boundingBoxMathScreen[0][i] = theV[i];
      }
    }
    for (let i = 0; i < 2; i++) {
      if (theV[i] > this.boundingBoxMathScreen[1][i]) {
        this.boundingBoxMathScreen[1][i] = theV[i];
      }
    }
    for (let i = 0; i < 3; i++) {
      if (input[i] < this.boundingBoxMath[0][i]) {
        this.boundingBoxMath[0][i] = input[i];
      }
    }
    for (let i = 0; i < 3; i++) {
      if (input[i] > this.boundingBoxMath[1][i]) {
        this.boundingBoxMath[1][i] = input[i];
      }
    }
    let theScalarProd = vectorScalarVector(this.screenNormal, input);
    if (theScalarProd < this.boundingSegmentZ[0]) {
      this.boundingSegmentZ[0] = theScalarProd;
    }
    if (theScalarProd > this.boundingSegmentZ[1]) {
      this.boundingSegmentZ[1] = theScalarProd;
    }
  }

  computeBoundingBox() {
    let thePatches = this.theIIIdObjects.thePatches;
    let theContours = this.theIIIdObjects.theContours;
    let thePoints = this.theIIIdObjects.thePoints;
    for (let i = 0; i < thePatches.length; i++) {
      this.computeBoundingBoxAccountPoint(thePatches[i].base);
      this.computeBoundingBoxAccountPoint(thePatches[i].v1);
      this.computeBoundingBoxAccountPoint(thePatches[i].v2);
      this.computeBoundingBoxAccountPoint(thePatches[i].vEnd);
    }
    for (let i = 0; i < theContours.length; i++) {
      for (let j = 0; j < theContours[i].thePoints.length; j++) {
        this.computeBoundingBoxAccountPoint(theContours[i].thePoints[j]);
      }
    }
    for (let i = 0; i < thePoints.length; i++) {
      this.computeBoundingBoxAccountPoint(thePoints[i].location);
    }
  }

  computeBuffers() {
    let thePatches = this.theIIIdObjects.thePatches;
    for (let i = 0; i < this.zBuffer.length; i++) {
      for (let j = 0; j < this.zBuffer[i].length; j++) {
        this.zBuffer[i][j].length = 0;
      }
    }
    this.computeBoundingBox();
    this.bufferDeltaX = (this.boundingBoxMathScreen[1][0] - this.boundingBoxMathScreen[0][0]) / this.zBufferColCount;
    this.bufferDeltaY = (this.boundingBoxMathScreen[1][1] - this.boundingBoxMathScreen[0][1]) / this.zBufferRowCount;
    for (let i = 0; i < thePatches.length; i++) {
      this.accountOnePatch(i);
    }
    this.computePatchOrder();
  }

  computePatchOrderOneContourPoint(thePatch, theContour, ptIndex) {
    let thePointMathScreen = theContour.thePointsMathScreen[ptIndex];
    let thePoint = theContour.thePoints[ptIndex];
    let theIndices = this.coordsMathScreenToBufferIndices(thePointMathScreen);
    let currentBuffer = this.zBuffer[theIndices[0]][theIndices[1]];
    let thePatches = this.theIIIdObjects.thePatches;
    for (let i = 0; i < currentBuffer.length; i++) {
      if (thePatch.index === currentBuffer[i]) {
        continue;
      }
      if (
        thePatch.patchesAboveMe.indexOf(currentBuffer[i]) >= 0 ||
        thePatch.patchesBelowMe.indexOf(currentBuffer[i]) >= 0
      ) {
        continue;
      }
      let otherPatch = thePatches[currentBuffer[i]];
      let relativePosition = this.pointRelativeToPatch(thePoint, otherPatch);
      if (relativePosition === - 1) {
        otherPatch.patchesBelowMe.push(thePatch.index);
        thePatch.patchesAboveMe.push(currentBuffer[i]);
      } else if (relativePosition === 1) {
        otherPatch.patchesAboveMe.push(thePatch.index);
        thePatch.patchesBelowMe.push(currentBuffer[i]);
      }
    }
  }

  computePatchPartialOrderOnePatch(thePatch) {
    let theContours = this.theIIIdObjects.theContours;
    for (let i = 0; i < thePatch.adjacentContours.length; i++) {
      for (let j = 0; j < theContours[thePatch.adjacentContours[i]].thePoints.length; j++) {
        this.computePatchOrderOneContourPoint(thePatch, theContours[thePatch.adjacentContours[i]], j);
      }
    }
  }

  computePatchPartialOrder() {
    let thePatches = this.theIIIdObjects.thePatches;
    for (let i = 0; i < thePatches.length; i++) {
      thePatches[i].patchesBelowMe = [];
      thePatches[i].patchesAboveMe = [];
    }
    for (let i = 0; i < thePatches.length; i++) {
      this.computePatchPartialOrderOnePatch(thePatches[i]);
    }
  }

  computePatchOrder() {
    this.computePatchPartialOrder();
    let thePatches = this.theIIIdObjects.thePatches;
    if (this.thePatchOrder.length !== thePatches.length) {
      this.thePatchOrder = new Array(thePatches.length);
      this.patchIsAccounted = new Array(thePatches.length);
    }
    for (let i = 0; i < thePatches.length; i++) {
      this.thePatchOrder[i] = - 1;
      this.patchIsAccounted[i] = 0;
    }
    this.numAccountedPatches = 0;
    for (let i = 0; i < thePatches.length; i++) {
      if (thePatches[i].patchesBelowMe.length === 0) {
        this.thePatchOrder[this.numAccountedPatches] = i;
        this.numAccountedPatches++;
        this.patchIsAccounted[i] = 1;
      }
    }
    this.numCyclicallyOverlappingPatchTieBreaks = 0;
    while (this.numAccountedPatches < thePatches.length) {
      let currentIndex = 0;
      while (currentIndex < this.numAccountedPatches) {
        let currentPatch = thePatches[this.thePatchOrder[currentIndex]];
        for (let i = 0; i < currentPatch.patchesAboveMe.length; i++) {
          let nextIndex = currentPatch.patchesAboveMe[i];
          if (this.patchIsAccounted[nextIndex] === 1) {
            continue;
          }
          let nextPatch = thePatches[nextIndex];
          let isGood = 1;
          for (let j = 0; j < nextPatch.patchesBelowMe.length; j++) {
            if (this.patchIsAccounted[nextPatch.patchesBelowMe[j]] !== 1) {
              isGood = 0;
              break;
            }
          }
          if (isGood === 1) {
            this.thePatchOrder[this.numAccountedPatches] = nextIndex;
            this.numAccountedPatches++;
            this.patchIsAccounted[nextIndex] = 1;
          }
        }
        currentIndex++;
      }
      if (this.numAccountedPatches < thePatches.length) {
        this.patchOverlapTieBreak();
      }
    }
  }

  patchOverlapTieBreak() {
    // If we have cyclically overlapping patches we break ties
    // by selecting/painting first the patches whose internal point
    // has the highest (screen) depth.
    let thePatches = this.theIIIdObjects.thePatches;
    let deepestNonAccountedIndex = - 1;
    let minDepth = 0;
    for (let i = 0; i < this.patchIsAccounted.length; i++) {
      if (this.patchIsAccounted[i] === 1) {
        continue;
      }
      if (deepestNonAccountedIndex === - 1) {
        deepestNonAccountedIndex = i;
        minDepth = vectorScalarVector(this.screenNormal, thePatches[i].internalPoint);
      }
      let currentDepth = vectorScalarVector(this.screenNormal, thePatches[i].internalPoint);
      if (currentDepth < minDepth) {
        minDepth = currentDepth;
        deepestNonAccountedIndex = i;
      }
    }
    this.numCyclicallyOverlappingPatchTieBreaks++;
    this.thePatchOrder[this.numAccountedPatches] = deepestNonAccountedIndex;
    this.numAccountedPatches++;
    this.patchIsAccounted[deepestNonAccountedIndex] = 1;
  }

  allocateZbuffer() {
    if (this.zBufferRowCount < 1) {
      this.zBufferRowCount = 1;
    }
    if (this.zBufferColCount < 1) {
      this.zBufferColCount = 1;
    }
    if (this.zBuffer.length < this.zBufferRowCount) {
      this.zBuffer = new Array(this.zBufferRowCount);
      this.zBufferIndexStrip = new Array(this.zBufferRowCount);
      for (let i = 0; i < this.zBufferRowCount; i++) {
        this.zBuffer[i] = new Array(this.zBufferColCount);
        for (let j = 0; j < this.zBufferColCount; j++) {
          this.zBuffer[i][j] = [];
        }
        this.zBufferIndexStrip[i] = [- 1, - 1];
      }
    }
  }

  getBufferBox(row, col) {
    return [
      [this.boundingBoxMathScreen[0][0] + this.bufferDeltaX * col, this.boundingBoxMathScreen[0][1] + this.bufferDeltaY * row],
      [this.boundingBoxMathScreen[0][0] + this.bufferDeltaX * (col + 1), this.boundingBoxMathScreen[0][1] + this.bufferDeltaY * (row + 1)]
    ];
  }

  paintZbuffer() {
    let theSurface = this.surface;
    theSurface.strokeStyle = "gray";
    theSurface.fillStyle = "black";
    theSurface.setLineDash([]);
    for (let i = 0; i < this.zBuffer.length; i++) {
      for (let j = 0; j < this.zBuffer[i].length; j++) {
        let bufferBox = this.getBufferBox(i, j);
        let bufferBoxLowLeft = this.coordsMathScreenToScreen(bufferBox[0]);
        let bufferBoxTopRight = this.coordsMathScreenToScreen(bufferBox[1]);
        theSurface.beginPath();
        theSurface.moveTo(bufferBoxLowLeft[0], bufferBoxLowLeft[1]);
        theSurface.lineTo(bufferBoxTopRight[0], bufferBoxLowLeft[1]);
        theSurface.lineTo(bufferBoxTopRight[0], bufferBoxTopRight[1]);
        theSurface.lineTo(bufferBoxLowLeft[0], bufferBoxTopRight[1]);
        theSurface.lineTo(bufferBoxLowLeft[0], bufferBoxLowLeft[1]);
        theSurface.stroke();
        if (this.zBuffer[i][j].length !== 0) {
          theSurface.fill();
        }
      }
    }
  }

  computeBasisFromNormal(inputNormal) {
    if (inputNormal[0] !== 0) {
      this.screenBasisUser[0] = [- inputNormal[1], inputNormal[0], 0];
      this.screenBasisUser[1] = [- inputNormal[2], 0, inputNormal[0]];
    } else if (inputNormal[1] !== 0) {
      this.screenBasisUser[0] = [1, 0, 0];
      this.screenBasisUser[1] = [0, inputNormal[2], - inputNormal[1]];
    } else {
      this.screenBasisUser[0] = [1, 0, 0];
      this.screenBasisUser[1] = [0, 1, 0];
    }
  }

  infoProjectionCompute() {
    if (!this.flagShowPerformance) {
      return;
    }
    this.textProjectionInfo = "";
    this.textProjectionInfo += `<br>screen normal: ${this.screenNormal}`;
    this.textProjectionInfo += `<br>e1: ${this.screenBasisOrthonormal[0]}`;
    this.textProjectionInfo += `<br>e2: ${this.screenBasisOrthonormal[1]}`;
    this.textProjectionInfo += `<br>selected e1: ${this.selectedScreenBasisOrthonormal[0]}`;
    this.textProjectionInfo += `<br>selected e2: ${this.selectedScreenBasisOrthonormal[1]}`;
  }

  computeBasis() {
    //if (this.screenBasisOrthonormal.length<2)
    //  this.screenBasisOrthonormal.length =2;
    this.screenBasisOrthonormal[0] = this.screenBasisUser[0].slice();
    this.screenBasisOrthonormal[1] = this.screenBasisUser[1].slice();
    let e1 = this.screenBasisOrthonormal[0];
    let e2 = this.screenBasisOrthonormal[1];
    vectorNormalize(e1);
    vectorAddVectorTimesScalar(e2, e1, - vectorScalarVector(e1, e2));
    vectorNormalize(e2);
    this.screenNormal = vectorCrossVector(e1, e2);
  }

  setBoundingBoxAsDefaultViewWindow() {
    this.resetViewNoRedraw();
    this.computeBoundingBox();
    let leftLowScreen = this.coordsMathScreenToScreen(this.boundingBoxMathScreen[0]);
    let rightUpScreen = this.coordsMathScreenToScreen(this.boundingBoxMathScreen[1]);
    let desiredHeight = Math.abs(rightUpScreen[1] - leftLowScreen[1]) * 1.05;
    let desiredWidth = Math.abs(rightUpScreen[0] - leftLowScreen[0]) * 1.05;
    let candidateScaleHeight = this.scale * this.height / desiredHeight;
    let candidateScaleWidth = this.scale * this.width / desiredWidth;
    // console.log("leftLowScreen: "+ leftLowScreen +" rightUpScreen: "+rightUpScreen);
    // console.log(centerScreen);
    // console.log("desiredHeight: "+desiredHeight);
    // console.log("candidateScaleHeight: "+candidateScaleHeight);
    // console.log("candidateScaleWidth: "+candidateScaleWidth);
    // console.log("old scale: "+ this.scale);
    this.scale = Math.min(candidateScaleHeight, candidateScaleWidth);
    //console.log("new scale: "+ this.scale);
    let newViewWindowCenterMath = vectorPlusVector(
      this.boundingBoxMathScreen[0],
      this.boundingBoxMathScreen[1]
    );
    vectorTimesScalar(newViewWindowCenterMath, 0.5);
    let newCenterViewWindowScreenRescaled = this.coordsMathScreenToScreen(newViewWindowCenterMath);
    let oldCenterViewWindowMathScreenRescaled = this.coordsMathScreenToScreen(this.lastCenterScreen);
    this.centerX = this.centerX + oldCenterViewWindowMathScreenRescaled[0] - newCenterViewWindowScreenRescaled[0];
    this.centerY = this.centerY + oldCenterViewWindowMathScreenRescaled[1] - newCenterViewWindowScreenRescaled[1];
    this.defaultCenterX = this.centerX;
    this.defaultCenterY = this.centerY;
    this.scaleDefault = this.scale;
    this.lastCenterScreen = newViewWindowCenterMath.slice();
  }

  resetView() {
    this.resetViewNoRedraw();
    this.redraw();
  }

  resetViewNoRedraw() {
    this.boundingBoxMathScreen = [[- 0.01, - 0.01], [0.01, 0.01]];
    this.boundingBoxMath = [[- 0.01, - 0.01, - 0.01], [0.01, 0.01, 0.01]];
    this.boundingSegmentZ = [- 0.01, 0.01];
    this.screenBasisUser = this.screenBasisUserDefault.slice();
    this.centerX = this.defaultCenterX;
    this.centerY = this.defaultCenterY;
    this.scale = this.scaleDefault;
    this.computeBasis();
  }

  constructControls() {
    this.spanControls.innerHTML = '';
    let buttonElement = document.createElement("BUTTON");
    buttonElement.style = "border:none; background:none; color:blue; padding:0; text-decoration: underline; cursor:pointer";
    buttonElement.innerHTML = "reset view";
    buttonElement.addEventListener("click", this.resetView.bind(this));
    let hintElement = document.createElement("SPAN");
    hintElement.innerHTML = `<small> shift + drag to rotate</small>`;
    this.spanControls.appendChild(buttonElement);
    this.spanControls.appendChild(hintElement);
  }

  coordsInjectMathScreen2dToMath3d(theCoords) {
    let output = this.screenBasisOrthonormal[0].slice();
    vectorTimesScalar(output, theCoords[0]);
    vectorAddVectorTimesScalar(output, this.screenBasisOrthonormal[1], theCoords[1]);
    return output;
  }

  coordsProjectMathToMathSelectedScreen2d(vector) {
    return [
      vectorScalarVector(vector, this.selectedScreenBasisOrthonormal[0]),
      vectorScalarVector(vector, this.selectedScreenBasisOrthonormal[1]),
    ];
  }

  coordsProjectMathToMathScreen2d(vector) {
    return [
      vectorScalarVector(vector, this.screenBasisOrthonormal[0]),
      vectorScalarVector(vector, this.screenBasisOrthonormal[1]),
    ];
  }

  /**
   * Returns a projection in 3d of
   * of the input vector
   * to the current screen.`
   * @returns{number[]}
   */
  coordsProjectToMathScreen3d(vector) {
    let output = this.screenBasisOrthonormal[0].slice();
    vectorTimesScalar(output, vectorScalarVector(vector, this.screenBasisOrthonormal[0]));
    vectorAddVectorTimesScalar(
      output,
      this.screenBasisOrthonormal[1],
      vectorScalarVector(vector, this.screenBasisOrthonormal[1]),
    );
    return output;
  }

  /**
   * Returns a projection in 3d
   * of the input vector
   * to the selected screen.`
   * @returns{number[]}
   */
  coordsProjectToSelectedMathScreen3d(
    /**@type{number[]} */
    vector,
  ) {
    let output = this.selectedScreenBasisOrthonormal[0].slice();
    vectorTimesScalar(output, vectorScalarVector(vector, this.selectedScreenBasisOrthonormal[0]));
    vectorAddVectorTimesScalar(
      output,
      this.selectedScreenBasisOrthonormal[1],
      vectorScalarVector(vector, this.selectedScreenBasisOrthonormal[1]),
    );
    return output;
  }

  coordsMathToScreen(vector) {
    return [
      this.scale * vectorScalarVector(vector, this.screenBasisOrthonormal[0]) + this.centerX,
      (- 1) * this.scale * vectorScalarVector(vector, this.screenBasisOrthonormal[1]) + this.centerY
    ];
  }

  coordsMathToSelectedScreen(vector) {
    return [
      this.scale * vectorScalarVector(vector, this.selectedScreenBasisOrthonormal[0]) + this.centerX,
      (- 1) * this.scale * vectorScalarVector(vector, this.selectedScreenBasisOrthonormal[1]) + this.centerY
    ];
  }

  coordsScreenToMathScreen(screenPos) {
    return [(screenPos[0] - this.centerX) / this.scale, (this.centerY - screenPos[1]) / this.scale];
  }

  coordsScreenAbsoluteToScreen(cx, cy) {
    return getPosXPosYObject(this.canvasContainer, cx, cy);
  }

  coordsScreenAbsoluteToMathScreen(screenX, screenY) {
    return this.coordsScreenToMathScreen(this.coordsScreenAbsoluteToScreen(screenX, screenY));
  }

  coordsMathScreenToScreen(theCoords) {
    return [this.scale * theCoords[0] + this.centerX, this.centerY - this.scale * theCoords[1]];
  }

  rotateOutOfPlane(input, orthoBasis1, orthoBasis2, theAngle) {
    let vComponent = input.slice();
    let scal1 = vectorScalarVector(orthoBasis1, input);
    let scal2 = vectorScalarVector(orthoBasis2, input);
    let projection = orthoBasis1.slice();
    vectorTimesScalar(projection, scal1);
    vectorAddVectorTimesScalar(projection, orthoBasis2, scal2);
    vectorAddVectorTimesScalar(vComponent, projection, - 1);
    projection = orthoBasis1.slice();
    vectorTimesScalar(projection, Math.cos(theAngle) * scal1 - Math.sin(theAngle) * scal2);
    vectorAddVectorTimesScalar(projection, orthoBasis2, Math.sin(theAngle) * scal1 + Math.sin(theAngle) * scal2);
    return vectorPlusVector(vComponent, projection);
  }

  computePositionDelta() {
    let oldX = this.clickedPosition[0];
    let oldY = this.clickedPosition[1];
    let newX = this.mousePosition[0];
    let newY = this.mousePosition[1];
    this.positionDelta = [newX - oldX, newY - oldY];
  }

  rotateAfterCursorDefaultGreatNormalCircle() {
    if (this.mousePosition.length == 0) {
      return;
    }
    this.computePositionDelta();
    this.unitRay = this.clickedPosition.slice();
    vectorNormalize(this.unitRay);
    this.rayComponent = this.unitRay.slice();
    vectorTimesScalar(this.rayComponent, vectorScalarVector(this.mousePosition, this.unitRay));
    let osculatingOldX = vectorLength(this.clickedPosition);
    let osculatingOldCos = osculatingOldX / vectorLength(this.selectedVector);
    let osculatingNewX = vectorScalarVector(this.mousePosition, this.unitRay);
    let osculatingNewCos = osculatingNewX / vectorLength(this.selectedVector);
    this.newAngleNormal = Math.acos(osculatingNewCos);
    this.oldAngleNormal = Math.acos(osculatingOldCos);
    this.angleNormal = this.oldAngleNormal - this.newAngleNormal;
    if (isNaN(this.angleNormal)) {
      return;
    }
    let newE1 = this.selectedScreenBasisOrthonormal[0].slice();
    let newE2 = this.selectedScreenBasisOrthonormal[1].slice();
    newE1 = this.rotateOutOfPlane(newE1, this.selectedScreenProjectionNormalized, this.selectedScreenNormal, this.angleNormal);
    newE2 = this.rotateOutOfPlane(newE2, this.selectedScreenProjectionNormalized, this.selectedScreenNormal, this.angleNormal);
    this.screenBasisUser[0] = newE1.slice();
    this.screenBasisUser[1] = newE2.slice();
    this.computeBasis();
    this.redraw();
  }

  makeValidCosine(
    /** @type{number}*/
    input,
  ) {
    if (input > 1) {
      return 1;
    }
    if (input < - 1) {
      return - 1;
    }
    return input;
  }

  rotateAfterCursorDefault() {
    if (this.mousePosition.length === 0) {
      return;
    }
    this.rotationModesAvailable[this.rotationMode].bind(this)();
  }

  mouseWheel(wheelDelta, screenX, screenY) {
    let screenPos = this.coordsScreenAbsoluteToScreen(screenX, screenY);
    let mathScreenPos = this.coordsScreenToMathScreen(screenPos);
    this.scale += wheelDelta;
    if (this.scale <= 0) {
      this.scale = 1;
    }
    let intermediateScreenPos = this.coordsMathScreenToScreen(mathScreenPos);
    //console.log("start screen: "+[screenX, screenY]);
    //console.log("intermed. screen: "+ intermediateScreenPos);
    this.centerX = this.centerX + screenPos[0] - intermediateScreenPos[0];
    this.centerY = this.centerY + screenPos[1] - intermediateScreenPos[1];
    this.redraw();
  }

  mouseMove(screenX, screenY) {
    this.screenXY[0] = screenX;
    this.screenXY[1] = screenY;
    if (this.selectedElement == "") {
      return;
    }
    this.mousePosition = this.coordsScreenAbsoluteToMathScreen(this.screenXY[0], this.screenXY[1]);
    this.infoMouseCompute();
    //this.infoPatchesCompute();
    this.infoProjectionCompute();
    this.showMessages();
    if (this.selectedElement === "default") {
      this.rotateAfterCursorDefault();
    }
    if (this.selectedElement === "origin") {
      this.panAfterCursor();
    }
    this.redrawFinish = new Date().getTime();
    this.redrawTime = this.redrawFinish - this.redrawStart;
  }

  panAfterCursor() {
    let difference = vectorMinusVector(this.mousePosition, this.clickedPosition);
    this.centerX += difference[0] * this.scale;
    this.centerY -= difference[1] * this.scale;
    this.redraw();
  }

  pointsWithinClickTolerance(leftXY, rightXY) {
    let squaredDistance = (
      (leftXY[0] - rightXY[0]) * (leftXY[0] - rightXY[0]) +
      (leftXY[1] - rightXY[1]) * (leftXY[1] - rightXY[1])
    ) * this.scale;
    return squaredDistance < 7;
  }

  canvasClick(screenX, screenY, event) {
    this.clickedPosition = this.coordsScreenAbsoluteToMathScreen(screenX, screenY);
    this.mousePosition = [];
    let mustSelectOrigin = true;
    if (event !== undefined) {
      if (event.shiftKey) {
        mustSelectOrigin = false;
      }
    }
    if (window.event !== undefined) {
      if (window.event.shiftKey) {
        mustSelectOrigin = false;
      }
    }
    if (this.pointsWithinClickTolerance(this.clickedPosition, [0, 0]) || mustSelectOrigin) {
      this.selectedElement = "origin";
    } else {
      this.selectedElement = "default";
      this.computeSelectedVector();
    }
    this.infoMouseCompute();
    this.showMessages();
  }

  selectEmpty() {
    this.selectedElement = "";
    this.selectedScreenBasisOrthonormal = [];
    this.selectedVector = [];
    this.selectedPolarAngleChange = 0;
    this.angleNormal = 0;
  }

  computeSelectedVector() {
    this.selectedScreenProjectionNormalized = this.coordsInjectMathScreen2dToMath3d(this.clickedPosition);
    this.selectedVector = this.selectedScreenProjectionNormalized.slice();
    vectorNormalize(this.selectedScreenProjectionNormalized);
    this.selectedScreenNormal = this.screenNormal;
    //    vectorAddVectorTimesScalar(this.selectedVector, this.screenNormal, 0.1);
    let lengthSelectedVector = vectorScalarVector(this.selectedVector, this.selectedVector);
    if (lengthSelectedVector < 0.5) {
      vectorTimesScalar(this.selectedVector, 1 / Math.sqrt(lengthSelectedVector));
    }
    this.selectedScreenBasisOrthonormal = [this.screenBasisOrthonormal[0].slice(), this.screenBasisOrthonormal[1].slice()];
  }

  showMessages() {
    if (!this.flagShowPerformance) {
      return;
    }
    if (this.spanMessages === null || this.spanMessages === undefined) {
      return;
    }
    let theHTML = "";
    if (this.textPerformance !== "") {
      theHTML += this.textPerformance + "<hr>";
    }
    if (this.textErrors !== "") {
      theHTML += `<span style =\"red\"><b>${this.textErrors}</b></span><hr>`;
    }
    theHTML += `<span>${this.textMouseInfo}</span><hr><span>${this.textProjectionInfo}</span>`;
    if (this.textPatchInfo !== "") {
      theHTML += `<hr><span>${this.textPatchInfo}</span>`;
    }
    this.spanMessages.innerHTML = theHTML;
  }

  infoPatchesCompute() {
    this.textPatchInfo = "";
    this.textPatchInfo += "Z-depth: " + this.boundingSegmentZ + "<br>";
    let thePatches = this.theIIIdObjects.thePatches;
    for (let i = 0; i < thePatches.length; i++) {
      let currentPatch = thePatches[i];
      for (let j = 0; j < currentPatch.patchesAboveMe.length; j++) {
        this.textPatchInfo += currentPatch.patchesAboveMe[j];
        if (j !== currentPatch.patchesAboveMe.length - 1) {
          this.textPatchInfo += ", ";
        } else {
          this.textPatchInfo += "->";
        }
      }
      this.textPatchInfo += `<b>${i}</b>`;
      if (currentPatch.patchesBelowMe.length > 0) {
        this.textPatchInfo += "->";
      }
      for (let j = 0; j < currentPatch.patchesBelowMe.length; j++) {
        this.textPatchInfo += currentPatch.patchesBelowMe[j];
        if (j !== currentPatch.patchesBelowMe.length) {
          this.textPatchInfo += ", ";
        }
      }
      this.textPatchInfo += "; contours: ";
      for (let j = 0; j < currentPatch.adjacentContours.length; j++) {
        this.textPatchInfo += currentPatch.adjacentContours[j];
        if (j !== currentPatch.adjacentContours.length - 1) {
          this.textPatchInfo += ", ";
        }
      }
      if (i != thePatches.length - 1) {
        this.textPatchInfo += "<br>";
      }
    }
    this.textPatchInfo += "<style>#patchInfo{ border: 1px solid black;}</style>";
    this.textPatchInfo += "<table id =\"patchInfo\">";
    for (let i = this.zBuffer.length - 1; i >= 0; i--) {
      this.textPatchInfo += "<tr id =\"patchInfo\">";
      for (let j = 0; j < this.zBuffer[i].length; j++) {
        this.textPatchInfo += "<td id =\"patchInfo\">";
        for (let k = 0; k < this.zBuffer[i][j].length; k++) {
          this.textPatchInfo += this.zBuffer[i][j][k];
          if (k !== this.zBuffer[i][j].length - 1) {
            this.textPatchInfo += ", ";
          }
        }
        this.textPatchInfo += "</td>";
      }
      this.textPatchInfo += "</tr>";
    }
    this.textPatchInfo += "</table>";
  }

  infoMouseCompute() {
    if (!this.flagShowPerformance) {
      return;
    }
    this.textMouseInfo = "";
    let thePatches = this.theIIIdObjects.thePatches;
    if (this.numAccountedPatches < thePatches.length) {
      this.textMouseInfo += `<span style ='color:red'><b>Error: only ${this.numAccountedPatches} out of `;
      this.textMouseInfo += `${this.theIIIdObjects.thePatches.length} patches accounted. </b></span><br>`;
    }
    this.textMouseInfo += `time last redraw: ${this.redrawTime} ms `;
    this.textMouseInfo += `(~${(1000 / this.redrawTime).toFixed(1)} f.p.s.)`;
    this.textMouseInfo += `<br>selected element: ${this.selectedElement}`;
    this.textMouseInfo += `<br>mouse coordinates: ${vectorToString(this.screenXY)}`;
    this.textMouseInfo += `<br>2d coordinates: ${vectorToString(this.mousePosition)}`;
    this.textMouseInfo += `<br>clicked coordinates: ${this.clickedPosition}`;
    this.textMouseInfo += `<br>delta of position: ${this.positionDelta}`;
    this.textMouseInfo += `<br>ray component of mouse: ${this.rayComponent}`;
    this.textMouseInfo += `<br>selected vector: ${this.selectedVector}`;
    this.textMouseInfo += `<br>normal angle change: ${this.angleNormal.toFixed(3)}`;
    this.textMouseInfo += ` (${(this.angleNormal * 180 / Math.PI).toFixed(1)} deg)`;
    this.textMouseInfo += ` = ${this.oldAngleNormal.toFixed(3)}`;
    this.textMouseInfo += ` (${(this.oldAngleNormal * 180 / Math.PI).toFixed(1)} deg)`;
    this.textMouseInfo += `- ${this.newAngleNormal.toFixed(3)} `;
    this.textMouseInfo += `(${(this.newAngleNormal * 180 / Math.PI).toFixed(1)} deg)`;
  }

  redraw() {
    this.redrawStart = new Date().getTime();
    let theContours = this.theIIIdObjects.theContours;
    let thePatches = this.theIIIdObjects.thePatches;
    let thePoints = this.theIIIdObjects.thePoints;
    let theLabels = this.theIIIdObjects.theLabels;
    let theSurface = this.surface;
    theSurface.clearRect(0, 0, this.width, this.height);
    for (let i = 0; i < thePatches.length; i++) {
      this.computePatch(thePatches[i]);
    }
    let computePatchesTime = new Date().getTime();
    for (let i = 0; i < theContours.length; i++) {
      this.computeContour(theContours[i]);
    }
    let computeContoursTime = new Date().getTime();
    this.computeBuffers();
    let computeBuffersTime = new Date().getTime();
    //this.paintZbuffer();
    let paintBuffersTime = new Date().getTime();
    let numPainted = 0;
    for (let i = 0; i < this.thePatchOrder.length; i++) {
      if (this.thePatchOrder[i] !== - 1) {
        this.paintOnePatch(thePatches[this.thePatchOrder[i]]);
        numPainted++;
      }
    }
    for (let i = 0; i < this.patchIsAccounted.length; i++) {
      if (this.patchIsAccounted[i] === 0) {
        this.paintOnePatch(thePatches[i]);
        numPainted++;
      }
    }
    let paintPatchTime = new Date().getTime();
    this.numContourPoints = 0;
    this.numContourPaths = 0;
    for (let i = 0; i < theContours.length; i++) {
      this.paintOneContour(theContours[i]);
    }
    let paintContourTime = new Date().getTime();
    for (let i = 0; i < thePoints.length; i++) {
      this.paintOnePoint(thePoints[i]);
    }
    for (let i = 0; i < theLabels.length; i++) {
      this.paintText(theLabels[i]);
    }
    this.paintMouseInfo();
    let redrawTime = new Date().getTime();
    if (this.flagShowPerformance) {
      this.textPerformance = "";

      this.textPerformance += `Redraw time (ms): ${(redrawTime - this.redrawStart)}=<br>`;
      this.textPerformance += `${computePatchesTime - this.redrawStart} (compute patches) + `;
      this.textPerformance += (computeContoursTime - computePatchesTime) + " (compute contours) + ";
      this.textPerformance += (computeBuffersTime - computeContoursTime) + " (compute buffers) + ";
      this.textPerformance += (paintBuffersTime - computeBuffersTime) + "<br>(paint buffers) + ";
      this.textPerformance += (paintPatchTime - paintBuffersTime) + "<br> (paint " + numPainted + " patche(s)) + <br>";
      this.textPerformance += (paintContourTime - paintPatchTime) + " (paint " + theContours.length + " contour(s) with ";
      this.textPerformance += this.numContourPoints + " points in " + this.numContourPaths + " sub-paths) + ";
      this.textPerformance += (redrawTime - paintContourTime) + " (paint all else). ";
    }
    this.showMessages();
  }

  drawSurface(theSurface) {
    let numUsegments = theSurface.patchDimensions[0];
    let numVsegments = theSurface.patchDimensions[1];
    let thePatches = this.theIIIdObjects.thePatches;
    let theContours = this.theIIIdObjects.theContours;
    //let incomingPatches = new Array(numUsegments);
    let deltaU = theSurface.deltaU;
    let deltaV = theSurface.deltaV;
    let firstPatchIndex = thePatches.length;
    for (let i = 0; i < numUsegments; i++) {
      //incomingPatches[i] = new Array(numVsegments);
      for (let j = 0; j < numVsegments; j++) {
        //let incomingPatch = incomingPatches[i][j];
        let currentU = theSurface.uvBox[0][0] + i * deltaU;
        let currentV = theSurface.uvBox[0][1] + j * deltaV;
        let base = theSurface.xyzFun(currentU, currentV);
        let v1 = theSurface.xyzFun(currentU + deltaU, currentV);
        let v2 = theSurface.xyzFun(currentU, currentV + deltaV);
        let edge1 = vectorMinusVector(v1, base);
        let edge2 = vectorMinusVector(v2, base);
        let incomingPatch = new Patch(base, edge1, edge2, theSurface.colors.colorUV, theSurface.colors.colorVU);
        incomingPatch.adjacentContours = new Array(4);
        incomingPatch.traversalOrder = [1, 1, 1, 1];
        incomingPatch.index = thePatches.length;
        incomingPatch.internalPoint = theSurface.xyzFun(currentU + deltaU / 2, currentV + deltaV / 2);
        thePatches.push(incomingPatch);
      }
    }
    let numSegmentsPerContour = this.defaultNumSegmentsPerContour;
    let contourPoints = new Array(numSegmentsPerContour + 1);
    for (let i = 0; i < numUsegments + 1; i++) {
      for (let j = 0; j < numVsegments; j++) {
        let currentU = theSurface.uvBox[0][0] + i * deltaU;
        for (let k = 0; k < numSegmentsPerContour + 1; k++) {
          let currentV = theSurface.uvBox[0][1] + (j + k / numSegmentsPerContour) * deltaV;
          contourPoints[k] = theSurface.xyzFun(currentU, currentV);
        }
        let incomingContour = new Contour(contourPoints, theSurface.colors.colorContour, theSurface.contourWidth);
        incomingContour.index = theContours.length;
        if (i > 0) {
          incomingContour.adjacentPatches.push(firstPatchIndex + numVsegments * (i - 1) + j);
          thePatches[firstPatchIndex + numVsegments * (i - 1) + j].adjacentContours[2] = theContours.length;
          thePatches[firstPatchIndex + numVsegments * (i - 1) + j].traversalOrder[2] = - 1;
        }
        if (i < numUsegments) {
          incomingContour.adjacentPatches.push(firstPatchIndex + numVsegments * i + j);
          thePatches[firstPatchIndex + numVsegments * i + j].adjacentContours[0] = theContours.length;
        }
        theContours.push(incomingContour);
      }
    }
    for (let i = 0; i < numUsegments; i++) {
      for (let j = 0; j < numVsegments + 1; j++) {
        let currentV = theSurface.uvBox[0][1] + j * deltaV;
        for (let k = 0; k < numSegmentsPerContour + 1; k++) {
          let currentU = theSurface.uvBox[0][0] + (i + k / numSegmentsPerContour) * deltaU;
          contourPoints[k] = theSurface.xyzFun(currentU, currentV);
        }
        let incomingContour = new Contour(contourPoints, theSurface.colors.colorContour, theSurface.contourWidth);
        incomingContour.index = theContours.length;
        if (j > 0) {
          incomingContour.adjacentPatches.push(firstPatchIndex + numVsegments * i + j - 1);
          thePatches[firstPatchIndex + numVsegments * i + j - 1].adjacentContours[1] = theContours.length;
        }
        if (j < numVsegments) {
          incomingContour.adjacentPatches.push(firstPatchIndex + numVsegments * i + j);
          thePatches[firstPatchIndex + numVsegments * i + j].adjacentContours[3] = theContours.length;
          thePatches[firstPatchIndex + numVsegments * i + j].traversalOrder[3] = - 1;
        }
        theContours.push(incomingContour);
      }
    }
  }
}

class Drawing {
  constructor() {
    this.canvases = {};
    this.firstCriticalRunTimeError = "";
    this.firstCanvas = null;
    this.numberOfControlsConstructed = 0;
    this.plotUpdaters = {};
    this.Surface = Surface;
    this.CurveThreeD = CurveThreeD;
  }

  deleteCanvas(canvasId) {
    if (typeof canvasId !== "string") {
      canvasId = canvasId.id;
    }
    if (this.canvases[canvasId] !== undefined && this.canvases[canvasId] !== null) {
      delete this.canvases[canvasId];
    }
  }

  /**@returns {Canvas} */
  getCanvas(/**@type {string}*/ canvasId) {
    let theCanvas = null;
    if (typeof canvasId === "string") {
      theCanvas = document.getElementById(canvasId);
      if (theCanvas === null) {
        throw (`Canvas with id ${canvasId} missing. `);
      }
    } else {
      theCanvas = canvasId;
      canvasId = theCanvas.id;
    }
    if (this.canvases[canvasId] === undefined) {
      this.canvases[canvasId] = new Canvas(theCanvas);
      if (this.firstCanvas == null) {
        this.firstCanvas = this.canvases[canvasId];
      }
    }
    return this.canvases[canvasId];
  }

  /**@returns {CanvasTwoD} */
  getCanvasTwoDNullOnFailure(canvasId) {
    return this.getCanvasTwoDInternal(canvasId, false);
  }

  /**@returns {CanvasTwoD} */
  getCanvasTwoD(canvasId) {
    return this.getCanvasTwoDInternal(canvasId, true);
  }

  /**@returns {CanvasTwoD} */
  getCanvasTwoDInternal(canvasId, /**@type {boolean} */ throwOnFailure) {
    let theCanvas = null;
    if (typeof canvasId === "string") {
      theCanvas = document.getElementById(canvasId);
      if (theCanvas === null) {
        if (throwOnFailure) {
          throw (`Canvas with id ${canvasId} missing. `);
        } else {
          return null;
        }
      }
    } else {
      theCanvas = canvasId;
      canvasId = theCanvas.id;
    }
    if (this.canvases[canvasId] === undefined) {
      this.canvases[canvasId] = new CanvasTwoD(theCanvas);
      if (this.firstCanvas == null) {
        this.firstCanvas = this.canvases[canvasId];
      }
    }
    return this.canvases[canvasId];
  }

  testPicture(inputCanvas) {
    let theCanvas = this.getCanvas(document.getElementById(inputCanvas));
    theCanvas.screenBasisUserDefault = [[0.59, 0.78, 0.18], [0.46, - 0.15, - 0.87]];
    theCanvas.screenBasisUser = theCanvas.screenBasisUserDefault.slice();
    theCanvas.initialize(inputCanvas, false);
    theCanvas.drawLine([- 1, 0, 0], [1, 0, 0], 'black', 2);
    theCanvas.drawLine([0, - 1, 0], [0, 1, 0], 'black', 2);
    theCanvas.drawLine([0, 0, - 1], [0, 0, 1], 'black', 2);
    theCanvas.drawLine([0, 0, 0], [1, 0.5, 0.5], 'red', 2);
    theCanvas.scale = 100;
    theCanvas.drawSurface(testGetMoebiusSurface());
    theCanvas.drawSurface(testGetMoebiusSurface2());
    theCanvas.drawPoints([[1, 0, 0]], 'red');
    theCanvas.drawPoints([[0, 1, 0]], 'green');
    theCanvas.drawPoints([[0, 0, 1]], 'blue');
    theCanvas.drawText({ location: [1, 0, 0], text: "x", color: "green" });
    theCanvas.drawText({ location: [0, 1, 0], text: "y", color: "green" });
    theCanvas.drawText({ location: [0, 0, 1], text: "z", color: "green" });
    theCanvas.setBoundingBoxAsDefaultViewWindow();
    //console.log(theCanvas.theIIIdObjects.thePatches);
    theCanvas.redraw();
  }

  testPictureTwoD(inputCanvas1, inputCanvas2, inputCanvas3) {
    let theCanvas = this.getCanvasTwoD(document.getElementById(inputCanvas1));
    theCanvas.initialize(inputCanvas1);
    theCanvas.drawLine([- 10, 0], [19, 0], 'green');
    theCanvas.drawLine([0, - 1], [0, 1], 'purple');
    theCanvas.drawText([- 1, - 1], '(- 1,- 1)', 'orange');
    theCanvas.drawFunction(testFunctionPlot, - 10, 10, 100, 'red', 4);
    theCanvas.setViewWindow([- 10, - 1], [19, 1]);
    theCanvas.plotFillStart('orange');
    theCanvas.drawLine([0, - 5], [1, - 4], 'green');
    theCanvas.drawLine([1, - 4], [2, - 5], 'black');
    theCanvas.drawLine([2, - 5], [0, - 5], 'black');
    theCanvas.plotFillFinish();
    theCanvas.plotFillStart('pink');
    theCanvas.drawCurve([testFunctionPlot, testFunctionPlot2], - 4, 4, 300, 'blue', 1);
    theCanvas.plotFillFinish();
    theCanvas.drawVectorField(testVectorField2d, true, [- 6, - 6], [6, 6], [20, 20], 0.5, "red", 2);
    theCanvas.redraw();
    let theCanvas2 = this.getCanvasTwoD(document.getElementById(inputCanvas2));
    theCanvas2.initialize(inputCanvas2);
    theCanvas2.drawLine([- 10, - 1], [10, 1], 'green');
    theCanvas2.drawLine([0, - 19], [0, 1], 'purple');
    theCanvas2.drawText([- 1, - 1], '(- 1,- 1)', 'orange');
    theCanvas2.drawPath([[2, 2], [3, 3], [1, 4]], 'cyan');
    theCanvas2.drawPathFilled([[- 2, - 2], [- 7, - 3], [- 1, - 4], [- 2, - 2]], 'red', 'green');
    theCanvas2.plotFillStart('pink');
    theCanvas2.drawFunction(testFunctionPlot, - 10, 10, 100, 'red', 2);
    theCanvas2.drawLine([10, 0], [- 10, 0], 'black');
    theCanvas2.plotFillFinish();
    theCanvas2.drawFunction(testFunctionPlot, - 10, 10, 100, 'red', 0.5);
    theCanvas2.setViewWindow([- 1, - 19], [1, 5]);
    theCanvas2.drawVectorField(testVectorField2d, false, [- 6, - 6], [6, 6], [20, 20], 0.5, "red", 2);
    theCanvas2.redraw();
    let theCanvas3 = this.getCanvasTwoD(document.getElementById(inputCanvas3));
    theCanvas3.initialize(inputCanvas3);
    theCanvas3.drawFunction(testFunctionPlot, - 10, 10, 100, 'red', 2);
    theCanvas3.drawGrid();
    theCanvas3.drawCoordinateAxes();
    theCanvas3.setViewWindow([- 1, - 19], [1, 5]);
    theCanvas3.drawFunction(testFunctionPlot2, "minusInfinity", "infinity", 100, 'red', 4);
    theCanvas3.redraw();
  }


  mouseMoveRedraw(inputCanvas, event) {
    let x = event.clientX;
    let y = event.clientY;
    let theCanvas = this.getCanvas(inputCanvas);
    if (theCanvas !== null && theCanvas !== undefined) {
      theCanvas.mouseMove(x, y);
    }
  }

  mouseWheel(theEvent) {
    if (theEvent === undefined) {
      theEvent = window.event;
    }
    if (theEvent.target === undefined) {
      return;
    }
    if (theEvent.preventDefault !== undefined) {
      theEvent.preventDefault();
    }
    if (theEvent.stopPropagation !== undefined) {
      theEvent.stopPropagation();
    }
    let theWheelDelta = theEvent.detail ? theEvent.detail * - 1 : theEvent.wheelDelta / 40;
    let theCanvas = this.canvases[theEvent.target.id];
    if (theCanvas === undefined || theCanvas === null) {
      return;
    }
    let theIncrement = 0.6;
    theCanvas.mouseWheel(theWheelDelta * theIncrement, theEvent.clientX, theEvent.clientY);
  }

  mouseUp(inputCanvas) {
    let theCanvas = this.getCanvas(inputCanvas);
    theCanvas.selectEmpty();
    theCanvas.redraw();
  }

  canvasClick(theCanvasContainer, theEvent) {
    this.canvases[theCanvasContainer.id].canvasClick(theEvent.clientX, theEvent.clientY, theEvent);
  }
}


let drawing = new Drawing();
if (window.calculator === undefined) {
  window.calculator = {};
}
window.calculator.drawing = drawing;

module.exports = {
  drawing,
};

},
"/calculator-html/graphics_n_dimensions" : function(require, module, exports){
"use strict";
/**
 * File needs to function as stand-alone javascript
 * as well be used as a commonJS module included via
 * require('graphics_n_dimension.js')).
 * Please don't require(...) any modules from this file.
 **/

var collectionGraphicsNDimensions = {};

function startProjectionPlaneUser(canvasId) {
  collectionGraphicsNDimensions[canvasId].startProjectionPlaneUser();
}

function toStringVector(vector) {
  var result = "";
  result += "(";
  for (var i = 0; i < vector.length; i++) {
    result += vector[i].toFixed(2);
    if (i !== vector.length - 1) {
      result += ", ";
    }
  }
  result += ")";
  return result;
}

function setBilinearForm(idCanvas, row, column) {

}


function getAngleFromXandY(x, y) {
  return Math.atan2(y, x);
}

function getAngleScreenChange(newX, newY, oldX, oldY) {
  var result = getAngleFromXandY(newX, newY) - getAngleFromXandY(oldX, oldY);
  var topBound = Math.PI;
  var bottomBound = - Math.PI;
  while (result > topBound || result <= bottomBound) {
    if (result > topBound) {
      result -= 2 * Math.PI;
    } else {
      result += 2 * Math.PI;
    }
  }
  return result;
}

class GraphicsNDimensions {
  constructor(inputIdCanvas, inputIdInfo, inputIdHighlightInfo, PanelExpandable) {
    this.PanelExpandable = PanelExpandable;
    if (this.PanelExpandable === undefined) {
      this.PanelExpandable = null;
    }
    this.vectors = [];
    this.vectorProjections = [];
    this.drawOperations = [];
    this.idCanvas = inputIdCanvas;
    this.idsBasis = [];
    this.idInfo = inputIdInfo;
    this.idPlaneInfo = `${inputIdInfo}projectionPlane`;
    this.panelInfo = null;
    if (inputIdHighlightInfo !== null && inputIdHighlightInfo !== undefined && inputIdHighlightInfo !== "") {
      this.idHighlightInfo = inputIdHighlightInfo;
    } else {
      this.idHighlightInfo = null;
    }
    this.highlightInfoContent = [];
    this.basisCircles = [];
    this.projectionsBasisCircles = [];
    this.eiBasis = [];
    this.projectionsEiVectors = [];
    this.indicesHighlightOperations = [];
    this.projectionsLabeledVectors = [];
    this.projectionScreenBasis = [];
    this.projectionSelectedAtSelection = [];
    this.screenBasis = [];
    this.screenBasisAtSelection = [];
    this.canvasContainer = document.getElementById(this.idCanvas);
    this.dimension = 0;
    this.theBilinearForm = [];
    this.graphicsUnit = 0;
    this.selectedBasisIndex = - 1;
    this.selectedHighlightIndex = - 1;
    /**
     * @type {Object<string, Object<string, boolean> >}
     * Keys are indices of groups currently highlighted.
     * Values are arrays with indices
     * within each group over which the mouse is located. */

    this.currentHighlightIndices = {};
    this.flagAllowMovingCoordinateSystemFromArbitraryClick = true;

    this.vOrthogonalSelected = [];
    this.vProjectionNormalizedSelected = [];

    this.angleScreenChange = 0;
    this.angleCuttingChange = 0;

    this.canvasContainer.addEventListener("DOMMouseScroll", this.mouseHandleWheel.bind(this));
    this.canvasContainer.addEventListener("wheel", this.mouseHandleWheel.bind(this));
    this.canvasContainer.addEventListener("mousedown", this.clickCanvas.bind(this));
    this.canvasContainer.addEventListener("mouseup", this.releaseMouse.bind(this));
    this.canvasContainer.addEventListener("mousemove", this.mouseMoveRedraw.bind(this));
    this.animationBasisChange = {
      frameCount: 0,
      numberOfFrames: 20,
      screenGoal: [],
      screenStart: [],
      frameStarted: false
    };
    this.animation = {
      currentFrameIndex: - 1,
      numberOfFrames: - 1,
      timeoutHandle: null,
      frameLength: 300
    };
    this.canvas = null;
    this.widthHTML = this.canvasContainer.width;
    this.heightHTML = this.canvasContainer.height;
    this.shiftScreenCoordinates = [this.widthHTML / 2, this.heightHTML / 2];
    this.mousePositionScreen = [0, 0];
    this.mousePositionScreenClicked = [0, 0];
    this.shiftScreenCoordinatesClicked = [0, 0];

    collectionGraphicsNDimensions[this.idCanvas] = this;
    this.clickTolerance = 5;
    this.textShift = [- 3, - 4];
  }

  initVectors(inputVectors) {
    this.vectors = inputVectors;
    this.vectorProjections = [];
    for (var counterVector = 0; counterVector < this.vectors.length; counterVector++) {
      this.vectorProjections.push([0, 0]);
    }
  }

  /** @returns {string} */
  getInfoHTML() {
    var result = "";
    result += `<br>Mouse position: ${toStringVector(this.mousePositionScreen)}`;
    result += `<br>Selected index: ${this.selectedBasisIndex}`;
    if (this.selectedBasisIndex >= 0) {
      result += `: ${toStringVector(this.basisCircles[this.selectedBasisIndex])}`;
      result += `<br>Screen basis at selection:`;
      result += `<br>${toStringVector(this.screenBasisAtSelection[0])}`;
      result += `<br>${toStringVector(this.screenBasisAtSelection[1])}`;
      result += `<br>Angle change screen: ${this.angleScreenChange.toFixed(2)}`;
      result += `<br>Angle change cutting: ${this.angleCuttingChange.toFixed(2)}`;
      result += `<br>Projection selected: ${toStringVector(this.vProjectionNormalizedSelected)}`;
      result += `<br>Orthogonal component selected: ${toStringVector(this.vOrthogonalSelected)}`;
    }
    result += `<br>Coordinate center in screen coordinates: <br>${toStringVector(this.shiftScreenCoordinates)}`;
    result += "<br>The projection plane (drawn on the screen) is spanned by the following two vectors.\n";
    result += `<br>${toStringVector(this.screenBasis[0])}`;
    result += `<br>${toStringVector(this.screenBasis[1])}`;
    for (var i = 0; i < this.basisCircles.length; i++) {
      result += `<br>${i}: ${toStringVector(this.basisCircles[i])}: ${toStringVector(this.projectionsBasisCircles[i])}`;
    }
    return result;
  }

  writeInfo() {
    var info = this.getInfoHTML();
    var panelInfoElement = document.getElementById(this.idPlaneInfo);
    panelInfoElement.innerHTML = info;
  }

  initInfo() {
    var infoHTML = "";
    infoHTML += "<div style = 'height:300px; overflow-y: scroll;'>";
    for (var i = 0; i < 2; i++) {
      this.idsBasis[i] = [];
      for (var j = 0; j < this.dimension; j++) {
        this.idsBasis[i][j] = `${this.idCanvas}textEbasis_${i}_${j}`;
        infoHTML += `<textarea rows = "1" cols = "2" id = "${this.idsBasis[i][j]}"></textarea>`;
      }
      infoHTML += "<br>";
    }
    infoHTML += `<button onclick = "window.calculator.graphicsNDimensions.startProjectionPlaneUser('${this.idCanvas}')">`;
    infoHTML += `Change to basis</button><br>`;
    //infoHTML += `<button onclick = "snapShotLaTeX('${this.idCanvas}')>LaTeX snapshot</button>`;
    infoHTML += `<span id = '${this.idCanvas}snapShotLateXspan'></span>\n`;
    infoHTML += `<div id = '${this.idPlaneInfo}' class = 'panel'></div>`;
    infoHTML += `</div>`;
    if (this.PanelExpandable === null) {
      document.getElementById(this.idInfo).innerHTML = infoHTML;
    } else {
      this.panelInfo = new this.PanelExpandable(this.idInfo);
      this.panelInfo.initialize(true);
      this.panelInfo.setPanelContent(infoHTML);
      this.panelInfo.doToggleContent();
      this.panelInfo.matchPanelStatus();
    }
  }

  snapShotLaTeX() {
    var textComponent = document.getElementById(`${this.idCanvas}snapShotLateXspan`);
    var result = "";
    result += `\\documentclass{article} \\usepackage{auto-pst-pdf}<br>`;
    result += `\n%\\usepackage{pst-plot}<br>\n\\begin{document}<br>\n`;
    result += `\\psset{xunit = 0.01cm, yunit = 0.01cm} <br>\n\\begin{pspicture}(0,0)(1,1)\n`;
    ComputeProjections();
    for (var counterDrawOperation = 0; counterDrawOperation < this.drawOperations.length; counterDrawOperation++) {
      result += this.drawOperations[counterDrawOperation].getLaTeXOperation();
    }
    result += "\\end{pspicture}<br>";
    if (nonImplementedFound) {
      result += `Not all elements in the html picture were drawn in LaTex. To do: fix this.`;
    }
    result += "\\end{document}";
    textComponent.innerHTML = result;
  }

  drawStandardEiBasis(color) {
    for (var i = 0; i < this.dimension; i++) {
      var eiVector = new Array(this.dimension);
      eiVector.fill(0);
      eiVector[i] = 1;
      this.drawCircle(eiVector, color, 3);
    }
  }

  drawCircle(position, color, radius, frameId, frameIndex) {
    if (radius === undefined) {
      radius = 3;
    }
    if (color === undefined) {
      color = "black";
    }
    this.drawOperations.push(new DrawCircleAtVector(
      this.idCanvas, {
      location: position,
      colorFill: color,
      radius: radius,
      frameId: frameId,
      frameIndex: frameIndex
    }));
  }

  drawLine(left, right, color) {
    if (color === undefined) {
      color = "black";
    }
    this.drawOperations.push(new DrawSegmentBetweenTwoVectors(
      this.idCanvas, {
      left: left,
      right: right,
      lineWidth: 1,
      colorLine: color
    }
    ));
  }

  drawPath(points, color, lineWidth, frameId, frameIndex) {
    if (color === undefined) {
      color = "black";
    }
    this.drawOperations.push(new DrawPath(
      this.idCanvas, {
      points: points,
      lineWidth: lineWidth,
      colorLine: color,
      frameId: frameId,
      frameIndex: frameIndex
    }
    ));
  }

  drawHighlightGroup(points, labels, color, radius) {
    if (color === undefined) {
      color = "black";
    }
    if (radius === undefined) {
      radius = 3;
    }
    this.drawOperations.push(new DrawHighlights(
      this.idCanvas, {
      vectors: points,
      indexInOperations: this.drawOperations.length,
      labels: labels,
      color: color,
      radius: radius
    }
    ));
  }

  drawText(location, text, color) {
    if (color === undefined) {
      color = "black";
    }
    this.drawOperations.push(new DrawTextAtVector(
      this.idCanvas, {
      location: location,
      text: text,
      colorFill: color
    }
    ));
  }

  getBilinearFormInput() {
    var result = "";
    result += "The bilinear form of the vector space follows. The ij^th element ";
    result += "gives the scalar product of e_i and e_j. If you enter a degenerate or non-positive definite ";
    result += "symmetric bilinear form the javascript might crash. You are expected to enter ";
    result += "a symmetric strictly positive definite matrix. <br> \n";
    for (var counterRow = 0; counterRow < this.theBilinearForm.length; counterRow++) {
      for (var counterColumn = 0; counterColumn < this.theBilinearForm[counterRow].NumCols; counterColumn++) {
        var idBilinearForm = `${this.idCanvas}textBilinearForm_${i}_${j}`;
        result += `<textarea rows = "1" cols = "2" id = "${idBilinearForm}" `;
        result += `onChange = "setBilinearForm('this.idCanvas', ${counterRow}, ${counterColumn})">`;
        result += this.theBilinearForm[i][j];
        result += "</textarea>";
      }
      result += "<br>";
    }
    result += `<button id = "canvasRedraw('${theCanvasId}');">redraw</button>`;
    result += "<br> Left click + hold+ move the mouse on a special vector = rotates the special vector. ";
    result += "<br>Moving a vector rotates ``infinitesimally'' the projection plane of your screen ";
    result += "<br>1) inside the projection plane ";
    result += "<br>2) in the plane spanned by the selected vector and its orthogonal complement relative to the projection plane. ";
    result += "<br>The angle change matches the motion of your mouse pointer.  ";
    result += " Special care must be taken if the selected vector lies ";
    result += "inside the projection plane or the selected vector is orthogonal to the projection plane. ";
    result += "If one of these cases happens, the picture might jump around a bit.";
    result += "<br>The mouse wheel zooms in/out. ";
    result += "Zooming is tested to work on Firefox and google Chrome browsers on Ubuntu. ";
    result += `<br>${this.drawOperations.length} elements drawn. `;
    var textComponent = document.getElementById(`${this.idCanvas}snapShotLateXspan`);
    textComponent.innerHTML = result;
  }

  startProjectionPlaneUser() {
    this.animationBasisChange.frameCount = 0;
    this.animationBasisChange.screenStart[0] = this.screenBasis[0].slice();
    this.animationBasisChange.screenStart[1] = this.screenBasis[1].slice();
    for (var i = 0; i < 2; i++) {
      this.animationBasisChange.screenGoal[i] = [];
      for (var counterDimension = 0; counterDimension < this.dimension; counterDimension++) {
        var coordinate = document.getElementById(this.idsBasis[i][counterDimension]).value;
        this.animationBasisChange.screenGoal[i][counterDimension] = Number(coordinate);
      }
    }
    this.animateChangeProjectionPlaneUser();
  }

  registerFrameIndex(frameIndex) {
    if (typeof frameIndex !== "number") {
      return;
    }
    if (this.animation.numberOfFrames < frameIndex) {
      this.animation.numberOfFrames = frameIndex;
    }
  }

  animateChangeProjectionPlaneUser() {
    this.animationBasisChange.frameCount++;
    var frameCount = this.animationBasisChange.frameCount;
    var maxFrameCount = this.animationBasisChange.numberOfFrames;
    if (frameCount > maxFrameCount) {
      return;
    }
    var screenStart = this.animationBasisChange.screenStart;
    var screenGoal = this.animationBasisChange.screenGoal;
    for (var i = 0; i < this.dimension; i++) {
      this.screenBasis[0][i] = screenGoal[0][i] * (frameCount / maxFrameCount) + screenStart[0][i] * (1 - frameCount / maxFrameCount);
      this.screenBasis[1][i] = screenGoal[1][i] * (frameCount / maxFrameCount) + screenStart[1][i] * (1 - frameCount / maxFrameCount);
    }
    this.makeScreenBasisOrthonormal();
    this.drawAll();
    setTimeout(this.animateChangeProjectionPlaneUser.bind(this), 100);
  }


  drawAll() {
    if (this.animationBasisChange.frameStarted) {
      return;
    }
    this.animationBasisChange.frameStarted = true;
    if (this.canvas == null || this.canvas == undefined) {
      this.init();
    }
    this.computeProjectionsEiBasis();
    this.computeProjectionsSpecialVectors();
    this.canvas.clearRect(0, 0, this.widthHTML, this.heightHTML);
    this.writeInfo();
    this.highlightInfoContent = [];
    for (var counterOperation = 0; counterOperation < this.drawOperations.length; counterOperation++) {
      var currentOperation = this.drawOperations[counterOperation];
      if (currentOperation.frameId !== undefined && currentOperation.frameId !== null) {
        if (currentOperation.frameIndex !== this.animation.currentFrameIndex) {
          continue;
        }
      }
      currentOperation.drawNoFinish();
    }
    if (this.highlightInfoContent.length > 0) {
      if (this.idHighlightInfo !== null) {
        var highlightComponent = document.getElementById(this.idHighlightInfo);
        highlightComponent.innerHTML = this.highlightInfoContent.join("<br>");
      }
    }
    this.animationBasisChange.frameStarted = false;
  }

  makeStandardBilinearForm() {
    this.theBilinearForm = new Array(this.dimension);
    for (var i = 0; i < this.theBilinearForm.length; i++) {
      this.theBilinearForm[i] = newArray(this.dimension);
      this.theBilinearForm[i].fill(0, 0, this.dimension);
      this.theBilinearForm[i][i] = 1;
    }
  }

  makeEiBasis() {
    this.eiBasis = new Array(this.dimension);
    for (var i = 0; i < this.eiBasis.length; i++) {
      this.eiBasis[i] = new Array(this.dimension);
      this.eiBasis[i].fill(0, 0, this.dimension);
      this.eiBasis[i][i] = 1;
    }
  }

  makeBasisCircles() {
    this.basisCircles = new Array(this.dimension);
    this.projectionsBasisCircles = new Array(this.dimension);
    for (var i = 0; i < this.basisCircles.length; i++) {
      this.basisCircles[i] = new Array(this.dimension);
      this.basisCircles[i].fill(0, 0, this.dimension);
      this.basisCircles[i][i] = 1;
      this.projectionsBasisCircles[i] = new Array(2);
      this.projectionsBasisCircles[i].fill(0, 0, 2);
    }
  }

  init() {
    this.initInfo();
    if (this.theBilinearForm.length != this.dimension) {
      this.makeStandardBilinearForm(this.dimension);
    }
    if (this.basisCircles.length === 0) {
      this.makeBasisCircles();
    } else {
      this.projectionsBasisCircles = new Array(this.basisCircles.length);
      for (var i = 0; i < this.basisCircles.length; i++) {
        this.projectionsBasisCircles[i] = new Array(2);
        this.projectionsBasisCircles[i].fill(0, 0, 2);
      }
    }

    this.makeEiBasis();
    var theDiv = document.getElementById(this.idCanvas);
    theDiv.width = this.widthHTML;
    theDiv.height = this.heightHTML;
    this.canvas = theDiv.getContext("2d");
  }

  pointsAreWithinClickTolerance(x1, y1, x2, y2) {
    if (
      Math.abs(x1 - x2) > this.clickTolerance ||
      Math.abs(y1 - y2) > this.clickTolerance
    ) {
      return false;
    }
    return true;
  }

  scaleToUnitLength(output) {
    var scale = 1 / Math.sqrt(this.scalarProduct(output, output));
    multiplyVectorByScalar(output, scale)
  }

  scalarProduct(vector1, vector2) {
    var result = 0;
    for (var i = 0; i < this.dimension; i++) {
      for (var j = 0; j < this.dimension; j++) {
        result += vector1[i] * vector2[j] * this.theBilinearForm[i][j];
      }
    }
    return result;
  }

  makeScreenBasisOrthonormal() {
    addVectorTimesScalar(
      this.screenBasis[1],
      this.screenBasis[0],
      - this.scalarProduct(this.screenBasis[0], this.screenBasis[1]) /
      this.scalarProduct(this.screenBasis[0], this.screenBasis[0])
    );
    this.scaleToUnitLength(this.screenBasis[0]);
    this.scaleToUnitLength(this.screenBasis[1]);
  }

  computeScreenCoordinates(input, output) {
    output[0] = this.shiftScreenCoordinates[0] + this.graphicsUnit * this.scalarProduct(this.screenBasis[0], input);
    output[1] = this.shiftScreenCoordinates[1] + this.graphicsUnit * this.scalarProduct(this.screenBasis[1], input);
  }

  computeProjectionsEiBasis() {
    if (this.projectionsEiVectors.length != this.dimension) {
      this.projectionsEiVectors[i] = new Array(this.dimension);
      for (var i = 0; i < this.dimension; i++) {
        this.projectionsEiVectors[i] = new Array(this.dimension);
      }
    }
    for (var i = 0; i < this.eiBasis.length; i++) {
      this.computeScreenCoordinates(this.eiBasis[i], this.projectionsEiVectors[i]);
    }
  }

  computeProjectionsSpecialVectors() {
    for (var i = 0; i < this.basisCircles.length; i++) {
      if (this.projectionsBasisCircles[i] === null || this.projectionsBasisCircles[i] === undefined) {
        this.projectionsBasisCircles[i] = [];
      }
      this.computeScreenCoordinates(this.basisCircles[i], this.projectionsBasisCircles[i]);
    }
  }

  rotateInPlane(
    inputOutput, orthonormalBasis1, orthonormalBasis2, angle
  ) {
    var result = inputOutput.slice();
    var scalarProductWithBasis1 = this.scalarProduct(result, orthonormalBasis1);
    var scalarProductWithBasis2 = this.scalarProduct(result, orthonormalBasis2);
    addVectorTimesScalar(result, orthonormalBasis1, - scalarProductWithBasis1);
    addVectorTimesScalar(result, orthonormalBasis2, - scalarProductWithBasis2);
    addVectorTimesScalar(
      result,
      orthonormalBasis1,
      scalarProductWithBasis1 * Math.cos(angle) -
      scalarProductWithBasis2 * Math.sin(angle)
    );
    addVectorTimesScalar(
      result,
      orthonormalBasis2,
      scalarProductWithBasis1 * Math.sin(angle) +
      scalarProductWithBasis2 * Math.cos(angle)
    );
    for (var i = 0; i < inputOutput.length; i++) {
      inputOutput[i] = result[i];
    }
  }

  changeBasis() {
    var newX = this.mousePositionScreen[0] - this.shiftScreenCoordinates[0];
    var newY = this.mousePositionScreen[1] - this.shiftScreenCoordinates[1];
    if (newX == 0 && newY == 0) {
      return;
    }
    var oldX = this.projectionSelectedAtSelection[0] - this.shiftScreenCoordinates[0];
    var oldY = this.projectionSelectedAtSelection[1] - this.shiftScreenCoordinates[1];
    newX /= this.graphicsUnit;
    newY /= this.graphicsUnit;
    oldX /= this.graphicsUnit;
    oldY /= this.graphicsUnit;
    if (newX * newX + newY * newY <= 0.03) {
      return;
    }
    this.angleScreenChange = - getAngleScreenChange(newX, newY, oldX, oldY);
    if (this.angleScreenChange > Math.PI / 2 || this.angleScreenChange < - Math.PI / 2) {
      return;
    }
    this.screenBasis[0] = this.screenBasisAtSelection[0].slice();
    this.screenBasis[1] = this.screenBasisAtSelection[1].slice();
    this.rotateInPlane(
      this.screenBasis[0],
      this.screenBasisAtSelection[0], this.screenBasisAtSelection[1],
      this.angleScreenChange
    );
    this.rotateInPlane(
      this.screenBasis[1],
      this.screenBasisAtSelection[0], this.screenBasisAtSelection[1],
      this.angleScreenChange
    );
    if (this.dimension <= 2) {
      return;
    }
    var selectedVector = this.basisCircles[this.selectedBasisIndex];
    var xCuttingOld = this.scalarProduct(selectedVector, this.vProjectionNormalizedSelected);
    var yCuttingOld = this.scalarProduct(selectedVector, this.vOrthogonalSelected);
    var hypothenuseSquared = xCuttingOld * xCuttingOld + yCuttingOld * yCuttingOld;

    var xCuttingNew = Math.sqrt(newX * newX + newY * newY);
    if (xCuttingNew * xCuttingNew > hypothenuseSquared) {
      xCuttingNew = Math.sqrt(hypothenuseSquared) - 0.01;
    }
    var yCuttingNew = Math.sqrt(hypothenuseSquared - xCuttingNew * xCuttingNew);
    //if (newX * oldX + newY * oldY < 0) {
    //  xCuttingNew *= - 1;
    //}
    this.angleCuttingChange = - Math.atan2(yCuttingNew, xCuttingNew) + Math.atan2(yCuttingOld, xCuttingOld);
    for (var i = 0; i < 5; i++) {
      if (this.angleCuttingChange <= - Math.PI) {
        this.angleCuttingChange += 2 * Math.PI;
      }
      if (this.angleCuttingChange > Math.PI) {
        this.angleCuttingChange -= 2 * Math.PI;
      }
      if (this.angleCuttingChange >= 0 && this.angleCuttingChange <= Math.PI) {
        break;
      }
    }

    this.rotateInPlane(
      this.screenBasis[0],
      this.vProjectionNormalizedSelected, this.vOrthogonalSelected,
      this.angleCuttingChange
    );
    this.rotateInPlane(
      this.screenBasis[1],
      this.vProjectionNormalizedSelected, this.vOrthogonalSelected,
      this.angleCuttingChange
    );
    this.makeScreenBasisOrthonormal();
  }

  computePosXPosY(event) {
    this.mousePositionScreen[0] = event.clientX;
    this.mousePositionScreen[1] = event.clientY;
    var rect = this.canvasContainer.getBoundingClientRect();
    this.mousePositionScreen[0] -= rect.left;
    this.mousePositionScreen[1] -= rect.top;
    //  while (thePointer) {
    //    this.mousePositionScreen[0] -= thePointer.offsetLeft;
    //    if (typeof thePointer.scrollLeft === "number") {
    //      this.mousePositionScreen[0] += thePointer.scrollLeft;
    //    }
    //    this.mousePositionScreen[1] -= thePointer.offsetTop;
    //    if (typeof thePointer.scrollTop === "number") {
    //      this.mousePositionScreen[1] += thePointer.scrollTop;
    //    }
    //    //thePointer = thePointer.offsetParent;
    //    thePointer = thePointer.parentElement;
    //  }
  }

  releaseMouse(event) {
    this.selectedBasisIndex = - 1;
  }

  selectIndex(index) {
    this.selectedBasisIndex = index;
    this.projectionSelectedAtSelection[0] = this.projectionsBasisCircles[index][0];
    this.projectionSelectedAtSelection[1] = this.projectionsBasisCircles[index][1];
    if (this.screenBasisAtSelection.length === 0) {
      this.screenBasisAtSelection = new Array(2);
    }
    this.screenBasisAtSelection[0] = this.screenBasis[0].slice();
    this.screenBasisAtSelection[1] = this.screenBasis[1].slice();

    var epsilon = 0.0000001;
    for (var round = 0; round < this.dimension + 1; round++) {
      var selectedVector = this.basisCircles[this.selectedBasisIndex].slice();
      if (round > 0) {
        selectedVector[(round + 1) % this.dimension] += 0.01;
      }
      var vectorTimesE1 = this.scalarProduct(selectedVector, this.screenBasisAtSelection[0]);
      var vectorTimesE2 = this.scalarProduct(selectedVector, this.screenBasisAtSelection[1]);
      this.vProjectionNormalizedSelected = this.screenBasisAtSelection[0].slice();
      multiplyVectorByScalar(this.vProjectionNormalizedSelected, vectorTimesE1);
      addVectorTimesScalar(this.vProjectionNormalizedSelected, this.screenBasisAtSelection[1], vectorTimesE2);
      this.vOrthogonalSelected = selectedVector.slice();
      addVectorTimesScalar(this.vOrthogonalSelected, this.vProjectionNormalizedSelected, - 1);
      var vOrthogonalSquareLength = this.scalarProduct(this.vOrthogonalSelected, this.vOrthogonalSelected);
      var vProjectionSquareLength = this.scalarProduct(this.vProjectionNormalizedSelected, this.vProjectionNormalizedSelected);
      if (vOrthogonalSquareLength > epsilon && vProjectionSquareLength > epsilon) {
        break;
      }
      if (this.dimension <= 2 && vProjectionSquareLength > epsilon) {
        break;
      }
    }
    this.scaleToUnitLength(this.vProjectionNormalizedSelected);
    if (this.dimension > 2) {
      this.scaleToUnitLength(this.vOrthogonalSelected);
    }
  }

  clickCanvas(event) {
    this.computePosXPosY(event);
    this.mousePositionScreenClicked[0] = this.mousePositionScreen[0];
    this.mousePositionScreenClicked[1] = this.mousePositionScreen[1];
    this.selectedBasisIndex = - 1;
    if (!this.flagAllowMovingCoordinateSystemFromArbitraryClick) {
      if (this.pointsAreWithinClickTolerance(posx, posy, 0, 0)) {
        this.selectedBasisIndex = - 2;
      }
    } else {
      this.selectedBasisIndex = - 2;
    }
    if (this.selectedBasisIndex === - 2) {
      this.shiftScreenCoordinatesClicked[0] = this.shiftScreenCoordinates[0];
      this.shiftScreenCoordinatesClicked[1] = this.shiftScreenCoordinates[1];
    }
    for (var i = 0; i < this.basisCircles.length; i++) {
      if (this.pointsAreWithinClickTolerance(
        this.mousePositionScreenClicked[0], this.mousePositionScreenClicked[1],
        this.projectionsBasisCircles[i][0], this.projectionsBasisCircles[i][1]
      )) {
        this.selectIndex(i);
      }
    }
  }

  computeHighlightedIndex() {
    var oldSelected = this.selectedHighlightIndex;
    this.selectedHighlightIndex = - 1;
    this.currentHighlightIndices = {};
    for (var i = 0; i < this.indicesHighlightOperations.length; i++) {
      var currentIndex = this.indicesHighlightOperations[i];
      var currentHighlight = this.drawOperations[currentIndex];
      currentHighlight.computeProjections();
      var currentVectors = currentHighlight.vectorProjections;
      for (var j = 0; j < currentVectors.length; j++) {
        if (this.pointsAreWithinClickTolerance(
          this.mousePositionScreen[0], this.mousePositionScreen[1], currentVectors[j][0], currentVectors[j][1]
        )) {
          this.selectedHighlightIndex = currentIndex;
          if (this.currentHighlightIndices[currentIndex] === undefined) {
            this.currentHighlightIndices[currentIndex] = {};
          }
          this.currentHighlightIndices[currentIndex][j] = true;
        }
      }
    }
    return oldSelected !== this.selectedHighlightIndex;
  }

  mouseMoveRedraw(event) {
    this.computePosXPosY(event);
    this.writeInfo();
    //this.processMousePosition(posx, - posy);
    var doRedraw = this.computeHighlightedIndex();
    if (this.selectedBasisIndex == - 1 && !doRedraw) {
      return;
    }
    if (this.selectedBasisIndex == - 2) {
      if (
        this.shiftScreenCoordinates[0] !== this.mousePositionScreen[0] ||
        this.shiftScreenCoordinates[1] !== this.mousePositionScreen[1]
      ) {
        doRedraw = true;
      }
      var deltaX = this.mousePositionScreen[0] - this.mousePositionScreenClicked[0];
      var deltaY = this.mousePositionScreen[1] - this.mousePositionScreenClicked[1];
      this.shiftScreenCoordinates[0] = this.shiftScreenCoordinatesClicked[0] + deltaX;
      this.shiftScreenCoordinates[1] = this.shiftScreenCoordinatesClicked[1] + deltaY;
    } else if (this.selectedBasisIndex >= 0) {
      this.changeBasis();
      var doRedraw = true;
    }
    if (doRedraw) {
      this.drawAll();
    }
  }

  mouseHandleWheel(event) {
    event = event ? event : window.event;
    event.preventDefault();
    event.stopPropagation();
    var theWheelDelta = event.detail ? event.detail * - 1 : event.wheelDelta / 40;
    this.computePosXPosY(event);

    var oldXDelta = (this.mousePositionScreen[0] - this.shiftScreenCoordinates[0]);
    var oldYDelta = (this.mousePositionScreen[1] - this.shiftScreenCoordinates[1]);
    var oldXDeltaScaled = oldXDelta / this.graphicsUnit;
    var oldYDeltaScaled = oldYDelta / this.graphicsUnit;
    this.graphicsUnit += theWheelDelta;
    if (this.graphicsUnit < 3) {
      this.graphicsUnit = 3;
    }
    var newXDelta = oldXDeltaScaled * this.graphicsUnit;
    var newYDelta = oldYDeltaScaled * this.graphicsUnit;
    this.shiftScreenCoordinates[0] += oldXDelta - newXDelta;
    this.shiftScreenCoordinates[1] += oldYDelta - newYDelta;
    this.drawAll();
  }

  initFromObject(input) {
    this.dimension = input.dimension;
    this.theBilinearForm = input.bilinearForm;
    this.screenBasis = input.screenBasis;
    this.basisCircles = input.draggablePoints;
    if (input.frameLength !== undefined && input.frameLength !== null) {
      this.animation.frameLength = input.frameLength;
    }
    for (var i = 0; i < input.drawObjects.length; i++) {
      var currentOperation = input.drawObjects[i];
      if (currentOperation.operation === "circleAtVector") {
        this.drawCircle(
          currentOperation.location,
          currentOperation.color,
          currentOperation.radius,
          currentOperation.frameId,
          currentOperation.frameIndex
        );
      } else if (currentOperation.operation === "segment") {
        this.drawLine(currentOperation.points[0], currentOperation.points[1], currentOperation.color);
      } else if (currentOperation.operation === "highlightGroup") {
        this.drawHighlightGroup(
          currentOperation.points, currentOperation.labels,
          currentOperation.color, currentOperation.radius
        );
      } else if (currentOperation.operation === "text") {
        this.drawText(currentOperation.location, currentOperation.text, currentOperation.color);
      } else if (currentOperation.operation === "path") {
        this.drawPath(
          currentOperation.points,
          currentOperation.color,
          currentOperation.lineWidth,
          currentOperation.frameId,
          currentOperation.frameIndex
        );
      }
    }
    this.graphicsUnit = input.graphicsUnit;
    if (this.graphicsUnit === undefined || this.graphicsUnit === null) {
      this.graphicsUnit = 150;
    }
    if (input.widthHTML !== undefined && input.widthHTML !== null) {
      this.widthHTML = input.widthHTML;
    }
    if (input.heightHTML !== undefined && input.heightHTML !== null) {
      this.heightHTML = input.heightHTML;
    }
    if (this.animation.numberOfFrames > 0) {
      this.animation.timeoutHandle = setTimeout(this.animate.bind(this), 0);
    } else {
      this.drawAll();
    }
  }

  animate() {
    clearTimeout(this.animation.timeoutHandle);
    this.animation.currentFrameIndex++;
    if (this.animation.currentFrameIndex < 0 || this.animation.currentFrameIndex > this.animation.numberOfFrames) {
      this.animation.currentFrameIndex = 0;
    }
    this.drawAll();
    this.animation.timeoutHandle = setTimeout(this.animate.bind(this), this.animation.frameLength);
  }

}

class DrawHighlights {
  constructor(inputOwnerId, inputData) {
    this.ownerId = inputOwnerId;
    this.indexInOperations = inputData.indexInOperations;
    var owner = collectionGraphicsNDimensions[this.ownerId];
    owner.indicesHighlightOperations.push(this.indexInOperations);
    this.vectors = inputData.vectors;
    this.vectorProjections = [];
    this.color = inputData.color;
    this.labels = inputData.labels;
    this.radius = inputData.radius;
  }

  computeProjections() {
    var owner = collectionGraphicsNDimensions[this.ownerId];
    if (this.vectorProjections.length !== this.vectors.length) {
      this.vectorProjecions = new Array(this.vectors.length);
    }
    for (var i = 0; i < this.vectors.length; i++) {
      if (this.vectorProjections[i] === undefined || this.vectorProjections[i] === null) {
        this.vectorProjections[i] = [];
      }
      owner.computeScreenCoordinates(this.vectors[i], this.vectorProjections[i]);
    }
  }

  drawNoFinish() {
    /**@type {GraphicsNDimensions} */
    var owner = collectionGraphicsNDimensions[this.ownerId];
    if (!(this.indexInOperations in owner.currentHighlightIndices)) {
      return;
    }
    var currentIndices = owner.currentHighlightIndices[this.indexInOperations];
    var nextLine = [];
    for (var i = 0; i < this.labels.length; i++) {
      if (i in currentIndices) {
        nextLine.push(`<b>${this.labels[i]}</b>`);
      } else {
        nextLine.push(this.labels[i]);
      }
    }
    owner.highlightInfoContent.push(nextLine.join(", "));

    this.computeProjections();
    var canvas = owner.canvas;
    canvas.strokeStyle = this.color;
    for (var i = 0; i < this.vectors.length; i++) {
      canvas.beginPath();
      canvas.arc(
        this.vectorProjections[i][0],
        this.vectorProjections[i][1],
        this.radius,
        0, 2 * Math.PI
      );
      canvas.stroke();
    }
  }
}

class DrawPath {
  constructor(inputOwnerId, inputData) {
    this.ownerId = inputOwnerId;
    this.points = inputData.points;
    this.lineWidth = inputData.lineWidth;
    this.colorLine = inputData.colorLine;
    if (inputData.frameId !== "" && inputData.frameId !== null && inputData.frameId !== undefined) {
      this.frameId = inputData.frameId;
      this.frameIndex = inputData.frameIndex;
      collectionGraphicsNDimensions[this.ownerId].registerFrameIndex(this.frameIndex);
    }
  }

  drawNoFinish() {
    var owner = collectionGraphicsNDimensions[this.ownerId];
    var canvas = owner.canvas;
    canvas.beginPath();
    canvas.strokeStyle = this.colorLine;
    canvas.lineWidth = this.lineWidth;
    var vector = [];
    owner.computeScreenCoordinates(this.points[0], vector);
    canvas.moveTo(vector[0], vector[1]);
    for (var counterPoints = 1; counterPoints < this.points.length; counterPoints++) {
      owner.computeScreenCoordinates(this.points[counterPoints], vector);
      canvas.lineTo(vector[0], vector[1]);
    }
    canvas.stroke();
  }
}

class DrawSegmentBetweenTwoVectors {
  constructor(inputOwnerId, inputData) {
    this.ownerId = inputOwnerId;
    this.left = inputData.left.slice();
    this.right = inputData.right.slice();
    this.lineWidth = inputData.lineWidth;
    this.colorLine = inputData.colorLine;
  }

  drawNoFinish() {
    var owner = collectionGraphicsNDimensions[this.ownerId];
    var canvas = owner.canvas;
    canvas.beginPath();
    canvas.strokeStyle = this.colorLine;
    canvas.lineWidth = this.lineWidth;
    var screenCoordinatesLeft = [];
    var screenCoordinatesRight = [];
    owner.computeScreenCoordinates(this.left, screenCoordinatesLeft);
    owner.computeScreenCoordinates(this.right, screenCoordinatesRight);
    canvas.moveTo(screenCoordinatesLeft[0], screenCoordinatesLeft[1]);
    canvas.lineTo(screenCoordinatesRight[0], screenCoordinatesRight[1]);
    canvas.stroke();
  }
}

class DrawFilledShape {
  constructor(inputOwnerId, inputData) {
    this.points = inputData.points;
    this.ownerId = inputOwnerId;
    this.colorFill = inputData.colorFill;
    this.lineWidth = inputData.lineWidth;
  }

  drawNoFinish() {
    var owner = collectionGraphicsNDimensions[this.ownerId];
    var canvas = owner.canvas;
    canvas.beginPath();
    canvas.fillStyle = this.colorFill;
    canvas.lineWidth = this.lineWidth;
    var currentPoint = [];
    owner.computeScreenCoordinates(this.points[0], currentPoint);
    canvas.moveTo(currentPoint[0], currentPoint[1]);
    for (var counterPoint = 1; counterPoint < this.points.length; counterPoint++) {
      owner.computeAllScreenCoordinates(this.points[counterPoint], currentPoint);
      canvas.lineTo(currentPoint[0], currentPoint[1]);
    }
    canvas.closePath();
    canvas.fill();
    //canvas.stroke();
  }
}

class DrawCircleAtVector {
  constructor(inputOwnerId, inputData) {
    this.ownerId = inputOwnerId;
    this.location = inputData.location.slice();
    this.locationScreenCoordinates = [];
    this.colorFill = inputData.colorFill;
    this.radius = inputData.radius;
    if (inputData.frameId !== undefined && inputData.frameId !== null) {
      this.frameId = inputData.frameId;
      this.frameIndex = inputData.frameIndex;
      collectionGraphicsNDimensions[this.ownerId].registerFrameIndex(this.frameIndex);
    }
  }

  drawNoFinish() {
    var owner = collectionGraphicsNDimensions[this.ownerId];
    var canvas = owner.canvas;
    canvas.strokeStyle = this.colorFill;
    canvas.fillStyle = this.colorFill;
    owner.computeScreenCoordinates(this.location, this.locationScreenCoordinates);
    canvas.beginPath();
    canvas.arc(
      this.locationScreenCoordinates[0],
      this.locationScreenCoordinates[1],
      this.radius,
      0, 2 * Math.PI
    );
    canvas.fill();
  }
}

class DrawTextAtVector {
  constructor(inputOwnerId, inputData) {
    this.ownerId = inputOwnerId;
    this.text = inputData.text;
    this.location = inputData.location;
    this.locationScreen = [];
    this.colorFill = inputData.colorFill;
  }

  drawNoFinish() {
    var owner = collectionGraphicsNDimensions[this.ownerId];
    var canvas = owner.canvas;
    canvas.strokeStyle = this.colorFill;
    owner.computeScreenCoordinates(this.location, this.locationScreen);
    canvas.strokeText(this.text, this.locationScreen[0] + owner.textShift[0], this.locationScreen[1] + owner.textShift[1]);
  }
}

function multiplyVectorByScalar(vector, scalar) {
  for (var counterDimension = 0; counterDimension < vector.length; counterDimension++) {
    vector[counterDimension] *= scalar;
  }
}

function addVectorTimesScalar(vector, other, scalar) {
  for (var counterDimension = 0; counterDimension < vector.length; counterDimension++) {
    vector[counterDimension] += other[counterDimension] * scalar;
  }
}

function testA3(idCanvas, idSpanInformation) {
  var theA3 = new GraphicsNDimensions(idCanvas, idSpanInformation);
  theA3.dimension = 3;
  theA3.theBilinearForm = [
    [2, -1, 0],
    [-1, 2, -1],
    [0, -1, 2]
  ];
  theA3.screenBasis = [
    [0.707107, 0.707107, 0],
    [0, 0.707107, 0.707107]
  ];
  var labeledVectors = [
    [-1, -1, -1],
    [0, -1, -1],
    [-1, -1, 0],
    [0, 0, -1],
    [0, -1, 0],
    [-1, 0, 0],
    [1, 0, 0],
    [0, 1, 0],
    [0, 0, 1],
    [1, 1, 0],
    [0, 1, 1],
    [1, 1, 1],
  ];
  var segments = [
    [[0, - 1, - 1], [1, 0, 0]],
    [[0, - 1, - 1], [-1, -1, -1]],
    [[0, - 1, - 1], [0, 0, -1]],
    [[0, - 1, - 1], [0, -1, 0]],
    [[-1, -1, 0], [-1, 0, 0]],
    [[-1, -1, 0], [0, 0, 1]],
    [[-1, -1, 0], [-1, -1, -1]],
    [[-1, -1, 0], [0, -1, 0]],
    [[1, 1, 0], [1, 0, 0]],
    [[1, 1, 0], [0, 0, -1]],
    [[1, 1, 0], [1, 1, 1]],
    [[1, 1, 0], [0, 1, 0]],
    [[0, 1, 1], [-1, 0, 0]],
    [[0, 1, 1], [0, 0, 1]],
    [[0, 1, 1], [1, 1, 1]],
    [[0, 1, 1], [0, 1, 0]],
    [[-1, 0, 0], [-1, -1, -1]],
    [[-1, 0, 0], [0, 1, 0]],
    [[1, 0, 0], [1, 1, 1]],
    [[1, 0, 0], [0, -1, 0]],
    [[0, 0, 1], [1, 1, 1]],
    [[0, 0, 1], [0, -1, 0]],
    [[-1, -1, -1], [0, 0, -1]],
    [[0, 0, -1], [0, 1, 0]]
  ];
  theA3.drawStandardEiBasis("red");
  theA3.drawText([1, 0, 0], "(1, 0, 0)");
  for (var counterLabel = 0; counterLabel < labeledVectors.length; counterLabel++) {
    theA3.drawLine([0, 0, 0], labeledVectors[counterLabel], "green");
    //theA3.drawText(labeledVectors[counterLabel], `[${labeledVectors.join(', ')}]`);
    //theA3.drawCircle(labeledVectors[counterLabel], "red");
  }
  for (var counterSegment = 0; counterSegment < segments.length; counterSegment++) {
    theA3.drawLine(segments[counterSegment][0], segments[counterSegment][1], "blue");
  }
  theA3.graphicsUnit = 150;
  theA3.drawAll();
}

function createGraphicsFromObject(input) {
  if (input.idCanvas === undefined || input.idCanvas === null) {
    throw ("idCanvas missing.");
  }
  if (input.idSpanInformation === undefined || input.idSpanInformation === null) {
    throw ("idSpanInformation missing.");
  }
  var theObject = new GraphicsNDimensions(input.idCanvas, input.idSpanInformation, input.idHighlightInformation);
  theObject.initFromObject(input);
}

function testA4(idCanvas, idSpanInformation) {
  var theA4 = new GraphicsNDimensions(idCanvas, idSpanInformation);
  theA4.dimension = 4;
  theA4.theBilinearForm = [
    [2, -1, 0, 0],
    [-1, 2, -1, 0],
    [0, -1, 2, -1],
    [0, 0, -1, 2]
  ];
  theA4.screenBasis = [
    [-0.195, 0.316, 0.828, 0.632],
    [0.602, 0.973, 0.602, 0]
  ];
  var labeledVectors = [
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 1, 0],
    [0, 0, 0, 1],
    [1, 1, 0, 0],
    [0, 1, 1, 0],
    [0, 0, 1, 1],
    [1, 1, 1, 0],
    [0, 1, 1, 1],
    [1, 1, 1, 1],
  ];
  var numberOfPositiveVectors = labeledVectors.length;
  for (var counter = 0; counter < numberOfPositiveVectors; counter++) {
    var theVector = labeledVectors[counter].slice();
    multiplyVectorByScalar(theVector, - 1);
    labeledVectors.push(theVector);
  }
  var segments = [];
  for (var counter = 0; counter < labeledVectors.length; counter++) {
    var minDistance = 10;
    for (var secondCounter = counter + 1; secondCounter < labeledVectors.length; secondCounter++) {
      var newDistance = theA4.scalarProduct(labeledVectors[counter], labeledVectors[secondCounter]);
      if (newDistance < minDistance && newDistance > 0) {
        minDistance = newDistance;
      }
    }
    for (var secondCounter = counter + 1; secondCounter < labeledVectors.length; secondCounter++) {
      var theDistance = theA4.scalarProduct(labeledVectors[counter], labeledVectors[secondCounter]);
      if (theDistance != minDistance) {
        continue;
      }
      segments.push([labeledVectors[counter].slice(), labeledVectors[secondCounter].slice()]);
    }
  }

  theA4.drawStandardEiBasis("red");
  for (var counterLabel = 0; counterLabel < labeledVectors.length; counterLabel++) {
    theA4.drawLine([0, 0, 0, 0], labeledVectors[counterLabel], "green");
    //theA3.drawText(labeledVectors[counterLabel], `[${labeledVectors.join(', ')}]`);
    //theA3.drawCircle(labeledVectors[counterLabel], "red");
  }
  for (var counterSegment = 0; counterSegment < segments.length; counterSegment++) {
    theA4.drawLine(segments[counterSegment][0], segments[counterSegment][1], "blue");
  }
  theA4.graphicsUnit = 150;
  theA4.drawAll();
}

var module;
if (window.calculator === undefined) {
  window.calculator = {};
}

if (window.calculator.graphicsNDimensions === undefined) {
  window.calculator.graphicsNDimensions = {
    startProjectionPlaneUser: startProjectionPlaneUser,
    createGraphicsFromObject: createGraphicsFromObject,
    GraphicsNDimensions: GraphicsNDimensions,
  };
}

if (module === undefined) {
  module = {};
}

module.exports = {
  createGraphicsFromObject,
  GraphicsNDimensions,
  startProjectionPlaneUser
};

},
"/calculator-html/course_page" : function(require, module, exports){
"use strict";
const submitRequests = require("./submit_requests");
const pathnames = require("./pathnames");
const ids = require("./ids_dom_elements");
const problemPage = require("./problem_page");
const typeset = require("./math_typeset");
const miscellaneous = require("./miscellaneous_frontend");

function modifyDeadlines(incomingId) {
  var thePage = window.calculator.mainPage;
  var nameDatePicker = `datePicker${incomingId}`;
  var theDates = document.getElementsByName(nameDatePicker);
  var jsonToSubmit = {};
  var idDecoded = decodeURIComponent(incomingId);
  jsonToSubmit[idDecoded] = {
    deadlines: {}
  };

  for (var counterDates = 0; counterDates < theDates.length; counterDates++) {
    var currentSection = thePage.user.sectionsTaught[counterDates];
    jsonToSubmit[idDecoded].deadlines[currentSection] = theDates[counterDates].value;
  }
  var theURL = "";
  theURL += `${pathnames.urls.calculatorAPI}?`;
  theURL += `${pathnames.urlFields.request}=${pathnames.urlFields.requests.setProblemDeadline}&`;
  theURL += `${pathnames.urlFields.mainInput}=${encodeURIComponent(JSON.stringify(jsonToSubmit))}`;
  submitRequests.submitGET({
    url: theURL,
    progress: ids.domElements.spanProgressReportGeneral,
    result: `deadlines${incomingId}`,
  });
}

var problemWeightsVisible = false;

function toggleDeadline(deadlineId, panelId, button) {
  var thePanel = document.getElementById(deadlineId);
  var theProblem = problemPage.allProblems.getProblemById(panelId);
  if (thePanel.style.maxHeight === '200px') {
    thePanel.style.opacity = '0';
    thePanel.style.maxHeight = '0';
    button.innerHTML = `${theProblem.toStringDeadline()} &#9666;`;
  } else {
    thePanel.style.opacity = '1';
    thePanel.style.maxHeight = '200px';
    button.innerHTML = `${theProblem.toStringDeadline()} &#9660;`;
  }
}

function toggleProblemWeights() {
  let theWeights = document.getElementsByClassName('panelProblemWeights');
  let theButtons = document.getElementsByClassName('accordionLikeProblemWeight');
  for (let i = 0; i < theWeights.length; i++) {
    if (!problemWeightsVisible) {
      theWeights[i].style.opacity = '1';
      theWeights[i].style.maxHeight = '200px';
    } else {
      theWeights[i].style.opacity = '0';
      theWeights[i].style.maxHeight = '0';
    }
  }
  for (let i = 0; i < theButtons.length; i++) {
    let currentProblem = problemPage.allProblems.getProblemById(theButtons[i].name);
    if (!problemWeightsVisible) {
      theButtons[i].innerHTML = `${currentProblem.toStringProblemWeight()} &#9660;`;
    } else {
      theButtons[i].innerHTML = `${currentProblem.toStringProblemWeight()} &#9666;`;
    }
  }
  problemWeightsVisible = !problemWeightsVisible;
}

function afterLoadCoursePage(incoming, result) {
  let courseBody = document.getElementById(ids.domElements.divCurrentCourseBody);
  let coursePage = document.getElementById(ids.domElements.divCurrentCourse);
  courseBody.innerHTML = miscellaneous.jsonParseGetHtmlStandard(incoming);
  let titleElements = courseBody.getElementsByTagName('title');
  if (titleElements !== null && titleElements !== undefined) {
    if (titleElements.length > 0) {
      document.getElementsByTagName('title')[0].text = titleElements[0].text;
    }
  }
  //mathjax.typeSetHard(coursePage);
  typeset.typesetter.typesetSoft(coursePage, "");
  let theTopics = document.getElementsByTagName("topicList");
  problemPage.writeEditCoursePagePanel();
  if (theTopics.length === 0) {
    return;
  }
  loadTopicList(problemPage.processLoadedTopicsWriteToCoursePage);
}

function loadTopicList(callback) {
  let thePage = window.calculator.mainPage;
  let topicListRequest = "topicListJSONNoLogin";
  if (thePage.isLoggedIn()) {
    topicListRequest = "topicListJSON";
  }
  let topicName = thePage.storage.variables.currentCourse.topicList.getValue();
  let courseHome = thePage.storage.variables.currentCourse.courseHome.getValue();
  let theURL = "";
  theURL += `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${topicListRequest}&`;
  theURL += `${pathnames.urlFields.problem.topicList}=${topicName}&`;
  theURL += `${pathnames.urlFields.problem.courseHome}=${courseHome}&`;
  submitRequests.submitGET({
    url: theURL,
    callback: callback,
    progress: ids.domElements.spanProgressReportGeneral
  });
}

let lastLoadedCourse = {
  courseHome: null,
  topicList: null,
};

function selectCurrentCoursePage() {
  var thePage = window.calculator.mainPage;
  var storageVariables = thePage.storage.variables;
  var incomingCourse = storageVariables.currentCourse.courseHome.getValue();
  var incomingTopicList = storageVariables.currentCourse.topicList.getValue();
  if (
    incomingCourse === null ||
    incomingCourse === "" ||
    incomingCourse === undefined
  ) {
    var courseBody = document.getElementById(ids.domElements.divCurrentCourseBody);
    var temporarySelectCourseId = "buttonTemporarySelectCourse";
    var courseBodyHTML = `<button id = '${temporarySelectCourseId}' `;
    courseBodyHTML += `class = "buttonSelectPage buttonSlowTransition buttonFlash" style = "width:150px" `;
    courseBodyHTML += `onclick = "window.calculator.mainPage.selectPage('selectCourse')">Please select course</button>`;
    courseBody.innerHTML = courseBodyHTML;
    setTimeout(() => {
      document.getElementById(temporarySelectCourseId).classList.remove("buttonFlash");
    }, 0);
    return;
  }
  if (lastLoadedCourse.courseHome === incomingCourse && lastLoadedCourse.topicList === incomingTopicList) {
    return;
  }
  lastLoadedCourse.courseHome = incomingCourse;
  lastLoadedCourse.topicList = incomingTopicList;
  var topicRequest = "templateJSONNoLogin";
  if (thePage.user.flagLoggedIn) {
    topicRequest = "templateJSON";
  }
  var theURL = "";
  theURL += `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${topicRequest}&`;
  theURL += `${pathnames.urlFields.problem.courseHome}=${incomingCourse}&`;
  theURL += `${pathnames.urlFields.problem.topicList}=${incomingTopicList}`;
  submitRequests.submitGET({
    url: theURL,
    callback: afterLoadCoursePage,
    progress: ids.domElements.spanProgressReportGeneral
  });
}

module.exports = {
  loadTopicList,
  lastLoadedCourse,
  modifyDeadlines,
  selectCurrentCoursePage,
  toggleDeadline,
  toggleProblemWeights,
};
},
"/calculator-html/problem_page" : function(require, module, exports){
"use strict";
const submitRequests = require("./submit_requests");
const pathnames = require("./pathnames");
const ids = require("./ids_dom_elements");
const editPage = require("./edit_page");
const initializeButtons = require("./initialize_buttons");
const typeset = require("./math_typeset");
const miscellaneous = require("./miscellaneous_frontend");
const miscellaneousFrontend = require("./miscellaneous_frontend");
const datePicker = require("./date_picker").datePicker;
const storage = require("./storage");
const AnswerPanel = require("./answer_panel").AnswerPanel;

class ProblemCollection {
  constructor() {
    /** @type{Object<string,Problem>} */
    this.topicProblems = {};
    /** @type{Object<string,Problem>} */
    this.allProblems = {};
    /** @type{string} */
    this.previousProblemId = null;
    /** @type{string} */
    this.nextProblemId = null;
    /** @type{Object<string, boolean>} */
    this.theChapterIds = {};
    this.theTopics = {};
  }

  /** @returns{Problem} */
  getProblemById(
    /**@type{string} */
    label,
  ) {
    if (!(label in this.allProblems)) {
      throw (`Error: problem label ${label} not found. `);
    }
    return this.allProblems[label];
  }

  resetTopicProblems() {
    this.theChapterIds = {};
    this.topicProblems = {};
  }

  /** @returns{Problem} */
  createOrUpdateProblem(
    problemData,
  ) {
    if (problemData.id.includes("%")) {
      console.log("Unexpected percent sign in problem id.");
    }
    // theProblemId is percent encoded, safe to embed in html.
    let theProblemId = encodeURIComponent(problemData.id);
    let element = document.getElementById(ids.domElements.problemPageContentContainer);
    let currentProblem = this.getProblemByIdOrRegisterEmpty(theProblemId, element);
    currentProblem.initializeInfo(problemData, null);
    return currentProblem;
  }

  normalizeFileName(
    problemFileName,
  ) {
    problemFileName = decodeURIComponent(problemFileName);
    return encodeURIComponent(problemFileName);
  }

  getProblemByIdOrNull(
    problemFileName,
  ) {
    let label = this.normalizeFileName(problemFileName);
    if (label in this.allProblems) {
      return this.allProblems[label];
    }
    return null;
  }

  /**@return{Problem} */
  getProblemByIdOrRegisterEmpty(
    problemFileName,
    /**@type{HTMLElement} */
    outputElement,
  ) {
    // normalize the file name:
    let problem = this.getProblemByIdOrNull(problemFileName);
    if (problem !== null) {
      return problem;
    }
    let incoming = new Problem(outputElement);
    let label = this.normalizeFileName(problemFileName);
    incoming.initializeBasic({
      id: label,
      fileName: problemFileName
    });
    this.allProblems[label] = incoming;
    return incoming;
  }
}

function selectCurrentProblem(problemIdURLed, exerciseType) {
  let thePage = window.calculator.mainPage;
  thePage.storage.variables.currentCourse.problemFileName.setAndStore(decodeURIComponent(problemIdURLed));
  thePage.storage.variables.currentCourse.exerciseType.setAndStore(exerciseType);
  let theProblem = getCurrentProblem();
  theProblem.flagForReal = false;
  if (
    exerciseType === pathnames.urlFields.scoredQuizJSON &&
    !thePage.user.flagDatabaseInactiveEveryoneIsAdmin
  ) {
    theProblem.flagForReal = true;
  }
  thePage.pages.problemPage.flagLoaded = false;
  thePage.selectPage(thePage.pages.problemPage.name);
}

class Problem {
  constructor(
    /** @type{HTMLElement}*/
    outputElement,
  ) {
    /**@type{string}*/
    this.nextProblemId = "";
    /**@type{string} */
    this.previousProblemId = "";
    /**@type{number} */
    this.totalChildren = 0;
    /** @type{HTMLElement}*/
    this.outputElement = outputElement;
  }

  setRandomSeed(input) {
    if (input === undefined) {
      input = null;
    }
    this.randomSeed = input;
  }

  setRandomSeedFromEnvironment() {
    let currentCourse = window.calculator.mainPage.storage.variables.currentCourse;
    this.flagForReal = (currentCourse.exerciseType.getValue() !== pathnames.urlFields.exerciseJSON);
    let incomingRandomSeed = currentCourse.randomSeed.getValue();
    if (incomingRandomSeed === "" || incomingRandomSeed === null || incomingRandomSeed === undefined) {
      if (!this.flagForReal) {
        return;
      }
    }
    this.setRandomSeed(incomingRandomSeed);
    currentCourse.randomSeed.value = "";
  }

  initializeBasic(problemData) {
    /** ProblemId is percent encoded, safe to embed in html. */
    this.problemId = encodeURIComponent(problemData.id);
    /** 
     * @type {string}
     * This id is for problem navigation only, does not include the entire panel.
     */
    this.idNavigationProblemNotEntirePanel = `navigationPanel${this.problemId}`;
    /**@type {AnswerPanel[]} */
    this.answerPanels = [];
    this.title = problemData.title;
    this.fileName = problemData.fileName;
    if (this.fileName === undefined || this.fileName === null) {
      this.fileName = "";
    }
    if (window.calculator.mainPage.flagProblemPageOnly) {
      this.flagForReal = false;
    } else {
      this.setRandomSeedFromEnvironment();
    }
  }

  writeProblemPage(input, outputComponent) {
    let problemData = null;
    this.outputElement.textContent = "";
    try {
      problemData = miscellaneous.jsonUnescapeParse(input);
    } catch (e) {
      this.outputElement.textContent = `Error parsing: ${e}. Failed to parse: ${input}`;
      return;
    }

    if (problemData.crashReport !== undefined && problemData.crashReport !== null) {
      let html = miscellaneousFrontend.htmlFromCommentsAndErrors(problemData);
      this.outputElement.innerHTML = html;
      return;
    }
    this.initializeProblemContent(problemData);
  }

  /** @returns{number} Number of children processed. */
  initializeInfo(problemData, inputParentIdURLed) {
    this.initializeBasic(problemData);
    this.decodedProblem = "";
    this.commentsProblem = "";
    this.parentIdURLed = inputParentIdURLed;

    this.problemLabel = "";
    this.previousProblemId = "";
    this.nextProblemId = "";
    this.scriptIds = null;
    this.type = problemData.type;
    this.problemNumberString = problemData.problemNumberString;
    this.idButtonPoints = `modifyPoints${this.problemId}`;
    this.idTextareaPoints = `points${this.problemId}`;
    this.idModifyReportDeadline = `deadlines${this.problemId}`;
    this.idDeadlinePanel = `deadlinesPanel${this.problemId}`;
    this.idDeadlineContainer = `${ids.stringResources.prefixDeadlineContainer}${this.problemId}`;
    this.idModifyReportPoints = `report${this.problemId}`;
    this.correctlyAnswered = problemData.correctlyAnswered;
    this.totalQuestions = problemData.totalQuestions;
    this.deadlines = [];
    this.deadlineString = null;
    this.deadline = null;
    this.weight = problemData.weight;
    this.links = {
      /**@type{HTMLElement[]} */
      video: [],
      /**@type{HTMLElement[]} */
      slides: [],
      /**@type{HTMLElement[]} */
      homework: [],
    };
    /**@type{HTMLElement[]} */
    this.badProblemExplanation = [];
    if (problemData.deadlines !== undefined) {
      this.deadlines = problemData.deadlines;
    }
    if (problemData.deadline !== undefined) {
      this.deadlineString = problemData.deadline;
    }
    if (this.fileName !== "") {
      this.previousProblemId = allProblems.previousProblemId;
      if (
        this.previousProblemId !== null &&
        this.previousProblemId !== undefined &&
        this.previousProblemId !== ""
      ) {
        let previousProblem = allProblems.allProblems[this.previousProblemId];
        previousProblem.nextProblemId = this.problemId;
      }
      allProblems.previousProblemId = this.problemId;
    }
    this.problemNumberString = problemData.problemNumberString;
    this.video = problemData.video;
    this.querySlides = problemData.querySlides;
    if (this.querySlides === undefined || this.querySlides === null) {
      this.querySlides = "";
    }
    this.queryHomework = problemData.queryHomework;
    if (this.queryHomework === undefined || this.queryHomework === null) {
      this.queryHomework = "";
    }
    if (this.type === "Chapter") {
      allProblems.theChapterIds[this.problemId] = true;
    }
    // const secondPartTime = new Date().getTime();
    this.childrenIds = [];
    if (Array.isArray(problemData.children)) {
      for (let counterChildren = 0; counterChildren < problemData.children.length; counterChildren++) {
        const currentChild = allProblems.createOrUpdateProblem(problemData.children[counterChildren]);
        this.totalChildren += currentChild.totalChildren + 1;
        this.childrenIds.push(currentChild.problemId);
      }
    }
  }

  /**@returns{HTMLElement[]} */
  computeBadProblemExplanation() {
    let userHasInstructorRights = true;
    let pageLastKnownGoodProblemName = "";
    let thePage = window.calculator.mainPage;
    if (!thePage.flagProblemPageOnly) {
      userHasInstructorRights = thePage.user.hasInstructorRights();
    }
    this.badProblemExplanation = [];
    if (!this.decodedProblem.includes(pathnames.urlFields.problem.failedToLoadProblem)) {
      thePage.lastKnownGoodProblemFileName = this.fileName;
      return;
    }
    pageLastKnownGoodProblemName = thePage.lastKnownGoodProblemFileName;
    let badProblemExplanationPartOne = document.createElement("div");
    badProblemExplanationPartOne.innerHTML += "It appears your problem failed to load.<br>";
    if (this.lastKnownGoodProblemFileName !== "" && userHasInstructorRights) {
      badProblemExplanationPartOne.innerHTML += "Perhaps you may like to clone the last good known problem.<br>";
    }
    this.badProblemExplanation.push(badProblemExplanationPartOne);
    miscellaneousFrontend.appendHtmlToArray(this.badProblemExplanation, editPage.getClonePanel(pageLastKnownGoodProblemName, this.fileName));
    let epilogueElement = document.createElement("hr");
    this.badProblemExplanation.push(epilogueElement);
  }

  initializeProblemContent(problemData) {
    this.initializeBasic(problemData)
    this.decodedProblem = decodeURIComponent(problemData[pathnames.urlFields.problem.content]);
    this.commentsProblem = problemData["commentsProblem"];
    if (this.commentsProblem === undefined) {
      this.commentsProblem = "";
    }
    this.commentsProblem += miscellaneousFrontend.htmlFromCommentsAndErrors(problemData);
    this.computeBadProblemExplanation();
    let answerVectors = problemData["answers"];
    if (answerVectors === undefined) {
      this.writeToHTML();
      return;
    }
    this.flagForReal = problemData["forReal"];
    this.setRandomSeed(problemData.randomSeed);
    for (let counterAnswers = 0; counterAnswers < answerVectors.length; counterAnswers++) {
      let currentVector = answerVectors[counterAnswers];
      this.answerPanels[counterAnswers] = new AnswerPanel({
        problemId: this.problemId,
        properties: currentVector.properties,
        previousAnswers: currentVector.previousAnswers,
        answerHighlight: currentVector.answerHighlight,
        answerPanelId: currentVector.answerPanelId,
        mathQuillPanelOptions: currentVector.mathQuillPanelOptions,
        idEquationEditorElement: currentVector.idEquationEditorElement,
        idEquationEditorElementLocation: currentVector.idEquationEditorElementLocation,
        idPureLatex: currentVector.idPureLatex,
        idButtonContainer: currentVector.idButtonContainer,
        idButtonSubmit: currentVector.idButtonSubmit,
        idButtonInterpret: currentVector.idButtonInterpret,
        idButtonAnswer: currentVector.idButtonAnswer,
        idButtonSolution: currentVector.idButtonSolution,
        idVerificationSpan: currentVector.idVerificationSpan,
        flagAnswerPanel: true,
        flagCalculatorPanel: false,
        randomSeed: problemData.randomSeed,
      });
    }
    this.writeToHTML();
    this.scriptIds = [];
    for (let scriptLabel in problemData.scripts) {
      let newLabel = encodeURIComponent(this.problemId + "_" + scriptLabel);
      this.scriptIds.push(newLabel);
      let scriptContent = decodeURIComponent(problemData.scripts[scriptLabel]);
      window.calculator.mainPage.scriptInjector.injectScript(newLabel, scriptContent);
    }
  }

  getAppAnchorRequestFileCourseTopics(
    /**@type {boolean} */
    isScoredQuiz,
    /**@type {boolean} */
    includeRandomSeed,
  ) {
    let thePage = window.calculator.mainPage;
    let theExerciseType = pathnames.urlFields.exerciseJSON;
    if (isScoredQuiz && !thePage.user.flagDatabaseInactiveEveryoneIsAdmin) {
      theExerciseType = pathnames.urlFields.scoredQuizJSON;
    }
    let requestJSON = {
      currentPage: thePage.pages.problemPage.name,
      exerciseType: theExerciseType,
      problemFileName: this.fileName,
      courseHome: thePage.storage.variables.currentCourse.courseHome.getValue(),
      topicList: thePage.storage.variables.currentCourse.topicList.getValue(),
    };
    if (includeRandomSeed) {
      if (
        this.randomSeed !== "" &&
        this.randomSeed !== null &&
        this.randomSeed !== undefined
      ) {
        requestJSON["randomSeed"] = this.randomSeed;
      }
    }
    let stringifiedHash = thePage.storage.getPercentEncodedURL(requestJSON);
    return stringifiedHash;
  }

  getCalculatorURLFileCourseTopics() {
    let thePage = window.calculator.mainPage;
    return this.getCalculatorURLInput(
      this.fileName,
      thePage.storage.variables.currentCourse.courseHome.getValue(),
      thePage.storage.variables.currentCourse.topicList.getValue(),
    );
  }

  getCalculatorURLInput(
    inputFileName, inputCourseHome, inputTopicList
  ) {
    let result = "";
    result += `fileName=${inputFileName}&`;
    result += `courseHome=${inputCourseHome}&`;
    result += `topicList=${inputTopicList}`;
    return result;
  }

  getCalculatorURLRequestPartOne(isScoredQuiz) {
    let thePage = window.calculator.mainPage;
    let result = "";
    if (isScoredQuiz === undefined) {
      isScoredQuiz = this.flagForReal;
    }
    result += `${pathnames.urlFields.request}=`;
    if (isScoredQuiz && !thePage.user.flagDatabaseInactiveEveryoneIsAdmin) {
      result += pathnames.urlFields.scoredQuizJSON;
    } else {
      result += pathnames.urlFields.exerciseJSON;
      if (this.randomSeed !== null && this.randomSeed !== "" && this.randomSeed !== undefined) {
        result += `&${pathnames.urlFields.randomSeed}=${this.randomSeed}`;
      }
    }
    return result;
  }

  getCalculatorURLRequestInput(
    isScoredQuiz, inputFileName, inputCourseHome, inputTopicList
  ) {
    let result = "";
    result += this.getCalculatorURLRequestPartOne(isScoredQuiz) + "&";
    result += this.getCalculatorURLInput(
      inputFileName,
      inputCourseHome,
      inputTopicList,
    );
    return result;
  }

  getCalculatorURLRequestFileCourseTopics(isScoredQuiz) {
    let result = "";
    result += this.getCalculatorURLRequestPartOne(isScoredQuiz);
    result += `&${this.getCalculatorURLFileCourseTopics()}&`;
    return result;
  }

  /**@returns {HTMLElement} */
  getProblemNavigation() {
    let result = document.createElement("DIV");
    result.id = this.idNavigationProblemNotEntirePanel;
    result.className = 'problemNavigation';
    if (!window.calculator.mainPage.flagProblemPageOnly) {
      let children = this.getProblemNavigationContent();
      for (let i = 0; i < children.length; i++) {
        result.append(children[i]);
      }
    }
    return result;
  }
  /**@returns {HTMLElement} */
  getNextProblemButton(
    /** @type{ProblemNavigationHints} */
    hints
  ) {
    if (
      this.nextProblemId === null ||
      this.nextProblemId === "" ||
      this.nextProblemId === undefined
    ) {
      return document.createTextNode("");
    }
    let nextProblem = allProblems.getProblemById(this.nextProblemId);
    let nextURL = nextProblem.getAppAnchorRequestFileCourseTopics(hints.isScoredQuiz, false);
    let nextProblemTag = document.createElement("a");
    nextProblemTag.className = hints.linkType;
    nextProblemTag.href = `#${nextURL}`;
    nextProblemTag.addEventListener(
      "click",
      selectCurrentProblem.bind(
        null,
        this.nextProblemId,
        hints.defaultRequest,
      )
    );
    nextProblemTag.innerHTML = "&#8594;";
    return nextProblemTag;
  }

  /** @returns {HTMLElement} */
  getPreviousProblemButton(
    /** @type{ProblemNavigationHints} */
    hints
  ) {
    if (
      this.previousProblemId === null ||
      this.previousProblemId === "" ||
      this.previousProblemId === undefined
    ) {
      return document.createTextNode("");
    }
    let previousProblem = allProblems.getProblemById(this.previousProblemId);
    let previousURL = previousProblem.getAppAnchorRequestFileCourseTopics(hints.isScoredQuiz, false);
    let previousLink = document.createElement("a");
    previousLink.className = hints.linkType;
    previousLink.href = `#${previousURL}`;
    previousLink.addEventListener(
      "click", window.calculator.problemPage.selectCurrentProblem.bind(
        null,
        this.previousProblemId,
        hints.defaultRequest,
      )
    );
    previousLink.innerHTML = "&#8592;";
    return previousLink;
  }

  /** @returns{ProblemNavigationHints} */
  getProblemNavigationHints() {
    let thePage = window.calculator.mainPage;
    let result = new ProblemNavigationHints();
    if (this.flagForReal && thePage.user.flagLoggedIn && !thePage.user.flagDatabaseInactiveEveryoneIsAdmin) {
      result.defaultRequest = pathnames.urlFields.scoredQuizJSON;
      result.linkType = "problemLinkQuiz";
      result.isScoredQuiz = true;
    }
    return result;
  }

  /**@returns {HTMLElement[]} */
  getProblemNavigationContent() {
    let thePage = window.calculator.mainPage;
    let result = [];
    let hints = this.getProblemNavigationHints();
    result.push(this.getPreviousProblemButton(hints));
    if (this.flagForReal && thePage.user.flagLoggedIn) {
      let practiceURL = this.getAppAnchorRequestFileCourseTopics(false, false);
      let practiceTag = document.createElement("a");
      practiceTag.className = "problemLinkPractice";
      practiceTag.href = `#${practiceURL}`;
      practiceTag.addEventListener("click", window.calculator.problemPage.selectCurrentProblem.bind(null, this.problemId, "exerciseJSON"));
      practiceTag.innerHTML = "Practice";
      result.push(practiceTag);
    } else {
      let selectedPracticeTag = document.createElement("span");
      selectedPracticeTag.className = "problemLinkSelectedPractice";
      selectedPracticeTag.style.color = "green";
      selectedPracticeTag.innerHTML = "Practice";
      result.push(selectedPracticeTag)
    }
    if (!this.flagForReal && thePage.user.flagLoggedIn && !thePage.user.flagDatabaseInactiveEveryoneIsAdmin) {
      let quizURL = this.getAppAnchorRequestFileCourseTopics(true, false);
      let quizTag = document.createElement("a");
      quizTag.className = "problemLinkQuiz";
      quizTag.href = `#${quizURL}`;
      quizTag.addEventListener("click", window.calculator.problemPage.selectCurrentProblem.bind(null, this.problemId, "scoredQuizJSON"));
      quizTag.innerHTML = "Quiz";
      result.push(quizTag);
    } else {
      if (this.flagForReal) {
        let quizTag = document.createElement("span");
        quizTag.className = "problemLinkSelectedQuiz";
        quizTag.style.color = "brown";
        quizTag.innerHTML = "Quiz";
        result.push(quizTag);
      }
    }
    result.push(this.getNextProblemButton(hints));
    if (this.flagForReal !== true && this.flagForReal !== "true") {
      let scoresTag = document.createElement("b");
      scoresTag.style.color = "green";
      scoresTag.innerHTML = "Scores not recorded.";
      result.push(scoresTag);
      result.push(document.createTextNode(" "));
      let randomSeedElement = document.createElement("SPAN");
      randomSeedElement.id = ids.domElements.spanProblemLinkWithRandomSeed;
      let randomSeedAnchor = document.createElement("a");
      randomSeedAnchor.href = `#${this.getAppAnchorRequestFileCourseTopics(false, true)}`;
      randomSeedAnchor.innerHTML = this.randomSeed;
      randomSeedElement.appendChild(randomSeedAnchor);
      result.push(randomSeedElement);
    } else {
      let scoresTag = document.createElement("b");
      scoresTag.style.color = "brown";
      scoresTag.innerHTML = "Scores are recorded. ";
      result.push(scoresTag);
    }
    return result;
  }

  getEditPanel() {
    return editPage.getEditPanel(decodeURIComponent(this.problemId));
  }

  /**@returns{HTMLElement[]} */
  getHTMLProblems() {
    let nextElement = document.createElement("div");
    nextElement.className = "bodySubsection";
    let table = document.createElement("table");
    nextElement.appendChild(table);
    table.className = "topicList";
    for (let counterSubSection = 0; counterSubSection < this.childrenIds.length; counterSubSection++) {
      let currentProblem = allProblems.getProblemById(this.childrenIds[counterSubSection]);
      let row = table.insertRow(- 1);
      currentProblem.getHTMLOneProblemTr(row);
    }
    return [nextElement];
  }

  /**@returns{HTMLElement[]} */
  getHTMLSubSection() {
    let result = [];
    let nextElement = document.createElement("div");
    nextElement.className = "headSubsection";
    nextElement.innerHTML = `${this.problemNumberString} ${this.title} ${this.toStringDeadlineContainer()}`;
    result.push(nextElement);
    miscellaneousFrontend.appendHtmlToArray(result, this.getHTMLProblems());
    return result;
  }

  isProblemContainer() {
    if (this.childrenIds.length !== undefined) {
      if (this.childrenIds.length > 0) {
        let currentProblem = allProblems.getProblemById(this.childrenIds[0]);
        if (currentProblem.type === "Problem") {
          return true;
        }
      }
    }
    return false;
  }

  /** @returns{HTMLElement[]} */
  getHTMLSection() {
    let result = [];
    if (this.type === "Section") {
      let sectionElement = document.createElement("div");
      sectionElement.className = "headSection";
      sectionElement.innerHTML = `${this.problemNumberString} ${this.title} ${this.toStringDeadlineContainer()}`;
      result.push(sectionElement);
    }
    let nextElement = document.createElement("div");
    nextElement.className = "bodySection";
    result.push(nextElement);
    if (this.type === "Topic") {
      miscellaneousFrontend.appendHtml(nextElement, this.getHTMLSubSection());
    } else if (this.isProblemContainer()) {
      miscellaneousFrontend.appendHtml(nextElement, this.getHTMLProblems());
    } else if (this.type === "Section") {
      for (let counterSection = 0; counterSection < this.childrenIds.length; counterSection++) {
        let currentSubSection = allProblems.getProblemById(this.childrenIds[counterSection]);
        miscellaneousFrontend.appendHtml(nextElement, currentSubSection.getHTMLSubSection());
      }
    } else {
      miscellaneousFrontend.appendHtml(nextElement, this.getHTMLSubSection());
    }
    return result;
  }

  /**@returns{HTMLElement[]} */
  toHTMLChapter() {
    let result = [];
    let headChapterElement = document.createElement("div");
    headChapterElement.className = "headChapter";
    headChapterElement.innerHTML = `${this.problemNumberString} ${this.title} ${this.toStringDeadlineContainer()}`
    result.push(headChapterElement);
    let bodyChapterElement = document.createElement("div");
    bodyChapterElement.className = "bodyChapter";

    if (this.isProblemContainer()) {
      let incomingProblems = this.getHTMLProblems();
      for (let i = 0; i < incomingProblems.length; i++) {
        bodyChapterElement.appendChild(incomingProblems[i]);
      }
    } else {
      for (let counterSection = 0; counterSection < this.childrenIds.length; counterSection++) {
        let currentSection = allProblems.getProblemById(this.childrenIds[counterSection]);
        miscellaneousFrontend.appendHtml(bodyChapterElement, currentSection.getHTMLSection());
      }
    }
    result.push(bodyChapterElement);
    return result;
  }

  /**@returns {HTMLElement[]} */
  getProblemMaterialLinks() {
    let result = [];
    this.links.slides = [];
    this.links.video = [];
    this.links.homework = [];
    if (this.video !== "" && this.video !== undefined && this.video !== null) {
      let videoLink = document.createElement("a");
      videoLink.classList = "videoLink";
      videoLink.href = this.video;
      videoLink.target = "_blank";
      videoLink.innerHTML = "Video";
      this.links.video.push(videoLink);
    }
    if (this.querySlides !== "" && this.querySlides !== null && this.querySlides !== undefined) {
      for (let counter in linkSlides) {
        this.links.slides.push(this.getLinkFromSpec(linkSpecs[linkSlides[counter]], this.querySlides));
      }
    }
    miscellaneousFrontend.appendHtmlToArray(result, this.links.slides);
    if (this.queryHomework !== "" && this.queryHomework !== null && this.queryHomework !== undefined) {
      for (let counter in linkHomework) {
        miscellaneousFrontend.appendHtmlToArray(this.links.homework, this.getLinkFromSpec(linkSpecs[linkHomework[counter]], this.queryHomework));
      }
    }
    miscellaneousFrontend.appendHtmlToArray(result, this.links.homework);
    return result;
  }

  getHTMLOneProblemTr(
    outputRow
  ) {
    let thePage = window.calculator.mainPage;
    let nextCell = outputRow.insertCell(- 1);
    nextCell.className = "topicListTitle";
    nextCell.innerHTML = `${this.problemNumberString} ${this.title}`;
    nextCell = outputRow.insertCell(- 1);
    nextCell.className = "topicListMaterials";
    let materialLinks = this.getProblemMaterialLinks();
    miscellaneousFrontend.appendHtml(nextCell, materialLinks);
    nextCell = outputRow.insertCell(- 1);
    nextCell.className = "topicListPracticeQuiz";
    if (this.fileName !== "") {
      if (thePage.user.flagLoggedIn) {
        let nextElement = document.createElement("a");
        nextElement.className = "problemLinkQuiz";
        nextElement.href = `#${this.getAppAnchorRequestFileCourseTopics(true)}`;
        nextElement.addEventListener(
          "click",
          window.calculator.problemPage.selectCurrentProblem.bind(
            null,
            this.problemId,
            "scoredQuizJSON",
          ),
        );
        nextElement.innerHTML = "Quiz";
        nextCell.appendChild(nextElement);
      }
      let nextElement = document.createElement("a");
      nextElement.className = "problemLinkPractice";
      nextElement.href = `#${this.getAppAnchorRequestFileCourseTopics(false)}`;
      nextElement.innerHTML = "Practice";
      nextElement.addEventListener("click", window.calculator.problemPage.selectCurrentProblem.bind(null, this.problemId, "exerciseJSON"));
      nextCell.appendChild(nextElement);
    }
    nextCell = outputRow.insertCell(- 1);
    nextCell.className = "topicListProblemWeight";
    let weightContent = this.getProblemWeightContent();
    miscellaneousFrontend.appendHtml(nextCell, weightContent)
    nextCell = outputRow.insertCell(- 1);
    nextCell.className = "topicListDeadlines";
    nextCell.innerHTML = this.toStringDeadlineContainer();
  }

  writeToHTML() {
    this.outputElement.textContent = "";
    problemNavigation.setCurrentProblemAndUpdate(this);
    let contentArray = [];
    miscellaneousFrontend.appendHtmlToArray(contentArray, this.badProblemExplanation);
    let problemBody = document.createElement("span");
    problemBody.innerHTML = this.decodedProblem + this.commentsProblem
    contentArray.push(problemBody);
    miscellaneousFrontend.appendHtml(this.outputElement, contentArray);
    for (let counterAnswers = 0; counterAnswers < this.answerPanels.length; counterAnswers++) {
      let answer = this.answerPanels[counterAnswers];
      let answerElement = document.getElementById(answer.input.answerPanelId);
      answer.writeToElement(answerElement);
    }
    initializeButtons.initializeAccordionButtons();
    typeset.typesetter.typesetSoft(this.outputElement, "");
  }

  toStringDeadline() {
    let thePage = window.calculator.mainPage;
    if (thePage.user.hasInstructorRights() && !thePage.studentView()) {
      return "Deadlines";
    }
    if (thePage.user.hasInstructorRights() && thePage.studentView()) {
      let sectionIndex = thePage.storage.variables.currentSectionComputed.getValue();
      this.deadlineString = this.deadlines[sectionIndex];
    }
    if (this.deadlineString === "" || this.deadlineString === null || this.deadlineString === undefined) {
      if (this.parentIdURLed !== null && this.parentIdURLed !== undefined && this.parentIdURLed !== "") {
        let parentProblem = allProblems.getProblemById(this.parentIdURLed);
        let inheritedResult = parentProblem.toStringDeadline();
        if (inheritedResult !== "") {
          if (!inheritedResult.endsWith("[inherited]")) {
            inheritedResult += " [inherited]";
          }
        }
        return inheritedResult;
      }
      return "";
    }
    this.deadline = new Date(this.deadlineString);
    let remainingInHours = (this.deadline - (new Date())) / 1000 / 60 / 60;
    remainingInHours += 24;
    let resultString = "";
    if (this.isSolvedForSure()) {
      resultString += `<b style = 'color:green'>${this.deadline.toLocaleDateString()}</b>`;
      return resultString;
    }
    if (remainingInHours < 48 && remainingInHours >= 0) {
      resultString += `<b style = 'color:red'>${this.deadline.toLocaleDateString()}`;
      resultString += `, ~${remainingInHours.toFixed(1)} hrs left</b>`;
      return resultString;
    }
    if (remainingInHours < 0) {
      resultString += `<b style = 'color:red'>${this.deadline.toLocaleDateString()}</b>`;
      resultString += ` <b>[passed]</b>`;
      return resultString;
    }
    resultString += `<b style>${this.deadline.toLocaleDateString()}</b>`
    return resultString;
    //  this.deadlines[];
  }

  toStringDeadlineContainer() {
    let result = "";
    result += `<span id = '${this.idDeadlineContainer}' class = '${ids.domElements.classSpanDeadlineContainer}'>${this.toStringDeadlinePanel()}</span>`;
    return result;
  }

  toStringDeadlinePanel() {
    let thePage = window.calculator.mainPage;
    if (!thePage.user.hasInstructorRights() || thePage.studentView()) {
      return this.toStringDeadline();
    }
    if (this.type === "Problem" && this.fileName === "") {
      return "";
    }
    let result = "";
    result += `<button class = "accordionLike" `;
    result += `onclick = "window.calculator.coursePage.toggleDeadline('${this.idDeadlinePanel}', '${this.problemId}', this);">`;
    result += `${this.toStringDeadline()} &#9666;</button>`;
    result += `<span class = "panelDeadlines" id = "${this.idDeadlinePanel}">`;
    result += "<table>";
    result += "<tr><th>Grp.</th><th>Deadline</th></tr>";
    for (let counterGroup = 0; counterGroup < thePage.user.sectionsTaught.length; counterGroup++) {
      result += `<tr><td>${thePage.user.sectionsTaught[counterGroup]}</td>`;
      result += `<td><input type="date" class = "datePicker" name = "datePicker${this.problemId}" `;
      if (this.deadlines[counterGroup] !== "" && this.deadlines[counterGroup] !== undefined) {
        let deadline = this.deadlines[counterGroup];
        result += `value = "${deadline}"`;
      }
      result += `></input></td></tr>`;
    }
    result += "</table>";
    //console.log("Problem data problem: " + JSON.stringify(this.fileName));
    //console.log("Problem data title: " + JSON.stringify(this.title));
    result += `<button onclick = "window.calculator.coursePage.modifyDeadlines('${this.problemId}')">Set</button>`;
    result += `<span id = '${this.idModifyReportDeadline}'></span>`;
    result += `</span>`;
    return result;
  }

  toHTMLWeights() {
    let result = "";
    result += "<span class = 'panelProblemWeights' style = 'opacity: 1; max-height: 200px;'>";
    result += `Pts: <textarea class = 'textareaStudentPoints' rows = '1' cols = '2' id = '${this.idTextareaPoints}'>`;
    if (this.weight !== undefined && this.weight !== null) {
      result += this.weight;
    }
    result += "</textarea>";
    result += `<button id = '${this.idButtonPoints}' onclick = "window.calculator.problemPage.modifyWeight('${this.problemId}')">Modify</button><br>`;
    result += `<span id = '${this.idModifyReportPoints}'></span>`;
    result += "</span>";
    return result;
  }

  modifyWeight() {
    let problemWeightTextareaId = `points${this.problemId}`;
    let incomingPoints = document.getElementById(problemWeightTextareaId).value;
    let modifyObject = {};
    let idDecoded = decodeURIComponent(this.problemId);
    //let problemModifyWeightReport = `report${id}`;
    modifyObject[idDecoded] = {
      weight: incomingPoints
    };
    let theURL = "";
    theURL += `${pathnames.urls.calculatorAPI}?`;
    theURL += `${pathnames.urlFields.request}=${pathnames.urlFields.requests.setProblemWeight}&`;
    theURL += `${pathnames.urlFields.mainInput}=${encodeURIComponent(JSON.stringify(modifyObject))}`;
    submitRequests.submitGET({
      url: theURL,
      progress: ids.domElements.spanProgressReportGeneral,
      result: this.idModifyReportPoints,
    });
  }

  /**@returns{HTMLElement[]} */
  getProblemWeightContent(inputRow) {
    let thePage = window.calculator.mainPage;
    if (this.type !== "Problem" || this.fileName === "") {
      return [];
    }
    let content = document.createElement("span");
    if (!thePage.user.hasInstructorRights() || thePage.studentView()) {
      content.innerHTML = this.toStringProblemWeight();
      return [content];
    }
    let pointsString = "";
    pointsString += `<button class = 'accordionLikeProblemWeight' onclick = "window.calculator.coursePage.toggleProblemWeights()" `;
    pointsString += `name = "${this.problemId}">${this.toStringProblemWeight()} &#9666;</button>`;
    let problemWeightString = this.toHTMLWeights();
    content.innerHTML = `${pointsString}<br> ${problemWeightString}`;
    return [content];
  }

  isSolvedForSure() {
    if (this.correctlyAnswered === undefined || this.correctlyAnswered === NaN) {
      return false;
    }
    if (
      this.correctlyAnswered >= this.totalQuestions &&
      this.totalQuestions !== undefined &&
      this.totalQuestions !== 0
    ) {
      return true;
    }
    return false;
  }

  toStringProblemWeight() {
    let result = "";
    let color = "brown";
    if (this.correctlyAnswered !== undefined && this.correctlyAnswered !== NaN) {
      if (this.isSolvedForSure()) {
        color = "green";
      }
      let numCorrectlyAnswered = this.correctlyAnswered;
      let totalQuestions = this.totalQuestions;
      if (totalQuestions === 0) {
        totalQuestions = "?";
      }
      result += `${numCorrectlyAnswered} out of ${totalQuestions}`;
      if (this.weight !== undefined && this.totalQuestions !== 0) {
        let problemWeightConverted = parseInt(this.weight);
        let points = ((0.0 + this.correctlyAnswered * problemWeightConverted) / this.totalQuestions);
        points = Number(points.toFixed(2));
        result += ` = ${points} pts`;
        if (this.correctlyAnswered < this.totalQuestions) {
          color = "red";
        }
      } else {
        result += ` = ? pts`;
      }
    }
    return `<b style = "color:${color}">${result}</b>`;
  }

  /** @returns{HTMLElement} */
  getLinkFromSpec(
    /**@type {{request: string, name: string, extension: string, options: string, download: boolean}} */
    linkSpec,
    /**@type {string} */
    query
  ) {
    if (linkSpec.adminView === true) {
      let studentView = window.calculator.mainPage.storage.variables.flagStudentView.getValue();
      if (studentView !== false && studentView !== "false") {
        return null;
      }
    }
    let href = "";
    href += `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${linkSpec.request}&`;
    href += `${query}&${linkSpec.options}`;
    let result = document.createElement("a");
    result.className = "slidesLink";
    result.href = href;
    let extension = linkSpec.extension;
    if (extension === undefined || extension === null) {
      extension = "";
    }
    result.download = `${convertStringToLaTeXFileName(this.title)}${extension}`;
    result.target = "_blank";
    result.innerHTML = linkSpec.name;
    return result;
  }
}

function getCalculatorURLRequestFileCourseTopicsFromStorage() {
  let thePage = window.calculator.mainPage;
  let currentCourse = thePage.storage.variables.currentCourse;
  let exerciseType = currentCourse.exerciseType.getValue();
  if (exerciseType === "" || exerciseType === null || exerciseType === undefined) {
    exerciseType = pathnames.urlFields.exerciseJSON;
    currentCourse.exerciseType.setAndStore(exerciseType);
  }
  let fileName = currentCourse.fileName.getValue();
  let topicList = currentCourse.topicList.getValue();
  let courseHome = currentCourse.courseHome.getValue();
  let environmentRandomSeed = currentCourse.randomSeed.getValue();
  let result = "";
  result += `${pathnames.urls.calculatorAPI}?`;
  result += `${pathnames.urlFields.request}=${exerciseType}&fileName=${fileName}&`;
  result += `topicList=${topicList}&courseHome=${courseHome}&`;
  if (
    environmentRandomSeed !== null &&
    environmentRandomSeed !== "" &&
    environmentRandomSeed !== undefined
  ) {
    result += `randomSeed=${environmentRandomSeed}&`;
  }
  currentCourse.randomSeed.value = "";
  return result;
}

function ProblemNavigationHints() {
  this.linkType = "problemLinkPractice";
  this.defaultRequest = pathnames.urlFields.exerciseJSON;
  this.isScoredQuiz = false;
}

class ProblemNavigation {
  constructor() {
    /**@type{Problem} */
    this.currentProblem = null;
    /** @type{HTMLElement|null}*/
    this.infoBar = document.getElementById(ids.domElements.divProblemInfoBar);
  }

  setCurrentProblemAndUpdate(
    /**@type{Problem} */
    inputProblem,
  ) {
    this.currentProblem = inputProblem;
    this.writeToHTML();
  }

  writeToHTML() {
    if (this.currentProblem === null) {
      return;
    }
    if (this.infoBar === null) {
      return;
    }
    let problemTitle = document.createElement("DIV");
    problemTitle.className = "problemTitle";

    let problemTitleContainer = document.createElement("DIV");
    problemTitleContainer.className = "problemTitleContainer";
    problemTitle.appendChild(problemTitleContainer);
    if (
      this.currentProblem.problemLabel !== undefined &&
      this.currentProblem.problemLabel !== "" &&
      this.currentProblem.problemLabel !== null
    ) {
      problemTitleContainer.appendChild(document.createTextNode(this.currentProblem.problemLabel));
    }
    problemTitleContainer.appendChild(document.createTextNode(this.currentProblem.title));

    this.infoBar.textContent = "";
    if (!window.calculator.mainPage.flagProblemPageOnly) {
      this.infoBar.appendChild(this.currentProblem.getProblemNavigation());
    }

    if (
      this.currentProblem.links !== undefined &&
      this.currentProblem.links !== null
    ) {
      if (this.currentProblem.links.slides !== null) {
        miscellaneousFrontend.appendHtml(problemTitle, this.currentProblem.links.slides);
      }
      if (this.currentProblem.links.video !== null) {
        miscellaneousFrontend.appendHtml(problemTitle, this.currentProblem.links.video);
      }
    }
    //topPart += "<br>"
    problemTitle.appendChild(this.currentProblem.getEditPanel());
    this.infoBar.appendChild(problemTitle);
    typeset.typesetter.typesetSoft(this.infoBar, "");
  }
}

function modifyWeight(id) {
  let theProblemWeight = allProblems.allProblems[id];
  theProblemWeight.modifyWeight();
}

function convertStringToLaTeXFileName(input) {
  let result = encodeURIComponent(input.split(" ").join("-")).split("%").join("-");
  if (result.length === 0) {
    return "undefined";
  }
  if (result[0] === "-") {
    result = "L" + result;
  }
  return result;
}

let linkSpecs = {
  slidesProjector: {
    request: pathnames.urlFields.requests.slidesFromSource,
    name: "Slides",
    extension: ".pdf",
    options: "layout=projector&",
  },
  slidesPrintable: {
    request: pathnames.urlFields.requests.slidesFromSource,
    name: "Printable",
    extension: ".pdf",
    options: "layout=printable&",
  },
  slidesTex: {
    request: pathnames.urlFields.requests.sourceSlides,
    name: ".tex",
    extension: ".tex",
    options: "",
    download: true,
    adminView: true,
  },
  homeworkWithAnswers: {
    request: pathnames.urlFields.requests.homeworkFromSource,
    extension: ".pdf",
    name: "HW",
    options: "answerKey=false&",
  },
  homeworkNoAnswers: {
    request: pathnames.urlFields.requests.homeworkFromSource,
    name: "HW+answ.",
    extension: ".pdf",
    options: "answerKey=true&",
  },
  homeworkTex: {
    request: pathnames.urlFields.requests.sourceHomework,
    name: ".tex",
    extension: ".pdf",
    options: "",
    download: true,
    adminView: true,
  },
};


let linkSlides = [
  "slidesProjector",
  "slidesPrintable",
  "slidesTex",
];

let linkHomework = [
  "homeworkWithAnswers",
  "homeworkNoAnswers",
  "homeworkTex",
];

/**@returns{HTMLElement[]} */
function getHTMLfromTopics() {
  let result = [];
  for (let label in allProblems.theChapterIds) {
    let currentProblem = allProblems.getProblemById(label);
    result.push(currentProblem.toHTMLChapter());
  }
  let extraHtml = miscellaneousFrontend.htmlFromCommentsAndErrors(allProblems.theTopics);
  if (extraHtml !== "") {
    let extraNode = document.createElement("span");
    extraNode.innerHTML = extraHtml;
    result.push(extraNode);
  }
  return result;
}

function initializeDatePickers() {
  let thePickers = document.getElementsByClassName("datePicker");
  for (let counterPicker = 0; counterPicker < thePickers.length; counterPicker++) {
    datePicker.createDatePicker(thePickers[counterPicker]);
  }
}

function initializeProblemWeightsAndDeadlines() {
  let theWeights = document.getElementsByClassName('panelProblemWeights');
  for (let i = 0; i < theWeights.length; i++) {
    //theScores[i].style.transition ='opacity 1s linear';
    theWeights[i].style.maxHeight = '0px';
  }
  let theDeadlines = document.getElementsByClassName('panelDeadlines');
  for (let i = 0; i < theDeadlines.length; i++) {
    //theScores[i].style.transition ='opacity 1s linear';
    theDeadlines[i].style.maxHeight = '0px';
  }
}

function writeEditCoursePagePanel() {
  let thePage = window.calculator.mainPage;
  let panel = document.getElementById(ids.domElements.courseEditPanel);
  panel.innerHTML = "";
  let courseHome = thePage.storage.variables.currentCourse.courseHome.getValue()
  panel.appendChild(editPage.getEditPanel(courseHome));
  let topicList = thePage.storage.variables.currentCourse.topicList.getValue();
  panel.appendChild(editPage.getEditPanel(topicList));
  if (
    allProblems.theTopics.topicBundleFile !== undefined &&
    allProblems.theTopics.topicBundleFile !== null &&
    allProblems.theTopics.topicBundleFile !== ""
  ) {
    for (
      let counterTopicBundle = 0;
      counterTopicBundle < allProblems.theTopics.topicBundleFile.length;
      counterTopicBundle++
    ) {
      let nextToEdit = allProblems.theTopics.topicBundleFile[counterTopicBundle];
      panel.appendChild(editPage.getEditPanel(nextToEdit));
    }
  }
}

function processLoadedTopics(incomingTopics, result) {
  const startTime = new Date().getTime();
  allProblems.previousProblemId = null;
  allProblems.resetTopicProblems();
  allProblems.theTopics = miscellaneous.jsonUnescapeParse(incomingTopics);
  if (!Array.isArray(allProblems.theTopics["children"])) {
    return;
  }
  let totalChildren = 0;
  for (let counterChapter = 0; counterChapter < allProblems.theTopics["children"].length; counterChapter++) {
    const currentChapter = allProblems.theTopics["children"][counterChapter];
    const problem = allProblems.createOrUpdateProblem(currentChapter);
    totalChildren += problem.totalChildren;
  }
  const finalTime = new Date().getTime() - startTime;
  const timePerChild = finalTime / totalChildren;
  if (finalTime > 1000) {
    console.log(`Final time of processLoadedTopics: ${finalTime} ms for ${totalChildren} children at ${timePerChild.toFixed()} ms per child.`);
  }
}

function processLoadedTopicsWriteToEditPage(incomingTopics, result) {
  processLoadedTopics(incomingTopics, result);
  editPage.selectEditPage(null);
}

function processLoadedTopicsWriteToCoursePage(incomingTopics, result) {
  const startTime = new Date().getTime();
  processLoadedTopics(incomingTopics, result);
  writeTopicsToCoursePage();
  const writeTime = new Date().getTime() - startTime;
  if (writeTime > 1000) {
    console.log(`Less than a second to generate html expected, needed ${writeTime} ms instead.`);
  }
}

function writeTopicsToCoursePage() {
  let thePage = window.calculator.mainPage;
  let topicsElements = document.getElementsByTagName("topicList");
  writeEditCoursePagePanel();
  let htmlContentElements = getHTMLfromTopics();
  let extraComments = miscellaneousFrontend.htmlElementsFromCommentsAndErrors(allProblems.theTopics);
  miscellaneousFrontend.appendHtml(topicsElements[0], extraComments);
  miscellaneousFrontend.appendHtml(topicsElements[0], htmlContentElements);
  initializeProblemWeightsAndDeadlines();
  initializeDatePickers();
  //mathjax.typeSetHard(topicsElements[0]);
  if (thePage.pages.problemPage.flagLoaded) {
    problemNavigation.writeToHTML();
  }
  typeset.typesetter.typesetSoft(topicsElements[0], "");
}

function updateProblemPage() {
  let thePage = window.calculator.mainPage;
  // thePage.pages.problemPage.flagLoaded is modified by the following
  // functions: selectCurrentProblem, logout, callbackClone,
  // the present function updateProblemPage
  /**@type {Problem} */
  let problem = getCurrentProblem();
  if (thePage.pages.problemPage.flagLoaded) {
    if (problem !== undefined && problem !== null) {
      let problemNavigation = document.getElementById(problem.idNavigationProblemNotEntirePanel);
      if (problemNavigation !== null) {
        problemNavigation.innerHTML = "";
        let updatedContent = problem.getProblemNavigationContent();
        for (let i = 0; i < updatedContent.length; i++) {
          problemNavigation.appendChild(updatedContent[i]);
        }
      }
    }
    return;
  }
  let theURL;
  if (problem !== undefined && problem !== null) {
    let forReal = problem.flagForReal;
    if (!thePage.user.flagLoggedIn) {
      forReal = false;
    }
    theURL = `${pathnames.urls.calculatorAPI}?${problem.getCalculatorURLRequestFileCourseTopics(forReal)}`;
  } else {
    let fileName = thePage.storage.variables.currentCourse.fileName.getValue();
    if (fileName === "" || fileName === undefined || fileName === null) {
      let courseBody = document.getElementById(ids.domElements.problemPageContentContainer);
      let temporarySelectProblem = "buttonTemporarySelectProblem";
      let selectProblemHtml = "";
      selectProblemHtml += `Problems are selected from the <button id = '${temporarySelectProblem}'`;
      selectProblemHtml += `class = "buttonSelectPage buttonSlowTransition buttonFlash" style = "width:150px"`;
      selectProblemHtml += `onclick = "window.calculator.mainPage.selectPage('currentCourse')">Current course</button>`;
      selectProblemHtml += "<br>To select a problem, click Practice or Quiz within the course page. ";
      courseBody.innerHTML = selectProblemHtml;
      setTimeout(() => {
        document.getElementById(temporarySelectProblem).classList.remove("buttonFlash");
      }, 100);
      return;
    }
    theURL = getCalculatorURLRequestFileCourseTopicsFromStorage();
  }
  thePage.pages.problemPage.flagLoaded = true;
  submitRequests.submitGET({
    url: theURL,
    callback: (input, outputComponent) => {
      problem.writeProblemPage(input, outputComponent);
    },
    progress: ids.domElements.spanProgressReportGeneral,
  });
}

function loadProblemIntoElement(
  /**@type{HTMLElement|string} */
  problemElement,
) {
  if (typeof problemElement === "string") {
    problemElement = document.getElementById(problemElement);
  }
  let problemFileName = problemElement.getAttribute("problem");
  let problem = allProblems.getProblemByIdOrRegisterEmpty(problemFileName, problemElement);
  problem.flagForReal = false;
  if (problemElement.getAttribute("forReal") === "true") {
    problem.flagForReal = true;
  }
  let theURL = `${pathnames.urls.calculatorAPI}?${problem.getCalculatorURLRequestFileCourseTopics(problem.flagForReal)}`;
  submitRequests.submitGET({
    url: theURL,
    callback: (input, outputComponent) => {
      problem.writeProblemPage(input, outputComponent);
    },
    progress: ids.domElements.spanProgressReportGeneral,
    result: problemElement,
  });
}

/**@returns{Problem|null} */
function getCurrentProblem() {
  let problemFileName = storage.storage.variables.currentCourse.problemFileName.getValue();
  if (
    problemFileName === "" ||
    problemFileName === null ||
    problemFileName === undefined
  ) {
    return null;
  }
  let element = document.getElementById(ids.domElements.problemPageContentContainer);
  return allProblems.getProblemByIdOrRegisterEmpty(problemFileName, element);
}

let problemNavigation = new ProblemNavigation();
let allProblems = new ProblemCollection();

module.exports = {
  Problem,
  allProblems,
  problemNavigation,
  updateProblemPage,
  loadProblemIntoElement,
  processLoadedTopicsWriteToCoursePage,
  processLoadedTopicsWriteToEditPage,
  writeEditCoursePagePanel,
  selectCurrentProblem,
  modifyWeight,
};
},
"/calculator-html/select_course" : function(require, module, exports){
"use strict";
const submitRequests = require("./submit_requests");
const pathnames = require("./pathnames");
const editPage = require("./edit_page");
const ids = require("./ids_dom_elements");
const miscellaneousFrontend = require("./miscellaneous_frontend");

function selectCourse(courseIndex) {
  var thePage = window.calculator.mainPage;
  var theCourse = thePage.theCourses[courseIndex];
  thePage.storage.variables.currentCourse.courseHome.setAndStore(theCourse.courseHome);
  thePage.storage.variables.currentCourse.topicList.setAndStore(theCourse.topicList);
  thePage.selectPage(thePage.pages.currentCourse.name);
}

function afterLoadSelectCoursePage(incomingPage, result) {
  var result = [];
  var thePage = window.calculator.mainPage;
  thePage.theCourses = JSON.parse(incomingPage)["courses"];
  pageSetup.needsLoad = false;

  var userHasProblemEditRights = thePage.user.hasProblemEditRights();
  if (userHasProblemEditRights) {
    var problemInfoBar = document.createElement("div");
    problemInfoBar.className = "problemInfoBar";
    problemInfoBar.appendChild(editPage.getEditPanel("/coursesavailable/default.txt"));
    result.push(problemInfoBar);
  }
  var courseContainer = document.createElement("div");
  courseContainer.style.textAlign = "center";
  courseContainer.style.width = "100%";
  for (var counterCourses = 0; counterCourses < thePage.theCourses.length; counterCourses ++) {
    var currentCourse = thePage.theCourses[counterCourses];
    var isRoughDraft = false;
    if (currentCourse.roughDraft === "true" || currentCourse.roughDraft === true) {
      isRoughDraft = true;
      if (!thePage.serverIsOnLocalHost() && !userHasProblemEditRights) {
        continue;
      }
    }
    var editButton = document.createElement("button");
    editButton.className = "courseButton";
    editButton.addEventListener("click", selectCourse.bind(null, counterCourses));
    var editButtonInternal = "";
    editButtonInternal += `${currentCourse.title}`;
    if (isRoughDraft) {
      editButtonInternal += "<b style = 'color:red; font-size: x-small'>rough draft</b>";
    }
    editButton.innerHTML = editButtonInternal;
    courseContainer.appendChild(editButton);
    if (counterCourses != thePage.theCourses.length - 1) {
      courseContainer.appendChild(document.createElement("br"));
    }
  }
  result.push(courseContainer);
  var divSelectcourse = document.getElementById("divSelectCourse");
  divSelectcourse.innerHTML = "";
  miscellaneousFrontend.appendHtml(divSelectcourse, result);
}

var pageSetup = {
  needsLoad: true,
};

function selectCoursePage() {
  if (pageSetup.needsLoad !== true) {
    return;
  }
  submitRequests.submitGET({
    url: `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${pathnames.urlFields.selectCourse}`,
    callback: afterLoadSelectCoursePage,
    progress: ids.domElements.spanProgressReportGeneral,
  });
}

module.exports = {
  pageSetup,
  selectCoursePage,
  selectCourse,
};
},
"/calculator-html/equation_editor" : function(require, module, exports){
// Licensed to you under the Apache 2.0 license.
"use strict";

var module;
if (module === undefined) {
  module = {
    exports: null,
  };
}

class MathNodeType {
  normalizeConstructorInput(input) {
    for (let label in knownTypeDefaults) {
      if (!(label in input)) {
        input[label] = knownTypeDefaults[label];
      }
    }
    if (input["arrows"] === undefined) {
      input["arrows"] = knownTypeDefaultsArrows;
      return;
    }
    for (let label in knownTypeDefaultsArrows) {
      if (!(label in input["arrows"])) {
        input["arrows"][label] = knownTypeDefaultsArrows[label];
      }
    }
  }

  constructor(input) {
    this.normalizeConstructorInput(input);
    this.arrows = input["arrows"];
    this.type = input["type"];
    this.minHeightScale = input["minHeightScale"];
    this.width = input["width"];
    this.height = input["height"];
    this.display = input["display"];
    this.verticalAlign = input["verticalAlign"];
    this.outline = input["outline"];
    this.fontSizeRatio = input["fontSizeRatio"];
    this.fontWeight = input["fontWeight"];
    this.whiteSpace = input["whiteSpace"];
    this.textAlign = input["textAlign"];
    this.position = input["position"];
    this.minWidth = input["minWidth"];
    this.cursor = input["cursor"];
    this.overflow = input["overflow"];
    this.boxSizing = input["boxSizing"];
    this.colorImplied = input["colorImplied"];
    this.colorText = input["colorText"];
    // Padding.
    this.paddingBottom = input["paddingBottom"];
    this.paddingTop = input["paddingTop"];
    this.paddingRight = input["paddingRight"];
    this.paddingLeft = input["paddingLeft"];
    this.padding = input["padding"];
    // Margins.
    this.margin = input["margin"];
    this.marginBottom = input["marginBottom"];
    this.marginRight = input["marginRight"];
    this.marginLeft = input["marginLeft"];
    // Borders
    this.borderTopLeftRadius = input["borderTopLeftRadius"];
    this.borderTopRightRadius = input["borderTopRightRadius"];
    this.borderBottomLeftRadius = input["borderBottomLeftRadius"];
    this.borderBottomRightRadius = input["borderBottomRightRadius"];
    this.borderStyle = input["borderStyle"];
    this.borderColor = input["borderColor"];
    this.borderBottom = input["borderBottom"];
    this.borderTop = input["borderTop"];
    this.borderLeft = input["borderLeft"];
    this.borderRight = input["borderRight"];
  }

  /**@return {MathNodeType} */
  clone() {
    return Object.assign(new MathNodeType({}), this);
  }
}

const knownTypeDefaults = {
  "width": "",
  "height": "",
  "minWidth": "",
  "display": "inline-block",
  "minHeightScale": 0,
  "verticalAlign": "",
  "fontSizeRatio": 1,
  "fontWeight": "",
  "whiteSpace": "",
  "textAlign": "",
  "position": "absolute",
  "cursor": "",
  "outline": "",
  "overflow": "",
  "boxSizing": "",
  // Colors
  "colorText": "",
  "colorImplied": "",
  // Padding
  "paddingBottom": "",
  "paddingTop": "",
  "paddingLeft": "",
  "paddingRight": "",
  "padding": "",
  // Margins
  "marginBottom": "",
  "marginLeft": "",
  "marginRight": "",
  "margin": "",
  // Borders.
  "borderBottomLeftRadius": "",
  "borderBottomRightRadius": "",
  "borderTopLeftRadius": "",
  "borderTopRightRadius": "",
  "borderStyle": "",
  "borderColor": "",
  "borderBottom": "",
  "borderTop": "",
  "borderLeft": "",
  "borderRight": "",
};

class ArrowMotionTypes {
  constructor() {
    this.parentForward = "parentForward";
    this.firstAtomToTheLeft = "firstAtomToTheLeft";
    this.firstAtomToTheRight = "firstAtomToTheRight";
  }
}

let arrowMotion = new ArrowMotionTypes();

const knownTypeDefaultsArrows = {
  "ArrowUp": arrowMotion.parentForward,
  "ArrowDown": arrowMotion.parentForward,
  "ArrowLeft": arrowMotion.firstAtomToTheLeft,
  "ArrowRight": arrowMotion.firstAtomToTheRight,
};

const defaultFractionScale = 0.9;

const knownTypes = {
  root: new MathNodeType({
    "type": "root",
    "padding": "2px",
    "margin": "2px",
    "cursor": "text",
    "minWidth": "30px",
  }),
  // A math expression with no children such as "x", "2".
  // This is the only element type that has contentEditable = true;
  atom: new MathNodeType({
    "type": "atom",
    "outline": "0px solid transparent",
    "width": "auto",
    "height": "auto",
    "minWidth": "4px",
    "verticalAlign": "text-bottom",
    "overflow": "hidden",
  }),
  // A non-editable math expression/operator such as "+" or "-".
  atomImmutable: new MathNodeType({
    "type": "atomImmutable",
    "paddingLeft": `${0.1}em`,
    "paddingRight": `${0.1}em`,
    "outline": "0px solid transparent",
    "textAlign": "center",
    "width": "auto",
    "height": "auto",
  }),
  eventCatcher: new MathNodeType({
    "type": "eventCatcher",
    "width": "0px",
    "maxWidth": "0px",
    "height": "0px",
    "maxHeight": "0px",
    "display": "hidden",
    "overflow": "hidden",
  }),
  error: new MathNodeType({
    "type": "error",
    "colorText": "red",
    "whiteSpace": "nowrap",
  }),
  leftDelimiterMark: new MathNodeType({
    "type": "leftDelimiterMark",
    "borderLeft": "2px solid",
    "colorImplied": "silver",
    "boxSizing": "border-box",
  }),
  // Left delimiter (parentheses, bracket, ...)
  leftDelimiter: new MathNodeType({
    "type": "leftDelimiter",
    "colorImplied": "silver",
  }),
  // Right delimiter mark surrounded by two spacers.
  rightDelimiterMark: new MathNodeType({
    "type": "rightDelimiterMark",
    "borderRight": "2px solid",
    "colorImplied": "silver",
    "boxSizing": "border-box",
  }),
  // Right delimiter (parentheses, bracket, ...)
  rightDelimiter: new MathNodeType({
    "type": "rightDelimiter",
    "colorImplied": "silver",
  }),
  // Horizontally laid out math such as "x+2". 
  // The example "x+2" consists of the three elements "x", "+" and 2.
  // Not allowed to contain other horizontally laid out math elements.
  horizontalMath: new MathNodeType({
    "type": "horizontalMath",
    "whiteSpace": "nowrap",
    "verticalAlign": "text-bottom",
    "textAlign": "center",
  }),
  verticalLineInTable: new MathNodeType({
    "type": "verticalLine",
    "borderLeft": "1px solid black",
  }),
  // Represents expressions such as "x/y" or "\frac{x}{y}".
  fraction: new MathNodeType({
    "type": "fraction",
  }),
  cancel: new MathNodeType({
    "type": "cancel",
  }),
  cancelSign: new MathNodeType({
    "type": "cancelSign",
    "borderLeft": "2px solid black",
  }),
  cancelUnderBox: new MathNodeType({
    "type": "cancelUnderBox",
  }),
  // Represents the numerator x of a fraction x/y.
  numerator: new MathNodeType({
    "type": "numerator",
    "borderBottom": "1px solid black",
    "fontSizeRatio": defaultFractionScale,
    "minHeightScale": defaultFractionScale,
    "arrows": {
      "ArrowUp": arrowMotion.firstAtomToTheLeft,
      "ArrowDown": arrowMotion.firstAtomToTheRight,
    },
    "whiteSpace": "nowrap",
    "textAlign": "center",
  }),
  // Represents the denominator y of a fraction x/y.
  denominator: new MathNodeType({
    "type": "denominator",
    "fontSizeRatio": defaultFractionScale,
    "minHeightScale": defaultFractionScale,
    "arrows": {
      "ArrowUp": arrowMotion.firstAtomToTheLeft,
      "ArrowDown": arrowMotion.firstAtomToTheRight,
    },
    "textAlign": "center",
  }),
  overLinedBox: new MathNodeType({
    "type": "overLinedBox",
    "borderTop": "1px solid black",
    "boxSizing": "border-box",
  }),
  genericMathBox: new MathNodeType({
    "type": "genericMathBox",
  }),
  baseWithExponent: new MathNodeType({
    "type": "baseWithExponent",
  }),
  exponent: new MathNodeType({
    "type": "exponent",
    "fontSizeRatio": 0.75,
    "minHeightScale": 0.75,
  }),
  baseWithSubscript: new MathNodeType({
    "type": "baseWithSubscript",
  }),
  underBrace: new MathNodeType({
    "type": "underBrace",
  }),
  overBrace: new MathNodeType({
    "type": "overBrace",
  }),
  horizontalBraceUp: new MathNodeType({
    "type": "horizontalBraceUp",
  }),
  topRightQuarterCircle: new MathNodeType({
    "type": "topRightQuarterCircle",
    "borderTopRightRadius": "4px",
  }),
  topLeftQuarterCircle: new MathNodeType({
    "type": "topLeftQuarterCircle",
    "borderTopLeftRadius": "4px",
  }),
  bottomRightQuarterCircle: new MathNodeType({
    "type": "bottomRightQuarterCircle",
    "borderBottomRightRadius": "4px",
  }),
  bottomLeftQuarterCircle: new MathNodeType({
    "type": "bottomLeftQuarterCircle",
    "borderBottomLeftRadius": "4px",
  }),
  horizontalLineBottomMargin: new MathNodeType({
    "type": "horizontalLineBottomMargin",
    "borderBottom": "2px solid black",
  }),
  verticalLineLeftMargin: new MathNodeType({
    "type": "verticalLineLeftMargin",
    "borderLeft": "solid",
  }),
  verticalLineRightMargin: new MathNodeType({
    "type": "verticalLineRightMargin",
    "borderRight": "solid",
  }),
  subscript: new MathNodeType({
    "type": "subscript",
    "fontSizeRatio": 0.75,
    "minHeightScale": 0.75,
  }),
  sqrt: new MathNodeType({
    "type": "sqrt",
    "margin": "2px",
  }),
  sqrtSign: new MathNodeType({
    "type": "sqrtSign",
  }),
  sqrtSignDecoration: new MathNodeType({
    "type": "sqrtSignDecoration",
    "borderTop": "1px solid black",
  }),
  sqrtSignLeft: new MathNodeType({
    "type": "sqrtSignLeft",
    "borderLeft": "1px solid black",
  }),
  sqrtSignRight: new MathNodeType({
    "type": "sqrtSignRight",
    "borderLeft": "1px solid black",
  }),
  radicalExponentBox: new MathNodeType({
    "type": "radicalExponentBox",
    "fontSizeRatio": 0.75,
    "minHeightScale": 0.75,
  }),
  radicalUnderBox: new MathNodeType({
    "type": "radicalUnderBox",
    "borderTop": "1px solid black",
  }),
  matrix: new MathNodeType({
    "type": "matrix",
  }),
  matrixTable: new MathNodeType({
    "type": "matrixTable",
  }),
  matrixRow: new MathNodeType({
    "type": "matrixRow",
  }),
  matrixRowEntry: new MathNodeType({
    "type": "matrixRowEntry",
  }),
  operatorWithSuperAndSubscript: new MathNodeType({
    "type": "operatorWithSuperAndSubscript",
  }),
  operatorWithSubscript: new MathNodeType({
    "type": "operatorWithSubscript",
  }),
  operatorStandalone: new MathNodeType({
    "type": "operatorStandalone",
    "fontSizeRatio": 1.8,
    "minHeightScale": 1.8,
  }),
  operatorSubscript: new MathNodeType({
    "type": "operatorSubscript",
    "fontSizeRatio": 0.55,
    "minHeightScale": 0.55,
  }),
  operatorSuperscript: new MathNodeType({
    "type": "operatorSuperscript",
    "fontSizeRatio": 0.55,
    "minHeightScale": 0.55,
  }),
};

class MathNodeFactory {
  horizontalMath(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {MathNode|null} */
    content,
  ) {
    const result = new MathNodeHorizontalMath(equationEditor);
    if (content === null) {
      content = this.atom(equationEditor, "");
    }
    result.appendChild(content);
    return result;
  }

  genericMathBox(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {MathNode|null} */
    content,
  ) {
    const result = new MathNodeGenericBox(equationEditor);
    result.appendChild(this.horizontalMath(equationEditor, content));
    return result;
  }

  /** @returns{MathNode} 
   * Returns a horizontal math with content given by the input array.
   * Normalizes the input but does not ensure editable atoms at the ends. 
   */
  horizontalMathFromArray(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {(MathNode|null)[]} */
    content,
  ) {
    let first = null;
    if (content.length > 0) {
      first = content[0];
    }
    let result = this.horizontalMath(equationEditor, first);
    for (let i = 1; i < content.length; i++) {
      if (content[i] === null) {
        continue;
      }
      result.appendChild(content[i]);
    }
    result.normalizeHorizontalMath();
    return result;
  }

  atom(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {string} */
    initialContent,
  ) {
    const result = new MathNodeAtom(equationEditor);
    result.positionCaretBeforeKeyEvents = initialContent.length;
    result.initialContent = initialContent;
    return result;
  }

  atomImmutable(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {string} */
    operator,
  ) {
    const result = new MathNodeAtomImmutable(equationEditor);
    if (operator in latexConstants.operatorsExtraPadding) {
      let extraPadding = latexConstants.operatorsExtraPadding[operator];
      result.type.paddingLeft = extraPadding;
      result.type.paddingRight = extraPadding;
    }
    result.initialContent = operator;
    return result;
  }

  /** @returns {MathNode} */
  fraction(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type{MathNode|null}*/
    numeratorContent,
    /** @type{MathNode|null}*/
    denominatorContent,
  ) {
    const fraction = new MathNodeFraction(equationEditor);
    const numerator = new MathNodeNumerator(equationEditor);
    const denominator = new MathNodeDenominator(equationEditor);
    numerator.appendChild(this.horizontalMath(equationEditor, numeratorContent));
    denominator.appendChild(this.horizontalMath(equationEditor, denominatorContent));
    fraction.appendChild(numerator);
    fraction.appendChild(denominator);
    return fraction;
  }

  rootMath(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    const result = new MathNodeRoot(equationEditor);
    result.appendChild(this.horizontalMath(equationEditor, null));
    return result;
  }

  error(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {string} */
    initialContent,
  ) {
    const result = new MathNodeError(equationEditor);
    result.initialContent = initialContent;
    return result;
  }

  /** @returns {MathNode} */
  cancel(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type{MathNode}*/
    content,
  ) {
    const result = new MathNodeCancel(equationEditor);
    const cancelSign = new MathNode(equationEditor, knownTypes.cancelSign);
    const horizontal = this.horizontalMath(equationEditor, content);
    let underTheCancel = new MathNodeCancelUnderBox(equationEditor);
    underTheCancel.appendChild(horizontal);
    underTheCancel.normalizeHorizontalMath();
    underTheCancel.ensureEditableAtoms();
    result.appendChild(cancelSign);
    result.appendChild(underTheCancel);
    return result;
  }

  /** @returns {MathNode} */
  sqrtSign(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    let result = new MathNodeSqrtSign(equationEditor);
    result.appendChild(new MathNode(equationEditor, knownTypes.sqrtSignDecoration));
    result.appendChild(new MathNode(equationEditor, knownTypes.sqrtSignLeft));
    result.appendChild(new MathNode(equationEditor, knownTypes.sqrtSignRight));
    return result;
  }

  /** @returns {MathNode} */
  sqrt(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {MathNode|null} */
    underTheRadicalContent,
    /** @type {MathNode|null} */
    exponentContent,
  ) {
    const sqrt = new MathNodeSqrt(equationEditor);
    const radicalExponentBox = new MathNode(equationEditor, knownTypes.radicalExponentBox);
    radicalExponentBox.appendChild(this.horizontalMath(equationEditor, exponentContent));
    sqrt.appendChild(radicalExponentBox);
    sqrt.appendChild(mathNodeFactory.sqrtSign(equationEditor));
    const underTheRadical = new MathNodeRadicalUnderBox(equationEditor);
    underTheRadical.appendChild(mathNodeFactory.horizontalMath(equationEditor, underTheRadicalContent));
    sqrt.appendChild(underTheRadical);
    return sqrt;
  }

  /** @returns {MathNode} */
  overLine(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {MathNode|null} */
    content,
  ) {
    const result = new MathNodeOverLine(equationEditor);
    const horizontalMath = this.horizontalMath(equationEditor, content);
    result.appendChild(horizontalMath);
    return result;
  }

  /** @returns {MathNode} */
  overBrace(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {MathNode|null} */
    content,
    /** @type {MathNode|null} */
    overBraceContent,
  ) {
    const result = new MathNodeOverBrace(equationEditor);
    const base = mathNodeFactory.horizontalMath(equationEditor, content);
    // 6 components of overbrace line
    const horizontalBraceTopLeft = new MathNode(equationEditor, knownTypes.topLeftQuarterCircle);
    const horizontalBraceLeft = new MathNode(equationEditor, knownTypes.horizontalLineBottomMargin);
    const horizontalBraceBottomRight = new MathNode(equationEditor, knownTypes.bottomRightQuarterCircle);
    const horizontalBraceBottomLeft = new MathNode(equationEditor, knownTypes.bottomLeftQuarterCircle);
    const horizontalBraceRight = new MathNode(equationEditor, knownTypes.horizontalLineBottomMargin);
    const horizontalBraceTopRight = new MathNode(equationEditor, knownTypes.topRightQuarterCircle);

    const horizontalBrace = new MathNode(equationEditor, knownTypes.horizontalBraceUp);
    horizontalBrace.appendChildren([
      horizontalBraceTopLeft,
      horizontalBraceLeft,
      horizontalBraceBottomRight,
      horizontalBraceBottomLeft,
      horizontalBraceRight,
      horizontalBraceTopRight,
    ]);
    let superscript = mathNodeFactory.genericMathBox(equationEditor, overBraceContent);
    result.appendChild(base);
    result.appendChild(horizontalBrace);
    result.appendChild(superscript);
    return result;
  }

  /** @returns {MathNode} */
  baseWithExponent(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type{MathNode}*/
    base,
    /** @type{MathNode|null}*/
    exponent,
  ) {
    const baseWithExponent = new MathNodeBaseWithExponent(equationEditor);
    // Horizontal math wrapper for the exponent.
    const exponentWrapped = new MathNodeExponent(equationEditor);
    let exponentContainer = this.horizontalMath(equationEditor, exponent);
    exponentContainer.normalizeHorizontalMath();
    exponentContainer.ensureEditableAtoms();
    exponentWrapped.appendChild(exponentContainer);
    // Horizontal math wrapper for the base.
    const baseHorizontal = new MathNode(equationEditor, knownTypes.horizontalMath);
    baseHorizontal.appendChild(base);
    baseHorizontal.normalizeHorizontalMath();
    // The base with the exponent.
    baseWithExponent.appendChild(baseHorizontal);
    baseWithExponent.appendChild(exponentWrapped);
    return baseWithExponent;
  }

  /** @returns {MathNode} */
  baseWithSubscript(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type{MathNode}*/
    base,
    /** @type{MathNode|null}*/
    subscript,
  ) {
    // Horizontal math wrapper for the exponent.
    const subscriptWrapped = new MathNodeSubscript(equationEditor);
    let subscriptContainer = this.horizontalMath(equationEditor, subscript);
    subscriptContainer.normalizeHorizontalMath();
    subscriptContainer.ensureEditableAtoms();
    subscriptWrapped.appendChild(subscriptContainer);
    // Horizontal math wrapper for the base.
    const baseHorizontal = new MathNode(equationEditor, knownTypes.horizontalMath);
    baseHorizontal.appendChild(base);
    baseHorizontal.normalizeHorizontalMath();
    // The base with the subscript.
    const baseWithSubscript = new MathNodeBaseWithSubscript(equationEditor);
    baseWithSubscript.appendChild(baseHorizontal);
    baseWithSubscript.appendChild(subscriptWrapped);
    return baseWithSubscript;
  }

  /** @returns {MathNode} */
  leftParenthesis(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {boolean} */
    implied,
  ) {
    return this.leftDelimiter(equationEditor, "(", implied);
  }

  /** @returns {MathNode} */
  leftDelimiter(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {string} */
    content,
    /** @type {boolean} */
    implied,
  ) {
    const leftDelimiter = new MathNodeLeftDelimiter(equationEditor);
    leftDelimiter.implied = implied;
    if (content === "") {
      return leftDelimiter;
    }
    leftDelimiter.appendChild(this.delimiterMark(equationEditor, content, true, implied));
    leftDelimiter.extraData = content;
    return leftDelimiter;
  }

  delimiterMark(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {string} */
    content,
    /**@type{boolean} */
    left,
    /** @type {boolean} */
    implied,
  ) {
    let result = null;
    switch (content) {
      case "|":
        result = new MathNodeAbsoluteValue(equationEditor, left);
        break;
      case "\\rangle":
      case "\\langle":
      // utf16 version of \\rangle 
      case "\u27E9":
      // utf16 version of \\langle 
      case "\u27E8":
        result = new MathNodeAngleBrackets(equationEditor, left);
        if (left) {
          result.appendChild(new MathNode(equationEditor, knownTypes.verticalLineLeftMargin));
          result.appendChild(new MathNode(equationEditor, knownTypes.verticalLineLeftMargin));
        } else {
          result.appendChild(new MathNode(equationEditor, knownTypes.verticalLineRightMargin));
          result.appendChild(new MathNode(equationEditor, knownTypes.verticalLineRightMargin));
        }
        break;
      case "[":
      case "]":
        result = new MathNodeSquareBrackets(equationEditor, left);
        break;
      case "(":
      case ")":
        result = new MathNodeParenthesis(equationEditor, left);
        if (left) {
          result.appendChild(new MathNode(equationEditor, knownTypes.verticalLineLeftMargin));
        } else {
          result.appendChild(new MathNode(equationEditor, knownTypes.verticalLineRightMargin));
        }
        break;
      case "{":
      case "}":
      default:
        result = new MathNodeCurlyBrace(equationEditor, left);
        if (left) {
          result.appendChild(new MathNode(equationEditor, knownTypes.topLeftQuarterCircle));
          result.appendChild(new MathNode(equationEditor, knownTypes.verticalLineLeftMargin));
          result.appendChild(new MathNode(equationEditor, knownTypes.bottomRightQuarterCircle));
          result.appendChild(new MathNode(equationEditor, knownTypes.topRightQuarterCircle));
          result.appendChild(new MathNode(equationEditor, knownTypes.verticalLineLeftMargin));
          result.appendChild(new MathNode(equationEditor, knownTypes.bottomLeftQuarterCircle));
        } else {
          result.appendChild(new MathNode(equationEditor, knownTypes.topRightQuarterCircle));
          result.appendChild(new MathNode(equationEditor, knownTypes.verticalLineLeftMargin));
          result.appendChild(new MathNode(equationEditor, knownTypes.bottomLeftQuarterCircle));
          result.appendChild(new MathNode(equationEditor, knownTypes.topRightQuarterCircle));
          result.appendChild(new MathNode(equationEditor, knownTypes.verticalLineLeftMargin));
          result.appendChild(new MathNode(equationEditor, knownTypes.bottomRightQuarterCircle));
        }
        break;
    }
    result.implied = implied;
    return result;
  }

  /** @returns {MathNode} */
  rightParenthesis(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {boolean} */
    implied,
  ) {
    return this.rightDelimiter(equationEditor, ")", implied);
  }

  /** @returns {MathNode} */
  rightDelimiter(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {string} */
    content,
    /** @type {boolean} */
    implied,
  ) {
    const rightDelimiter = new MathNodeRightDelimiter(equationEditor);
    rightDelimiter.implied = implied;
    if (content === "") {
      return rightDelimiter;
    }
    rightDelimiter.appendChild(this.delimiterMark(equationEditor, content, false, implied));
    rightDelimiter.extraData = content;
    return rightDelimiter;
  }

  /** @returns {MathNode} */
  matrix(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {number} */
    rows,
    /** @type {number} */
    columns,
    /** @type {string} */
    columnStyle,
  ) {
    const matrixTable = new MathNode(equationEditor, knownTypes.matrixTable);
    for (let i = 0; i < rows; i++) {
      matrixTable.appendChild(this.matrixRow(equationEditor, columns));
    }
    let leftDelimiter = null;
    let rightDelimiter = null;
    if (columnStyle === "") {
      leftDelimiter = this.leftParenthesis(equationEditor, false);
      rightDelimiter = this.rightParenthesis(equationEditor, false);
    } else {
      leftDelimiter = this.atom(equationEditor, "");
      rightDelimiter = this.atom(equationEditor, "");
    }
    let parenthesesLayout = this.horizontalMath(equationEditor, leftDelimiter);
    parenthesesLayout.appendChild(matrixTable);
    parenthesesLayout.appendChild(rightDelimiter);
    let result = new MathNodeMatrix(equationEditor);
    result.latexExtraStyle = columnStyle;
    result.appendChild(parenthesesLayout);
    result.appendChildren(
      new LatexColumnStyleIterator(columnStyle).verticalSeparators(equationEditor),
    );
    return result;
  }

  /** @returns {MathNode} */
  matrixRow(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {number} */
    columns,
  ) {
    let result = new MathNodeMatrixRow(equationEditor);
    for (let i = 0; i < columns; i++) {
      result.appendChild(this.matrixRowEntry(equationEditor, null));
    }
    return result;
  }

  /** @returns {MathNode} */
  matrixRowEntry(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {MathNode|null} */
    content,
  ) {
    let result = new MathNodeRowEntry(equationEditor);
    result.appendChild(this.horizontalMath(equationEditor, content));
    return result;
  }

  /** @returns {MathNode} */
  matrixVerticalLine(
    /** @type {EquationEditor} */
    equationEditor,
    /**@type {number} */
    columnIndex,
    /** @type {number} */
    numberOfStrips,
  ) {
    let result = new MathNodeVerticalLine(equationEditor);
    result.extraData = new VerticalBarData(columnIndex, numberOfStrips);
    return result;
  }

  /** @returns {MathNode} */
  operatorWithSuperAndSubscript(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {string} */
    operator,
    /** @type {MathNode|null} */
    superscript,
    /** @type {MathNode|null} */
    subscript,
  ) {
    let result = new MathNodeOperatorWithSuperAndSubscript(equationEditor);
    let superscriptNode = new MathNodeOperatorSuperscript(equationEditor);
    let subscriptNode = new MathNodeOperatorSubscript(equationEditor);
    let operatorNode = new MathNodeOperatorStandalone(equationEditor);
    superscriptNode.appendChild(this.horizontalMath(equationEditor, superscript));
    subscriptNode.appendChild(this.horizontalMath(equationEditor, subscript));
    operatorNode.appendChild(this.atomImmutable(equationEditor, operator));
    result.appendChild(superscriptNode);
    result.appendChild(operatorNode);
    result.appendChild(subscriptNode);
    return result;
  }

  /** @returns {MathNode} */
  operatorWithSubscript(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {string} */
    operator,
    /** @type {MathNode|null} */
    subscript,
  ) {
    let result = new MathNodeOperatorWithSubscript(equationEditor);
    let subscriptNode = new MathNode(equationEditor, knownTypes.operatorSubscript);
    let subscriptScale = 0.8;
    subscriptNode.type.fontSizeRatio = subscriptScale;
    subscriptNode.type.minHeightScale = subscriptScale;
    let operatorNode = new MathNode(equationEditor, knownTypes.operatorStandalone);
    let operatorScale = 1;
    operatorNode.type.fontSizeRatio = operatorScale;
    operatorNode.type.minHeightScale = operatorScale;
    subscriptNode.appendChild(this.horizontalMath(equationEditor, subscript));
    operatorNode.appendChild(this.atomImmutable(equationEditor, operator));
    result.appendChild(operatorNode);
    result.appendChild(subscriptNode);
    return result;
  }
}

var mathNodeFactory = new MathNodeFactory();

class MathNodeWithCaretPosition {
  constructor(
    /** @type {MathNode|null} */
    element,
    /** @type {number} */
    position,
  ) {
    /** @type {MathNode|null} */
    this.element = element;
    /** @type {number} */
    this.position = position;
    if (this.element === null) {
      this.position = - 1;
    }
  }

  assign(
    /**@type{MathNodeWithCaretPosition} */
    other,
  ) {
    this.element = other.element;
    this.position = other.position;
  }

  /**@returns{number} */
  getPositionWholeItemIfNegative(
    /**@type{number} If position is negative, 
     * determines which end to select: 
     * negative direction for left end, non-negative for right.*/
    direction,
  ) {
    if (this.position >= 0) {
      return this.position;
    }
    if (direction < 0) {
      return 0;
    }
    return this.element.textContentOrInitialContent().length;
  }

  /**@returns{number} */
  nextPositionInDirection(
    /**@type{number} */
    direction,
  ) {
    if (direction === 0) {
      direction = 1;
    }
    let content = this.element.textContentOrInitialContent();
    let result = this.position + direction;
    for (; result >= 0 && result < content.length; result += direction) {
      let code = content.charCodeAt(result);
      if (code < 0xD800 || code > 0xDFFF) {
        return result;
      }
    }
    if (result >= content.length) {
      return content.length;
    }
    if (result < 0) {
      return 0;
    }
    return - 1;
  }

  /** @returns {MathNodeWithCaretPosition} */
  leftHorizontalNeighborBalanced(
    /**@type{boolean} */
    shrinking,
  ) {
    if (this.element === null) {
      return new MathNodeWithCaretPosition(null, - 1);
    }
    if (this.position > 0 && this.element.hasHorozintalMathParent()) {
      return new MathNodeWithCaretPosition(this.element, this.nextPositionInDirection(- 1));
    }
    let next = null;
    if (shrinking && this.element.type.type === knownTypes.rightDelimiter.type) {
      let matching = this.element.findMatchingDelimiter();
      if (matching === null) {
        return new MathNodeWithCaretPosition(null, - 1);
      }
      next = matching.firstAtomSiblingOrUncle(- 1);
    } else {
      next = this.element.firstAtomSiblingOrUncle(- 1);
    }
    if (next === null) {
      return new MathNodeWithCaretPosition(null, - 1);
    }
    return new MathNodeWithCaretPosition(next, - 1);
  }

  /** @returns {MathNodeWithCaretPosition} */
  rightHorizontalNeighborBalanced(
    /**@type{boolean} */
    shrinking,
  ) {
    if (this.element === null) {
      return new MathNodeWithCaretPosition(null, -1);
    }
    if (
      this.position >= 0 &&
      this.position < this.element.lengthContentIfAtom() &&
      this.element.hasHorozintalMathParent()
    ) {
      return new MathNodeWithCaretPosition(this.element, this.nextPositionInDirection(1));
    }
    let next = null;
    if (shrinking && this.element.type.type === knownTypes.leftDelimiter.type) {
      let matching = this.element.findMatchingDelimiter();
      if (matching === null) {
        return new MathNodeWithCaretPosition(null, - 1);
      }
      next = matching.firstAtomSiblingOrUncle(1);
    } else {
      next = this.element.firstAtomSiblingOrUncle(1);
    }
    if (next === null) {
      return new MathNodeWithCaretPosition(null, -1);
    }
    return new MathNodeWithCaretPosition(next, - 1);
  }

  /** @returns {MathNodeWithCaretPosition} */
  leftNeighbor() {
    if (this.element === null) {
      return new MathNodeWithCaretPosition(null, -1);
    }
    if (this.position > 0) {
      return new MathNodeWithCaretPosition(this.element, this.nextPositionInDirection(- 1));
    }
    let resultElement = this.element.firstAtomToTheLeft();
    if (resultElement === null) {
      return new MathNodeWithCaretPosition(null, - 1);
    }
    return new MathNodeWithCaretPosition(resultElement, resultElement.element.textContent.length);
  }

  /** @returns {MathNodeWithCaretPosition} */
  rightNeighbor() {
    if (this.element === null) {
      return new MathNodeWithCaretPosition(null, -1);

    }
    if (this.position < this.element.lengthContentIfAtom()) {
      return new MathNodeWithCaretPosition(this.element, this.nextPositionInDirection(1));
    }
    return new MathNodeWithCaretPosition(this.element.firstAtomToTheRight(), 0);
  }

  /** @returns {string} */
  toString() {
    if (this.element === null) {
      return `[null, ${this.position}]`;
    }
    let detached = "";
    if (this.element.isDetached()) {
      detached = ",<b style='color:red'> detached</b>";
    }
    return `[${this.element.toString()}, ${this.position}${detached}]`;
  }
}

/** @returns {EquationEditor} 
 * Converts the textContent of an html element to typeset math.
 */
function mathFromElement(
  /**@type{HTMLElement} */
  container,
  /**@type{boolean} */
  editable,
  /**@type{boolean} */
  sanitizeLatexSource,
  /**@type{boolean} whether to remove \\displaystyle from latex source.*/
  removeDisplayStyle,
) {
  let content = container.textContent;
  if (content === null) {
    content = "";
  }
  return mathFromLatex(container, content, editable, sanitizeLatexSource, removeDisplayStyle);
}

/** @returns {EquationEditor} Returns typeset math.*/
function mathFromLatex(
  /**@type{HTMLElement} */
  container,
  /**@type{string} */
  latex,
  /**@type{boolean} */
  editable,
  /**@type{boolean} */
  sanitizeLatexSource,
  /**@type{boolean} whether to remove \\displaystyle from latex source.*/
  removeDisplayStyle,
) {
  let result = new EquationEditor(container, new EquationEditorOptions({
    editable: editable,
    sanitizeLatexSource: sanitizeLatexSource,
    removeDisplayStyle: removeDisplayStyle,
    logTiming: true,
  }));
  result.writeLatex(latex);
  return result;
}

/**@returns{HTMLElement}*/
function boldElement(
  /**@type{string} */
  text,
  /**@type{string} */
  color,
) {
  let result = document.createElement("b");
  result.textContent = text;
  result.style.color = color;
  return result;
}

class SyntancticElement {
  constructor(
    /**@type{MathNode|null} */
    node,
    /**@type{string} */
    content,
    /**@type{string} */
    syntacticRole,
  ) {
    /**@type{MathNode|null} contains parsed math content. */
    this.node = node;
    /**@type{string} contains non-parsed atomic content. */
    this.content = content;
    /**@type{string} */
    this.syntacticRole = syntacticRole;
  }

  /**@returns{HTMLElement[]} */
  toHtmlDebugData() {
    let result = [];
    if (this.node !== null) {
      let next = this.node.toLatex();
      if (next === "") {
        next = `[${this.node.type.type}]`;
      }
      result.push(document.createTextNode(next));
    }
    if (this.content !== "") {
      result.push(boldElement(this.content, "orange"));
    }
    if (this.syntacticRole !== "") {
      result.push(boldElement(this.syntacticRole, "red"));
    }
    return result;
  }

  isExpression() {
    return this.syntacticRole === "" && this.node !== null;
  }

  isMatrixEnder() {
    return this.syntacticRole in latexConstants.matrixEnder;
  }
}

class ToLatexOptions {
  constructor(useCaretCommand) {
    this.useCaretCommand = useCaretCommand;
  }
}

let latexOptionsWithCaret = new ToLatexOptions(true);

class LaTeXConstants {
  constructor() {
    this.latinCharactersString = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    this.latinCharacters = {};
    for (let i = 0; i < this.latinCharactersString.length; i++) {
      this.latinCharacters[this.latinCharactersString[i]] = true;
    }
    this.digitString = "0123456789";
    this.digits = {};
    for (let i = 0; i < this.digitString.length; i++) {
      this.digits[this.digitString[i]] = true;
    }
    this.characterReplacingSelectionString = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 +-*";
    this.characterReplacingSelection = {};
    for (let i = 0; i < this.characterReplacingSelectionString.length; i++) {
      this.characterReplacingSelection[this.characterReplacingSelectionString[i]] = true;
    }
    this.operatorsExtraPadding = {
      "=": "0.3em",
      // leq
      "\u2264": "0.3em",
      // geq
      "\u2265": "0.3em",
      // Latex to (right arrow).
      "\u2192": "0.3em",
      ">": "0.3em",
      "<": "0.3em",
      // neq
      "\u2260": "0.3em",
      // ellipsis dots
      "\u2026": "0.3em",
    };
    /**@type{Object.<string, string>} */
    this.operatorsNormalized = {
      // Full-width plus sign, wider and taller plus sign.
      "\uFF0B": "+",
      "+": "+",
      // \pm
      "\u00B1": "\u00B1",
      // Mathematical minus, a wider dash.
      "\u2212": "\u2212",
      "-": "\u2212",
      "*": "\u00B7",
      // A vertically centered small solid dot.
      "\u00B7": "\u00B7",
      "=": "=",
    };
    /**@type{Object.<string, string>} */
    this.operatorsFromUft8 = {
      "\u2212": "-",
    };
    /**@type{Object.<string, string>} */
    this.latexSyntacticValues = {
      "{": "{",
      "}": "}",
      "^": "^",
      "_": "_",
      "(": "(",
      ")": ")",
      "\\": "\\",
      "&": "&",
      "[": "[",
      "]": "]",
      "|": "|",
    };
    /**@type{Object.<string, string>} */
    this.latexBackslashCommands = {
      "left": "\\left",
      "right": "\\right",
      "cancel": "\\cancel",
      "sqrt": "\\sqrt",
      "begin": "\\begin",
      // Special command reserved for indicating the 
      // caret position when the latex is used in an editable box.
      "caret": "\\caret",
      "end": "\\end",
      "frac": "\\frac",
      "mathcal": "\\mathcal",
      "mathbb": "\\mathbb",
      "langle": "\\langle",
      "rangle": "\\rangle",
      "{": "\\{",
      "binom": "\\binom",
      "stackrel": "\\stackrel",
      "overbrace": "\\overbrace",
      "overline": "\\overline",
      "color": "\\color",
      "mathbf": "\\mathbf",
    };
    /**@type{Object.<string, string>} */
    this.latexBackslashOperators = {
      "bullet": "\u2022",
      "otimes": "\u2297",
      "oplus": "\u2295",
      "times": "\u00D7",
      "circ": "\u2218",
      "cdot": "\u00B7",
      "leq": "\u2264",
      "neq": "\u2260",
      "dots": "\u2026",
      "vdots": "\u22EE",
      "approx": "~",
      "lt": "<",
      "gt": ">",
      "to": "\u2192",
      "nwarrow": "\u2196",
      "nearrow": "\u2197",
      "searrow": "\u2198",
      "swarrow": "\u2199",
      "pm": "\u00B1",
      "det": "det",
      "geq": "\u2265",
      "sin": "sin",
      "cos": "cos",
      "tan": "tan",
      "cot": "cot",
      "sec": "sec",
      "csc": "csc",
      "ln": "ln",
      "log": "log",
      "arctan": "arctan",
      "arccos": "arccos",
      "arcsin": "arcsin",
      "emptyset": "\u2205",
      "in": "\u2208",
      "cap": "\u2229",
      "cup": "\u222A",
    };
    /**@type{Object.<string, string>} */
    this.latexBackslashOperatorsBackslashed = {};
    for (let operator in this.latexBackslashOperators) {
      this.latexBackslashOperatorsBackslashed["\\" + operator] = this.latexBackslashOperators[operator];
    }

    /**@type{Object.<string, string>} */
    this.operatorWithSuperAndSubscript = {
      "sum": "\u03A3",
      "int": "\u222B",
    };
    /**@type{Object.<string, string>} */
    this.operatorWithSuperAndSubscriptBackslashed = {};
    for (let operator in this.operatorWithSuperAndSubscript) {
      this.operatorWithSuperAndSubscriptBackslashed["\\" + operator] = this.operatorWithSuperAndSubscript[operator];
    }

    /**@type{Object.<string, string>} */
    this.operatorsWithSubscript = {
      "lim": "lim",
    };
    /**@type{Object.<string, string>} */
    this.operatorsWithSubscriptBackslashed = {};
    for (let operator in this.operatorsWithSubscript) {
      this.operatorsWithSubscriptBackslashed["\\" + operator] = this.operatorsWithSubscript[operator];
    }

    /**@type{Object.<string, string>} */
    this.latexBackslashAtomsEditable = {
      "alpha": "\u03B1",
      "beta": "\u03B2",
      "gamma": "\u03B3",
      "delta": "\u03B4",
      "epsilon": "\u03B5",
      "varepsilon": "\u03B5",
      "zeta": "\u03B6",
      "eta": "\u03B7",
      "theta": "\u03B8",
      "vartheta": "",
      "iota": "\u03B9",
      "kappa": "\u03BA",
      "lambda": "\u03BB",
      "mu": "\u03BC",
      "nu": "\u03BD",
      "xi": "\u03BE",
      "omicron": "\u03BF",
      "pi": "\u03C0",
      "rho": "\u03C1",
      "sigma": "\u03C3",
      "tau": "\u03C4",
      "upsilon": "\u03C5",
      "phi": "\u03C6",
      "varphi": "\u03D5",
      "chi": "\u03C7",
      "psi": "\u03C8",
      "omega": "\u03C9",
      "Alpha": "\u0391",
      "Beta": "\u0392",
      "Gamma": "\u0393",
      "Delta": "\u0394",
      "Epsilon": "\u0395",
      "Zeta": "\u0396",
      "Eta": "\u0397",
      "Theta": "\u0398",
      "Iota": "\u0399",
      "Kappa": "\u039A",
      "Lambda": "\u039B",
      "Mu": "\u039C",
      "Nu": "\u039D",
      "Xi": "\u039E",
      "Omicron": "\u039F",
      "Pi": "\u03A0",
      "Rho": "\u03A1",
      "Sigma": "\u03A3",
      "Tau": "\u03A4",
      "Upsilon": "\u03A5",
      "Phi": "\u03A6",
      "Chi": "\u03A7",
      "Psi": "\u03A8",
      "Omega": "\u03A9",
      "infty": "\u221E",
      "S": "\u00A7",
    };
    /**@type{Object.<string, string>} */
    this.latexBackslashAtomsEditableBackslashed = {};
    for (let operator in this.latexBackslashAtomsEditable) {
      this.latexBackslashAtomsEditableBackslashed["\\" + operator] = this.latexBackslashAtomsEditable[operator];
    }

    /**@type{Object.<string, string>} */
    this.mathcalEquivalents = {
      "A": "\uD835\uDC9C",
      "C": "\uD835\uDC9E",
      "D": "\uD835\uDC9F",
      "G": "\uD835\uDCA2",
      "J": "\uD835\uDCA5",
      "K": "\uD835\uDCA6",
      "L": "\u2112",
      "N": "\uD835\uDCA9",
      "O": "\uD835\uDCAA",
      "P": "\uD835\uDCAB",
      "Q": "\uD835\uDCAC",
      "S": "\uD835\uDCAE",
      "T": "\uD835\uDCAF",
      "U": "\uD835\uDCB0",
      "V": "\uD835\uDCB1",
      "W": "\uD835\uDCB2",
      "X": "\uD835\uDCB3",
      "Y": "\uD835\uDCB4",
      "Z": "\uD835\uDCB5",
    };
    /**@type{Object.<string, string>} */
    this.mathbbEquivalents = {
      "A": "\uD835\uDD38",
      "C": "\u2102",
      "H": "\u210D",
      "N": "\u2115",
      "O": "\uD835\uDD46",
      "P": "\u2119",
      "Q": "\u211A",
      "R": "\u211D",
      "Z": "\u2124",
    };
    /**@type{Object.<string, string>} */
    this.leftDelimiters = {
      "\\left.": "",
      "\\langle": "\u27E8",
      "(": "(",
      "[": "[",
      "|": "|",
      "\\{": "{",
    };
    /**@type{Object.<string, string>} */
    this.delimitersAmbiguous = {
      "|": "|",
    };
    /**@type{Object.<string, string>} */
    this.rightDelimiters = {
      "\\right.": "",
      "\\rangle": "\u27E9",
      ")": ")",
      "|": "|",
      "]": "]",
      "\\}": "}",
    };
    /**@type{Object.<string, string>} */
    this.leftRightDelimiterPair = {
      "\\langle": "\\rangle",
      "\u27E8": "\u27E9", // langle, rangle
      "[": "]",
      "(": ")",
      "{": "}",
      "|": "|",
    };
    /**@type{Object.<string, string>} */
    this.rightLeftDelimiterPair = {
      "\\rangle": "\\langle",
      "\u27E9": "\u27E8", // rangle, langle
      "]": "[",
      ")": "(",
      "}": "{",
    };
    this.latexCommandsIgnored = {
      "displaystyle": true,
      "text": true,
      "mathrm": true,
      "phantom": true,
      "limits": true,
    };
    this.beginEndEnvironments = {
      "pmatrix": "pmatrix",
      "array": "array",
    };
    this.matrixEnder = {
      "\\end{pmatrix}": true,
      "\\end{array}": true,
    };
    /** @type{Object.<string, boolean>} */
    // The boolean indicates that the white space should be ignored.
    this.whiteSpaceCharactersIgnored = {
      "~": false,
      " ": true,
      "\t": true,
      "\u00A0": true,
      "\n": true,
    };
    this.whiteSpaceUtf16 = {
      "\u00A0": " ",
      "\u200A": " ",
      "\u200B": " ",
      "\u2009": " ",
    };
    /** @type{Object.<string, string>} */
    this.utf16ToLatexMap = null;

    /** @type{Object.<string, boolean>} */
    this.recognizedCommandsKeyInput = {
      "\\langle": true,
      "\\rangle": true,
      "\\matrix": true,
      "\\pmatrix": true,
      "\\cancel": true,
      "\\sqrt": true,
    };
    for (let operator in this.operatorWithSuperAndSubscriptBackslashed) {
      this.recognizedCommandsKeyInput[operator] = true;
    }
    for (let operator in this.operatorsWithSubscriptBackslashed) {
      this.recognizedCommandsKeyInput[operator] = true;
    }
    for (let operator in this.latexBackslashOperatorsBackslashed) {
      this.recognizedCommandsKeyInput[operator] = true;
    }
    for (let operator in this.latexBackslashAtomsEditableBackslashed) {
      this.recognizedCommandsKeyInput[operator] = true;
    }
  }

  computeUtf16ToLatexMap() {
    if (this.utf16ToLatexMap !== null) {
      return;
    }
    this.utf16ToLatexMap = {};
    for (let i = 32; i < 125; i++) {
      let character = String.fromCharCode(i);
      this.utf16ToLatexMap[character] = character;
    }
    // Non-breakable space.
    for (let key in this.whiteSpaceUtf16) {
      this.utf16ToLatexMap[key] = " ";
    }
    for (let key in this.latexBackslashAtomsEditable) {
      let current = this.latexBackslashAtomsEditable[key];
      this.utf16ToLatexMap[current] = `\\${key} `;
    }
    for (let key in this.latexBackslashOperators) {
      let current = this.latexBackslashOperators[key];
      this.utf16ToLatexMap[current] = `\\${key} `;
    }
    for (let key in this.operatorWithSuperAndSubscript) {
      let current = this.operatorWithSuperAndSubscript[key];
      this.utf16ToLatexMap[current] = `\\${key} `;
    }
    for (let key in this.operatorsWithSubscript) {
      let current = this.operatorsWithSubscript[key];
      this.utf16ToLatexMap[current] = `\\${key} `;
    }
    for (let key in this.mathcalEquivalents) {
      let current = this.mathcalEquivalents[key];
      this.utf16ToLatexMap[current] = `\\mathcal{${key}} `;
    }
    for (let key in this.mathbbEquivalents) {
      let current = this.mathbbEquivalents[key];
      this.utf16ToLatexMap[current] = `\\mathbb{${key}} `;
    }
    for (let key in this.operatorsFromUft8) {
      this.utf16ToLatexMap[key] = this.operatorsFromUft8[key];
    }
  }

  /** @returns {LatexWithAnnotation} */
  convertUtf16ToLatex(
    /** @type{string} */
    input,
    /** @type{number} */
    selectionStart,
    /** @type{number} */
    selectionEnd,
    /**@type{number} */
    positionCaret,
  ) {
    this.computeUtf16ToLatexMap();
    let result = [];
    let lengthSoFar = 0;
    let startFound = false;
    let endFound = false;

    if (positionCaret === 0) {
      result.push("\\caret ");
      lengthSoFar += 7;
    }
    for (let i = 0; i < input.length; i++) {
      let current = "";
      for (let j = 0; j < 4 && i + j < input.length; j++) {
        current += input[i + j];
        if (current in this.utf16ToLatexMap) {
          current = this.utf16ToLatexMap[current];
          i += j;
          result.push(current);
          current = "";
          break;
        }
      }
      if (current !== "") {
        result.push(current);
      }
      if (i === selectionStart && !startFound) {
        selectionStart = lengthSoFar;
        startFound = true;
      }
      lengthSoFar += current.length;
      if (i + 1 === selectionEnd && !endFound) {
        selectionEnd = lengthSoFar;
        endFound = true;
      }
      if (i + 1 === positionCaret) {
        result.push("\\caret ");
        lengthSoFar += 7;
      }
    }
    return new LatexWithAnnotation(result.join(""), selectionStart, selectionEnd);
  }

  isCharacterReplacingSelection(
    /**@type{string}*/
    input,
  ) {
    return input in this.characterReplacingSelection;
  }

  isLatinCharacter(
    /**@type{string}*/
    input,
  ) {
    return input in this.latinCharacters;
  }

  isDigit(
    /**@type{string}*/
    input,
  ) {
    return input in this.digits;
  }

  isWhiteSpace(
    /**@type{string} */ input,
  ) {
    return (input in this.whiteSpaceCharactersIgnored);
  }

  isWhiteSpaceIgnored(
    /**@type{string} */ input,
  ) {
    if (!(input in this.whiteSpaceCharactersIgnored)) {
      return false;
    }
    return this.whiteSpaceCharactersIgnored[input];
  }

  normalizeOperatorToUtf8(
    /**@type{string} */
    input,
  ) {
    if (input in this.operatorsNormalized) {
      return this.operatorsNormalized[input];
    }
    return input;
  }

}
const latexConstants = new LaTeXConstants();

class LaTeXParser {
  constructor(
    /**@type{EquationEditor} */
    equationEditor,
    /**@type{string} */
    latex,
  ) {
    /**@type{EquationEditor} */
    this.equationEditor = equationEditor;
    /**@type{string} */
    this.latex = latex;
    /**@type {MathNode} */
    this.result = new MathNode(equationEditor, knownTypes.horizontalMath);
    /**@type{string[]} */
    this.words = [];
    /**@type{SyntancticElement[]} */
    this.parsingStack = [];
    /**@type {number} 
     * Dummy elements are prepended to the parsing stack  
     * so parsing rules can safely assume a minimal number 
     * of syntanctic elements. 
     */
    this.dummyParsingElements = 6;
    /**@type{boolean} */
    this.debug = false;
    /**@type{HTMLElement[][]} */
    this.reductionLog = [];
    /**@type{string} */
    this.lastRuleName = "";
    /**@type{number} */
    this.startTime = 0;
    /**@type{boolean} Whether the special command \caret is found. 
     * Used to indicate the position of the 
     * caret when the latex is used in an editable box.
     */
    this.caretFound = false;
  }

  initialize() {
    this.parsingStack = [];
    for (let i = 0; i < this.dummyParsingElements; i++) {
      this.parsingStack.push(new SyntancticElement(null, "", ""));
    }
  }

  parseWords() {
    let next = [];
    for (let i = 0; i < this.latex.length; i++) {
      let nextCharacter = this.latex[i];
      if (latexConstants.isLatinCharacter(nextCharacter)) {
        next.push(nextCharacter);
        continue;
      }
      if (next.length > 0) {
        this.words.push(next.join(""));
      }
      this.words.push(nextCharacter);
      next = [];
    }
    if (next.length > 0) {
      this.words.push(next.join(""));
    }
  }

  /**@returns{MathNode} */
  parse() {
    this.startTime = new Date().getTime();
    this.initialize();
    this.parseWords();
    this.result = new MathNode(this.equationEditor, knownTypes.horizontalMath);
    let startingNode = mathNodeFactory.horizontalMath(this.equationEditor, null);
    this.parsingStack.push(new SyntancticElement(startingNode, "", ""));
    for (let i = 0; i < this.words.length; i++) {
      if (!this.reduceStack(new SyntancticElement(null, this.words[i], ""))) {
        return this.constructError();
      }
    }
    if (!this.reduceStack(new SyntancticElement(null, "", "parsingEnd"))) {
      return this.constructError();
    }
    if (this.parsingStack.length !== this.dummyParsingElements + 2) {
      if (this.equationEditor.options.debugLogContainer !== null) {
        console.log(`Failed to parse ${this.latex}: not all syntactic elements were reduced.`);
      }
      return this.constructError();
    }
    let secondToLastElement = this.parsingStack[this.parsingStack.length - 2];
    if (secondToLastElement.node === null) {
      if (this.equationEditor.options.debugLogContainer !== null) {
        console.log(`Failed to parse ${this.latex}: final syntactic element is not a node.`);
      }
      return this.constructError();
    }
    let elapsedTime = new Date().getTime() - this.startTime;
    if (elapsedTime > 200 && this.equationEditor.options.logTiming) {
      console.log(`Parsing took too long: ${elapsedTime}ms`);
    }
    secondToLastElement.node.normalizeHorizontalMathRecursive();
    if (this.equationEditor.options.editable) {
      secondToLastElement.node.ensureEditableAtomsRecursive();
    }
    if (elapsedTime > 200 && this.equationEditor.options.logTiming) {
      console.log(`Normalization+parsing took too long: ${elapsedTime}ms`);
    }
    // let elapsedTime = new Date().getTime() - this.startTime;
    return secondToLastElement.node;
  }

  /**@returns{MathNode} */
  constructError() {
    let error = mathNodeFactory.error(this.equationEditor, this.latex);
    let left = mathNodeFactory.atom(this.equationEditor, "");
    let right = mathNodeFactory.atom(this.equationEditor, "");
    return mathNodeFactory.horizontalMathFromArray(this.equationEditor, [left, error, right]);
  }

  /** @returns{boolean} */
  reduceStack(
    /**@type {SyntancticElement} */
    syntacticElement,
  ) {
    let numberOfRuleApplications = 0;
    let startingLength = this.parsingStack.length;
    this.parsingStack.push(syntacticElement);
    if (this.debug) {
      this.reductionLog.push(this.toHtmlStackDebug("append"));
      this.lastRuleName = "";
    }
    while (this.applyOneRule()) {
      if (this.debug) {
        this.reductionLog.push(this.toHtmlStackDebug(this.lastRuleName));
        this.lastRuleName = "";
      }
      numberOfRuleApplications++;
      let stackReduction = startingLength - this.parsingStack.length;
      let maximumRuleApplications = Math.max(10, stackReduction * 10);
      if (numberOfRuleApplications > maximumRuleApplications) {
        // Too many rules to reduce an expression: no more than 10 rule applications per
        // unit of stack reduction.
        // Perhaps we have a substitution loop in our parsing rules?
        console.log("Too many parsing rule applications.");
        return false;
      }
    }
    return true;
  }

  /** @returns{boolean} */
  decreaseParsingStack(
    /**@type{number} */
    elementsToRemove,
  ) {
    this.parsingStack.length = this.parsingStack.length - elementsToRemove;
    return true;
  }

  /** @returns{boolean} */
  replaceParsingStackTop(
    /**@type{MathNode|null} */
    node,
    /**@type{string} */
    syntancticValue,
    /**@type{number} */
    indexToRemove,
  ) {
    return this.replaceParsingStackRange(node, syntancticValue, indexToRemove, - 1);
  }

  /** @returns{boolean} */
  replaceParsingStackRange(
    /**@type{MathNode|null} */
    node,
    /**@type{string} */
    syntancticRole,
    /**@type{number} */
    firstIndexToRemove,
    /**@type{number} */
    lastIndexToRemove,
  ) {
    if (firstIndexToRemove < 0) {
      firstIndexToRemove += this.parsingStack.length;
    }
    if (lastIndexToRemove < 0) {
      lastIndexToRemove += this.parsingStack.length;
    }
    let incoming = new SyntancticElement(node, "", syntancticRole);
    this.parsingStack[firstIndexToRemove] = incoming;
    let nodesToRemove = lastIndexToRemove - firstIndexToRemove;
    for (let i = lastIndexToRemove + 1; i < this.parsingStack.length; i++) {
      this.parsingStack[i - nodesToRemove] = this.parsingStack[i];
    }
    this.parsingStack.length -= nodesToRemove;
    return true;
  }

  /**@returns{HtmlElement[]} */
  toHtmlStackDebug(
    /**@type{string} */
    ruleName,
  ) {
    let result = [];
    for (let i = this.dummyParsingElements; i < this.parsingStack.length; i++) {
      let currentElements = this.parsingStack[i].toHtmlDebugData();
      for (let j = 0; j < currentElements.length; j++) {
        result.push(currentElements[j]);
      }
    }
    result.push(document.createTextNode(` [${ruleName}]`));
    return result;
  }

  /**@returns{HtmlElement[]} */
  toHtmlDebug() {
    let result = [];
    for (let i = 0; i < this.reductionLog.length; i++) {
      for (let j = 0; j < this.reductionLog[i].length; j++) {
        result.push(this.reductionLog[i][j]);
      }
      result.push(document.createElement("hr"));
    }
    return result;
  }

  specialFont(
    /**@type{Object.<string, string>} */
    specialFontEquivalents,
  ) {
    let last = this.parsingStack[this.parsingStack.length - 1];

    if (latexConstants.isLatinCharacter(last.content)) {
      if (!(last.content in specialFontEquivalents)) {
        return false;
      }
      this.lastRuleName = "special font";
      let node = mathNodeFactory.atom(this.equationEditor, specialFontEquivalents[last.content]);
      return this.replaceParsingStackTop(node, "", -2);
    }
    if (!last.isExpression() || last.node.type.type !== knownTypes.horizontalMath.type) {
      return false;
    }
    if (last.node.children.length !== 1) {
      return false;
    }
    let contentIfAtom = last.node.children[0].contentIfAtom();
    if (!(contentIfAtom in specialFontEquivalents)) {
      return false;
    }
    this.lastRuleName = "special font horizontal math";
    let node = mathNodeFactory.atom(this.equationEditor, specialFontEquivalents[contentIfAtom]);
    return this.replaceParsingStackTop(node, "", - 2);
  }

  /**@returns{boolean} Applies the first possible rule to the top of the parsing stack. */
  applyOneRule() {
    let last = this.parsingStack[this.parsingStack.length - 1];
    if (latexConstants.isWhiteSpace(last.content)) {
      if (latexConstants.isWhiteSpaceIgnored(last.content)) {
        this.lastRuleName = "clean whitespace";
        this.parsingStack.length = this.parsingStack.length - 1;
        return true;
      } else {
        this.lastRuleName = "create whitespace";
        let node = mathNodeFactory.atom(this.equationEditor, " ");
        return this.replaceParsingStackTop(node, "", - 1);
      }
    }
    if (last.content in latexConstants.latexSyntacticValues) {
      this.lastRuleName = "built-in syntactic element";
      return this.replaceParsingStackTop(null, latexConstants.latexSyntacticValues[last.content], - 1);
    }

    let secondToLast = this.parsingStack[this.parsingStack.length - 2];
    if (secondToLast.syntacticRole === "\\") {
      if (last.syntacticRole === "\\") {
        this.lastRuleName = "double backslash";
        return this.replaceParsingStackTop(null, "\\\\", - 2);
      }
      if (last.syntacticRole === "{") {
        this.lastRuleName = "{ delimiter";
        return this.replaceParsingStackTop(null, "\\{", - 2);
      }
      if (last.syntacticRole === "}") {
        this.lastRuleName = "} delimiter";
        return this.replaceParsingStackTop(null, "\\}", - 2);
      }
    }
    let thirdToLast = this.parsingStack[this.parsingStack.length - 3];
    let fourthToLast = this.parsingStack[this.parsingStack.length - 4];
    if (secondToLast.syntacticRole === "{" && last.isExpression()) {
      if (last.node.type.type !== knownTypes.horizontalMath.type) {
        this.lastRuleName = "horizontal math after curly brace";
        let node = mathNodeFactory.horizontalMath(this.equationEditor, last.node);
        return this.replaceParsingStackTop(node, "", - 1);
      }
    }
    if (thirdToLast.syntacticRole === "{" && secondToLast.isExpression() && last.syntacticRole === "}") {
      this.lastRuleName = "remove curly braces";
      let node = secondToLast.node;
      if (node.type.type !== knownTypes.horizontalMath.type) {
        node = mathNodeFactory.horizontalMath(this.equationEditor, node);
      }
      return this.replaceParsingStackTop(node, "", - 3);
    }
    if (secondToLast.syntacticRole === "\\" && last.content in latexConstants.latexBackslashCommands) {
      this.lastRuleName = "latex command";
      return this.replaceParsingStackTop(null, latexConstants.latexBackslashCommands[last.content], - 2);
    }
    if (secondToLast.syntacticRole === "\\left" && last.syntacticRole in latexConstants.leftDelimiters) {
      this.lastRuleName = "\\left combined with left delimiter";
      this.parsingStack[this.parsingStack.length - 2] = last;
      return this.decreaseParsingStack(1);
    }
    if (secondToLast.syntacticRole === "\\color" && last.isExpression()) {
      if (secondToLast.node === null) {
        this.lastRuleName = "set color";
        // We have a situation along the lines of \color{red} with last.node = red.
        // Write the last node as the node that determines the color.
        secondToLast.node = last.node;
        return this.decreaseParsingStack(1);
      } else {
        this.lastRuleName = "apply color";
        // We already have the color set along the lines of \\color{red}{last}
        // with secondToLast = \color{red} and secondToLast.node = red.
        let node = mathNodeFactory.genericMathBox(this.equationEditor, last.node);
        node.type.colorText = secondToLast.node.toLatex();
        return this.replaceParsingStackTop(node, "", - 2);
      }
    }
    if (secondToLast.syntacticRole === "\\mathbf" && last.isExpression()) {
      this.lastRuleName = "apply bold";
      // We already have the color set along the lines of \\color{red}{last}
      // with secondToLast = \color{red} and secondToLast.node = red.
      let node = mathNodeFactory.genericMathBox(this.equationEditor, last.node);
      node.type.fontWeight = "bold";
      return this.replaceParsingStackTop(node, "", - 2);
    }
    if (secondToLast.syntacticRole === "\\right" && last.syntacticRole in latexConstants.rightDelimiters) {
      this.lastRuleName = "\\right combined with right delimiter";
      this.parsingStack[this.parsingStack.length - 2] = last;
      return this.decreaseParsingStack(1);
    }
    if (secondToLast.syntacticRole === "\\left" && last.content === ".") {
      return this.replaceParsingStackTop(null, "\\left.", - 2);
    }
    if (secondToLast.syntacticRole === "\\right" && last.content === ".") {
      return this.replaceParsingStackTop(null, "\\right.", - 2);
    }
    if (secondToLast.syntacticRole === "\\mathcal") {
      if (this.specialFont(latexConstants.mathcalEquivalents)) {
        return true;
      }
    }
    if (secondToLast.syntacticRole === "\\mathbb") {
      if (this.specialFont(latexConstants.mathbbEquivalents)) {
        return true;
      }
    }
    if (last.content in latexConstants.latexCommandsIgnored && secondToLast.syntacticRole === "\\") {
      return this.decreaseParsingStack(2);
    }
    if (secondToLast.syntacticRole === "\\" && last.content in latexConstants.operatorWithSuperAndSubscript) {
      this.lastRuleName = "operator with superscript and subscript";
      let operatorSymbol = latexConstants.operatorWithSuperAndSubscript[last.content];
      let syntacticElement = new SyntancticElement(null, operatorSymbol, "operatorWithSuperAndSubscript");
      this.parsingStack[this.parsingStack.length - 2] = syntacticElement;
      return this.decreaseParsingStack(1);
    }
    if (secondToLast.syntacticRole === "\\" && last.content in latexConstants.operatorsWithSubscript) {
      this.lastRuleName = "operator with subscript";
      let operatorSymbol = latexConstants.operatorsWithSubscript[last.content];
      let syntacticElement = new SyntancticElement(null, operatorSymbol, "operatorWithSubscript");
      this.parsingStack[this.parsingStack.length - 2] = syntacticElement;
      return this.decreaseParsingStack(1);
    }
    if (
      secondToLast.syntacticRole === "\\overline" &&
      last.isExpression()
    ) {
      this.lastRuleName = "over-line";
      let node = mathNodeFactory.overLine(this.equationEditor, last.node);
      return this.replaceParsingStackTop(node, "", - 2);
    }
    if (
      fourthToLast.syntacticRole === "\\overbrace" &&
      thirdToLast.isExpression() &&
      secondToLast.syntacticRole === "^" &&
      last.isExpression()
    ) {
      this.lastRuleName = "over-brace";
      let node = mathNodeFactory.overBrace(this.equationEditor, thirdToLast.node, last.node);
      return this.replaceParsingStackTop(node, "", - 4);
    }
    let fifthToLast = this.parsingStack[this.parsingStack.length - 5];
    if (
      fifthToLast.syntacticRole === "operatorWithSuperAndSubscript" &&
      fourthToLast.syntacticRole === "^" &&
      thirdToLast.isExpression() &&
      secondToLast.syntacticRole === "_" &&
      last.isExpression()
    ) {
      this.lastRuleName = "operatorWithSuperAndSubscript combines with super and subscript.";
      let node = mathNodeFactory.operatorWithSuperAndSubscript(this.equationEditor, fifthToLast.content, thirdToLast.node, last.node);
      return this.replaceParsingStackTop(node, "", - 5);
    }
    if (
      fifthToLast.syntacticRole === "operatorWithSuperAndSubscript" &&
      fourthToLast.syntacticRole === "_" &&
      thirdToLast.isExpression() &&
      secondToLast.syntacticRole === "^" &&
      last.isExpression()
    ) {
      this.lastRuleName = "operatorWithSuperAndSubscript combines with sub and superscript.";
      let node = mathNodeFactory.operatorWithSuperAndSubscript(this.equationEditor, fifthToLast.content, last.node, thirdToLast.node);
      return this.replaceParsingStackTop(node, "", - 5);
    }
    if (
      secondToLast.syntacticRole === "operatorWithSuperAndSubscript" &&
      last.syntacticRole !== "^" &&
      last.syntacticRole !== "_" &&
      last.syntacticRole !== "\\"
    ) {
      this.lastRuleName = "operator standalone";
      let node = mathNodeFactory.operatorWithSuperAndSubscript(this.equationEditor, secondToLast.content, null, null);
      return this.replaceParsingStackRange(node, "", - 2, - 2);
    }
    if (
      fourthToLast.syntacticRole === "operatorWithSuperAndSubscript" &&
      thirdToLast.syntacticRole === "^" &&
      secondToLast.isExpression() &&
      last.syntacticRole !== "_"
    ) {
      this.lastRuleName = "operator with superscript only";
      let node = mathNodeFactory.operatorWithSuperAndSubscript(this.equationEditor, fourthToLast.content, secondToLast.node, null);
      return this.replaceParsingStackRange(node, "", - 4, - 2);
    }
    if (
      fourthToLast.syntacticRole === "operatorWithSuperAndSubscript" &&
      thirdToLast.syntacticRole === "_" &&
      secondToLast.isExpression() &&
      last.syntacticRole !== "^"
    ) {
      this.lastRuleName = "operator with subscript only (allows superscript)";
      let node = mathNodeFactory.operatorWithSuperAndSubscript(this.equationEditor, fourthToLast.content, null, secondToLast.node);
      return this.replaceParsingStackRange(node, "", - 4, - 2);
    }
    if (
      thirdToLast.syntacticRole === "operatorWithSubscript" &&
      secondToLast.syntacticRole === "_" &&
      last.isExpression()
    ) {
      this.lastRuleName = "operator with subscript only";
      let node = mathNodeFactory.operatorWithSubscript(this.equationEditor, thirdToLast.content, last.node);
      return this.replaceParsingStackTop(node, "", - 3);
    }
    if (secondToLast.syntacticRole === "\\" && last.content in latexConstants.latexBackslashOperators) {
      this.lastRuleName = "atom immutable from backslash";
      let node = mathNodeFactory.atomImmutable(
        this.equationEditor,
        latexConstants.latexBackslashOperators[last.content],
      );
      return this.replaceParsingStackTop(node, "", - 2);
    }
    if (secondToLast.syntacticRole === "\\" && last.content in latexConstants.latexBackslashAtomsEditable) {
      this.lastRuleName = "latex symbol";
      let node = mathNodeFactory.atom(
        this.equationEditor,
        latexConstants.latexBackslashAtomsEditable[last.content],
      );
      return this.replaceParsingStackTop(node, "", - 2);
    }
    if (last.syntacticRole === "\\caret") {
      this.lastRuleName = "caret location";
      let node = mathNodeFactory.atom(this.equationEditor, "");
      node.desiredCaretPosition = 0;
      return this.replaceParsingStackTop(node, "", - 1);
    }
    if (
      (thirdToLast.syntacticRole === "\\begin" || thirdToLast.syntacticRole === "\\end") &&
      secondToLast.syntacticRole === "{" &&
      last.content in latexConstants.beginEndEnvironments
    ) {
      this.lastRuleName = "begin or end environment";
      return this.replaceParsingStackTop(null, latexConstants.beginEndEnvironments[last.content], - 1);
    }
    if (
      fourthToLast.syntacticRole === "\\begin" &&
      thirdToLast.syntacticRole === "{" &&
      secondToLast.syntacticRole in latexConstants.beginEndEnvironments &&
      last.syntacticRole === "}"
    ) {
      let environment = latexConstants.beginEndEnvironments[secondToLast.syntacticRole];
      return this.replaceParsingStackTop(null, `\\begin{${environment}}`, - 4);
    }
    if (
      fourthToLast.syntacticRole === "\\end" &&
      thirdToLast.syntacticRole === "{" &&
      secondToLast.syntacticRole in latexConstants.beginEndEnvironments &&
      last.syntacticRole === "}"
    ) {
      let environment = latexConstants.beginEndEnvironments[secondToLast.syntacticRole];
      return this.replaceParsingStackTop(null, `\\end{${environment}}`, - 4);
    }
    if (last.syntacticRole === "\\begin{pmatrix}") {
      this.lastRuleName = "begin pmatrix to matrix builder";
      let matrix = mathNodeFactory.matrix(this.equationEditor, 1, 0, "");
      return this.replaceParsingStackTop(matrix, "matrixBuilder", - 1);
    }
    if (
      fourthToLast.syntacticRole === "\\begin{array}" &&
      thirdToLast.syntacticRole === "{" &&
      secondToLast.isExpression() &&
      last.syntacticRole === "|"
    ) {
      if (secondToLast.node.type.type === knownTypes.horizontalMath.type) {
        secondToLast.node.appendChild(mathNodeFactory.atom(this.equationEditor, last.syntacticRole));
        return this.decreaseParsingStack(1);
      }
    }
    if (secondToLast.syntacticRole === "\\begin{array}" && last.isExpression()) {
      this.lastRuleName = "begin array to matrix builder";
      let matrix = mathNodeFactory.matrix(this.equationEditor, 1, 0, last.node.toLatex());
      return this.replaceParsingStackTop(matrix, "matrixBuilder", - 2);
    }
    if (thirdToLast.syntacticRole === "matrixBuilder" && secondToLast.isExpression() && last.syntacticRole === "&") {
      // Modify thirdToLast.node in place for performance reasons:
      // copying it may cause unwanted quadratic complexity.
      let incomingEntry = mathNodeFactory.matrixRowEntry(this.equationEditor, secondToLast.node);
      thirdToLast.node.getLastMatrixRow().appendChild(incomingEntry);
      return this.decreaseParsingStack(2);
    }
    if (secondToLast.syntacticRole === "matrixBuilder" && last.syntacticRole === "&") {
      // Modify secondToLast.node in place for performance reasons:
      // copying it may cause unwanted quadratic complexity.
      let incomingEntry = mathNodeFactory.matrixRowEntry(this.equationEditor, mathNodeFactory.atom(this.equationEditor, ""));
      secondToLast.node.getLastMatrixRow().appendChild(incomingEntry);
      return this.decreaseParsingStack(1);
    }
    if (last.syntacticRole === "\\\\" && secondToLast.isExpression() && thirdToLast.syntacticRole === "matrixBuilder") {
      // Modify thirdToLast.node in place for performance reasons:
      // copying it may cause unwanted quadratic complexity.
      let lastRow = thirdToLast.node.getLastMatrixRow();
      let incomingEntry = mathNodeFactory.matrixRowEntry(this.equationEditor, secondToLast.node);
      lastRow.appendChild(incomingEntry);
      let newRow = mathNodeFactory.matrixRow(this.equationEditor, 0);
      lastRow.parent.appendChild(newRow);
      return this.decreaseParsingStack(2);
    }
    if (last.syntacticRole === "\\\\" && secondToLast.syntacticRole === "matrixBuilder") {
      // Modify secondToLast.node in place for performance reasons:
      // copying it may cause unwanted quadratic comoplexity.
      let lastRow = secondToLast.node.getLastMatrixRow();
      let incomingEntry = mathNodeFactory.matrixRowEntry(this.equationEditor, mathNodeFactory.atom(this.equationEditor, ""));
      lastRow.appendChild(incomingEntry);
      let newRow = mathNodeFactory.matrixRow(this.equationEditor, 0);
      lastRow.parent.appendChild(newRow);
      return this.decreaseParsingStack(1);
    }
    if (thirdToLast.syntacticRole === "matrixBuilder" && secondToLast.isExpression() && last.isMatrixEnder()) {
      let incomingEntry = mathNodeFactory.matrixRowEntry(this.equationEditor, secondToLast.node);
      thirdToLast.node.getLastMatrixRow().appendChild(incomingEntry);
      // Normalize the matrix: ensure all rows have same number of columns, no last empty row, etc.
      thirdToLast.node.normalizeMatrix();
      (new LatexColumnStyleIterator(thirdToLast.node.latexExtraStyle)).applyStyleToMatrix(thirdToLast.node);
      // Mark the matrix as a regular expression.
      thirdToLast.syntacticRole = "";
      return this.decreaseParsingStack(2);
    }
    if (secondToLast.syntacticRole === "matrixBuilder" && last.isMatrixEnder()) {
      this.lastRuleName = "finish matrix";
      // Normalize the matrix: ensure all rows have same number of columns, no last empty row, etc.
      secondToLast.node.normalizeMatrix();
      (new LatexColumnStyleIterator(secondToLast.node.latexExtraStyle)).applyStyleToMatrix(secondToLast.node);
      // Mark the matrix as a regular expression.
      secondToLast.syntacticRole = "";
      return this.decreaseParsingStack(1);
    }
    if (secondToLast.syntacticRole === "\\sqrt" && last.isExpression()) {
      this.lastRuleName = "Square root";
      let node = mathNodeFactory.sqrt(this.equationEditor, last.node, secondToLast.node);
      return this.replaceParsingStackTop(node, "", - 2);
    }
    if (secondToLast.syntacticRole === "\\cancel" && last.isExpression()) {
      this.lastRuleName = "cancel expression";
      let node = mathNodeFactory.cancel(this.equationEditor, last.node);
      return this.replaceParsingStackTop(node, "", - 2);
    }
    if (secondToLast.syntacticRole === "{" && last.syntacticRole === "}") {
      this.lastRuleName = "{} to empty atom";
      let node = mathNodeFactory.atom(this.equationEditor, "");
      return this.replaceParsingStackTop(node, "", -2);
    }
    if (
      fourthToLast.syntacticRole === "\\sqrt" &&
      fourthToLast.node === null &&
      thirdToLast.syntacticRole === "[" &&
      secondToLast.isExpression() &&
      last.syntacticRole === "]"
    ) {
      this.lastRuleName = "nth radical";
      fourthToLast.node = secondToLast.node;
      return this.decreaseParsingStack(3);
    }
    if (
      thirdToLast.syntacticRole in latexConstants.leftDelimiters &&
      secondToLast.isExpression() &&
      last.syntacticRole in latexConstants.rightDelimiters
    ) {
      this.lastRuleName = "parenthetic expression to expression";
      let leftDelimiter = latexConstants.leftDelimiters[thirdToLast.syntacticRole];
      let rightDelimiter = latexConstants.rightDelimiters[last.syntacticRole];
      let left = mathNodeFactory.leftDelimiter(this.equationEditor, leftDelimiter, false);
      let right = mathNodeFactory.rightDelimiter(this.equationEditor, rightDelimiter, false);
      let horizontal = mathNodeFactory.horizontalMathFromArray(this.equationEditor, [left, secondToLast.node, right]);
      return this.replaceParsingStackTop(horizontal, "", - 3);
    }
    if (
      secondToLast.syntacticRole in latexConstants.leftDelimiters &&
      last.syntacticRole in latexConstants.rightDelimiters
    ) {
      this.lastRuleName = "parenthetic expression to expression";
      let leftDelimiter = latexConstants.leftDelimiters[secondToLast.syntacticRole];
      let rightDelimiter = latexConstants.rightDelimiters[last.syntacticRole];
      let left = mathNodeFactory.leftDelimiter(this.equationEditor, leftDelimiter, false);
      let right = mathNodeFactory.rightDelimiter(this.equationEditor, rightDelimiter, false);
      let atom = mathNodeFactory.atom(this.equationEditor, "\u200B");
      let horizontal = mathNodeFactory.horizontalMathFromArray(this.equationEditor, [left, atom, right]);
      return this.replaceParsingStackTop(horizontal, "", - 2);
    }
    if (last.isExpression() && secondToLast.syntacticRole === "_" && thirdToLast.isExpression()) {
      this.lastRuleName = "make subscript";
      let node = mathNodeFactory.baseWithSubscript(this.equationEditor, thirdToLast.node, last.node);
      return this.replaceParsingStackTop(node, "", - 3);
    }
    if (
      last.isExpression() &&
      secondToLast.isExpression() &&
      latexConstants.isDigit(last.node.contentIfAtom())
    ) {
      if (secondToLast.node.type.type === knownTypes.horizontalMath.type && secondToLast.node.children.length > 0) {
        if (latexConstants.isDigit(secondToLast.node.children[secondToLast.node.children.length - 1].contentIfAtom())) {
          this.lastRuleName = "merge digits into horizontal math";
          secondToLast.node.appendChild(last.node);
          return this.decreaseParsingStack(1);
        }
      }
    }
    if (
      last.isExpression() &&
      secondToLast.isExpression() &&
      latexConstants.isDigit(last.node.contentIfAtom()) &&
      latexConstants.isDigit(secondToLast.node.contentIfAtom())
    ) {
      this.lastRuleName = "merge two digits";
      let node = mathNodeFactory.horizontalMath(this.equationEditor, secondToLast.node);
      node.appendChild(last.node);
      return this.replaceParsingStackTop(node, "", - 2);
    }
    if (thirdToLast.isExpression() && secondToLast.syntacticRole === "^" && last.isExpression()) {
      this.lastRuleName = "make exponent";
      let node = mathNodeFactory.baseWithExponent(this.equationEditor, thirdToLast.node, last.node);
      return this.replaceParsingStackTop(node, "", - 3);
    }
    if (thirdToLast.syntacticRole === "\\frac" && secondToLast.isExpression() && last.isExpression()) {
      let node = mathNodeFactory.fraction(this.equationEditor, secondToLast.node, last.node);
      return this.replaceParsingStackTop(node, "", - 3);
    }
    if (thirdToLast.syntacticRole === "\\binom" && secondToLast.isExpression() && last.isExpression()) {
      let node = mathNodeFactory.matrix(this.equationEditor, 2, 1, "");
      node.getMatrixCell(0, 0).children[0].appendChild(secondToLast.node);
      node.getMatrixCell(1, 0).children[0].appendChild(last.node);
      return this.replaceParsingStackTop(node, "", - 3);
    }
    if (thirdToLast.syntacticRole === "\\stackrel" && secondToLast.isExpression() && last.isExpression()) {
      let node = mathNodeFactory.matrix(this.equationEditor, 3, 1, "");
      node.getMatrixCell(0, 0).children[0].appendChild(secondToLast.node);
      node.getMatrixCell(1, 0).children[0].appendChild(last.node);
      node.getMatrixCell(2, 0).children[0].appendChild(mathNodeFactory.atom(this.equationEditor, "\u00A0"));
      node.children[0].replaceChildAtPosition(0, mathNodeFactory.leftDelimiter(this.equationEditor, "", false));
      node.children[0].replaceChildAtPosition(2, mathNodeFactory.rightDelimiter(this.equationEditor, "", false));
      return this.replaceParsingStackTop(node, "", - 3);
    }
    if (last.content in latexConstants.operatorsNormalized) {
      this.lastRuleName = "atom immutable";
      let node = mathNodeFactory.atomImmutable(
        this.equationEditor,
        latexConstants.operatorsNormalized[last.content],
      );
      return this.replaceParsingStackTop(node, "", - 1);
    }
    if (last.content !== "" && last.syntacticRole === "" && last.node === null) {
      this.lastRuleName = "construct atom";
      let node = mathNodeFactory.atom(this.equationEditor, last.content);
      return this.replaceParsingStackTop(node, "", - 1);
    }
    if (thirdToLast.isExpression() && secondToLast.isExpression() && last.syntacticRole !== "^" && last.syntacticRole !== "_") {
      // Absorb atom / immutable atom to preceding horizontal math.
      if (thirdToLast.node.type.type === knownTypes.horizontalMath.type) {
        this.lastRuleName = "merge node into horizontal math";
        thirdToLast.node.appendChild(secondToLast.node);
        return this.replaceParsingStackRange(thirdToLast.node, "", - 3, - 2);
      } else {
        this.lastRuleName = "merge expressions nodes into horizontal math";
        let node = mathNodeFactory.horizontalMathFromArray(this.equationEditor, [thirdToLast.node, secondToLast.node]);
        return this.replaceParsingStackRange(node, "", - 3, - 2);
      }
    }
    return false;
  }
}

class EquationEditorOptions {
  constructor(
    /** @type{{editable:boolean,removeDisplayStyle:boolean,sanitizeLatexSource:boolean,debugLogContainer:HTMLElement|null,latexInput:HTMLElement|null,editHandler:Function|null}} */
    options,
  ) {
    /** @type{boolean} */
    this.editable = options.editable;
    /** @type{boolean} */
    this.removeDisplayStyle = options.removeDisplayStyle;
    /** @type{boolean} */
    this.sanitizeLatexSource = options.sanitizeLatexSource;
    /**@type{HTMLElement|null} */
    this.debugLogContainer = options.debugLogContainer;
    /**@type{HTMLElement|null} */
    this.latexInput = options.latexInput;
    /** @type{boolean} */
    this.logTiming = options.logTiming;
    /**@type{Function|null} */
    // Called on modification of the editor. Will provide two arguments: the editor and the MathNode being edited.
    this.editHandler = options.editHandler;
    if (this.editable === undefined) {
      this.editable = true;
    }
    if (this.removeDisplayStyle === undefined) {
      this.removeDisplayStyle = false;
    }
    if (this.sanitizeLatexSource === undefined) {
      this.sanitizeLatexSource = false;
    }
    if (this.debugLogContainer === undefined) {
      this.debugLogContainer = null;
    }
    if (this.latexInput === undefined) {
      this.latexInput = null;
    }
    if (this.editHandler === undefined) {
      this.editHandler = null;
    }
    if (this.logTiming === undefined) {
      this.logTiming = false;
    }
    /** @type{boolean} */
    this.showLatexOnDoubleClick = !this.editable;
  }
}

class KeyHandlerResult {
  constructor(
    /**@type{boolean} */
    preventDefault,
    /**@type{boolean} */
    updateAlignment,
  ) {
    this.preventDefault = preventDefault;
    this.updateAlignment = updateAlignment;
  }
}

class CircularBuffer {
  constructor(
    /**@type{number} */
    capacity,
  ) {
    /**@type{string[]} */
    this.elements = [];
    /**@type{number} */
    this.lowestIndex = 0;
    /**@type{number} */
    this.highestIndex = - 1;
    /**@type{number} */
    this.capacity = capacity;
  }

  push(
    /**@type{string} */
    input,
  ) {
    this.highestIndex++;
    if (this.totalElements() > this.capacity) {
      this.lowestIndex++;
    }
    this.setElement(this.highestIndex, input);
  }

  pop() {
    if (this.totalElements() <= 0) {
      return null;
    }
    let circularIndex = this.indexToCircular(this.highestIndex);
    let result = this.elements[circularIndex];
    this.highestIndex--;
    return result;
  }

  setElement(
    /**@type{number} */
    index,
    /**@type{string} */
    input,
  ) {
    let circularIndex = this.indexToCircular(index);
    for (let i = this.elements.length; i <= circularIndex; i++) {
      this.elements.push("");
    }
    this.elements[circularIndex] = input;
  }

  indexToCircular(
    /**@type{number} */
    index,
  ) {
    return index % this.capacity;
  }

  /**@returns{string|null} */
  get(
    /**@type{number} */
    index,
  ) {
    if (index > this.highestIndex || index < this.lowestIndex) {
      return null;
    }
    let circularIndex = this.indexToCircular(index);
    if (circularIndex >= this.elements.length) {
      return null;
    }
    return this.elements[circularIndex];
  }

  /**@returns{number} */
  totalElements() {
    return this.highestIndex - this.lowestIndex + 1;
  }

  /**@returns{string} */
  toString() {
    let elementsToShowAtEachEnd = 2;
    if (this.totalElements() <= elementsToShowAtEachEnd * 2) {
      let result = [];
      for (let i = this.lowestIndex; i <= this.highestIndex; i++) {
        result.push(this.get(i));
      }
      return result.join(", ");
    }
    let resultLeft = [];
    for (let i = this.lowestIndex; i < this.lowestIndex + elementsToShowAtEachEnd; i++) {
      resultLeft.push(this.get(i));
    }
    let resultRight = [];
    for (let i = this.highestIndex - elementsToShowAtEachEnd + 1; i <= this.highestIndex; i++) {
      resultRight.push(this.get(i));
    }
    let left = resultLeft.join(", ");
    let right = resultRight.join(", ");
    let omitted = this.totalElements() - 2 * elementsToShowAtEachEnd;
    return `${left} ...(${omitted} omitted)...${right}`;
  }
}

class FocusInformation {
  constructor() {
    /** @type {MathNode|null} Used to write to the last focused node.*/
    this.lastFocused = null;
    /** @type{MathNodeWithCaretPosition} */
    this.lastSelectionStart = new MathNodeWithCaretPosition(null, -1);
    /** @type{MathNodeWithCaretPosition} */
    this.lastSelectionStartExpanded = new MathNodeWithCaretPosition(null, - 1);
    /** @type{MathNodeWithCaretPosition} */
    this.lastSelectionEnd = new MathNodeWithCaretPosition(null, -1);
    /** @type{MathNodeWithCaretPosition} */
    this.lastSelectionEndExpanded = new MathNodeWithCaretPosition(null, -1);
  }

  setLastFocused(
    /**@type{MathNode|null} */
    lastFocused,
  ) {
    this.lastFocused = lastFocused;
  }

  setLastSelection(
    /**@type{EquationEditor} */
    editor,
  ) {
    this.lastSelectionStart.assign(editor.selectionStart);
    this.lastSelectionStartExpanded.assign(editor.selectionStartExpanded);
    this.lastSelectionEnd.assign(editor.selectionEnd);
    this.lastSelectionEndExpanded.assign(editor.selectionEndExpanded);
  }

  restoreSelection(
    /**@type{EquationEditor} */
    editor,
  ) {
    editor.selectionStart.assign(this.lastSelectionStart);
    editor.selectionStartExpanded.assign(this.lastSelectionStartExpanded);
    editor.selectionEnd.assign(this.lastSelectionEnd);
    editor.selectionEndExpanded.assign(this.lastSelectionEndExpanded);
  }

  /**@returns {HTMLElement[]} */
  toHtmlDebugData() {
    let result = [];
    if (this.lastFocused === null) {
      return result;
    }
    result.push(document.createElement("br"));
    result.push(document.createTextNode(
      `Last focused: ${this.lastFocused.toString()}, position: ${this.lastFocused.positionCaretBeforeKeyEvents}`
    ));
    if (this.lastFocused.isDetached()) {
      result.push(document.createElement("br"));
      result.push(boldElement("Detached last focused.", "red"));
    }
    return result;
  }
}

class EquationEditor {
  constructor(
    /** @type{HTMLElement} */
    containerGiven,
    /** @type{EquationEditorOptions|null} */
    options,
  ) {
    /** @type{HTMLElement} */
    this.container = containerGiven;
    /** @type{HTMLElement|null} */
    this.latexContainer = null;
    this.container.style.display = "inline-block";
    this.container.style.position = "relative";
    this.container.textContent = "";
    /** @type{EquationEditorOptions} */
    this.options = new EquationEditorOptions({});
    if (options !== null && options !== undefined) {
      this.options = options;
    }
    this.rootNode = mathNodeFactory.rootMath(this);
    if (!this.options.editable) {
      this.rootNode.type.borderStyle = "";
      this.rootNode.type.padding = "";
      this.rootNode.type.margin = "";
      this.rootNode.type.cursor = "";
      this.rootNode.type.minWidth = "";
    } else {
      this.container.style.margin = "2px";
      this.container.style.padding = "2px";
    }
    /**@type{boolean} */
    this.preventEditorBlur = false;
    /**@type{boolean} */
    this.mouseSelectionStarted = false;
    /**@type{boolean} */
    this.selectionNoMoreDefault = false;
    /**@type{boolean} */
    this.mouseIgnoreNextClick = false;
    /** @type {boolean} */
    this.mouseSelectionVisible = false;
    /** @type{MathNodeWithCaretPosition} */
    this.selectionStart = new MathNodeWithCaretPosition(null, -1);
    /** @type{MathNodeWithCaretPosition} */
    this.selectionStartExpanded = new MathNodeWithCaretPosition(null, - 1);
    /** @type{MathNodeWithCaretPosition} */
    this.selectionEnd = new MathNodeWithCaretPosition(null, -1);
    /** @type{MathNodeWithCaretPosition} */
    this.selectionEndExpanded = new MathNodeWithCaretPosition(null, -1);
    /** @type{string} */
    this.latexLastWritten = "";
    /** @type{string} */
    this.latexLastEdit = "";
    /** @type{string} */
    this.latexLastEditWithCaret = "";
    /** @type{CircularBuffer} */
    this.history = new CircularBuffer(5000);
    /** @type{string[]} */
    this.redoBuffer = [];
    /** @type {boolean}*/
    this.backslashSequenceStarted = false;
    /** @type {string}*/
    this.backslashSequence = "";
    /** @type {number} */
    this.backslashPosition = - 1;
    /**@type {string} */
    this.positionDebugString = "";
    /**@type {boolean} */
    this.hasFocusDOM = false;
    /**@type{boolean} If changing this.container's font size, set this to true before the change, and back to false after.*/
    this.resizingEditorFont = false;
    if (this.options.latexInput !== null) {
      this.options.latexInput.addEventListener('keyup', (e) => {
        this.writeLatexFromInput();
      });
    }
    this.focusInformation = new FocusInformation();
    /** @type{string} */
    this.lastSelectionAction = "";
    /** @type{number} */
    this.standardAtomHeight = 0;
    /** @type{string} */
    this.lastCopied = "";
    /** @type{MathNode|null} */
    this.eventCatcher = null;
    this.prepareEventCatcher();
  }

  focusEventCatcher() {
    if (this.eventCatcher.element === null) {
      return false;
    }
    this.eventCatcher.element.focus();
    return true;
  }

  focusRestore() {
    if (!this.rootNode.focusRestore()) {
      this.resetSelectionFocusBestChoice();
    }
  }
  undo() {
    if (this.history.totalElements() <= 0) {
      return;
    }
    this.redoBuffer.push(this.latexLastEditWithCaret);
    let element = this.history.pop();
    this.writeLatex(element);
    this.latexLastEditWithCaret = element;
    this.latexLastEdit = this.rootNode.toLatexWithAnnotation(null).latex;
    this.focusRestore();
  }

  redo() {
    if (this.redoBuffer.length === 0) {
      return;
    }
    let element = this.redoBuffer.pop();
    this.writeLatex(element);
    this.writeLatexToInput(false);
    this.focusRestore();
  }

  /**@returns{KeyHandlerResult} */
  pasteFromClipboard() {
    if (!this.hasSelection() || !this.selectionEscapedOriginalAtom()) {
      return new KeyHandlerResult(false, false);
    }
    navigator.clipboard.readText().then((text) => {
      this.deleteSelection(text);
    });
    return new KeyHandlerResult(true, true);
  }

  copyToClipboard() {
    let latexWithAnnotation = this.rootNode.toLatexWithAnnotation(null);
    let toBeCopied = "";
    if (latexWithAnnotation.selectionStart === - 1 || latexWithAnnotation.selectionEnd === - 1) {
      toBeCopied = latexWithAnnotation.latex;
    } else {
      let start = latexWithAnnotation.selectionStart;
      let end = latexWithAnnotation.selectionEnd;
      if (start > end) {
        let original = start;
        start = end;
        end = original;
      }
      let sliced = latexWithAnnotation.latex.slice(start, end);
      toBeCopied = sliced;
    }
    this.lastCopied = toBeCopied;
    navigator.clipboard.writeText(toBeCopied);
    this.writeDebugInfo(null);
  }

  computeStandardAtomHeight() {
    // In firefox, empty space can be interpretted to have zero height; 
    // not so for non-breaking space.
    this.eventCatcher.initialContent = "\u200A";
    this.eventCatcher.element = document.createElement("div");
    this.eventCatcher.element.textContent = this.eventCatcher.initialContent;
    this.container.appendChild(this.eventCatcher.element);
    let boundingBox = this.eventCatcher.element.getBoundingClientRect();
    this.standardAtomHeight = boundingBox.height;
    this.container.removeChild(this.eventCatcher.element);
    this.eventCatcher.element = null;
  }

  prepareEventCatcher() {
    if (!this.options.editable) {
      return;
    }
    this.eventCatcher = new MathNode(this, knownTypes.eventCatcher);
    this.computeStandardAtomHeight();
    this.eventCatcher.createDOMElementIfMissing();
    this.container.appendChild(this.eventCatcher.element);
    this.eventCatcher.element.style.position = "absolute";
    this.eventCatcher.element.style.left = 0;
    this.eventCatcher.element.style.top = 0;
    this.eventCatcher.element.addEventListener("copy", (_) => {
      this.copyToClipboard();
    });
    this.eventCatcher.element.addEventListener("paste", (e) => {
      this.pasteFromClipboard(e);
    });
    this.eventCatcher.element.addEventListener("keydown", (e) => {
      this.handleKeyDownCatchAll(e);
    });
    this.container.addEventListener("keydown", (e) => {
      this.handleKeyDownCatchAll(e);
    });
    this.eventCatcher.element.addEventListener("blur", (e) => {
      this.blur();
    });
  }

  /** Removes all ranges from the window selection. */
  resetSelectionDOM() {
    try {
      window.getSelection().removeAllRanges();
    } catch (e) {
      console.log(`Failed to remove all ranges ${e}`);
    }
  }

  resetSelectionFullSelectEventCatcher() {
    this.resetSelectionLeaveRangesIntact();
    this.resetSelectionDOMSelectEventCatcher();
  }

  /** Removes all ranges from the window selection. */
  resetSelectionDOMSelectEventCatcher() {
    this.resetSelectionDOM();
    let range = document.createRange();
    range.setStart(this.eventCatcher.element, 0);
    range.setEnd(this.eventCatcher.element, 0);
    window.getSelection().addRange(range);
    this.eventCatcher.focus(1);
  }

  storeSelection() {
    this.focusInformation.setLastSelection(this);
  }

  updateDOM() {
    this.rootNode.updateDOM();
  }

  writeDebugInfo(
    /** @type{LaTeXParser|null} */ parser,
  ) {
    if (this.options.debugLogContainer === null) {
      return;
    }
    let result = [];
    if (parser !== null) {
      let syntacticStack = parser.toHtmlDebug();
      for (let i = 0; i < syntacticStack.length; i++) {
        result.push(syntacticStack[i]);
      }
      result.push(document.createElement("hr"));
    }
    let debugPart = this.toHtmlDebugData();
    for (let i = 0; i < debugPart.length; i++) {
      result.push(debugPart[i]);
    }
    this.options.debugLogContainer.textContent = "";
    for (let i = 0; i < result.length; i++) {
      this.options.debugLogContainer.appendChild(result[i]);
    }
  }

  writeLatexToInput(
    /**@type{boolean} */
    wipeOffRedoBuffer,
  ) {
    if (this.backslashSequenceStarted) {
      return;
    }
    let latexWithAnnotationNoCaret = this.rootNode.toLatexWithAnnotation(null);
    if (this.latexLastEdit === latexWithAnnotationNoCaret.latex) {
      return;
    }
    if (wipeOffRedoBuffer) {
      this.redoBuffer = [];
    }
    this.history.push(this.latexLastEditWithCaret);
    this.latexLastEditWithCaret = this.rootNode.toLatexWithAnnotation(latexOptionsWithCaret).latex;
    this.latexLastEdit = latexWithAnnotationNoCaret.latex;
    if (this.options.latexInput !== null) {
      this.options.latexInput.value = latexWithAnnotationNoCaret.latex;
    }
  }

  writeLatexFromInput() {
    if (this.options.latexInput === null) {
      return;
    }
    let inputContent = this.options.latexInput.value;
    this.writeLatex(inputContent);
  }

  writeLatex(
    /**@type {string} */
    latex,
  ) {
    this.latexLastWritten = latex;
    this.rootNode.removeAllChildren();
    if (this.rootNode.element !== null) {
      this.rootNode.element.textContent = "";
    }
    let parser = new LaTeXParser(this, latex);
    if (this.options.debugLogContainer !== null) {
      parser.debug = true;
    }
    let newContent = parser.parse();
    if (newContent === null) {
      this.writeDebugInfo(parser);
      console.log(`Failed to construct node from your input ${latex}.`);
      return;
    }
    this.rootNode.appendChild(newContent);
    this.updateDOM();
    this.updateAlignment();
    this.writeDebugInfo(parser);
    this.container.setAttribute("latexsource", latex);
    this.setLastFocused(this.rootNode.rightmostAtomChild());
  }

  writeLatexLastFocused(
    /**@type {string} */
    latex,
  ) {
    if (this.focusInformation.lastFocused === null) {
      let toWriteTo = this.rootNode.rightmostAtomChild();
      if (toWriteTo === null) {
        console.log("Unexpected failure to find atom child.");
        return;
      }
      toWriteTo.positionCaretBeforeKeyEvents = toWriteTo.textContentOrInitialContent().length;
      toWriteTo.writeLatex(latex);
      return;
    }
    let lastFocusedReference = this.focusInformation.lastFocused;
    // Ensure reference to last modified is wiped early.
    this.focusInformation.lastFocused = null;
    lastFocusedReference.writeLatex(latex);
  }

  accountFrameTime(
    /**@type{number} */
    frameStart,
  ) {
    let now = new Date().getTime();
    let elapsedTime = now - frameStart;
    if (elapsedTime > 100) {
      console.log(`Warning: last equation editor frame took a full ${elapsedTime}ms.`);
    }
  }

  setLastFocused(
    /**@type{MathNode|null} */
    lastFocused,
  ) {
    this.focusInformation.setLastFocused(lastFocused);
  }

  /**@returns {HTMLElement[]} */
  toHtmlDebugData() {
    let latexWithAnnotation = this.rootNode.toLatexWithAnnotation(null);
    let result = [];
    result.push(document.createTextNode(`Latex: ${latexWithAnnotation.latex}`));
    result.push(document.createElement("br"));
    result.push(document.createTextNode(`URL-encoded: ${encodeURIComponent(latexWithAnnotation.latex)}`));
    if (this.lastCopied !== "") {
      result.push(document.createElement("br"));
      result.push(document.createTextNode(`Last copied: ${this.lastCopied}`))
    }
    let focusInformation = this.focusInformation.toHtmlDebugData();
    for (let i = 0; i < focusInformation.length; i++) {
      result.push(focusInformation[i]);
    }
    result.push(document.createElement("br"));
    result.push(document.createTextNode(`History: ${this.toStringHistory()}`));
    if (this.lastSelectionAction !== "") {
      result.push(document.createElement("br"));
      result.push(document.createTextNode(`Last selection action: ${this.lastSelectionAction}`));
    }
    result.push(document.createElement("br"));
    result.push(document.createTextNode(`Latex selection: ${latexWithAnnotation.selectionStart}, ${latexWithAnnotation.selectionEnd}`));
    result.push(document.createElement("br"));
    result.push(document.createTextNode(this.toStringSelection()));
    result.push(document.createElement("br"));
    result.push(document.createTextNode(`Structure: `));
    let elements = this.rootNode.toHtmlDebugData(0);
    for (let i = 0; i < elements.length; i++) {
      result.push(document.createElement("br"));
      result.push(elements[i]);
    }
    result.push(document.createElement("br"));
    result.push(document.createTextNode(
      `Backslash position: ${this.backslashPosition}; started: ${this.backslashSequenceStarted}, sequence: ${this.backslashSequence}.`
    ));
    result.push(document.createElement("br"));
    result.push(document.createTextNode(
      `Position computation string: ${this.positionDebugString}.`
    ));
    return result;
  }

  toStringHistory() {
    let result = this.history.toString();
    if (this.redoBuffer.length > 0) {
      result += `<br>Redo buffer: ${this.redoBuffer.join(", ")}`;
    }
    return result;
  }

  /** Resets the selection and dispatches a key string to the last focused / best element.
   * 
   * @param {string} key 
   */
  dispatchKey(
    /**@type{string} */
    key,
  ) {
    let focused = this.restoreSelectionOrFocusBestChoice();
    this.dispatchKeyToNode(focused, key);
  }

  dispatchKeyToNode(
    /**@type{MathNode|null}*/
    focused,
    /**@type{string} */
    key,
  ) {
    if (focused === null) {
      return;
    }
    if (key === "ArrowLeft" && focused.positionCaretBeforeKeyEvents > 0) {
      focused.focus(0);
      return;
    }
    let event = new KeyboardEvent(
      "keydown", {
      key: key,
    });
    if (focused === this.eventCatcher) {
      this.handleKeyDownCatchAll(event);
      return;
    }
    focused.handleKeyDownDontComputeCaretPosition(event);
  }

  /**@returns{MathNode} */
  getLastFocused() {
    if (this.focusInformation.lastFocused === null) {
      return this.rootNode.rightmostAtomChild();
    }
    if (this.focusInformation.lastFocused.isDetached()) {
      return this.rootNode.rightmostAtomChild();
    }
    return this.focusInformation.lastFocused;
  }

  /**@returns{KeyHandlerResult} */
  arrowShiftHeld(
    /**@type{MathNode} */
    target,
    /**@type{string} */
    arrowKey,
  ) {
    this.initializeSelectionStart(target);
    let preventDefault = this.computeSelectionEndFromShiftKey(arrowKey);
    return new KeyHandlerResult(preventDefault, preventDefault);
  }

  /**@returns{MathNode} The node that was focused or the event catcher. */
  restoreSelectionOrFocusBestChoice() {
    if (this.hasSelection()) {
      this.eventCatcher.focus(0);
      return this.eventCatcher;
    }
    return this.resetSelectionFocusBestChoice();
  }

  /**@returns{MathNode} The node that was focused. */
  resetSelectionFocusBestChoice() {
    if (this.hasSelection()) {
      let lastSelected = this.selectionEndExpanded.element;
      let direction = - 1;
      if (this.selectionStartToTheLeftOfSelectionEnd()) {
        direction = 1;
      }
      this.resetSelectionFullSelectEventCatcher();
      lastSelected.focus(direction);
      return lastSelected;
    }
    let result = this.getLastFocused();
    this.resetSelectionFullSelectEventCatcher();
    let position = - 1;
    if (result.isAtomEditable()) {
      position = result.positionCaretBeforeKeyEvents;
    }
    result.focus(1);
    if (position !== -1) {
      result.positionCaretBeforeKeyEvents = position;
    }
    return result;
  }

  makeSqrtFromSelection(
    /** @type{SplitBySelectionResult} */
    splitBySelection,
  ) {
    let ancestor = splitBySelection.ancestor;
    ancestor.removeAllChildren();
    let underTheRadical = mathNodeFactory.horizontalMathFromArray(this, splitBySelection.split);
    underTheRadical.ensureEditableAtoms();
    let sqrt = mathNodeFactory.sqrt(this, underTheRadical, null);
    ancestor.appendChildren(splitBySelection.beforeSplit);
    ancestor.appendChild(sqrt);
    ancestor.appendChildren(splitBySelection.afterSplit);
    ancestor.ensureEditableAtoms();
    ancestor.updateDOM();
    sqrt.children[2].focusStandard(0);
  }

  makeFractionNumeratorFromSelection(
    /**@type{SplitBySelectionResult|split} */
    split,
  ) {
    if (split === null) {
      return;
    }
    let ancestor = split.ancestor;
    ancestor.removeAllChildren();
    for (let i = 0; i < split.beforeSplit.length; i++) {
      ancestor.appendChild(split.beforeSplit[i]);
    }
    let numerator = mathNodeFactory.horizontalMathFromArray(this, split.split);
    numerator.ensureEditableAtoms();
    let fraction = mathNodeFactory.fraction(this, numerator, null);
    ancestor.appendChild(fraction);
    for (let i = 0; i < split.afterSplit.length; i++) {
      ancestor.appendChild(split.afterSplit[i]);
    }
    ancestor.normalizeHorizontalMath();
    ancestor.ensureEditableAtoms();
    ancestor.updateDOM();
    fraction.children[1].focus(- 1);
  }

  /** Determines whether to delete a selection with non-default editable action when
   * a key is pressed.
   * 
   * @param {string} key
   * 
   */
  shouldDeleteSelection(
    key,
  ) {
    return this.hasSelection() &&
      this.selectionEscapedOriginalAtom() &&
      latexConstants.isCharacterReplacingSelection(key);
  }

  /** @returns{KeyHandlerResult} */
  handleControlKeys(
    /**@type{KeyboardEvent} */
    e,
  ) {
    if (!e.ctrlKey) {
      return new KeyHandlerResult(false, false);
    }
    switch (e.key) {
      case "Z":
        this.redo();
        return new KeyHandlerResult(true, true);
      case "z":
        this.undo();
        return new KeyHandlerResult(true, true);
      case "c":
        this.copyToClipboard();
        return new KeyHandlerResult(true, false);
      case "x":
        this.copyToClipboard();
        return this.deleteSelection(null);
      case "v":
        this.pasteFromClipboard();
        return new KeyHandlerResult()
      default:
        return new KeyHandlerResult(false, false);
    }
  }

  handleKeyDownCatchAll(
    /**@type{KeyboardEvent} */
    e,
  ) {
    e.stopPropagation();
    e.preventDefault();
    let key = e.key;
    if (e.ctrlKey) {
      this.handleControlKeys(e);
      return;
    }
    if (this.shouldDeleteSelection(key)) {
      this.deleteSelection(key);
      return;
    }
    switch (key) {
      case "ArrowLeft":
      case "ArrowRight":
      case "ArrowUp":
      case "ArrowDown":
        if (e.shiftKey) {
          this.arrowShiftHeld(this.getLastFocused(), key);
          return;
        }
        this.resetSelectionFocusBestChoice();
        return;
      case "/":
        this.makeFractionNumeratorFromSelection(this.splitAtomsBySelection());
        return;
      case "\\sqrt":
        if (!this.hasSelection()) {
          this.resetSelectionFocusBestChoice().makeSqrt();
          return;
        }
        this.makeSqrtFromSelection(this.splitAtomsBySelection());
        return;
      case "Delete":
      case "Backspace":
        if (this.hasSelection()) {
          this.deleteSelection(null);
          return;
        }
        this.resetSelectionFocusBestChoice();
        return;
      default:
        return;
    }
  }

  /**@returns{boolean} */
  hasSelection() {
    return this.selectionStart.element !== null;
  }

  /**@returns{boolean} */
  selectionEscapedOriginalAtom() {
    return this.selectionStartExpanded.position === - 1;
  }

  /** @returns{KeyHandlerResult} whether the default should be prevented. 
   * 
   * @param {string|null} keyOrLatex A Latex snippet, latin character, whitespace or digit to replace the selection.
  */
  deleteSelection(
    /**@type{string|null} */
    keyOrLatex,
  ) {
    if (!this.hasSelection()) {
      return new KeyHandlerResult(false, false);
    }
    if (!this.selectionEscapedOriginalAtom()) {
      this.resetSelectionLeaveRangesIntact();
      return new KeyHandlerResult(false, false);
    }
    let expanded = this.selectionStartExpanded.element.beefUpToHorizontalParent();
    if (expanded.type.type === knownTypes.root.type) {
      // Delete the root node.
      this.rootNode.removeAllChildren();
      this.rootNode.appendChild(mathNodeFactory.horizontalMath(this, null));
      this.resetSelectionLeaveRangesIntact();
      this.updateDOM();
      this.rootNode.focus(0);
      this.writeLatexToInput(true);
      this.writeDebugInfo(null);
      return new KeyHandlerResult(true, true);
    }
    let horizontalOwner = expanded.parent;
    let parent = horizontalOwner.parent;
    if (parent === null) {
      console.log("Unexpected horizontal math element without parent.");
      this.resetSelectionLeaveRangesIntact();
      return new KeyHandlerResult(false, false);
    }
    let splitBySelection = this.splitAtomsBySelection();
    if (splitBySelection === null) {
      console.log("Unexpected failure to split by selection");
      this.resetSelectionLeaveRangesIntact();
      return new KeyHandlerResult(false, false);
    }
    let horizontalReplacement = mathNodeFactory.horizontalMathFromArray(this, splitBySelection.beforeSplit);
    /**@type{MathNode} */
    let replacing = null;
    if (keyOrLatex !== null) {
      replacing = new LaTeXParser(this, keyOrLatex).parse();
    } else {
      replacing = mathNodeFactory.atom(this, "");
    }
    if (replacing.type.type === knownTypes.atom.type) {
      replacing.desiredCaretPosition = replacing.textContentOrInitialContent().length;
    } else {
      replacing.desiredCaretPosition = 1;
    }
    horizontalReplacement.appendChild(replacing);
    horizontalReplacement.appendChildren(splitBySelection.afterSplit);
    horizontalReplacement.normalizeHorizontalMath();
    horizontalReplacement.ensureEditableAtoms();
    parent.replaceChildAtPosition(horizontalOwner.indexInParent, horizontalReplacement);
    this.resetSelectionLeaveRangesIntact();
    parent.updateDOM();
    parent.focusRestore();
    this.writeLatexToInput(true);
    this.writeDebugInfo(null);
    return new KeyHandlerResult(true, true);
  }

  updateAlignment() {
    this.rootNode.computeBoundingBox();
    this.rootNode.doAlign();
    let boundingRectangle = this.rootNode.element.getBoundingClientRect();
    // Bounding box may not be computed correctly at this point in Firefox.
    let desiredHeight = Math.max(boundingRectangle.height, this.rootNode.boundingBox.height, this.standardAtomHeight);
    // Bounding box may not be computed correctly at this point in Firefox.
    let desiredWidth = Math.max(boundingRectangle.width, this.rootNode.boundingBox.width);
    if (this.options.editable) {
      desiredHeight += 2;
    }
    this.container.style.height = desiredHeight;
    this.container.style.width = desiredWidth;
    if (this.rootNode.boundingBox.needsMiddleAlignment && !this.options.editable) {
      this.container.style.verticalAlign = "middle";
    } else {
      this.container.style.verticalAlign = "text-bottom";
    }
  }

  /**@returns {string} */
  toStringSelection() {
    if (this.selectionStart.element === null) {
      return "";
    }
    let startAnnotationString = "[expanded selection null]";
    if (this.selectionStartExpanded.element !== null) {
      let startAnnotation = this.selectionStartExpanded.element.toLatexWithAnnotation(null);
      startAnnotationString = startAnnotation.toString();
    }
    let endAnnotation = this.selectionEnd.element.toLatexWithAnnotation(null);
    let result = `Selection: from: ${this.selectionStartExpanded.toString()} to: ${this.selectionEndExpanded.toString()}.`;
    result += `Actually selected: ${this.selectionStart.toString()} to: ${this.selectionEnd.toString()}.`;
    result += `Latex from: ${startAnnotationString} to ${endAnnotation.toString()}`;
    return result;
  }

  /** @returns {SplitBySelectionResult|null} */
  splitOneAtomBySelection() {
    if (this.selectionStartExpanded.element === null) {
      return null;
    }
    if (
      this.selectionEnd.element !== this.selectionStartExpanded.element ||
      !this.selectionEnd.element.isAtomEditable()
    ) {
      return null;
    }
    let atom = this.selectionEnd.element;
    if (!atom.hasHorozintalMathParent()) {
      console.log("Atom has non-horizontal math parent.");
      return null;
    }
    let parent = atom.parent;
    let result = new SplitBySelectionResult(parent);
    for (let i = 0; i < atom.indexInParent; i++) {
      result.beforeSplit.push(parent.children[i]);
    }
    let left = null;
    let middle = null;
    let right = null;
    let leftPosition = this.selectionStartExpanded.position;
    let rightPosition = this.selectionEnd.position;
    if (rightPosition < leftPosition) {
      let temporary = rightPosition;
      rightPosition = leftPosition;
      leftPosition = temporary;
    }
    if (leftPosition < 0) {
      console.log("Unexpected negative left position.");
      return null;
    }
    let rightPositionShifted = rightPosition - leftPosition;
    if (rightPositionShifted < 0) {
      console.log("Unexpected negative shifted right position.");
      return null;
    }

    // Suppose our atom has content: "leftmiddleright". 
    // Suppose the middle is selected, i.e., the selection borders are as indicated: "left|middle|right".
    let leftSplit = atom.splitByPosition(leftPosition);
    if (leftSplit[0] !== null) {
      // The left section is non-empty.
      left = leftSplit[0];
    }
    if (leftSplit[1] === null) {
      // The middle section is empty - we have a zero-length selection.
      // We choose not to split.
      return null;
    }
    let rightSplit = leftSplit[1].splitByPosition(rightPositionShifted);
    middle = rightSplit[0];
    right = rightSplit[1];
    if (left !== null) {
      result.beforeSplit.push(left);
    }
    result.split.push(middle);
    if (right !== null) {
      result.afterSplit.push(right);
    }
    for (let i = atom.indexInParent + 1; i < parent.children.length; i++) {
      result.afterSplit.push(parent.children[i]);
    }
    return result;
  }

  /** @returns {SplitBySelectionResult|null} */
  splitAtomsBySelection() {
    if (this.selectionStartExpanded.element === null || this.selectionEndExpanded.element === null) {
      return null;
    }
    let start = this.selectionStartExpanded;
    let end = this.selectionEndExpanded;

    if (end.element.isToTheLeftOf(start.element)) {
      // Swap end and start
      let temporary = start;
      start = end;
      end = temporary;
    }
    if (
      this.selectionStartExpanded.element === this.selectionEndExpanded.element &&
      this.selectionStartExpanded.element.isAtomEditable() &&
      !this.selectionEscapedOriginalAtom()
    ) {
      // Selection is contained within a single atom.
      return this.splitOneAtomBySelection();
    }
    let ancestor = start.element.commonAncestor(end.element);
    if (ancestor === null) {
      console.log(`Not expected: no common ancestor element between ${start} and ${end}. `);
      return null;
    }
    if (ancestor.type.type !== knownTypes.horizontalMath.type) {
      ancestor = ancestor.beefUpToHorizontalParent().parent;
      if (ancestor === null) {
        // Common ancestor is not of type horizontal math. Don't split.
        return null;
      }
    }
    if (start.element === ancestor || end.element === ancestor) {
      // Start and end are the same node, which is the ancestor.
      return null;
    }
    while (start.element.parent !== ancestor && start.element.parent !== null) {
      start.element = start.element.parent;
    }
    while (end.element.parent !== ancestor && end.element.parent !== null) {
      end.element = end.element.parent;
    }
    let result = new SplitBySelectionResult(ancestor);
    for (let i = 0; i < start.element.indexInParent; i++) {
      result.beforeSplit.push(ancestor.children[i]);
    }
    for (let i = start.element.indexInParent; i <= end.element.indexInParent; i++) {
      result.split.push(ancestor.children[i]);
    }
    for (let i = end.element.indexInParent + 1; i < ancestor.children.length; i++) {
      result.afterSplit.push(ancestor.children[i]);
    }
    return result;
  }

  /** @returns{MathNode} */
  elementFromPath(
    /** @type{number[]} */
    path,
  ) {
    let current = this.rootNode;
    for (let i = 0; i < path.length; i++) {
      current = current.children[path[i]];
    }
    return current;
  }

  handleDoubleClick(
    /** @type{MouseEvent} */
    e,
  ) {
    if (!this.options.showLatexOnDoubleClick) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    if (this.latexContainer !== null) {
      this.container.removeChild(this.latexContainer);
      this.latexContainer = null;
      this.container.style.width = this.rootNode.element.style.width;
      return;
    }
    this.latexContainer = document.createElement("SPAN");
    let latex = "";
    let writeOriginal = false;
    let removeDisplayStyle = false;
    if (this.rootNode.children[0].type.type === knownTypes.error.type) {
      writeOriginal = true;
    } else if (!this.options.editable && this.latexLastWritten !== "" && !this.options.sanitizeLatexSource) {
      writeOriginal = true;
      removeDisplayStyle = true;
    }
    if (writeOriginal) {
      if (removeDisplayStyle) {
        latex = this.latexLastWritten.split("\\displaystyle").join("");
      } else {
        latex = this.latexLastWritten;
      }
    } else {
      latex = this.rootNode.toLatex();
    }
    this.latexContainer.textContent = latex;
    this.latexContainer.style.position = "absolute";
    this.latexContainer.style.left = this.rootNode.element.style.width;
    this.latexContainer.style.whiteSpace = "nowrap";
    this.container.appendChild(this.latexContainer);
    let newWidth = this.rootNode.element.getBoundingClientRect().width + this.latexContainer.getBoundingClientRect().width;
    this.container.style.width = newWidth;
    let range = window.getSelection().getRangeAt(0);
    let rangeClone = range.cloneRange();
    rangeClone.selectNode(this.latexContainer);
    this.resetSelectionDOM();
    window.getSelection().addRange(rangeClone);
  }

  resetSelectionLeaveRangesIntact() {
    if (this.selectionStart.element !== null) {
      this.rootNode.unSelectMouseRecursive();
    }
    this.selectionStart.element = null;
    this.selectionStart.position = - 1;
    this.selectionEnd.element = null;
    this.selectionEnd.position = - 1;
    this.selectionStartExpanded.element = null;
    this.selectionStartExpanded.position = - 1;

    this.mouseSelectionStarted = false;
    this.mouseIgnoreNextClick = false;
    this.selectionNoMoreDefault = false;
    this.mouseSelectionVisible = false;
  }

  initializeSelectionStart(
    /** @type {MathNode} */
    start,
  ) {
    if (this.selectionStart.element !== null) {
      return;
    }
    this.resetSelectionLeaveRangesIntact();
    this.selectionStart = new MathNodeWithCaretPosition(start, start.positionCaretBeforeKeyEvents);
    this.selectionEnd = new MathNodeWithCaretPosition(start, start.positionCaretBeforeKeyEvents);
  }

  /**@returns{MathNodeWithCaretPosition|null} */
  computeNewSelectionFromShiftKey(
    /** @type {string} */
    key,
  ) {
    if (key === "ArrowLeft" || key === "ArrowUp") {
      let shrinking = this.selectionStartToTheLeftOfSelectionEnd();
      return this.selectionEnd.leftHorizontalNeighborBalanced(shrinking);
    } else {
      let shrinking = !this.selectionStartToTheLeftOfSelectionEnd();
      return this.selectionEnd.rightHorizontalNeighborBalanced(shrinking);
    }
  }

  /** @returns{boolean} whether the default should be prevented. */
  computeSelectionEndFromShiftKey(
    /** @type {string} */
    key,
  ) {
    let newSelection = this.computeNewSelectionFromShiftKey(key);
    if (newSelection === null) {
      return false;
    }
    if (newSelection.element === null) {
      return false;
    }
    this.selectionEnd = newSelection;
    setTimeout(() => {
      this.selectFromElement(newSelection.element);
    }, 0);
    if (this.selectionNoMoreDefault) {
      return true;
    }
    if (newSelection.element !== this.selectionStart.element) {
      return true;
    }
    return false;
  }

  /** @returns{boolean} whether the default browser selection action should be prevented. */
  selectFromElement(
    /** @type {MathNode} */
    element,
  ) {
    this.mouseIgnoreNextClick = true;
    if (element === this.selectionStart.element && !this.selectionNoMoreDefault) {
      this.selectionStartExpanded.assign(this.selectionStart);
      this.selectionEnd.element.storeCaretPosition("", false);
      this.selectionEnd.position = this.selectionEnd.element.positionCaretBeforeKeyEvents;
      if (
        this.selectionEnd.position === this.selectionStart.position &&
        this.selectionEnd.element.selectionLength !== 0
      ) {
        this.selectionEnd.position -= this.selectionEnd.element.selectionLength;
      }
      this.selectionEndExpanded.assign(this.selectionEnd);
      this.storeSelection();
      this.writeDebugInfo(null);
      return false;
    }
    this.preventEditorBlur = true;
    this.selectionNoMoreDefault = true;
    this.resetSelectionDOMSelectEventCatcher();
    this.eventCatcher.focus();
    // The selection has escaped the original element.
    // Once we are out of the original element, we 
    // can only select an entire atom.
    this.selectionStart.position = - 1;
    this.selectionEnd.element = element;
    this.selectionEnd.position = - 1;
    this.computeSelectionExpanded();
    this.highlightSelectionMouse();
    if (this.options.debugLogContainer !== null) {
      this.lastSelectionAction = `Mouse move selection above ${element.toString()}.`;
    }
    this.storeSelection();
    this.writeDebugInfo(null);
    this.preventEditorBlur = false;
    return true;
  }

  /**@returns{MathNodeWithCaretPosition} */
  expandElementForSelection(
    /**@type{MathNode} */
    toBeExpanded,
    /**@type{MathNode} */
    peer,
  ) {
    let parent = toBeExpanded.commonParent(peer);
    if (parent.parent === null) {
      return new MathNodeWithCaretPosition(this.rootNode, -1);
    }
    let container = parent.parent.children[parent.indexInParent];
    return new MathNodeWithCaretPosition(
      container.beefUpToHorizontalParent(),
      - 1,
    );
  }

  computeSelectionExpanded() {
    if (this.selectionStart.element === null || this.selectionEnd.element === null) {
      return;
    }
    this.selectionStartExpanded = this.expandElementForSelection(this.selectionStart.element, this.selectionEnd.element);
    this.selectionEndExpanded = this.expandElementForSelection(this.selectionEnd.element, this.selectionStartExpanded.element);
    this.balanceSelection();
  }

  balanceSelection() {
    let startElement = this.selectionStartExpanded.element;
    let endElement = this.selectionEndExpanded.element;
    let parent = startElement.parent;
    if (
      parent !== endElement.parent ||
      parent.type.type !== knownTypes.horizontalMath.type
    ) {
      console.log("Unexpected form of the selection (non-horizontal parent or different parent).");
      return;
    }
    let left = startElement.indexInParent;
    let right = endElement.indexInParent;
    let swapped = (right < left);
    if (swapped) {
      let swapper = right;
      right = left;
      left = swapper;
    }
    let leftOpenCount = 0;
    let rightOpenCount = 0;
    function accountChildToTheLeft(
      /**@type{MathNode} */
      child,
    ) {
      if (child.type.type === knownTypes.leftDelimiter.type) {
        if (rightOpenCount > 0) {
          rightOpenCount--;
        } else {
          leftOpenCount++;
        }
      } else if (child.type.type === knownTypes.rightDelimiter.type) {
        rightOpenCount++;
      }
    }
    function accountChildToTheRight(
      /**@type{MathNode} */
      child,
    ) {
      if (child.type.type === knownTypes.rightDelimiter.type) {
        if (leftOpenCount > 0) {
          leftOpenCount--;
        } else {
          rightOpenCount++;
        }
      } else if (child.type.type === knownTypes.leftDelimiter.type) {
        leftOpenCount++;
      }
    }
    for (let i = left; i <= right; i++) {
      accountChildToTheRight(parent.children[i]);
    }
    while (leftOpenCount > 0 || rightOpenCount > 0) {
      if (leftOpenCount > 0) {
        right++;
        if (right >= parent.children.length) {
          console.log("Missing right deliimiter");
          return;
        }
        accountChildToTheRight(parent.children[right]);
      }
      if (rightOpenCount > 0) {
        left--;
        if (left < 0) {
          console.log("Missing left delimiter");
          return;
        }
        accountChildToTheLeft(parent.children[left]);
      }
    }
    if (swapped) {
      this.selectionStartExpanded.element = parent.children[right];
      this.selectionEndExpanded.element = parent.children[left];
      this.selectionEnd.element = parent.children[left];
    } else {
      this.selectionStartExpanded.element = parent.children[left];
      this.selectionEndExpanded.element = parent.children[right];
      this.selectionEnd.element = parent.children[right];
    }
  }

  /**@return{boolean} */
  selectionStartToTheLeftOfSelectionEnd() {
    if (this.selectionStartExpanded.element === null || this.selectionEnd.element === null) {
      return true;
    }
    return this.selectionStartExpanded.element.isToTheLeftOf(this.selectionEnd.element);
  }

  highlightSelectionMouse() {
    if (this.selectionStartExpanded.element === null || this.selectionEnd.element === null) {
      return;
    }
    let left = this.selectionStartExpanded.element;
    let right = this.selectionEndExpanded.element;
    if (right.isToTheLeftOf(left)) {
      let copy = right;
      right = left;
      left = copy;
    }
    left = left.beefUpToHorizontalParent();
    right = right.beefUpToHorizontalParent();
    /**@type {MathNode} */
    let current = left;
    this.rootNode.unSelectMouseRecursive();
    this.rootNode.blurRecursive();
    for (; ;) {
      current.selectElementByMouse();
      if (current === right) {
        break;
      }
      current = current.horizontalSibling(1);
      if (current === null) {
        break;
      }
    }
  }

  handleMouseMoveSelection(
    /**@type{MouseEvent} */
    e,
    /**@type{MathNode} */
    element,
  ) {
    if (!this.mouseSelectionStarted) {
      return;
    }
    e.stopPropagation();
    if (this.selectFromElement(element)) {
      e.preventDefault();
    }
  }

  handleMouseSelectionStart(
    /**@type{MouseEvent} */
    e,
    /**@type{MathNode} */
    element,
  ) {
    this.preventEditorBlur = true;
    if (!this.hasFocusDOM) {
      this.eventCatcher.focus(1);
      this.hasFocusDOM = true;
    }
    e.stopPropagation();
    // e.preventDefault();
    element.storeCaretPosition("", false);
    // Discard previous selection data.
    this.resetSelectionLeaveRangesIntact();
    this.initializeSelectionStart(element);
    this.resetSelectionDOMSelectEventCatcher();
    this.mouseSelectionStarted = true;
    this.mouseSelectionVisible = true;
    if (this.options.debugLogContainer !== null) {
      this.lastSelectionAction = `Mouse selection start over ${element.toString()}, position:${element.positionCaretBeforeKeyEvents}.`;
    }
    // The mouse down event may fire before the built-in element ranges are updated.
    // So, release the event handling to allow built-in processing to take place, and 
    // schedule an element update immediately after.
    setTimeout(() => {
      element.storeCaretPosition("", false);
      this.selectionStart.position = element.positionCaretBeforeKeyEvents;
      this.writeDebugInfo(null);
    }, 0);
    this.writeDebugInfo(null);
    return;
  }

  handleMouseSelectionEnd(
    /**@type{MouseEvent} */
    e,
  ) {
    if (this.options.debugLogContainer !== null) {
      this.lastSelectionAction = `Mouse selection end.`;
    }
    this.mouseSelectionStarted = false;
    this.preventEditorBlur = false;
    this.writeDebugInfo(null);
    e.preventDefault();
    e.stopPropagation();
  }

  blur() {
    if (this.preventEditorBlur) {
      return;
    }
    this.hasFocusDOM = false;
    this.backslashSequenceStarted = false;
    this.resetSelectionLeaveRangesIntact();
    this.rootNode.blurRecursive();
  }
}

class SplitBySelectionResult {
  constructor(
    /** @type{MathNode} */
    ancestor,
  ) {
    /** @type{MathNode[]} */
    this.beforeSplit = [];
    /** @type{MathNode[]} */
    this.afterSplit = [];
    /** @type{MathNode[]} */
    this.split = [];
    /** @type{MathNode} */
    this.ancestor = ancestor;
  }
}

class BoundingBox {
  constructor() {
    /** @type{number}*/
    this.left = 0;
    /** @type{number}*/
    this.top = 0;
    /** @type{number}*/
    this.width = 0;
    /** @type{number}*/
    this.height = 0;
    /** @type{number}*/
    this.fractionLineHeight = 0;

    /**@type {boolean} */
    this.needsMiddleAlignment = false;
    /** @type{number[]}*/
    // Used for math nodes that have columns (matrices, tables (\begin{array}...)).
    this.columnOffsets = [];
    /** @type{number}*/
    // In a^b the following measures the width of b. 
    this.superScriptWidth = 0;
    /** @type{number}*/
    // In a_b the following measures the width of b. 
    this.subScriptWidth = 0;
    /** @type{string}*/
    this.transform = "";
    /** @type{string}*/
    this.transformOrigin = "";
    /** @type{number}*/
    this.heightBeforeTransform = - 1;
    /** @type{number}*/
    this.widthBeforeTransform = - 1;
  }

  /** @returns {number} */
  getColumnOffset(
    /**@type{number} */
    columnIndex,
  ) {
    if (columnIndex < 0) {
      return 0;
    }
    if (columnIndex >= this.columnOffsets.length) {
      return this.width;
    }
    return this.columnOffsets[columnIndex];
  }

  toString() {
    return `w: ${this.width.toFixed(2)}, h: ${this.height.toFixed(2)}, fl:${this.fractionLineHeight.toFixed(2)}`;
  }
}

class LatexWithAnnotation {
  constructor(
    /**@type{string} */
    latex,
    /**@type{number} */
    selectionStart,
    /**@type{number} */
    selectionEnd,
  ) {
    /** @type {string} */
    this.latex = latex;
    /** @type {number} */
    this.selectionStart = selectionStart;
    /** @type {number} */
    this.selectionEnd = selectionEnd;
  }

  /**@returns{LatexWithAnnotation} Accounts start/end of a selection. 
   * Returns this object.
   */
  accountOwner(
    /** @type{MathNode} */
    owner,
  ) {
    let endSelection = owner.equationEditor.selectionEndExpanded;
    let endElement = endSelection.element;
    if (owner === endElement && endSelection.position === -1) {
      if (owner.equationEditor.selectionStartToTheLeftOfSelectionEnd()) {
        this.selectionEnd = this.latex.length;
      } else {
        this.selectionEnd = 0;
      }
    }
    let startSelection = owner.equationEditor.selectionStartExpanded;
    let startElement = startSelection.element;
    if (owner === startElement && startSelection.position === -1) {
      if (owner.equationEditor.selectionStartToTheLeftOfSelectionEnd()) {
        this.selectionStart = 0;
      } else {
        this.selectionStart = this.latex.length;
      }
    }
    return this;
  }

  accountChild(
    /** @type{LatexWithAnnotation} */
    child,
    /** @type{number} */
    shift,
  ) {
    if (child.selectionStart !== - 1) {
      this.selectionStart = shift + child.selectionStart;
    }
    if (child.selectionEnd !== - 1) {
      this.selectionEnd = shift + child.selectionEnd;
    }
  }

  toString() {
    return `${this.latex} [[${this.selectionStart}, ${this.selectionEnd}]]`;
  }
}

class BackslashResult {
  constructor(
    /**@type{boolean} */
    keyAccountedCarryOutDefaultEvent,
    /**@type{string} */
    command,
  ) {
    this.keyAccountedCarryOutDefaultEvent = keyAccountedCarryOutDefaultEvent;
    this.command = command;
  }
}

class MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
    /** @type {MathNodeType} */
    type,
  ) {
    if (!(equationEditor instanceof EquationEditor)) {
      throw (`Unexpected equation editor ${equationEditor}`);
    }
    /** @type {Array<MathNode>} */
    this.children = [];
    /** @type {MathNodeType} */
    this.type = type.clone();
    /** @type {HTMLElement} */
    this.element = null;
    /** @type {MathNode} */
    this.parent = null;
    /** @type {number} */
    this.indexInParent = - 1;
    /** @type {number} */
    this.positionCaretBeforeKeyEvents = - 1;
    /** @type {number} */
    this.selectionLength = - 1;
    /** @type {number} */
    this.desiredCaretPosition = - 1;
    /** @type {string} */
    this.initialContent = "";
    /** @type {boolean} */
    this.focused = false;
    /** @type {boolean} 
     * Indicates whether the node was explicitly entered by the user 
     * or has been implied by a user action, such as parentheses auto-balancing.
     */
    this.implied = false;
    /** @type {boolean} */
    this.selectedByMouse = false;
    /** @type {EquationEditor} */
    this.equationEditor = equationEditor;
    this.boundingBox = new BoundingBox();
    /**@type {string} Used for matrix column formatting; additionally reserved for unforeseen use cases.*/
    this.latexExtraStyle = "";
    /** @type{Object} Reserved for data specific to particular MathNode types.*/
    this.extraData = null;
  }

  createDOMElementIfMissing() {
    if (this.element !== null) {
      // Element already created;
      return;
    }
    this.element = document.createElement("div");
    const fontSize = 20;
    if (
      (this.type.type === knownTypes.eventCatcher.type || this.type.type === knownTypes.atom.type) &&
      this.equationEditor.options.editable
    ) {
      this.element.contentEditable = true;
    }
    if (this.type.type === knownTypes.root.type && this.equationEditor.options.editable) {
      // equationeditoreditable one word for maximum portability.
      this.element.classList.add("equationeditoreditable");
      if (getComputedStyle(this.element).borderWidth === "") {
        this.element.style.borderStyle = "solid";
      }
    }

    // Padding.
    if (this.type.padding !== "") {
      this.element.style.padding = this.type.padding;
    }
    if (this.type.paddingBottom !== "") {
      this.element.style.paddingBottom = this.type.paddingBottom;
    }
    if (this.type.paddingTop !== "") {
      this.element.style.paddingTop = this.type.paddingTop;
    }
    if (this.type.paddingLeft !== "") {
      this.element.style.paddingLeft = this.type.paddingLeft;
    }
    if (this.type.paddingRight !== "") {
      this.element.style.paddingRight = this.type.paddingRight;
    }
    if (this.type.colorText !== "") {
      this.element.style.color = this.type.colorText;
    }
    // Margins
    if (this.type.margin !== "") {
      this.element.style.margin = this.type.margin;
    }
    if (this.type.marginBottom !== "") {
      this.element.style.marginBottom = this.type.marginBottom;
    }
    if (this.type.marginLeft !== "") {
      this.element.style.marginLeft = this.type.marginLeft;
    }
    if (this.type.marginRight !== "") {
      this.element.style.marginRight = this.type.marginRight;
    }
    if (this.type.boxSizing !== "") {
      this.element.style.boxSizing = this.type.boxSizing;
    }
    // Borders.
    if (this.type.borderStyle !== "") {
      this.element.style.border = this.type.borderStyle;
    }
    if (this.type.borderColor !== "") {
      this.element.style.borderColor = this.type.borderColor;
    }
    if (this.type.borderBottom !== "") {
      this.element.style.borderBottom = this.type.borderBottom;
    }
    if (this.type.borderTopLeftRadius !== "") {
      this.element.style.borderTopLeftRadius = this.type.borderTopLeftRadius;
    }
    if (this.type.borderTopRightRadius !== "") {
      this.element.style.borderTopRightRadius = this.type.borderTopRightRadius;
    }
    if (this.type.borderBottomLeftRadius !== "") {
      this.element.style.borderBottomLeftRadius = this.type.borderBottomLeftRadius;
    }
    if (this.type.borderBottomRightRadius !== "") {
      this.element.style.borderBottomRightRadius = this.type.borderBottomRightRadius;
    }
    if (this.type.borderTop !== "") {
      this.element.style.borderTop = this.type.borderTop;
    }
    if (this.type.borderLeft !== "") {
      this.element.style.borderLeft = this.type.borderLeft;
    }
    if (this.type.borderRight !== "") {
      this.element.style.borderRight = this.type.borderRight;
    }
    this.element.style.width = this.type.width;
    this.element.style.height = this.type.height;
    this.element.style.display = this.type.display;
    if (this.type.minHeightScale !== 0) {
      this.element.style.minHeight = this.type.minHeightScale * fontSize / 1.6;
    }
    if (this.type.minWidth !== "") {
      this.element.style.minWidth = this.type.minWidth;
    }
    if (this.type.overflow !== "") {
      this.element.style.overflow = this.type.overflow;
    }
    this.element.style.verticalAlign = this.type.verticalAlign;
    this.element.style.outline = this.type.outline;
    if (this.type.cursor !== "") {
      this.element.style.cursor = this.type.cursor;
    }
    if (this.type.textAlign !== "") {
      this.element.style.textAlign = this.type.textAlign;
    }
    if (this.type.whiteSpace !== "") {
      this.element.style.whiteSpace = this.type.whiteSpace;
    }
    // Fonts. 
    if (this.type.fontWeight !== "") {
      this.element.style.fontWeight = this.type.fontWeight;
    }
    if (this.type.fontSizeRatio !== 1) {
      this.element.style.fontSize = `${this.type.fontSizeRatio * 100}%`;
    }
    if (this.initialContent !== "") {
      this.element.textContent = this.initialContent;
    }
    if (this.type.position !== "") {
      this.element.style.position = this.type.position;
    }
    this.element.setAttribute("mathTagName", this.type.type);
    if (this.equationEditor.options.editable) {
      this.element.addEventListener("copy", (e) => {
        this.equationEditor.copyToClipboard();
      });
      if (this.type.type === knownTypes.atom.type) {
        this.element.addEventListener("paste", (e) => {
          this.pasteFromClipboard(e);
        });
        this.element.addEventListener("keyup", (e) => {
          this.handleKeyUp(e);
        });
        this.element.addEventListener("keydown", (e) => {
          this.handleKeyDown(e);
        });
        this.element.addEventListener("focus", (e) => {
          this.handleFocus(e);
        });
        this.element.addEventListener("blur", (e) => {
          this.handleBlur(e);
        });
      }
      if (this.type.type !== knownTypes.eventCatcher.type) {
        this.element.addEventListener("click", (e) => {
          this.handleSingleClick(e);
        });
        this.element.addEventListener("mousedown", (e) => {
          this.equationEditor.handleMouseSelectionStart(e, this);
        });
        this.element.addEventListener("mouseup", (e) => {
          this.equationEditor.handleMouseSelectionEnd(e);
        });
        this.element.addEventListener("mousemove", (e) => {
          this.equationEditor.handleMouseMoveSelection(e, this);
        });
      }
      if (this.type.type === knownTypes.root.type) {
        this.element.addEventListener("focusin", () => {
          // equationeditoreditablehighlighted one word for portability.
          this.element.classList.add("equationeditoreditablehighlighted")
        });
        this.element.addEventListener("focusout", () => {
          this.element.classList.remove("equationeditoreditablehighlighted")
        });
      }
    }
    if (this.type.type === knownTypes.root.type) {
      this.element.addEventListener("dblclick", (e) => {
        this.equationEditor.handleDoubleClick(e);
      });
    }
  }

  handleSingleClick(
    /** @type{MouseEvent} */
    e,
  ) {
    e.stopPropagation();
    e.preventDefault();
    if (this.equationEditor.mouseIgnoreNextClick) {
      this.equationEditor.mouseIgnoreNextClick = false;
      if (this.equationEditor.selectionEscapedOriginalAtom()) {
        this.equationEditor.resetSelectionDOMSelectEventCatcher();
        if (this.equationEditor.options.debugLogContainer !== null) {
          this.equationEditor.lastSelectionAction = "Set mouse ignore next to true.";
        }
      }
      this.equationEditor.writeDebugInfo(null);
      return;
    }
    if (this.equationEditor.options.debugLogContainer !== null) {
      this.equationEditor.lastSelectionAction = "Reset selection on single click.";
    }
    this.equationEditor.resetSelectionLeaveRangesIntact();
    this.storeCaretPosition("", false);
    if (this.type.type === knownTypes.atom.type) {
      return;
    }
    this.focus(1);
  }

  /** @returns {MathNode|null} */
  findFirstFocusedChild() {
    if (this.focused) {
      return this;
    }
    for (let i = 0; i < this.children.length; i++) {
      let candidate = this.children[i].findFirstFocusedChild();
      if (candidate !== null) {
        return candidate;
      }
    }
    return null;
  }

  selectElementByMouse() {
    if (!this.selectedByMouse && this.element !== null) {
      this.element.style.backgroundColor = "lightskyblue";
    }
    this.selectedByMouse = true;
  }

  unSelectElementByMouse() {
    if (this.selectedByMouse && this.element !== null) {
      this.element.style.backgroundColor = "";
    }
    this.selectedByMouse = false;
  }

  unSelectMouseRecursive() {
    this.unSelectElementByMouse();
    for (let i = 0; i < this.children.length; i++) {
      if (this.children[i] === null) {
        continue;
      }
      this.children[i].unSelectMouseRecursive();
    }
  }

  focusElement() {
    this.element.style.background = "#f0f0f0";
    this.focused = true;
    this.equationEditor.hasFocusDOM = true;
  }

  /**@returns {MathNode} */
  beefUpToHorizontalParent() {
    let parentWithIndex = this.findHorizontalMathParent();
    if (parentWithIndex.parent === null) {
      return this;
    }
    return parentWithIndex.parent.children[parentWithIndex.indexInParent];
  }

  blurElement() {
    this.focused = false;
    if (this.element === null) {
      return;
    }
    this.element.style.background = "";
  }

  blurRecursive() {
    this.blurElement();
    for (let i = 0; i < this.children.length; i++) {
      this.children[i].blurRecursive();
    }
  }

  updateDOM() {
    this.updateDOMRecursive(0);
    this.equationEditor.updateAlignment();
  }

  /** @returns {number} 
   * Returns the length of the content of an atom.
   * Returns -1 if the element is not an atom. 
   */
  lengthContentIfAtom() {
    if (!this.isAtomEditable()) {
      return - 1;
    }
    if (this.element === null) {
      return this.initialContent.length;
    }
    if (this.element.textContent === null) {
      return this.initialContent.length;
    }
    return this.element.textContent.length;
  }

  contentIfAtom() {
    if (!this.isAtomEditable()) {
      return "";
    }
    return this.textContentOrInitialContent();
  }

  /** @returns {string} */
  textContentOrInitialContent() {
    if (this.element === null) {
      if (this.initialContent === null) {
        console.log("Unexpected: initial content is null.");
        return "[null]";
      }
      return this.initialContent;
    }
    let result = this.element.textContent;
    if (result === null) {
      return "";
    }
    return result;
  }

  /** @returns {string} */
  contentIfAtomic() {
    if (!this.isAtomic()) {
      return "";
    }
    return this.textContentOrInitialContent();
  }

  /** @returns {boolean} */
  isAtomic() {
    return (
      this.type.type === knownTypes.atom.type ||
      this.type.type === knownTypes.atomImmutable.type ||
      this.type.type === knownTypes.sqrtSign.type
    );
  }

  /** @returns {boolean} */
  isDelimiter() {
    return (
      this.type.type === knownTypes.leftDelimiter.type ||
      this.type.type === knownTypes.rightDelimiter.type
    );
  }

  /** @returns {boolean} */
  isAtomEditable() {
    return this.type.type === knownTypes.atom.type;
  }

  /**@returns {boolean} */
  hasHorozintalMathParent() {
    if (this.parent === null) {
      return false;
    }
    return this.parent.type.type === knownTypes.horizontalMath.type;
  }

  updateDOMRecursive(
    /** @type {number} */
    depth,
  ) {
    if (
      this.type.type === knownTypes.atom.type
    ) {
      this.createDOMElementIfMissing();
      return;
    }
    for (let i = 0; i < this.children.length; i++) {
      let child = this.children[i];
      child.updateDOMRecursive(depth + 1);
    }
    const oldElement = this.element;
    this.element = null;
    this.createDOMElementIfMissing();
    if (this.implied) {
      this.element.style.color = this.type.colorImplied;
      this.element.style.borderColor = this.type.colorImplied;
    } else {
      this.element.style.color = this.type.colorText;
      this.element.style.borderColor = this.type.colorText;
    }
    for (let i = 0; i < this.children.length; i++) {
      this.element.appendChild(this.children[i].element);
    }
    if (depth === 0) {
      this.updateParentDOM(oldElement);
    }
  }

  computeBoundingBox() {
    for (let i = 0; i < this.children.length; i++) {
      let child = this.children[i];
      child.computeBoundingBox();
    }
    this.computeDimensions();
  }

  computeDimensionsDelimiter() {
    let boundingRecangleDOM = this.element.getBoundingClientRect();
    this.boundingBox.width = boundingRecangleDOM.width;
  }

  computeDimensionsAtomicNoTransform() {
    if (this.boundingBox.widthBeforeTransform >= 0) {
      return;
    }
    this.element.style.transformOrigin = "top left";
    this.element.style.transform = "";
    this.element.style.width = "";
    this.element.style.height = "";
    this.element.style.top = "";
    this.element.style.left = "";
    this.computeDimensionsAtomic();
    this.boundingBox.heightBeforeTransform = this.boundingBox.height;
    this.boundingBox.widthBeforeTransform = this.boundingBox.width;
  }

  computeDimensionsAtomic() {
    let boundingRecangleDOM = this.element.getBoundingClientRect();
    this.boundingBox.width = boundingRecangleDOM.width;
    this.boundingBox.height = boundingRecangleDOM.height;
    if (this.boundingBox.height === 0) {
      this.boundingBox.height = this.equationEditor.standardAtomHeight;
    }
    this.boundingBox.fractionLineHeight = this.boundingBox.height / 2;
  }

  computeDimensionsHorizontalBrace(
    /**@type{number} */
    desiredWidth,
  ) {
    this.boundingBox.width = desiredWidth;
    const topLeft = this.children[0];
    const leftStraight = this.children[1];
    const bottomRight = this.children[2];
    const bottomLeft = this.children[3];
    const rightStraight = this.children[4];
    const topRight = this.children[5];
    const desiredRadius = Math.max(4, Math.floor(desiredWidth * 0.02));
    const desiredHeight = desiredRadius;

    const radiusString = `${desiredRadius}px`;
    const borderString = `2px solid`;

    topLeft.element.style.borderTopLeftRadius = radiusString;
    topLeft.element.style.borderTop = borderString;
    topRight.element.style.borderTopRightRadius = radiusString;
    topRight.element.style.borderTop = borderString;
    bottomLeft.element.style.borderBottomLeftRadius = radiusString;
    bottomLeft.element.style.borderBottom = borderString;
    bottomRight.element.style.borderBottomRightRadius = radiusString;
    bottomRight.element.style.borderBottom = borderString;

    const halfWidth = desiredWidth / 2;

    topLeft.boundingBox.width = desiredRadius;
    topRight.boundingBox.width = desiredRadius;
    bottomRight.boundingBox.width = desiredRadius;
    bottomLeft.boundingBox.width = desiredRadius;

    topLeft.boundingBox.height = desiredHeight;
    topRight.boundingBox.height = desiredHeight;
    bottomRight.boundingBox.height = desiredHeight;
    bottomLeft.boundingBox.height = desiredHeight;

    topLeft.boundingBox.top = desiredHeight;
    topRight.boundingBox.top = desiredHeight;

    bottomRight.boundingBox.left = halfWidth - desiredRadius;
    bottomLeft.boundingBox.left = halfWidth;
    topRight.boundingBox.left = desiredWidth - desiredRadius;

    leftStraight.boundingBox.width = halfWidth - 2 * desiredRadius;
    leftStraight.boundingBox.left = desiredRadius;
    rightStraight.boundingBox.width = halfWidth - 2 * desiredRadius;
    rightStraight.boundingBox.left = halfWidth + desiredRadius;

    leftStraight.boundingBox.height = desiredHeight;
    rightStraight.boundingBox.height = desiredHeight;
    this.boundingBox.height = desiredHeight + 2;
  }

  computeDimensionsOverLine() {
    this.computeDimensionsStandard();
    // The border add 1 extra pixel of height.
    this.boundingBox.fractionLineHeight = this.children[0].boundingBox.fractionLineHeight + 1;
  }

  computeDimensionsOverBrace() {
    let base = this.children[0];
    let brace = this.children[1];
    let superscript = this.children[2];
    brace.computeDimensionsHorizontalBrace(base.boundingBox.width);
    superscript.boundingBox.width = base.boundingBox.width;
    superscript.computeBoundingBoxLeftSingleChild();
    this.boundingBox.width = base.boundingBox.width;
    this.boundingBox.height = base.boundingBox.height + brace.boundingBox.height + superscript.boundingBox.height;
    this.boundingBox.fractionLineHeight = brace.boundingBox.height + superscript.boundingBox.height + base.boundingBox.fractionLineHeight;
    brace.boundingBox.top = superscript.boundingBox.height;
    base.boundingBox.top = superscript.boundingBox.height + brace.boundingBox.height;
  }

  computeDimensionsFraction() {
    let numerator = this.children[0];
    let denominator = this.children[1];
    let extraSpaceBetweenNumeratorAndDenominator = 3;
    this.boundingBox.fractionLineHeight = numerator.boundingBox.height + 1;
    this.boundingBox.height = numerator.boundingBox.height + denominator.boundingBox.height + extraSpaceBetweenNumeratorAndDenominator;
    this.boundingBox.width = Math.max(numerator.boundingBox.width, denominator.boundingBox.width) + 4;
    this.boundingBox.needsMiddleAlignment = true;
    numerator.boundingBox.width = this.boundingBox.width;
    denominator.boundingBox.width = this.boundingBox.width;
    denominator.boundingBox.top = numerator.boundingBox.height + extraSpaceBetweenNumeratorAndDenominator;
    numerator.computeBoundingBoxLeftSingleChild();
    denominator.computeBoundingBoxLeftSingleChild();
  }

  computeDimensionsOperatorStandalone() {
    let child = this.children[0];
    // see latexConstants.operatorWithSuperAndSubscript
    let operatorShifts = {
      // sum
      "\u03A3": 0.22,
      // integral
      "\u222B": 0.03,
    };
    let operatorScales = {
      // sum
      "\u03A3": 2,
      // integral
      "\u222B": 2,
    };
    let proportionShiftUp = 0.1;
    let operatorName = child.initialContent;
    if (operatorName in operatorShifts) {
      proportionShiftUp = operatorShifts[operatorName];
    }
    let operatorScale = 1;
    if (operatorName in operatorScales) {
      operatorScale = operatorScales[operatorName];
    }
    child.boundingBox.top = - child.boundingBox.height * proportionShiftUp;
    this.boundingBox.height = child.boundingBox.height * (1 - proportionShiftUp * operatorScale);
    this.boundingBox.width = child.boundingBox.width;
    this.boundingBox.fractionLineHeight = this.boundingBox.height / 2;
  }

  computeDimensionsOperatorWithSuperAndSubscript() {
    let superscript = this.children[0];
    let operator = this.children[1];
    let subscript = this.children[2];
    let extraSpaceBelowSuperscriptPercent = 0.1;
    let extraSpaceBelowOperatorPercent = 0.1;
    let operatorContent = operator.children[0].initialContent;
    let extraSpaceBelowOperatorCustom = {
      // integral
      "\u222B": - 0.1,
    };
    if (operatorContent in extraSpaceBelowOperatorCustom) {
      extraSpaceBelowOperatorPercent = extraSpaceBelowOperatorCustom[operatorContent];
    }
    let extraSpaceBelowSuperscript = operator.boundingBox.height * extraSpaceBelowSuperscriptPercent;
    let extraSpaceBelowOperator = operator.boundingBox.height * extraSpaceBelowOperatorPercent;
    superscript.boundingBox.top = 0;
    operator.boundingBox.top = superscript.boundingBox.height + extraSpaceBelowSuperscript;
    subscript.boundingBox.top = superscript.boundingBox.height + extraSpaceBelowSuperscript + operator.boundingBox.height + extraSpaceBelowOperator;
    this.boundingBox.height =
      superscript.boundingBox.height + operator.boundingBox.height + subscript.boundingBox.height +
      extraSpaceBelowOperator + extraSpaceBelowSuperscript;
    this.boundingBox.width = Math.max(superscript.boundingBox.width, operator.boundingBox.width, subscript.boundingBox.width);
    this.boundingBox.fractionLineHeight = superscript.boundingBox.height + extraSpaceBelowSuperscript + operator.boundingBox.fractionLineHeight;
    this.boundingBox.needsMiddleAlignment = true;
    superscript.boundingBox.width = this.boundingBox.width;
    subscript.boundingBox.width = this.boundingBox.width;
    operator.boundingBox.width = this.boundingBox.width;
    superscript.computeBoundingBoxLeftSingleChild();
    operator.computeBoundingBoxLeftSingleChild();
    subscript.computeBoundingBoxLeftSingleChild();
  }

  computeDimensionsOperatorWithSubscript() {
    let operator = this.children[0];
    let subscript = this.children[1];
    let extraSpaceBelowOperatorPercent = 0.1;
    let extraSpaceBelowOperator = operator.boundingBox.height * extraSpaceBelowOperatorPercent;
    operator.boundingBox.top = 0;
    subscript.boundingBox.top = operator.boundingBox.height + extraSpaceBelowOperator;
    this.boundingBox.height = operator.boundingBox.height + extraSpaceBelowOperator + subscript.boundingBox.height;
    this.boundingBox.width = Math.max(operator.boundingBox.width, subscript.boundingBox.width);
    this.boundingBox.fractionLineHeight = operator.boundingBox.fractionLineHeight;
    this.boundingBox.needsMiddleAlignment = true;
    subscript.boundingBox.width = this.boundingBox.width;
    operator.boundingBox.width = this.boundingBox.width;
    operator.computeBoundingBoxLeftSingleChild();
    subscript.computeBoundingBoxLeftSingleChild();
  }

  containsFractionLineRecursive() {
    if (this.type.type === knownTypes.fraction.type) {
      return true;
    }
    for (let i = 0; i < this.children.length; i++) {
      if (this.children[i].containsFractionLineRecursive()) {
        return true;
      }
    }
    return false;
  }

  requiresTallExponent(
    /**@type{MathNode} */
    base,
  ) {
    if (base.type.type !== knownTypes.horizontalMath.type) {
      return false;
    }
    for (let i = base.children.length - 1; i >= 0; i--) {
      let child = base.children[i];
      if (child.type.type === knownTypes.matrix.type) {
        return true;
      }
      if (child.type.type === knownTypes.rightDelimiter.type) {
        return base.containsFractionLineRecursive();
      }
      if (child.type.type === knownTypes.atom.type) {
        if (child.textContentOrInitialContent() === "") {
          continue;
        }
      }
      return false;
    }
    return false;
  }

  computeDimensionsBaseWithSubscript() {
    let base = this.children[0];
    let subscript = this.children[1];
    let overlapRatio = 0.35;
    if (this.requiresTallExponent(base)) {
      overlapRatio = 0.1;
    }
    let overlap = base.boundingBox.height * overlapRatio;
    this.boundingBox.height = subscript.boundingBox.height + base.boundingBox.height - overlap;
    if (subscript.boundingBox.height > this.boundingBox.height) {
      this.boundingBox.height = subscript.boundingBox.height;
    }
    let baseWithExponent = null;
    if (base.type.type === knownTypes.horizontalMath.type) {
      if (base.children.length === 1) {
        if (base.children[0].type.type === knownTypes.baseWithExponent.type) {
          baseWithExponent = base.children[0];
        }
      }
    }
    base.boundingBox.left = 0;
    this.boundingBox.width = base.boundingBox.width + subscript.boundingBox.width;
    subscript.boundingBox.top = base.boundingBox.height * (1 - overlapRatio);
    if (baseWithExponent === null) {
      subscript.boundingBox.left = base.boundingBox.width;
      this.boundingBox.subScriptWidth = subscript.boundingBox.width;
    } else {
      subscript.boundingBox.left = base.boundingBox.width - baseWithExponent.boundingBox.superScriptWidth;
      this.boundingBox.superScriptWidth = 0;
      this.boundingBox.subScriptWidth = 0;
      this.boundingBox.width = Math.max(
        baseWithExponent.boundingBox.width +
        subscript.boundingBox.width -
        baseWithExponent.boundingBox.superScriptWidth,
        baseWithExponent.boundingBox.width,
      );
    }
    this.boundingBox.fractionLineHeight = base.boundingBox.fractionLineHeight;
    this.boundingBox.needsMiddleAlignment = true;
  }

  computeBoundingBoxLeftSingleChild() {
    let child = this.children[0];
    child.boundingBox.left = (this.boundingBox.width - child.boundingBox.width) / 2;
  }

  verticallyStretchParenthesis(
    /** @type {number}*/
    heightToEnclose,
    /** @type {number}*/
    fractionLineHeightEnclosed,
  ) {
    if (this.children.length === 0) {
      // Unbalanced parenthesis: the "missing delimiter" is there but has
      // no delimiter mark.
      return;
    }
    let child = this.children[0];
    child.verticallyStretch(heightToEnclose, fractionLineHeightEnclosed);

    this.boundingBox.top = 0;
    this.boundingBox.height = child.boundingBox.height;
    this.boundingBox.fractionLineHeight = child.boundingBox.fractionLineHeight;
    this.boundingBox.width = child.boundingBox.width;
  }

  computeDimensionsNumerator() {
    this.computeDimensionsStandard();
    this.boundingBox.height = this.children[0].boundingBox.height;
  }

  verticallyStretchSqrt(
    /** @type {number}*/
    heightToEnclose,
  ) {
    let decoration = this.children[0];
    let left = this.children[1];
    let right = this.children[2];
    let heightRatioRight = 0.5;
    let heightToWidthRatio = 0.1;
    let maxWidthHalfCheck = 10;
    let preferredWidth = heightToEnclose * heightToWidthRatio;

    decoration.boundingBox.width = 3;
    decoration.boundingBox.height = 1;
    decoration.boundingBox.top = heightToEnclose * (1 - heightRatioRight);
    if (preferredWidth > maxWidthHalfCheck) {
      preferredWidth = maxWidthHalfCheck;
    }

    left.boundingBox.height = heightToEnclose * heightRatioRight;
    left.boundingBox.width = preferredWidth;
    left.boundingBox.top = heightToEnclose * (1 - heightRatioRight);
    left.boundingBox.left = decoration.boundingBox.width - 1;

    right.boundingBox.height = heightToEnclose;
    right.boundingBox.width = 1;
    right.boundingBox.left = left.boundingBox.left + preferredWidth;
    right.boundingBox.top = 0;

    left.boundingBox.transformOrigin = "top left";
    right.boundingBox.transformOrigin = "top left";
    let leftSkew = left.boundingBox.width / left.boundingBox.height;
    left.boundingBox.transform = `matrix(1,0,${leftSkew},1,0,0)`;
    let rightSkew = preferredWidth / right.boundingBox.height;
    right.boundingBox.transform = `matrix(1,0,${-rightSkew},1,${preferredWidth},0)`;
    this.boundingBox.height = heightToEnclose;
    this.boundingBox.width = left.boundingBox.width + preferredWidth + decoration.boundingBox.width;
  }

  computeDimensionsSqrt() {
    let radicalExponentBox = this.children[0];
    let sqrtSign = this.children[1];
    let underTheRadical = this.children[2];
    // The proportion of the width of the sqrt sign that overlaps with the radical exponent.
    let sqrtProportionOverlapped = 0.85;
    let extraWidth = Math.max(0, radicalExponentBox.boundingBox.width - sqrtSign.boundingBox.width * sqrtProportionOverlapped);
    // The top of the sqrt sign may not connect perfectly with the overline of the under-the-radical content.
    // The following variable compensates for that.
    sqrtSign.verticallyStretchSqrt(underTheRadical.boundingBox.height);
    radicalExponentBox.boundingBox.top = - 0.15 * radicalExponentBox.boundingBox.height;
    let widthSqrtSign = 0.99;// 0.92;
    sqrtSign.boundingBox.left = extraWidth;
    underTheRadical.boundingBox.left = sqrtSign.boundingBox.left + sqrtSign.boundingBox.width * widthSqrtSign;
    this.boundingBox = new BoundingBox();
    this.boundingBox.height = underTheRadical.boundingBox.height * 1.15;
    this.boundingBox.fractionLineHeight = underTheRadical.boundingBox.fractionLineHeight + 2.2;
    let extraSpaceAfterRadical = 4;
    this.boundingBox.width = underTheRadical.boundingBox.left + underTheRadical.boundingBox.width + extraSpaceAfterRadical;
    this.boundingBox.needsMiddleAlignment = underTheRadical.boundingBox.needsMiddleAlignment;
  }

  computeDimensionsMatrix() {
    this.boundingBox.height = this.children[0].boundingBox.height;
    this.boundingBox.width = this.children[0].boundingBox.width;
    this.boundingBox.fractionLineHeight = this.children[0].boundingBox.fractionLineHeight;
    this.boundingBox.needsMiddleAlignment = true;
    let table = this.children[0].children[1];
    for (let i = 1; i < this.children.length; i++) {
      let verticalBar = this.children[i];
      verticalBar.boundingBox.height = this.boundingBox.height;
      verticalBar.boundingBox.width = 1;
      let columnIndex = verticalBar.extraData.columnIndex;
      let offset = table.boundingBox.getColumnOffset(columnIndex);
      verticalBar.boundingBox.left = offset;
    }
  }

  computeDimensionsMatrixTable() {
    this.boundingBox = new BoundingBox();
    let numberOfColumns = this.children[0].children.length;
    let numberOfRows = this.children.length;
    let left = 0;
    let betweenColumns = 10;
    for (let i = 0; i < numberOfColumns; i++) {
      this.boundingBox.columnOffsets.push(left);
      let width = 0;
      for (let j = 0; j < numberOfRows; j++) {
        width = Math.max(width, this.children[j].children[i].boundingBox.width);
      }
      for (let j = 0; j < numberOfRows; j++) {
        let child = this.children[j].children[i];
        let extraShift = (width - child.boundingBox.width) / 2;
        if (child.latexExtraStyle === "l") {
          extraShift = 0;
        } else if (child.latexExtraStyle === "r") {
          extraShift = width - child.boundingBox.width;
        }
        child.boundingBox.left = left + extraShift;
        child.computeBoundingBoxLeftSingleChild();
      }
      left += width + betweenColumns;
    }
    let rowWidth = left - betweenColumns;
    let top = 0;
    let betweenRows = 10;
    for (let i = 0; i < numberOfRows; i++) {
      let row = this.children[i];
      row.mergeBoundingBoxesHorizontallyAlignedElements();
      row.boundingBox.top = top;
      top += row.boundingBox.height + betweenRows;
    }
    this.boundingBox.height = top - betweenRows;
    this.boundingBox.width = rowWidth;
    this.boundingBox.fractionLineHeight = this.boundingBox.height / 2;
  }

  computeDimensionsRadicalUnderBox() {
    this.computeDimensionsStandard();
    let child = this.children[0];
    this.boundingBox.height = child.boundingBox.height + 1;
    this.boundingBox.fractionLineHeight = child.boundingBox.fractionLineHeight + 1;
  }

  computeDimensions() {
    if (this.isAtomic()) {
      this.computeDimensionsAtomic();
      return;
    }
    if (this.isDelimiter()) {
      this.computeDimensionsDelimiter();
      return;
    }
    if (this.type.type === knownTypes.error.type) {
      this.computeDimensionsAtomic();
      return;
    }
    if (this.type.type === knownTypes.sqrt.type) {
      this.computeDimensionsSqrt();
      return;
    }
    if (this.type.type === knownTypes.sqrtSign.type) {
      this.computeDimensionsSqrtSign();
      return;
    }
    if (this.type.type === knownTypes.matrixRow.type) {
      return;
    }
    if (this.type.type === knownTypes.matrixTable.type) {
      this.computeDimensionsMatrixTable();
      return;
    }
    if (this.type.type === knownTypes.matrix.type) {
      this.computeDimensionsMatrix();
      return;
    }
    if (this.type.type === knownTypes.radicalUnderBox.type) {
      this.computeDimensionsRadicalUnderBox();
      return;
    }
    if (this.type.type === knownTypes.fraction.type) {
      this.computeDimensionsFraction();
      return;
    }
    if (this.type.type === knownTypes.operatorWithSuperAndSubscript.type) {
      this.computeDimensionsOperatorWithSuperAndSubscript();
      return;
    }
    if (this.type.type === knownTypes.operatorWithSubscript.type) {
      this.computeDimensionsOperatorWithSubscript();
      return;
    }
    if (this.type.type === knownTypes.operatorStandalone.type) {
      this.computeDimensionsOperatorStandalone();
      return;
    }
    if (this.type.type === knownTypes.numerator.type) {
      this.computeDimensionsNumerator();
    }
    if (this.type.type === knownTypes.baseWithSubscript.type) {
      this.computeDimensionsBaseWithSubscript();
      return;
    }
    if (this.type.type === knownTypes.overBrace.type) {
      this.computeDimensionsOverBrace();
      return;
    }
    if (this.type.type === knownTypes.overLinedBox.type) {
      this.computeDimensionsOverLine();
      return;
    }
    if (this.type.type === knownTypes.horizontalMath.type) {
      this.computeDimensionsHorizontalMath();
      return;
    }
    this.computeDimensionsStandard();
  }

  computeDimensionsStandard() {
    this.computeDimensionsHorizontalMath();
  }

  computeDimensionsHorizontalMathParenthesesHeight() {
    // Compute parentheses height
    /** @type {number[]} */
    let enclosedHeights = [];
    let enclosedFractionLineHeights = [];
    /** @type {number[]} */
    let indicesOpenedParentheses = [];
    for (let i = 0; i < this.children.length; i++) {
      this.computeDimensionsHorizontalMathParenthesesAccountChild(
        i, enclosedHeights, enclosedFractionLineHeights, indicesOpenedParentheses,
      );
    }
  }

  computeDimensionsHorizontalMathParenthesesAccountChild(
    /** @type {number} */
    index,
    /** @type {number[]} */
    enclosedHeights,
    /** @type {number[]} */
    enclosedFractionLineHeights,
    /** @type {number[]} */
    indicesOpenedParentheses,
  ) {
    let child = this.children[index];
    if (child.type.type === knownTypes.leftDelimiter.type) {
      enclosedHeights.push(0);
      enclosedFractionLineHeights.push(0);
      indicesOpenedParentheses.push(index);
      return;
    }
    if (child.type.type === knownTypes.rightDelimiter.type) {
      if (enclosedHeights.length <= 0) {
        console.log("Warning: unbalanced right parenthesis.");
        return;
      }
      let currentHeight = enclosedHeights.pop();
      let currentFractionLineHeight = enclosedFractionLineHeights.pop();
      child.verticallyStretchParenthesis(currentHeight, currentFractionLineHeight);
      let leftCounterpart = this.children[indicesOpenedParentheses.pop()];
      leftCounterpart.verticallyStretchParenthesis(currentHeight, currentFractionLineHeight);
    }
    if (enclosedHeights.length > 0) {
      enclosedHeights[enclosedHeights.length - 1] = Math.max(
        child.boundingBox.height, enclosedHeights[enclosedHeights.length - 1]
      );
      enclosedFractionLineHeights[enclosedFractionLineHeights.length - 1] = Math.max(
        child.boundingBox.fractionLineHeight,
        enclosedFractionLineHeights[enclosedFractionLineHeights.length - 1]
      );
    }
  }

  mergeBoundingBoxesHorizontallyAlignedElements() {
    // Compute fraction line height.
    for (let i = 0; i < this.children.length; i++) {
      let child = this.children[i];
      this.boundingBox.fractionLineHeight = Math.max(
        this.boundingBox.fractionLineHeight,
        child.boundingBox.fractionLineHeight,
      );
    }
    // Compute top offsets of children.
    for (let i = 0; i < this.children.length; i++) {
      let child = this.children[i];
      child.boundingBox.top = this.boundingBox.fractionLineHeight - child.boundingBox.fractionLineHeight;
    }
    // Compute present element height.
    for (let i = 0; i < this.children.length; i++) {
      let child = this.children[i];
      let heightFromChild = child.boundingBox.height - child.boundingBox.fractionLineHeight + this.boundingBox.fractionLineHeight;
      this.boundingBox.height = Math.max(this.boundingBox.height, heightFromChild);
    }
  }

  computeDimensionsHorizontalMath() {
    this.boundingBox = new BoundingBox();
    this.computeDimensionsHorizontalMathParenthesesHeight();
    for (let i = 0; i < this.children.length; i++) {
      let child = this.children[i];
      child.boundingBox.left = this.boundingBox.width;
      this.boundingBox.width += child.boundingBox.width;
    }
    this.mergeBoundingBoxesHorizontallyAlignedElements();
    this.computeMiddleAlignment();
  }

  computeMiddleAlignment() {
    for (let i = 0; i < this.children.length; i++) {
      let child = this.children[i];
      if (child.boundingBox.needsMiddleAlignment) {
        this.boundingBox.needsMiddleAlignment = true;
        return;
      }
    }
  }

  doAlign() {
    if (this.boundingBox.transform !== "") {
      this.element.style.transformOrigin = this.boundingBox.transformOrigin;
      this.element.style.transform = this.boundingBox.transform;
    } //else {
    if (this.element.style.width !== "auto") {
      this.element.style.width = this.boundingBox.width;
    }
    if (this.element.style.height !== "auto") {
      this.element.style.height = this.boundingBox.height;
    }
    //    }
    this.element.style.left = this.boundingBox.left;
    this.element.style.top = this.boundingBox.top;
    for (let i = 0; i < this.children.length; i++) {
      this.children[i].doAlign();
    }
  }

  updateParentDOM(
    /** @type {HTMLElement|null} */
    oldElement,
  ) {
    let parentElement = null;
    if (this.type.type === knownTypes.root.type) {
      parentElement = this.equationEditor.container;
    } else {
      if (oldElement !== null) {
        parentElement = oldElement.parentElement;
      }
    }
    if (parentElement === null) {
      return;
    }
    if (parentElement.contains(oldElement)) {
      parentElement.replaceChild(this.element, oldElement);
    } else {
      parentElement.appendChild(this.element);
    }
  }

  handleFocus(_) {
    this.focusElement();
    this.storeCaretPosition("", false);
  }

  handleBlur(_) {
    this.blurElement();
    this.equationEditor.blur();
  }

  handleKeyDown(
    /** @type {KeyboardEvent} */
    event,
  ) {
    if (event.key === "Shift" || event.key === "Ctrl") {
      event.stopPropagation();
      return;
    }
    this.storeCaretPosition(event.key, event.shiftKey);
    this.handleKeyDownDontComputeCaretPosition(event);
  }

  handleKeyDownDontComputeCaretPosition(
    /** @type {KeyboardEvent} */
    event,
  ) {
    let frameStart = new Date().getTime();
    event.stopPropagation();
    let handlerResult = this.handleKeyDownCases(event);
    if (handlerResult.preventDefault) {
      event.preventDefault();
      this.equationEditor.accountFrameTime(frameStart);
    }
    if (
      handlerResult.updateAlignment &&
      this.type.type === knownTypes.atom.type &&
      this.element !== null &&
      !this.equationEditor.resizingEditorFont
    ) {
      // The content is not yet written to our editable field: 
      // that will happen once the event default is carried out.
      // This means that we cannot compute the width of our atom accurately now,
      // but will be able to do in the body of the setTimeout'ed function below.
      // This is a problem as the screen may be redrawn between the 
      // time the event default is called and the time we call 
      // equationEditor.updateAlignment in the timeout below, in which case the extra 
      // content will overflow its container box.
    }
    // While we no longer propagate the event, we need to 
    // release the thread so the browser can finish computations
    // with the released element. 
    setTimeout(() => {
      this.equationEditor.storeSelection();
      if (handlerResult.updateAlignment) {
        this.storeCaretPosition(event.key, event.shiftKey);
        this.element.style.maxWidth = "";
        this.element.style.maxHeight = "";
        this.equationEditor.updateAlignment();
        this.equationEditor.accountFrameTime(frameStart);
      }
      this.equationEditor.writeLatexToInput(true);
      this.equationEditor.writeDebugInfo(null);
      if (this.equationEditor.options.editHandler !== null) {
        this.equationEditor.options.editHandler(this.equationEditor, this);
      }
    }, 0);
  }

  handleKeyUp(
    /** @type {KeyboardEvent} */
    event,
  ) {
    if (!event.shiftKey && event.key !== "Shift") {
      this.equationEditor.selectionStart = new MathNodeWithCaretPosition(null, - 1);
      this.equationEditor.selectionEnd = new MathNodeWithCaretPosition(null, - 1);
    }
  }

  /** @returns {BackslashResult} */
  processBackslash(
    /** @type {string} */
    key,
    /** @type{boolean} */
    shiftHeld,
  ) {
    let result = new BackslashResult(false, key);
    if (key === "Shift") {
      return result;
    }
    if (this.type.type !== knownTypes.atom.type) {
      return result;
    }
    if (key === "\\" && !shiftHeld) {
      this.equationEditor.backslashSequenceStarted = true;
      this.equationEditor.backslashSequence = "\\";
      this.equationEditor.backslashPosition = this.positionCaretBeforeKeyEvents;
      result.keyAccountedCarryOutDefaultEvent = true;
      return result;
    }
    if (!this.equationEditor.backslashSequenceStarted) {
      return result;
    }
    if (key === " " && this.equationEditor.backslashSequenceStarted) {
      this.equationEditor.backslashSequenceStarted = false;
      if (this.equationEditor.backslashSequence in latexConstants.recognizedCommandsKeyInput) {
        return this.removeBackslashSequence();
      }
      return result;
    }
    if (latexConstants.isLatinCharacter(key)) {
      this.equationEditor.backslashSequence += key;
      result.keyAccountedCarryOutDefaultEvent = true;
      return result;
    }
    if (key === "Backspace") {
      if (this.equationEditor.backslashSequence === "\\") {
        this.equationEditor.backslashSequenceStarted = false;
      } else {
        this.equationEditor.backslashSequence = this.equationEditor.backslashSequence.slice(
          0, this.equationEditor.backslashSequence.length - 1,
        );
      }
      result.keyAccountedCarryOutDefaultEvent = true;
      return result;
    }
    this.equationEditor.backslashSequenceStarted = false;
    return result;
  }

  pasteFromClipboard(event) {
    event.preventDefault();
    let data = event.clipboardData.getData('text');
    event.preventDefault();
    this.storeCaretPosition("", false);
    this.writeLatex(data);
  }

  writeLatex(
    /** @type {string} */
    data,
  ) {
    if (this.type.type !== knownTypes.atom.type) {
      return;
    }
    let parser = new LaTeXParser(this.equationEditor, data);
    let newContent = parser.parse();
    if (newContent === null) {
      let content = this.textContentOrInitialContent();
      let leftSlice = content.slice(0, this.positionCaretBeforeKeyEvents);
      let rightSlice = content.slice(this.positionCaretBeforeKeyEvents);
      let endContent = leftSlice + data + rightSlice;
      this.element.textContent = endContent;
      this.desiredCaretPosition = this.positionCaretBeforeKeyEvents + data.length;
      this.updateDOM();
      this.equationEditor.updateAlignment();
      this.focusRestore();
      return;
    }
    let split = this.splitByCaretEmptyAtoms();
    /**@type {MathNode} */
    let newRightMostAtom = newContent.rightmostAtomChild();
    if (newRightMostAtom === null) {
      split[1].desiredCaretPosition = 0;
    } else {
      newRightMostAtom.desiredCaretPosition = newRightMostAtom.textContentOrInitialContent().length;
    }
    let horizontalContent = mathNodeFactory.horizontalMathFromArray(this.equationEditor, [split[0], newContent, split[1]]);
    horizontalContent.normalizeHorizontalMath();
    let parent = this.parent;
    parent.replaceChildAtPosition(this.indexInParent, horizontalContent);
    parent.normalizeHorizontalMath();
    parent.updateDOM();
    this.equationEditor.updateAlignment();
    parent.focusRestore();
  }

  insertString(
    /**@type{string} */
    input,
  ) {
    let split = this.splitByCaret();
    let atomNode = mathNodeFactory.atom(this.equationEditor, input);
    atomNode.desiredCaretPosition = input.length;
    let node = mathNodeFactory.horizontalMathFromArray(this.equationEditor, [split[0], atomNode, split[1]]);
    node.normalizeHorizontalMath();
    let parent = this.parent;
    parent.replaceChildAtPosition(this.indexInParent, node);
    parent.normalizeHorizontalMath();
    parent.updateDOM();
    parent.focusRestore();
    return true;
  }

  /** @returns {KeyHandlerResult} whether default should be prevented. */
  handleKeyDownCases(
    /** @type {KeyboardEvent} */
    e,
  ) {
    let key = e.key;
    if (e.ctrlKey) {
      return this.equationEditor.handleControlKeys(e);
    }
    let shiftHeld = e.shiftKey;
    let backslashPreprocessing = this.processBackslash(key, shiftHeld);
    if (backslashPreprocessing.keyAccountedCarryOutDefaultEvent) {
      return new KeyHandlerResult(false, true);
    }
    let command = backslashPreprocessing.command;

    if (command in latexConstants.operatorWithSuperAndSubscriptBackslashed) {
      let operator = latexConstants.operatorWithSuperAndSubscriptBackslashed[command];
      this.makeOperatorWithSuperscriptAndSubscript(operator);
      return new KeyHandlerResult(true, false);
    }
    if (command in latexConstants.operatorsWithSubscriptBackslashed) {
      let operator = latexConstants.operatorsWithSubscriptBackslashed[command];
      this.makeOperatorWithSubscript(operator);
      return new KeyHandlerResult(true, false);
    }
    if (command in latexConstants.latexBackslashOperatorsBackslashed) {
      let operator = latexConstants.latexBackslashOperatorsBackslashed[command];
      this.makeHorizontalOperator(operator);
      return new KeyHandlerResult(true, false);
    }
    if (
      command in latexConstants.leftDelimiters &&
      !(command in latexConstants.delimitersAmbiguous)
    ) {
      this.makeDelimiterLeft(command);
      return new KeyHandlerResult(true, false);
    }
    if (
      command in latexConstants.rightDelimiters &&
      !(command in latexConstants.delimitersAmbiguous)
    ) {
      this.makeDelimiterRight(command);
      return new KeyHandlerResult(true, false);
    }
    if (command in latexConstants.latexBackslashAtomsEditableBackslashed) {
      let content = latexConstants.latexBackslashAtomsEditableBackslashed[command];
      this.insertString(content);
      return new KeyHandlerResult(true, false);
    }
    switch (backslashPreprocessing.command) {
      case "/":
        this.makeFractionNumerator();
        return new KeyHandlerResult(true, false);
      case "*":
      case "+":
      case "-":
      case "=":
      case ">":
      case "<":
        this.makeHorizontalOperatorCorrectInput(key);
        return new KeyHandlerResult(true, false);
      case "^":
        this.makeBaseWithExponent();
        return new KeyHandlerResult(true, false);
      case "_":
        this.makeBaseWithSubscript();
        return new KeyHandlerResult(true, false);
      case "ArrowLeft":
      case "ArrowRight":
      case "ArrowUp":
      case "ArrowDown":
        return this.arrow(key, shiftHeld);
      case "|":
        this.makeDelimiterAmbiguous(key);
        return new KeyHandlerResult(true, false);
      case "Enter":
        return new KeyHandlerResult(true, false);
      case "Delete":
        return this.deleteButton();
      case "Backspace":
        return this.backspace();
      case "{":
        this.makeDelimiterLeft("{");
        return new KeyHandlerResult(true, false);
      case "}":
        this.makeDelimiterRight("}");
        return new KeyHandlerResult(true, false);
      case "\\sqrt":
        this.makeSqrt();
        return new KeyHandlerResult(true, false);
      case "\\cancel":
        this.makeCancel();
        return new KeyHandlerResult(true, false);
      case "\\pmatrix":
      case "\\matrix":
        this.makeMatrix(2, 2);
        return new KeyHandlerResult(true, false);
      default:
        return new KeyHandlerResult(false, true);
    }
  }

  arrowRight(
    /** @type {string} */
    key,
    /** @type {boolean} */
    shiftHeld,
  ) {
    if (this.type.type !== knownTypes.atom.type) {
      this.arrow(key, shiftHeld);
      return;
    }
    if (this.isAtomWithRightmostCursor()) {
      this.arrow(key, shiftHeld);
      return;
    }
  }

  /** @returns{number[]} The path needed to get from the current node to the root node.*/
  getPathToRoot() {
    let reversed = [];
    let current = this;
    while (current !== null) {
      if (current.indexInParent !== -1) {
        reversed.push(current.indexInParent);
      }
      current = current.parent;
    }
    return reversed.reverse();
  }

  /** @returns {number[]|null} */
  commonPathToRoot(
    /**@type{MathNode} */
    other,
  ) {
    if (this.equationEditor !== other.equationEditor) {
      return null;
    }
    let thisPath = this.getPathToRoot();
    let otherPath = other.getPathToRoot();
    let result = [];
    for (let i = 0; i < thisPath.length; i++) {
      if (i >= otherPath.length) {
        return result;
      }
      if (thisPath[i] !== otherPath[i]) {
        return result;
      }
      result.push(thisPath[i]);
    }
    return result;
  }

  /** @returns{MathNode|null} returns the common ancestor of two nodes. */
  commonAncestor(
    /**@type{MathNode} */
    other,
  ) {
    if (this === other || other === null) {
      return this;
    }
    if (this.equationEditor !== other.equationEditor) {
      return null;
    }
    let commonPath = this.commonPathToRoot(other);
    return this.equationEditor.elementFromPath(commonPath);
  }

  /** @returns{ParentWithIndex} 
   * returns the common ancestor of two nodes 
   * with the index of the ancestor's child 
   * that contains this node.  
   */
  commonParent(
    /**@type{MathNode} */
    other,
  ) {
    let commonPath = this.commonPathToRoot(other);
    let thisPath = this.getPathToRoot();
    if (thisPath.length === commonPath.length) {
      // The other element was contained in this element.
      return new ParentWithIndex(this.parent, this.indexInParent);
    }
    return new ParentWithIndex(
      this.equationEditor.elementFromPath(commonPath),
      thisPath[commonPath.length],
    );
  }

  /** @returns{boolean} Given two atoms, elements whether this is to the left of the other atom. */
  isToTheLeftOf(
    /**@type{MathNode} */ other,
  ) {
    let thisPath = this.getPathToRoot();
    let otherPath = other.getPathToRoot();
    for (let i = 0; i < thisPath.length; i++) {
      if (i >= otherPath.length) {
        // The this element is contained in the other element.
        return false;
      }
      if (thisPath[i] < otherPath[i]) {
        return true;
      }
      if (thisPath[i] > otherPath[i]) {
        return false;
      }
    }
    // The two elements are equal.
    return false;
  }

  /** @returns{KeyHandlerResult} whether the default should be prevented. */
  arrow(
    /** @type {string} */
    key,
    /** @type {boolean} */
    shiftHeld,
  ) {
    if (shiftHeld) {
      return this.equationEditor.arrowShiftHeld(this, key);
    }
    this.equationEditor.resetSelectionLeaveRangesIntact();
    if (this.arrowAbsorbedByAtom(key)) {
      if (key === "ArrowLeft") {
        this.positionCaretBeforeKeyEvents--;
      } else {
        this.positionCaretBeforeKeyEvents++;
      }
      return new KeyHandlerResult(false, false);
    }
    /** @type {MathNodeWithCaretPosition} */
    const toFocus = this.getAtomToFocus(key);
    if (toFocus.element !== null) {
      toFocus.element.positionCaretBeforeKeyEvents = toFocus.element.element.textContent.length + 1;
      toFocus.element.focus(toFocus.position);
    }
    return new KeyHandlerResult(true, true);
  }

  arrowAbsorbedByAtom(
    /** @type {string} */
    key,
  ) {
    if (this.type.type !== knownTypes.atom.type) {
      return false;
    }
    if (key === "ArrowLeft") {
      return this.positionCaretBeforeKeyEvents !== 0;
    }
    if (key === "ArrowRight") {
      return this.positionCaretBeforeKeyEvents !== this.element.textContent.length;
    }
    return false;
  }

  /** @returns {MathNodeWithCaretPosition} */
  getAtomToFocus(/** @type {string} */ key) {
    return this.getAtomToFocusFromAction(key, this.type.arrows[key]);
  }

  /** @returns {MathNodeWithCaretPosition} */
  getAtomToFocusFromAction(
    /** @type {string} */ key,
    /** @type {string} */ arrowType,
  ) {
    if (arrowType === arrowMotion.parentForward) {
      if (this.parent === null) {
        return new MathNodeWithCaretPosition(null, - 1);
      }
      return this.parent.getAtomToFocus(key);
    }
    if (arrowType === arrowMotion.firstAtomToTheLeft) {
      return (new MathNodeWithCaretPosition(this, 0)).leftNeighbor();
    }
    if (arrowType === arrowMotion.firstAtomToTheRight) {
      return (new MathNodeWithCaretPosition(this, this.textContentOrInitialContent().length)).rightNeighbor();
    }
    return new MathNodeWithCaretPosition(null, - 1);
  }

  /** @returns{MathNode|null} returns sibling, right one if direction is positive, left one otherwise. */
  firstAtom(
    /**@type{number} */
    direction,
  ) {
    if (direction > 0) {
      return this.firstAtomToTheRight();
    } else {
      return this.firstAtomToTheLeft();
    }
  }

  /** @returns{MathNode|null} 
   * Returns first atom uncle to the left or right that is a child of a horizontal ancestor. 
   * Negative direction indicates we are looking for uncles to the left, 
   * else we are looking for uncles to the right of the this element.
   * */
  firstAtomSiblingOrUncle(
    /**@type{number} */
    direction,
  ) {
    if (direction < 0) {
      direction = -1;
    } else {
      direction = 1;
    }
    let current = this;
    while (true) {
      let horizontalAncestor = current.findHorizontalMathParent();
      if (horizontalAncestor.parent === null) {
        return null;
      }
      for (
        let nextIndex = horizontalAncestor.indexInParent + direction;
        nextIndex >= 0 && nextIndex < horizontalAncestor.parent.children.length;
        nextIndex += direction
      ) {
        let candidate = horizontalAncestor.parent.children[nextIndex];
        if (candidate.isAtomic()) {
          return candidate;
        }
      }
      current = horizontalAncestor.parent;
    }
  }

  // Returns first MathNode atom that lies to the right of 
  // the present element or null if there is no such element. 
  firstAtomToTheRight() {
    if (this.parent === null) {
      return null;
    }
    return this.parent.firstAtomToTheRightOf(this.indexInParent);
  }

  /** @returns{MathNode|null} */
  firstAtomToTheRightOf(
    /** @type{number}*/
    childIndex,
  ) {
    for (let i = childIndex + 1; i < this.children.length; i++) {
      let candidate = this.children[i].leftmostAtomChild();
      if (candidate !== null) {
        return candidate;
      }
    }
    return this.firstAtomToTheRight();
  }

  /** @returns{MathNode|null} */
  firstAtomToTheLeft() {
    if (this.parent === null) {
      return null;
    }
    return this.parent.firstAtomToTheLeftOf(this.indexInParent);
  }

  /** @returns{MathNode|null} */
  firstAtomToTheLeftOf(
    /** @type {number} */
    childIndex,
  ) {
    for (let i = childIndex - 1; i >= 0; i--) {
      let candidate = this.children[i].rightmostAtomChild();
      if (candidate !== null) {
        return candidate;
      }
    }
    return this.firstAtomToTheLeft();
  }

  /** @returns{MathNode|null} */
  leftmostAtomChild() {
    if (this.type.type === knownTypes.atom.type) {
      return this;
    }
    for (let i = 0; i < this.children.length; i++) {
      let candidate = this.children[i].leftmostAtomChild();
      if (candidate !== null) {
        return candidate;
      }
    }
    return null;
  }

  /**@returns{MathNode|null} */
  rightmostAtomChild() {
    if (this.type.type === knownTypes.atom.type) {
      return this;
    }
    for (let i = this.children.length - 1; i >= 0; i--) {
      let candidate = this.children[i].rightmostAtomChild();
      if (candidate !== null) {
        return candidate;
      }
    }
    return null;
  }

  storeCaretPositionPreExisingRange(
    /** @type{string} */
    key,
    /** @type{boolean} */
    shiftHeld,
  ) {
    let previousPosition = this.positionCaretBeforeKeyEvents;
    let selection = window.getSelection();
    let range = null;
    let rangeClone = null;
    if (selection.rangeCount > 0) {
      range = selection.getRangeAt(0);
    } else {
      range = document.createRange();
    }
    rangeClone = range.cloneRange();
    rangeClone.selectNodeContents(this.element);
    rangeClone.setEnd(range.endContainer, range.endOffset);
    this.positionCaretBeforeKeyEvents = rangeClone.toString().length;// range.endOffset;
    this.selectionLength = range.toString().length;
    this.equationEditor.setLastFocused(this);
    this.equationEditor.positionDebugString = `Computed position: ${this.positionCaretBeforeKeyEvents}.`
    this.equationEditor.positionDebugString += `Range: [${range}], clone: [${rangeClone}], previous position: ${previousPosition}.`;
    this.equationEditor.positionDebugString += `end offset: ${range.endOffset}, start offset: ${range.startOffset}`;
    this.equationEditor.writeDebugInfo(null);
  }

  storeCaretPosition(
    /** @type{string} */
    key,
    /** @type{boolean} */
    shiftHeld,
  ) {
    if (this.type.type === knownTypes.eventCatcher.type) {
      return;
    }
    if (this.type.type !== knownTypes.atom.type) {
      this.positionCaretBeforeKeyEvents = - 1;
      this.selectionLength = 0;
      this.equationEditor.setLastFocused(null);
      return;
    }
    try {
      this.storeCaretPositionPreExisingRange(key, shiftHeld);
    } catch (e) {
      console.log(`Failed to store caret position ${e}.`);
    }
  }

  appendChild(
    /** @type{MathNode} */
    child,
  ) {
    if (child.parent !== this && child.parent !== null && child.indexInParent >= 0) {
      child.parent.children[child.indexInParent] = null;
    }
    child.parent = this;
    child.indexInParent = this.children.length;
    this.children.push(child);
  }

  appendChildren(
    /** @type{MathNode[]|null[]} */
    newChildren,
  ) {
    for (let i = 0; i < newChildren.length; i++) {
      if (newChildren[i] === null) {
        continue;
      }
      this.appendChild(newChildren[i]);
    }
  }

  ensureEditableAtomsRecursive() {
    for (let i = 0; i < this.children.length; i++) {
      this.children[i].ensureEditableAtomsRecursive();
    }
    if (this.type.type !== knownTypes.horizontalMath.type) {
      return;
    }
    if (this.parent !== null) {
      if (this.parent.type.type === knownTypes.matrix.type) {
        return;
      }
    }
    this.ensureEditableAtoms();
  }

  normalizeHorizontalMathRecursive() {
    for (let i = 0; i < this.children.length; i++) {
      this.children[i].normalizeHorizontalMathRecursive();
    }
    if (this.type.type !== knownTypes.horizontalMath.type) {
      return;
    }
    if (this.parent !== null) {
      if (this.parent.type.type === knownTypes.matrix.type) {
        return;
      }
    }
    this.normalizeHorizontalMath();
  }

  normalizeHorizontalMath() {
    if (this.type.type !== knownTypes.horizontalMath.type) {
      return false;
    }
    let found = false;
    while (
      this.normalizeHorizontalMathInHorizontalMathOnce() ||
      this.normalizeHorizontalMathAtomNextToAtomOnce()
    ) {
      found = true;
    }
    return found;
  }

  /**@returns{boolean} Whether normalization of horizontal math is needed. */
  normalizeHorizontalMathInHorizontalMathOnceAccountOneChild(
    /**@type{MathNode[]} */
    normalizedChildren,
    /**@type{MathNode} */
    current,
  ) {
    if (current.type.type !== knownTypes.horizontalMath.type) {
      normalizedChildren.push(current);
      return false;
    }
    for (let j = 0; j < current.children.length; j++) {
      if (current.desiredCaretPosition === 0 && j === 0) {
        current.children[j].desiredCaretPosition = 0;
      } else if (current.desiredCaretPosition > 0 && j === current.children.length - 1) {
        current.children[j].desiredCaretPosition = 1;
      }
      normalizedChildren.push(current.children[j]);
    }
    return true;

  }

  normalizeHorizontalMathInHorizontalMathOnce() {
    let normalizedChildren = [];
    let found = false;
    for (let i = 0; i < this.children.length; i++) {
      if (this.normalizeHorizontalMathInHorizontalMathOnceAccountOneChild(
        normalizedChildren, this.children[i],
      )) {
        found = true;
      }
    }
    if (!found) {
      return false;
    }
    this.replaceChildRangeWithChildren(0, this.children.length - 1, normalizedChildren);
    return true;
  }

  mergeAtomContentToTheRight(
    /**@type{MathNode} */
    right,
  ) {
    let thisContent = this.initialContent;
    if (this.element !== null) {
      thisContent = this.element.textContent;
    }
    let rightContent = right.initialContent;
    if (right.element !== null) {
      rightContent = right.element.textContent;
    }
    if (right.desiredCaretPosition !== - 1) {
      this.desiredCaretPosition = thisContent.length + right.desiredCaretPosition;
    }
    thisContent += rightContent;
    if (this.element === null) {
      this.initialContent = thisContent;
    } else {
      this.element.textContent = thisContent;
    }
  }

  normalizeHorizontalMathAtomNextToAtomOnce() {
    for (let i = 0; i < this.children.length - 1; i++) {
      let current = this.children[i];
      let next = this.children[i + 1];
      if (
        current.type.type !== knownTypes.atom.type ||
        next.type.type !== knownTypes.atom.type
      ) {
        continue;
      }
      current.mergeAtomContentToTheRight(next);
      this.removeChildRange(i + 1, i + 1);
      return true;
    }
    return false;
  }

  replaceChildAtPositionWithChildren(
    /** @type {number} */
    index,
    /** @type {MathNode[]} */
    newChildren,
  ) {
    this.replaceChildRangeWithChildren(index, index, newChildren);
  }

  replaceChildAtPosition(
    /** @type {number} */
    index,
    /** @type {MathNode} */
    child,
  ) {
    this.replaceChildRangeWithChildren(index, index, [child]);
  }

  insertChildAtPosition(
    /** @type {number} */
    index,
    /** @type {MathNode} */
    child,
  ) {
    this.replaceChildRangeWithChildren(index, index - 1, [child]);
  }

  /** @returns {MathNode} */
  removeChildReplaceWithNull(
    /** @type{number} */
    childIndex,
  ) {
    let result = this.children[childIndex];
    result.parent = null;
    result.indexInParent = - 1;
    this.children[childIndex] = null;
    return result;
  }

  removeChild(
    /** @type {number} */
    index,
  ) {
    return this.replaceChildRangeWithChildren(index, index, []);
  }

  removeChildRange(
    /** @type {number} */
    fromIndex,
    /** @type {number} */
    toIndex,
  ) {
    return this.replaceChildRangeWithChildren(fromIndex, toIndex, []);
  }

  replaceChildRangeWithChildren(
    /** @type {number} */
    fromIndex,
    /** @type {number} */
    toIndex,
    /** @type {Array<MathNode>} */
    inputChildren,
  ) {
    // Please do not modify removed as removed can
    // be in use as a member of a sub-tree of the inputChildren.
    let toBeShiftedDown = [];
    // Disown all removed children.
    for (
      let i = fromIndex;
      i <= toIndex && i >= 0 && i < this.children.length;
      i++
    ) {
      if (this.children[i] === null) {
        continue;
      }
      this.children[i].parent = null;
    }
    // Store all children that need to be shifted down.
    for (let i = toIndex + 1; i < this.children.length; i++) {
      toBeShiftedDown.push(this.removeChildReplaceWithNull(i));
    }
    this.children.length = fromIndex;
    for (let i = 0; i < inputChildren.length; i++) {
      if (inputChildren[i] === null) {
        continue;
      }
      this.appendChild(inputChildren[i]);
    }
    for (let i = 0; i < toBeShiftedDown.length; i++) {
      this.appendChild(toBeShiftedDown[i]);
    }
  }

  isAtomWithLeftmostCursor() {
    if (this.type.type !== knownTypes.atom.type) {
      return false;
    }
    let offset = window.getSelection().getRangeAt(0).startOffset;
    return offset === 0;
  }

  isAtomWithRightmostCursor() {
    if (this.type.type !== knownTypes.atom.type) {
      return false;
    }
    let offset = window.getSelection().getRangeAt(0).startOffset;
    return offset === this.element.textContent.length;
  }

  /** @returns{KeyHandlerResult} whether the default should be prevented. */
  deleteButton() {
    if (this.equationEditor.hasSelection()) {
      return this.equationEditor.deleteSelection(null);
    }
    if (
      this.positionCaretBeforeKeyEvents !== this.element.textContent.length ||
      this.type.type !== knownTypes.atom.type
    ) {
      return new KeyHandlerResult(false, true);
    }
    let cousinAtom = this.firstAtom(1);
    if (cousinAtom === null) {
      return new KeyHandlerResult(false, false);
    }
    let cousinLeftSibling = cousinAtom.previousHorizontalSibling();
    if (cousinLeftSibling !== null) {
      if (cousinLeftSibling.implied) {
        cousinAtom.desiredCaretPosition = 0;
        this.parent.focusRestore();
        return new KeyHandlerResult(true, false);
      }
    }
    let rightSibling = this.nextHorizontalSibling();
    if (rightSibling !== null && rightSibling.type.type === knownTypes.baseWithExponent.type) {
      rightSibling.focus(- 1);
      return new KeyHandlerResult(true, false);
    }
    this.positionCaretBeforeKeyEvents = - 1;
    cousinAtom.positionCaretBeforeKeyEvents = 0;
    return cousinAtom.backspace();
  }

  /** @returns{KeyHandlerResult} whether the default should be prevented. */
  backspace() {
    if (this.equationEditor.hasSelection()) {
      return this.equationEditor.deleteSelection(null);
    }
    if (
      this.positionCaretBeforeKeyEvents !== 0 ||
      this.type.type !== knownTypes.atom.type
    ) {
      return new KeyHandlerResult(false, true);
    }
    this.desiredCaretPosition = 0;
    let result = this.applyBackspaceToTheLeft();
    return new KeyHandlerResult(result, !result);
  }

  /** @returns {boolean} whether reduction occurred. */
  applyBackspaceToTheLeftChildWithSiblingWrapper() {
    let parent = this.parent;
    let parentIndexInParent = parent.indexInParent;
    let base = parent.children[0];
    this.children[0].children[0].desiredCaretPosition = 0;
    base.appendChild(this.children[0]);
    base.normalizeHorizontalMath();
    let parentParent = parent.parent;
    parentParent.replaceChildAtPosition(parentIndexInParent, base);
    parentParent.normalizeHorizontalMath();
    parentParent.updateDOM();
    parentParent.focusRestore();
    return true;
  }

  /** @returns {boolean} whether reduction occurred. */
  applyBackspaceToTheLeftWrapperChildWithSiblingWrapper() {
    let parent = this.parent;
    let parentIndexInParent = parent.indexInParent;
    let horizontal = parent.children[0].children[0];
    horizontal.appendChild(parent.children[1].children[0]);
    horizontal.normalizeHorizontalMath();
    let parentParent = parent.parent;
    parentParent.replaceChildAtPosition(parentIndexInParent, horizontal);
    parentParent.normalizeHorizontalMath();
    parentParent.updateDOM();
    parentParent.focusRestore();
    return true;
  }

  /** @returns {boolean} whether reduction occurred. */
  applyBackspaceToTheLeftEndOfOperatorSubscript() {
    let operatorWithSuperAndSubscript = this.parent;
    let superscript = operatorWithSuperAndSubscript.children[0];
    let subscript = operatorWithSuperAndSubscript.children[2];
    let horizontal = mathNodeFactory.horizontalMathFromArray(
      this.equationEditor,
      [superscript.children[0], subscript.children[0]],
    );
    horizontal.normalizeHorizontalMath();
    let parent = operatorWithSuperAndSubscript.parent;
    let indexOperator = operatorWithSuperAndSubscript.indexInParent;
    parent.replaceChildAtPosition(indexOperator, horizontal);
    parent.normalizeHorizontalMath();
    parent.updateDOM();
    parent.focusRestore();
    return true;
  }

  /** @returns {boolean} whether backspace was applied */
  applyBackspaceToTheLeftHorizontalMathParent() {
    let parent = this.parent;
    if (parent.type.type !== knownTypes.horizontalMath.type) {
      return false;
    }
    if (this.indexInParent === 0) {
      return this.parent.applyBackspaceToTheLeft();
    }
    let indexPrevious = this.indexInParent - 1;
    let previous = parent.children[indexPrevious];
    return previous.applyBackspaceToTheRight();
  }

  /** @returns {boolean} whether backspace was applied */
  applyBackspaceToTheLeft() {
    if (this.parent === null) {
      // We've reached the root node by pushing backspace in the first position.
      this.focusCancelOnce();
      return false;
    }
    if (this.indexInParent === 0) {
      return this.parent.applyBackspaceToTheLeft();
    }
    if (this.applyBackspaceToTheLeftHorizontalMathParent()) {
      return true;
    }
    this.parent.focusCancelOnce();
    return false;
  }

  applyBackspaceToTheRightAsLeftArrow() {
    let sibling = this.nextHorizontalSibling();
    if (sibling !== null) {
      sibling.focusCancelOnce();
    }
    this.rightmostAtomChild().focus(1);
    return true;
  }

  applyBackspaceToTheLeftAsLeftArrow() {
    let sibling = this.previousHorizontalSibling();
    if (sibling === null) {
      return false;
    }
    sibling.rightmostAtomChild().focus(1);
    return true;
  }

  /** @returns {boolean} whether backspace was applied */
  applyBackspaceToTheRight() {
    return false;
  }

  applyBackspaceToTheRightDelimiter() {
    if (
      this.type.type !== knownTypes.rightDelimiter.type &&
      this.type.type !== knownTypes.leftDelimiter.type
    ) {
      return false;
    }
    let matchingIndex = this.parent.findIndexMatchingDelimiter(this.indexInParent);
    if (matchingIndex === - 1) {
      console.log("Unexpected failure to find matching left parenthesis.");
      return false;
    }
    if (!this.parent.children[matchingIndex].implied) {
      this.implied = true;
      this.children[0].implied = true;
      this.parent.focusCancelOnce();
      this.focus(- 1);
      this.updateDOM();
      return true;
    }
    let parent = this.parent;
    let startingIndexInParent = this.indexInParent;
    parent.removeChild(Math.max(startingIndexInParent, matchingIndex));
    parent.removeChild(Math.min(startingIndexInParent, matchingIndex));
    parent.normalizeHorizontalMath();
    parent.updateDOM();
    parent.focusRestore();
    return true;
  }

  /** Returns the position of the operator.
   * 
   * - 1 stands for start ("+11"), 0 for middle ("1+1"), 1 for end ("11+"). 
   */
  computePositionOfOperator() {
    let positionOperator = 1;
    if (this.positionCaretBeforeKeyEvents === 0 && this.element.textContent.length > 0) {
      positionOperator = - 1;
    } else if (
      this.positionCaretBeforeKeyEvents > 0 &&
      this.positionCaretBeforeKeyEvents < this.element.textContent.length
    ) {
      positionOperator = 0;
    }
    return positionOperator;
  }

  /** @returns {ParentWithIndex} */
  findHorizontalMathParent() {
    let result = new ParentWithIndex(this.parent, this.indexInParent);
    while (result.parent !== null) {
      if (result.parent.type.type === knownTypes.horizontalMath.type) {
        return result;
      }
      result.indexInParent = result.parent.indexInParent;
      result.parent = result.parent.parent;
    }
    return result;
  }

  makeHorizontalOperatorCorrectInput(
    /** @type {string} */
    contentTransformedToMathSymbol,
  ) {
    this.makeHorizontalOperator(latexConstants.normalizeOperatorToUtf8(contentTransformedToMathSymbol));
  }

  makeHorizontalOperator(
    /** @type {string} */
    key,
  ) {
    let split = this.splitByCaretEmptyAtoms();
    this.makeHorizontalOperatorFromSplit(key, split);
  }

  makeHorizontalOperatorFromSplit(
    /** @type {string} */
    key,
    /** @type {MathNode[]} */
    split,
  ) {
    // Find closest ancestor node that's of type horizontal math.
    if (!this.hasHorozintalMathParent()) {
      console.log("Warning: horizontal operator made on element not contained in horizontal math.");
      return;
    }
    let parent = this.parent;
    let operator = mathNodeFactory.atomImmutable(this.equationEditor, key);
    parent.replaceChildAtPositionWithChildren(
      this.indexInParent, [
      split[0],
      operator,
      split[1],
    ]);
    parent.normalizeHorizontalMath();
    parent.ensureEditableAtoms();
    parent.updateDOM();
    operator.focus(1);
  }

  makeDelimiterAmbiguous(
    /** @type{string} */
    ambiguousDelimiter,
  ) {
    this.makeDelimiterCommon(
      ambiguousDelimiter,
      latexConstants.leftRightDelimiterPair[ambiguousDelimiter],
      true,
      true,
    );
  }

  makeDelimiterLeft(
    /** @type{string} */
    leftDelimiter,
  ) {
    this.makeDelimiterCommon(leftDelimiter, latexConstants.leftRightDelimiterPair[leftDelimiter], true, false);
  }

  makeDelimiterRight(
    /** @type{string} */
    rightDelimiter,
  ) {
    this.makeDelimiterCommon(latexConstants.rightLeftDelimiterPair[rightDelimiter], rightDelimiter, false, false);
  }

  makeMatrix(
    /**@type{number} */
    rows,
    /**@type{number} */
    columns,
  ) {
    let split = this.splitByCaretEmptyAtoms();
    this.makeMatrixFromSplit(rows, columns, split);
  }

  makeMatrixFromSplit(
    /**@type{number} */
    rows,
    /**@type{number} */
    columns,
    /** @type {MathNode[]} */
    split,
  ) {
    // Find closest ancestor node that's of type horizontal math.
    if (!this.hasHorozintalMathParent()) {
      console.log("Warning: horizontal operator made on element not contained in horizontal math.");
      return;
    }
    let parent = this.parent;
    let matrix = mathNodeFactory.matrix(this.equationEditor, rows, columns, "");
    parent.replaceChildAtPositionWithChildren(
      this.indexInParent, [
      split[0],
      matrix,
      split[1],
    ]);
    parent.normalizeHorizontalMath();
    parent.ensureEditableAtoms();
    parent.updateDOM();
    matrix.children[0].children[1].children[0].children[0].focus(0);
  }

  makeCancel() {
    let splitBySelection = this.equationEditor.splitAtomsBySelection();
    if (splitBySelection !== null) {
      this.makeCancelFromSplit(splitBySelection);
      return;
    }
    this.makeCancelFromSplit(this.splitByCaret());
  }

  makeSqrt() {
    let splitBySelection = this.equationEditor.splitAtomsBySelection();
    if (splitBySelection !== null) {
      this.equationEditor.makeSqrtFromSelection(splitBySelection);
    } else {
      this.makeSqrtFromCaret(splitBySelection);
    }
  }

  makeSum() {
    this.makeOperatorWithSuperscriptAndSubscript(latexConstants.latexBackslashAtomsEditable["Sigma"]);
  }

  makeOperatorWithSuperscriptAndSubscript(
    /** @type{string} */
    operator,
  ) {
    let split = this.splitByCaret();
    return this.makeOperatorWithSuperscriptAndSubscriptFromSplit(operator, split)
  }

  makeOperatorWithSuperscriptAndSubscriptFromSplit(
    /** @type {string} */
    operator,
    /** @type {MathNode[] */
    split,
  ) {
    let parent = this.parent;
    let oldIndex = this.indexInParent;
    let operatorNode = mathNodeFactory.operatorWithSuperAndSubscript(this.equationEditor, operator, null, null);
    if (split[0] === null) {
      parent.replaceChildAtPosition(oldIndex, operatorNode);
    } else {
      parent.replaceChildAtPosition(oldIndex, split[0]);
      oldIndex++;
      parent.insertChildAtPosition(oldIndex, operatorNode);
    }
    if (split[1] !== null) {
      parent.insertChildAtPosition(oldIndex + 1, split[1]);
    }
    parent.ensureEditableAtoms();
    parent.updateDOM();
    operatorNode.focus(1);
  }

  makeOperatorWithSubscript(
    /** @type {string} */
    operator,
  ) {
    let split = this.splitByCaret();
    return this.makeOperatorWithSubscriptFromSplit(operator, split)
  }

  makeOperatorWithSubscriptFromSplit(
    /** @type {string} */
    operator,
    /** @type {MathNode[] */
    split,
  ) {
    let parent = this.parent;
    let oldIndex = this.indexInParent;
    let operatorNode = mathNodeFactory.operatorWithSubscript(this.equationEditor, operator, null);
    if (split[0] === null) {
      parent.replaceChildAtPosition(oldIndex, operatorNode);
    } else {
      parent.replaceChildAtPosition(oldIndex, split[0]);
      oldIndex++;
      parent.insertChildAtPosition(oldIndex, operatorNode);
    }
    if (split[1] !== null) {
      parent.insertChildAtPosition(oldIndex + 1, split[1]);
    }
    parent.ensureEditableAtoms();
    parent.updateDOM();
    operatorNode.focus(1);
  }

  makeCancelFromSplit(
    /** @type {MathNode[]} */
    split,
  ) {
    let parent = this.parent;
    let oldIndex = this.indexInParent;
    let cancel = mathNodeFactory.cancel(this.equationEditor, split[1]);
    if (split[0] === null) {
      parent.replaceChildAtPosition(oldIndex, cancel);
    } else {
      parent.replaceChildAtPosition(oldIndex, split[0]);
      parent.insertChildAtPosition(oldIndex + 1, cancel);
    }
    parent.ensureEditableAtoms();
    parent.updateDOM();
    cancel.children[1].focusStandard(- 1);
  }

  makeSqrtFromCaret() {
    let split = this.splitByCaret();
    this.makseSqrtFromSplit(split);
  }

  makseSqrtFromSplit(
    /** @type {MathNode[]} */
    split,
  ) {
    let parent = this.parent;
    let oldIndex = this.indexInParent;
    let sqrt = mathNodeFactory.sqrt(this.equationEditor, split[1], null);
    if (split[0] === null) {
      parent.replaceChildAtPosition(oldIndex, sqrt);
    } else {
      parent.replaceChildAtPosition(oldIndex, split[0]);
      parent.insertChildAtPosition(oldIndex + 1, sqrt);
    }
    parent.ensureEditableAtoms();
    parent.updateDOM();
    sqrt.children[2].focusStandard(0);
  }

  makeDelimiterCommon(
    /** @type{string} */
    leftDelimiter,
    /** @type{string} */
    rightDelimiter,
    /** @type{boolean} */
    isLeft,
    /** @type{boolean} */
    isAmbiguous,
  ) {
    let positionOperator = this.computePositionOfOperator();
    // Find closest ancestor node that's of type horizontal math.
    let parentAndIndex = this.findHorizontalMathParent();
    if (parentAndIndex.parent === null) {
      // No ancestor is of type horizontal math. 
      console.log("Warning: could not find ancestor of type horizontal math.");
      return;
    }
    let oldIndexInParent = parentAndIndex.indexInParent;
    let parent = parentAndIndex.parent;
    parent.children[oldIndexInParent].doMakeDelimiterCommon(leftDelimiter, rightDelimiter, positionOperator, isLeft, isAmbiguous);
  }

  findIndexToInsertRightDelimiter(
    /**@type {number} */
    indexToInserLeftDelimiter,
  ) {
    if (indexToInserLeftDelimiter >= this.children.length) {
      return this.children.length;
    }
    let openDelimiters = 0;
    for (let i = indexToInserLeftDelimiter; i < this.children.length; i++) {
      let child = this.children[i];
      if (child.type.type === knownTypes.rightDelimiter.type) {
        openDelimiters--;
      } else if (child.type.type === knownTypes.leftDelimiter.type) {
        openDelimiters++;
      }
      if (openDelimiters < 0) {
        return i;
      }
    }
    return this.children.length;
  }

  findIndexToInsertLeftDelimiter(
    /**@type {number} */
    indexInsertedRightDelimiter,
  ) {
    let openDelimiters = 0;
    for (let i = indexInsertedRightDelimiter - 1; i >= 0; i--) {
      let child = this.children[i];
      if (child.type.type === knownTypes.rightDelimiter.type) {
        openDelimiters++;
      } else if (child.type.type === knownTypes.leftDelimiter.type) {
        openDelimiters--;
      }
      if (openDelimiters < 0) {
        return i + 1;
      }
    }
    return 0;
  }

  /**@returns{MathNode|null} */
  findMatchingDelimiter() {
    if (
      this.type.type !== knownTypes.rightDelimiter.type &&
      this.type.type !== knownTypes.leftDelimiter.type
    ) {
      return null;
    }
    if (!this.hasHorozintalMathParent()) {
      return null;
    }
    let parent = this.parent;
    let index = parent.findIndexMatchingDelimiter(this.indexInParent);
    if (index === - 1) {
      return null;
    }
    return parent.children[index];
  }

  /** @returns {number}*/
  findIndexMatchingDelimiter(
    /**@type {number} */
    indexStartingDelimiter,
  ) {
    let startingDelimiter = knownTypes.leftDelimiter.type;
    let endingDelimiter = knownTypes.rightDelimiter.type;
    let direction = 1;
    if (this.children[indexStartingDelimiter].type.type === knownTypes.rightDelimiter.type) {
      endingDelimiter = knownTypes.leftDelimiter.type;
      startingDelimiter = knownTypes.rightDelimiter.type;
      direction = - 1;
    }
    let openDelimiters = 1;
    for (
      let i = indexStartingDelimiter + direction;
      i < this.children.length && i >= 0;
      i += direction
    ) {
      let child = this.children[i];
      if (child.type.type === startingDelimiter) {
        openDelimiters++;
      } else if (child.type.type === endingDelimiter) {
        openDelimiters--;
      }
      if (openDelimiters === 0) {
        return i;
      }
    }
    return - 1;
  }

  /** @returns {MathNode[]} */
  splitByCaret() {
    return this.splitByPosition(this.positionCaretBeforeKeyEvents)
  }

  /** @returns {MathNode[]} */
  splitByCaretEmptyAtoms() {
    return this.splitByPositionEmptyAtoms(this.positionCaretBeforeKeyEvents)
  }

  /** @returns {MathNode[]} */
  splitByPositionEmptyAtoms(
    /** @type{number} */
    position,
  ) {
    let result = this.splitByPosition(position);
    if (result[0] === null) {
      result[0] = mathNodeFactory.atom(this.equationEditor, "");
    }
    if (result[1] === null) {
      result[1] = mathNodeFactory.atom(this.equationEditor, "");
    }
    return result;
  }

  /** @returns {MathNode[]} */
  splitByPosition(
    /** @type{number} */
    position,
  ) {
    return this.splitByPositionChopOffCharacters(position, 0);
  }

  /** @returns {string[]} */
  splitByPositionIntoStringsChopOffCharacters(
    /** @type{number} */
    position,
    /** @type{number} */
    charactersToRemove,
  ) {
    if (!this.isAtomEditable() || position < 0) {
      if (position <= 0) {
        return ["", ""];
      } else {
        return ["", ""];
      }
    }
    let content = this.contentIfAtom();
    let leftContent = content.slice(0, position);
    let rightContent = content.slice(position + charactersToRemove, content.length);
    return [leftContent, rightContent];
  }

  /** @returns {MathNode[]} */
  splitByPositionChopOffCharacters(
    /** @type{number} */
    position,
    /** @type{number} */
    charactersToRemove,
  ) {
    if (!this.isAtomEditable() || position < 0) {
      if (position <= 0) {
        return [null, this];
      } else {
        return [this, null];
      }
    }
    let splitStrings = this.splitByPositionIntoStringsChopOffCharacters(position, charactersToRemove);
    let leftContent = splitStrings[0];
    let rightContent = splitStrings[1]
    let leftNode = mathNodeFactory.atom(this.equationEditor, leftContent);
    let rightNode = mathNodeFactory.atom(this.equationEditor, rightContent);
    if (leftContent === "") {
      return [null, rightNode];
    }
    if (rightContent === "") {
      return [leftNode, null];
    }
    return [leftNode, rightNode];
  }

  doMakeDelimiterCommon(
    /** @type{string} */
    leftDelimiterString,
    /** @type{string} */
    rightDelimiterString,
    /**@type {number} */
    positionOperator,
    /**@type {boolean} */
    isLeft,
    /** @type{boolean} */
    isAmbiguous,
  ) {
    let parent = this.parent;
    if (parent.type.type !== knownTypes.horizontalMath.type) {
      console.log("Warning: making parentheses in non-horizontal math.");
    }
    let oldIndexInParent = this.indexInParent;
    let leftDelimiter = mathNodeFactory.leftDelimiter(
      this.equationEditor,
      leftDelimiterString,
      !isLeft,
    );
    let rightDelimiter = mathNodeFactory.rightDelimiter(
      this.equationEditor,
      rightDelimiterString,
      isLeft,
    );
    if (positionOperator === 0) {
      let leftAndRight = this.splitByCaret();
      parent.replaceChildAtPositionWithChildren(
        oldIndexInParent, leftAndRight,
      );
    }
    let indexLeftDelimiter = - 1;
    let indexRightDelimiter = - 1;
    if (isAmbiguous) {
      for (let i = oldIndexInParent; i >= 0; i--) {
        let child = parent.children[i];
        if (
          child.type.type === knownTypes.leftDelimiter.type &&
          child.initialContent === "|" &&
          !child.implied
        ) {
          isLeft = true;
        }
      }
      if (isLeft) {
        if (oldIndexInParent + 1 < parent.children.length) {
          let child = parent.children[oldIndexInParent + 1];
          if (child.type.type === knownTypes.rightDelimiter.type && child.implied === true) {
            isLeft = false;
          }
        }
      }
    }
    if (isLeft) {
      if (positionOperator === 1) {
        indexLeftDelimiter = oldIndexInParent + 1;
      } else if (positionOperator === 0) {
        indexLeftDelimiter = oldIndexInParent + 1;
      } else {
        indexLeftDelimiter = oldIndexInParent;
      }
      if (parent.replaceImpliedLeftDelimiter(leftDelimiterString, indexLeftDelimiter)) {
        return;
      }
      indexRightDelimiter = parent.findIndexToInsertRightDelimiter(indexLeftDelimiter);
    } else {
      if (positionOperator === 1) {
        indexRightDelimiter = oldIndexInParent + 1;
      } else if (positionOperator === 0) {
        indexRightDelimiter = oldIndexInParent + 1;
      } else {
        indexRightDelimiter = oldIndexInParent;
      }
      if (parent.replaceImpliedRightDelimiter(rightDelimiterString, indexRightDelimiter)) {
        return;
      }
      indexLeftDelimiter = parent.findIndexToInsertLeftDelimiter(indexRightDelimiter);
    }
    parent.insertChildAtPosition(indexRightDelimiter, rightDelimiter);
    parent.insertChildAtPosition(indexLeftDelimiter, leftDelimiter);
    parent.normalizeHorizontalMath();
    parent.ensureEditableAtoms();
    parent.updateDOM();
    if (isLeft) {
      leftDelimiter.focus(1);
    } else {
      rightDelimiter.focus(1);
    }
  }

  /** @returns{boolean} */
  replaceImpliedLeftDelimiter(
    /** @type {string} */
    delimiterString,
    /**@type {number}*/
    delimiterIndex,
  ) {
    let openDelimiters = 0;
    if (delimiterIndex >= this.children.length) {
      delimiterIndex = this.children[this.children.length - 1];
    }
    for (let i = delimiterIndex; i >= 0; i--) {
      let child = this.children[i];
      if (child.type.type === knownTypes.rightDelimiter.type) {
        openDelimiters++;
        continue;
      }
      if (child.type.type === knownTypes.leftDelimiter.type) {
        openDelimiters--;
        if (openDelimiters >= 0) {
          continue;
        }
        if (child.implied) {
          return this.moveDelimiterMarkExplicit(delimiterString, delimiterIndex, i);
        }
        return false;
      }
    }
    return false;
  }

  /** @returns{boolean} */
  replaceImpliedRightDelimiter(
    /** @type {string} */
    delimiterString,
    /** @type {number} */
    delimiterIndex,
  ) {
    let openDelimiters = 0;
    for (let i = delimiterIndex; i < this.children.length; i++) {
      let child = this.children[i];
      if (child.type.type === knownTypes.leftDelimiter.type) {
        openDelimiters++;
        continue;
      }
      if (child.type.type === knownTypes.rightDelimiter.type) {
        openDelimiters--;
        if (openDelimiters >= 0) {
          continue;
        }
        if (child.implied) {
          return this.moveDelimiterMarkExplicit(delimiterString, delimiterIndex, i);
        }
        return false;
      }
    }
    return false;
  }

  /** @returns{boolean} */
  moveDelimiterMarkExplicit(
    /** @type {string} */
    delimiterString,
    /** @type {number}*/
    toIndex,
    /** @type {number}*/
    fromIndex,
  ) {
    let isLeft = this.children[fromIndex].type.type === knownTypes.leftDelimiter.type;
    this.removeChild(fromIndex);
    if (toIndex > fromIndex) {
      toIndex--;
    }
    let incomingDelimiter = null;
    if (isLeft) {
      incomingDelimiter = mathNodeFactory.leftDelimiter(
        this.equationEditor, delimiterString, false
      );
    } else {
      incomingDelimiter = mathNodeFactory.rightDelimiter(
        this.equationEditor, delimiterString, false
      );
    }
    this.insertChildAtPosition(toIndex, incomingDelimiter);
    this.ensureEditableAtoms();
    this.updateDOM();
    incomingDelimiter.focus(1);
    return true;
  }

  /** @returns{boolean} */
  hasExponentOrSubscriptParent() {
    if (this.parent === null) {
      return false;
    }
    if (this.indexInParent !== 0) {
      return false;
    }
    let type = this.parent.type.type;
    return type === knownTypes.baseWithExponent.type || type === knownTypes.baseWithSubscript.type;
  }

  ensureEditableAtoms() {
    if (this.type.type !== knownTypes.horizontalMath.type) {
      console.log("Warning: call ensureEditableAtomToTheRight on non-horizontal math. ");
      return;
    }
    let correctedChildren = [];
    if (this.children.length === 0) {
      correctedChildren.push(mathNodeFactory.atom(this.equationEditor, ""));
    } else if (!this.children[0].isAtomEditable()) {
      if (!this.hasExponentOrSubscriptParent()) {
        correctedChildren.push(mathNodeFactory.atom(this.equationEditor, ""));
      }
    }
    for (let i = 0; i < this.children.length - 1; i++) {
      let child = this.children[i];
      let next = this.children[i + 1];
      correctedChildren.push(child);
      if (!child.isAtomEditable() && !next.isAtomEditable()) {
        correctedChildren.push(mathNodeFactory.atom(this.equationEditor, ""));
      }
    }
    correctedChildren.push(this.children[this.children.length - 1]);
    // Editable atom not inserted in the end if the parent is exponent or subscript.
    if (!correctedChildren[correctedChildren.length - 1].isAtomEditable()) {
      if (!this.hasExponentOrSubscriptParent()) {
        correctedChildren.push(mathNodeFactory.atom(this.equationEditor, ""));
      }
    }
    if (correctedChildren.length > this.children.length) {
      this.replaceChildRangeWithChildren(0, this.children.length, correctedChildren);
    }
  }

  setTextContent(
    /**@type{string} */
    input,
  ) {
    if (this.element === null) {
      this.initialContent = input;
      return;
    }
    this.element.textContent = input;
  }

  /** @returns {BackslashResult} */
  removeBackslashSequence() {
    let backslashSequence = this.equationEditor.backslashSequence;
    let split = this.splitByPositionIntoStringsChopOffCharacters(
      this.equationEditor.backslashPosition,
      backslashSequence.length,
    );
    this.positionCaretBeforeKeyEvents = this.equationEditor.backslashPosition;
    this.setTextContent(split[0] + split[1]);
    return new BackslashResult(false, backslashSequence);
  }

  makeFractionNumerator() {
    if (this.parent === null) {
      return;
    }
    let splitBySelection = this.equationEditor.splitAtomsBySelection();
    if (splitBySelection === null) {
      this.makeFractionNumeratorFromCaretPosition();
    } else {
      this.equationEditor.makeFractionNumeratorFromSelection(splitBySelection);
    }
  }

  makeFractionNumeratorFromCaretPosition() {
    const oldParent = this.parent;
    const oldIndexInParent = this.indexInParent;
    let fraction = null;
    let childIndexToFocus = 1;
    if (this.positionCaretBeforeKeyEvents === this.element.textContent.length) {
      fraction = mathNodeFactory.fraction(this.equationEditor, this, null);
    } else if (this.positionCaretBeforeKeyEvents === 0) {
      fraction = mathNodeFactory.fraction(this.equationEditor, null, this);
      childIndexToFocus = 0;
    } else {
      let split = this.splitByCaret();
      fraction = mathNodeFactory.fraction(this.equationEditor, split[0], split[1]);
    }
    oldParent.replaceChildAtPosition(oldIndexInParent, mathNodeFactory.atom(this.equationEditor, ""));
    oldParent.insertChildAtPosition(oldIndexInParent + 1, fraction);
    oldParent.insertChildAtPosition(oldIndexInParent + 2, mathNodeFactory.atom(this.equationEditor, ""));
    fraction.parent.updateDOM();
    fraction.children[childIndexToFocus].focus(- 1);
  }

  removeAllChildren() {
    this.removeChildRange(0, this.children.length - 1);
  }

  isEmptyAtom() {
    if (this.type.type !== knownTypes.atom.type) {
      return false;
    }
    if (this.element === null) {
      return false;
    }
    return this.element.textContent === "";
  }

  /** Returns an immediate horizontal math sibling, provided the node 
   * sits in horizontally laid out math and has a previous sibling.  
   * @returns{MathNode|null} 
   */
  previousHorizontalSibling() {
    return this.horizontalSibling(- 1);
  }

  /** Returns an immediate horizontal math sibling, provided the node 
   * sits in horizontally laid out math and has a next sibling.  
   * @returns{MathNode|null} 
   */
  nextHorizontalSibling() {
    return this.horizontalSibling(1);
  }

  horizontalSibling(
    /**@type{number}*/
    direction,
  ) {
    if (this.parent === null) {
      return null;
    }
    if (this.parent.type.type !== knownTypes.horizontalMath.type) {
      return null;
    }
    let index = this.indexInParent + direction;
    if (index < 0 || index >= this.parent.children.length) {
      return null;
    }
    return this.parent.children[index];
  }

  makeBaseWithExponent() {
    if (this.parent === null) {
      return;
    }
    let previous = this.previousHorizontalSibling();
    if (previous !== null) {
      if (this.isEmptyAtom() || previous.type.type == knownTypes.rightDelimiter.type) {
        previous.makeBaseWithExponent();
        return;
      }
    }
    if (
      this.type.type === knownTypes.rightDelimiter.type
    ) {
      this.makeBaseWithExponentRightDelimiter();
      return;
    }
    this.makeBaseDefaultWithExponentNoDelimiter();
  }

  makeBaseWithExponentRightDelimiter() {
    let rightIndex = this.indexInParent;
    let originalParent = this.parent;
    let leftIndex = originalParent.findIndexMatchingDelimiter(rightIndex);
    let baseContent = originalParent.children.slice(leftIndex, rightIndex + 1);
    let base = mathNodeFactory.horizontalMathFromArray(
      this.equationEditor,
      baseContent,
    );
    const baseWithExponent = mathNodeFactory.baseWithExponent(this.equationEditor, base, null);
    baseWithExponent.children[1].children[0].children[0].desiredCaretPosition = 0;
    originalParent.replaceChildRangeWithChildren(leftIndex, rightIndex, [baseWithExponent]);
    originalParent.ensureEditableAtoms();
    originalParent.updateDOM();
    originalParent.focusRestore();
  }

  makeBaseDefaultWithExponentNoDelimiter() {
    if (!this.isAtomEditable()) {
      this.makeBaseDefaultWithExponent();
      return;
    }
    let content = this.textContentOrInitialContent();
    let numberOfCharactersToSlice = 0;
    for (let i = content.length - 1; i >= 0; i--) {
      let current = content[i];
      if (!latexConstants.isDigit(current)) {
        break;
      }
      numberOfCharactersToSlice++;
    }
    if (numberOfCharactersToSlice === 0) {
      numberOfCharactersToSlice = 1;
    }
    if (numberOfCharactersToSlice >= content.length) {
      this.makeBaseDefaultWithExponent();
      return;
    }
    let leftContent = content.slice(0, content.length - numberOfCharactersToSlice);
    let rightContent = content.slice(content.length - numberOfCharactersToSlice);
    let left = mathNodeFactory.atom(this.equationEditor, leftContent);
    let right = mathNodeFactory.atom(this.equationEditor, rightContent);
    let originalParent = this.parent;
    let originalIndexInParent = this.indexInParent;
    const baseWithExponent = mathNodeFactory.baseWithExponent(this.equationEditor, right, null);
    baseWithExponent.children[1].children[0].children[0].desiredCaretPosition = 0;
    originalParent.replaceChildAtPositionWithChildren(originalIndexInParent, [left, baseWithExponent]);
    originalParent.ensureEditableAtoms();
    originalParent.updateDOM();
    originalParent.focusRestore();
  }

  makeBaseDefaultWithExponent() {
    let originalParent = this.parent;
    let originalIndexInParent = this.indexInParent;
    const baseWithExponent = mathNodeFactory.baseWithExponent(this.equationEditor, this, null);
    baseWithExponent.children[1].children[0].children[0].desiredCaretPosition = 0;
    originalParent.replaceChildAtPosition(originalIndexInParent, baseWithExponent);
    originalParent.ensureEditableAtoms();
    originalParent.updateDOM();
    originalParent.focusRestore();
  }

  makeBaseWithSubscript() {
    if (this.parent === null) {
      return;
    }
    if (this.isEmptyAtom()) {
      let previous = this.previousHorizontalSibling();
      if (previous !== null) {
        previous.makeBaseWithSubscript();
        return;
      }
    }
    if (
      this.type.type === knownTypes.rightDelimiter.type
    ) {
      this.makeBaseWithSubscriptRightDelimiter();
      return;
    }
    this.makeBaseDefaultWithSubscript();
  }

  makeBaseWithSubscriptRightDelimiter() {
    let rightIndex = this.indexInParent;
    let originalParent = this.parent;
    let leftIndex = originalParent.findIndexMatchingDelimiter(rightIndex);
    let baseContent = originalParent.children.slice(leftIndex, rightIndex + 1);
    let base = mathNodeFactory.horizontalMathFromArray(
      this.equationEditor,
      baseContent,
    );
    const baseWithSubscript = mathNodeFactory.baseWithSubscript(this.equationEditor, base, null);
    baseWithSubscript.children[1].children[0].children[0].desiredCaretPosition = 0;
    originalParent.replaceChildRangeWithChildren(leftIndex, rightIndex, [baseWithSubscript]);
    originalParent.ensureEditableAtoms();
    originalParent.updateDOM();
    originalParent.focusRestore();
  }

  makeBaseDefaultWithSubscript() {
    let originalParent = this.parent;
    let originalIndexInParent = this.indexInParent;
    const baseWithSubscript = mathNodeFactory.baseWithSubscript(this.equationEditor, this, null);
    baseWithSubscript.children[1].children[0].children[0].desiredCaretPosition = 0;
    originalParent.replaceChildAtPosition(originalIndexInParent, baseWithSubscript);
    originalParent.ensureEditableAtoms();
    originalParent.updateDOM();
    originalParent.focusRestore();
  }

  /** @returns{boolean} Focuses the cursor on an atom. */
  focusAtom(
    /** @type{number} */
    endToFocus,
  ) {
    if (this.element === null) {
      this.desiredCaretPosition = - 1;
      return false;
    }
    // The call to focus(null) will wipe the desiredCaretPosition.
    let originalDesiredPosition = this.desiredCaretPosition;
    let position = 0;
    if (endToFocus === 0) {
      position = originalDesiredPosition;
    }
    if (endToFocus > 0) {
      position = this.element.textContent.length;
    }
    if (position < 0) {
      position = 0;
    }
    if (position > this.element.textContent.length) {
      position = this.element.textContent.length;
    }
    this.setCaretPosition(position);
    this.equationEditor.setLastFocused(this);
    this.desiredCaretPosition = - 1;
    return true;
  }

  /** Focuses the HTMLElement that belongs to the math node.
   * 
   * The endToFocus parameter denotes where the focus should occur.
   * At the moment, negative endToFocus indicates the caret should
   * be on the element's left, and positive endToFocus indicates the caret 
   * should go on the right. Zero indicates to focus at this.positionCaretBeforeKeyEvents.
   * 
   * @returns{boolean} Whether the focus was successful.
   */
  focus(
    /** @type{number} */
    endToFocus,
  ) {
    if (this.type.type === knownTypes.atom.type) {
      return this.focusAtom(endToFocus);
    }
    if (this.type.type === knownTypes.eventCatcher.type) {
      if (this.element === null) {
        return false;
      }
      this.element.focus();
      return true;
    }

    return this.focusStandard(endToFocus);
  }

  focusStandard(
    /** @type{number} */
    endToFocus,
  ) {
    if (endToFocus === 1) {
      for (let i = this.children.length - 1; i >= 0; i--) {
        if (this.children[i].focus(endToFocus)) {
          return true;
        }
      }
    } else {
      for (let i = 0; i < this.children.length; i++) {
        if (this.children[i].focus(endToFocus)) {
          return true;
        }
      }
    }
    if (endToFocus === 0) {
      return false;
    }
    let sibling = this.firstAtom(endToFocus);
    if (sibling === null) {
      return false;
    }
    return sibling.focus(- endToFocus);
  }

  /** @returns {boolean} whether focus request was find. */
  focusCancelOnce() {
    if (this.desiredCaretPosition !== - 1) {
      this.desiredCaretPosition = - 1;
      return true;
    }
    for (let i = 0; i < this.children.length; i++) {
      if (this.children[i].focusCancelOnce()) {
        return true;
      }
    }
    return false;
  }

  /** @returns {boolean} whether focused child was found. */
  focusRestore() {
    if (this.desiredCaretPosition !== - 1) {
      this.focus(0);
      return true;
    }
    this.desiredCaretPosition = - 1;
    for (let i = 0; i < this.children.length; i++) {
      if (this.children[i].focusRestore()) {
        return true;
      }
    }
    let sibling = null;
    if (this.desiredCaretPosition > 0) {
      sibling = this.firstAtomToTheRight();
    } else if (this.desiredCaretPosition === 0) {
      sibling = this.firstAtomToTheLeft();
    }
    if (sibling !== null) {
      sibling.focus(0);
      return true;
    }
    return false;
  }

  setRangeStartEntireElement(
    /** @type{Range}  */
    range,
  ) {
    if (this.element.childNodes.length > 0) {
      range.setStart(this.element.childNodes[0], 0);
      return;
    }
    if (this.element.textContent !== null) {
      range.setStart(this.element, 0);
      return;
    }
    range.setStart(this.element, 0);
  }

  setRangeEndEntireElement(
    /** @type{Range}  */
    range,
  ) {
    if (this.element.childNodes.length > 0) {
      range.setEndAfter(this.element.lastChild);
      return;
    }
    if (this.element.textContent !== null) {
      range.setEnd(this.element, this.element.textContent.length);
      return;
    }
    range.setEnd(this.element, 0);
  }

  setRangeStart(
    /** @type{Range}  */
    range,
    /** @type {number} */
    position,
  ) {
    if (!this.isAtomEditable() || position < 0) {
      this.setRangeStartEntireElement(range);
    } else if (this.element.childNodes.length > 0) {
      range.setStart(this.element.childNodes[0], position);
    } else {
      range.setStart(this.element, 0);
    }
  }

  setRangeEnd(
    /** @type{Range}  */
    range,
    /** @type {number} */
    position,
  ) {
    if (!this.isAtomEditable() || position < 0) {
      this.setRangeEndEntireElement(range);
    } else if (this.element.childNodes.length > 0) {
      range.setEnd(this.element.childNodes[0], position);
    } else {
      range.setEnd(this.element, 0);
    }
  }

  setCaretPosition(
    /** @type {number}*/
    position,
  ) {
    let selection = window.getSelection();
    if (this.element !== null) {
      if (selection.rangeCount <= 0) {
        this.element.focus();
      }
    }
    let range = document.createRange();
    let collapseToStart = true;
    if (position >= this.element.textContent.length) {
      collapseToStart = false;
      range.selectNodeContents(this.element);
    } else if (position > 0) {
      collapseToStart = false;
      this.setRangeStart(range, position);
    } else {
      collapseToStart = true;
      this.setRangeStart(range, 0);
    }
    // console.log(`Position: ${position}, range ${range}, collapseToStart: ${collapseToStart} start offset: ${range.startOffset}, end offset: ${range.endOffset}, text len: ${this.element.textContent.length}`);
    range.collapse(collapseToStart);
    this.equationEditor.resetSelectionDOM();
    selection.addRange(range);
    this.positionCaretBeforeKeyEvents = position;
    //    this.element.focus();
  }

  isDetached() {
    let ancestor = this;
    while (ancestor.parent !== null) {
      ancestor = ancestor.parent;
    }
    return ancestor.type.type !== knownTypes.root.type;
  }

  toString() {
    const result = [];
    if (this.isAtomic()) {
      result.push(this.textContentOrInitialContent());
    }
    result.push(`[${this.type.type}]`);
    if (this.children.length > 0) {
      result.push("{");
      for (let i = 0; i < this.children.length; i++) {
        if (this.children[i] === null) {
          result.push("null");
          continue;
        }
        result.push(this.children[i].toString());
        if (i !== this.children.length - 1) {
          result.push(",");
        }
      }
      result.push("}");
    }
    return result.join("");
  }

  /**@returns{HTMLElement[]} */
  toHtmlDebugData(
    /** @type{number} */
    indentationLevel,
  ) {
    if (indentationLevel === null || indentationLevel === undefined) {
      indentationLevel = 0;
    }
    const indentation = "-".repeat(indentationLevel);
    const result = [];
    let content = `${indentation}${this.type.type}`;
    if (this.element !== null) {
      content += `[${this.element.textContent}]`;
    }
    if (this.focused) {
      content += ", F";
    }
    if (this.desiredCaretPosition !== - 1) {
      content += `, FD[${this.desiredCaretPosition}]`;
    }
    if (this.boundingBox.width !== 0) {
      content += `, w: ${this.boundingBox.width}`;
    }
    if (this.boundingBox.height !== 0) {
      content += `, h: ${this.boundingBox.height}`;
    }
    if (this.boundingBox.left !== 0) {
      content += `, l: ${this.boundingBox.left}`;
    }
    if (this.boundingBox.top !== 0) {
      content += `, t: ${this.boundingBox.top}`;
    }
    if (this.boundingBox.fractionLineHeight !== 0) {
      content += `, fl: ${this.boundingBox.fractionLineHeight}`;
    }
    if (this.type.type === knownTypes.atom.type) {
      content += `, caret: ${this.positionCaretBeforeKeyEvents}, `;
    }
    result.push(document.createTextNode(content));
    for (let i = 0; i < this.children.length; i++) {
      let childrenElements = this.children[i].toHtmlDebugData(indentationLevel + 1);
      for (let j = 0; j < childrenElements.length; j++) {
        result.push(childrenElements[j]);
      }
    }
    return result;
  }

  /** @returns {LatexWithAnnotation} */
  toLatexWithAnnotationAtomic(
    /**@type{ToLatexOptions|null} */
    options,
  ) {
    let selectionStart = - 1;
    let selectionEnd = - 1;
    if (this === this.equationEditor.selectionStartExpanded.element) {
      let position = this.equationEditor.selectionStartExpanded.position;
      if (this.equationEditor.selectionStartToTheLeftOfSelectionEnd()) {
        selectionStart = position;
      } else {
        selectionEnd = position;
      }
    }
    if (this === this.equationEditor.selectionEndExpanded.element) {
      let position = this.equationEditor.selectionEndExpanded.position;
      if (this.equationEditor.selectionStartToTheLeftOfSelectionEnd()) {
        selectionEnd = position;
      } else {
        selectionStart = position;
      }
    }
    let positionCaret = - 1;
    if (this.focused && options !== null && options.useCaretCommand) {
      positionCaret = this.positionCaretBeforeKeyEvents;
    }
    let result = latexConstants.convertUtf16ToLatex(
      this.contentIfAtomic(),
      selectionStart,
      selectionEnd,
      positionCaret,
    );
    return result.accountOwner(this);
  }

  /** @returns{string} */
  toLatex() {
    return this.toLatexWithAnnotation(null).latex;
  }

  /** @returns {LatexWithAnnotation} */
  toLatexWithAnnotation(
    /**@type{ToLatexOptions|null} */
    options,
  ) {
    let toJoin = [];
    let charactersSoFar = 0;
    let result = new LatexWithAnnotation("", - 1, - 1);
    for (let i = 0; i < this.children.length; i++) {
      let child = this.children[i];
      if (child === null) {
        toJoin.push("[[null]]");
        continue;
      }
      let childLatex = child.toLatexWithAnnotation(options);
      result.accountChild(childLatex, charactersSoFar);
      toJoin.push(childLatex.latex);
      charactersSoFar += childLatex.latex.length;
    }
    result.latex = toJoin.join("");
    result.accountOwner(this);
    return result;
  }

  /** If the element is a matrix, fetches its last row.
   * @returns {MathNode|null}
   */
  getLastMatrixRow() {
    if (this.type.type !== knownTypes.matrix.type) {
      return null;
    }
    let matrixTable = this.children[0].children[1];
    if (matrixTable.children.length === 0) {
      return null;
    }
    return matrixTable.children[matrixTable.children.length - 1];
  }

  getMatrixCell(
    /**@type {number} */
    rowIndex,
    /**@type {number} */
    columnIndex,
  ) {
    if (this.type.type !== knownTypes.matrix.type) {
      return null;
    }
    let matrixTable = this.children[0].children[1];
    if (rowIndex >= matrixTable.children.length) {
      return null;
    }
    let row = matrixTable.children[rowIndex];
    if (columnIndex >= row.children.length) {
      return null;
    }
    return row.children[columnIndex];
  }

  matrixColumnCount() {
    if (this.type.type !== knownTypes.matrix.type) {
      return - 1;
    }
    let matrixTable = this.children[0].children[1];
    let columnCount = 0;
    let numberOfRows = matrixTable.children.length;
    for (let i = 0; i < numberOfRows; i++) {
      columnCount = Math.max(columnCount, matrixTable.children[i].children.length);
    }
    return columnCount;
  }

  /** Ensures that a matrix has rows with equal number of columns. */
  normalizeMatrix() {
    let matrixTable = this.children[0].children[1];
    let columnCount = this.matrixColumnCount();
    let numberOfRows = matrixTable.children.length;
    // Last empty row is ignored. Previous empty rows are preserved.
    if (matrixTable.children[numberOfRows - 1].children.length === 0) {
      numberOfRows--;
      matrixTable.removeChild(numberOfRows);
    }
    // Expand rows to the colum count.
    for (let i = 0; i < matrixTable.children.length; i++) {
      let child = matrixTable.children[i];
      for (let j = child.children.length; j < columnCount; j++) {
        child.appendChild(mathNodeFactory.matrixRowEntry(this.equationEditor, null));
      }
    }
  }
}

class MathNodeAtom extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.atom);
  }

  /** @returns {LatexWithAnnotation} */
  toLatexWithAnnotation(
    /**@type{ToLatexOptions|null} */
    options,
  ) {
    return this.toLatexWithAnnotationAtomic(options);
  }
}

class MathNodeAtomImmutable extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.atomImmutable);
  }

  /** @returns {LatexWithAnnotation} */
  toLatexWithAnnotation(
    /**@type{ToLatexOptions|null} */
    options,
  ) {
    return this.toLatexWithAnnotationAtomic(options);
  }

  /** @returns {boolean} whether backspace was applied */
  applyBackspaceToTheRight() {
    let parent = this.parent;
    parent.children[this.indexInParent + 1].desiredCaretPosition = 0;
    parent.removeChild(this.indexInParent);
    parent.normalizeHorizontalMath();
    parent.updateDOM();
    parent.focusRestore();
    return true;
  }
}

class MathNodeFraction extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.fraction);
  }

  /** @returns {LatexWithAnnotation} */
  toLatexWithAnnotation(
    /**@type{ToLatexOptions|null} */
    options,
  ) {
    let numerator = this.children[0].toLatexWithAnnotation(options);
    let denominator = this.children[1].toLatexWithAnnotation(options);
    let result = new LatexWithAnnotation(`\\frac{${numerator.latex}}{${denominator.latex}}`, - 1, - 1);
    result.accountChild(numerator, 6);
    result.accountChild(denominator, 6 + numerator.latex.length + 2);
    result.accountOwner(this);
    if (this.children.length <= 2) {
      return result;
    }
    // This is not expected to happen: a fraction should have exactly two children.
    // console.log("Warning: corrupt fraction.");
    result.latex += "[";
    for (let i = 2; i < this.children.length; i++) {
      result.latex += this.children[i].toLatex();
    }
    result.latex += "]";
    return result.accountOwner(this);
  }

  applyBackspaceToTheRight() {
    return this.applyBackspaceToTheRightAsLeftArrow();
  }
}

class MathNodeNumerator extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.numerator);
  }
  /** @returns {boolean} whether reduction occurred. */
  applyBackspaceToTheLeft() {
    return this.applyBackspaceToTheLeftWrapperChildWithSiblingWrapper();
  }
}

class MathNodeDenominator extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.denominator);
  }
  /** @returns {boolean} whether reduction occurred. */
  applyBackspaceToTheLeft() {
    return this.applyBackspaceToTheLeftWrapperChildWithSiblingWrapper();
  }
}

class MathNodeBaseWithExponent extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.baseWithExponent);
  }

  /** @returns {LatexWithAnnotation} */
  toLatexWithAnnotation(
    /**@type{ToLatexOptions|null} */
    options,
  ) {
    let base = this.children[0];
    let baseLatex = base.toLatex();
    let exponent = this.children[1].toLatex();
    let useBracesInBase = false;
    if (base.type.type === knownTypes.fraction.type) {
      useBracesInBase = true;
    }
    if (useBracesInBase) {
      return new LatexWithAnnotation(
        `{${baseLatex}}^{${exponent}}`,
        - 1,
        - 1,
      );
    } else {
      return new LatexWithAnnotation(
        `${baseLatex}^{${exponent}}`,
        - 1,
        - 1,
      );
    }
  }

  applyBackspaceToTheRight() {
    return this.applyBackspaceToTheRightAsLeftArrow();
  }

  applyBackspaceToTheLeft() {
    return this.applyBackspaceToTheLeftAsLeftArrow();
  }

  computeDimensions() {
    let base = this.children[0];
    let exponent = this.children[1];
    let overlapRatio = 0.35;
    if (this.requiresTallExponent(base)) {
      overlapRatio = 0.1;
    }
    let overlap = base.boundingBox.height * overlapRatio;
    this.boundingBox.height = exponent.boundingBox.height + base.boundingBox.height - overlap;
    if (exponent.boundingBox.height > this.boundingBox.height) {
      this.boundingBox.height = exponent.boundingBox.height;
    }
    base.boundingBox.top = exponent.boundingBox.height - overlap;
    if (base.boundingBox.top < 0) {
      // The exponent is so small relative to the base that it 
      // fits entirely in the overlap between the base and the exponent.
      exponent.boundingBox.top = - base.boundingBox.top;
      base.boundingBox.top = 0;
    }
    base.boundingBox.left = 0;
    let baseWithSubscript = null;
    if (base.type.type === knownTypes.horizontalMath.type) {
      if (base.children.length === 1) {
        if (base.children[0].type.type === knownTypes.baseWithSubscript.type) {
          baseWithSubscript = base.children[0];
        }
      }
    }
    if (baseWithSubscript === null) {
      this.boundingBox.width = base.boundingBox.width + exponent.boundingBox.width;
      this.boundingBox.superScriptWidth = exponent.boundingBox.width;
      exponent.boundingBox.left = base.boundingBox.width;
    } else {
      this.boundingBox.width = Math.max(
        baseWithSubscript.boundingBox.width +
        exponent.boundingBox.width -
        baseWithSubscript.boundingBox.subScriptWidth,
        baseWithSubscript.boundingBox.width,
      );
      this.boundingBox.superScriptWidth = 0;
      this.boundingBox.subScriptWidth = 0;
      exponent.boundingBox.left = base.boundingBox.width - baseWithSubscript.boundingBox.subScriptWidth;

    }
    this.boundingBox.fractionLineHeight = base.boundingBox.top + base.boundingBox.fractionLineHeight;
    this.computeMiddleAlignment();
  }
}

class MathNodeHorizontalMath extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.horizontalMath);
  }
}

class MathNodeGenericBox extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.genericMathBox);
  }
}

class MathNodeRoot extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.root);
  }

  computeDimensions() {
    this.computeDimensionsStandard();
    if (!this.boundingBox.needsMiddleAlignment || this.equationEditor.options.editable) {
      return;
    }
    let bottomDistance = this.boundingBox.height - this.boundingBox.fractionLineHeight;
    if (bottomDistance > this.boundingBox.fractionLineHeight) {
      this.boundingBox.height = bottomDistance * 2;
      this.boundingBox.top += bottomDistance - this.boundingBox.fractionLineHeight;
      this.boundingBox.fractionLineHeight = bottomDistance;
    } else {
      this.boundingBox.height = this.boundingBox.fractionLineHeight * 2;
    }
  }
}

class MathNodeError extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.error);
  }
  applyBackspaceToTheRight() {
    let parent = this.parent;
    parent.children[this.indexInParent + 1].desiredCaretPosition = 0;
    parent.removeChild(this.indexInParent);
    parent.normalizeHorizontalMath();
    parent.updateDOM();
    parent.focusRestore();
    return true;
  }
}

class MathNodeCancel extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.cancel);
  }

  toLatexWithAnnotation(
    /**@type{ToLatexOptions|null} */
    options,
  ) {
    let childLatex = this.children[1].toLatex();
    return new LatexWithAnnotation(`\\cancel{${childLatex}}`, - 1, - 1);
  }

  applyBackspaceToTheRight() {
    this.applyBackspaceToTheRightAsLeftArrow();
  }

  computeDimensions() {
    let content = this.children[1];
    content.boundingBox.left = 0;
    this.boundingBox.height = content.boundingBox.height;
    this.boundingBox.width = content.boundingBox.width;
    this.boundingBox.fractionLineHeight = content.boundingBox.fractionLineHeight;
    let cancelSign = this.children[0];
    cancelSign.boundingBox.width = 4;
    cancelSign.boundingBox.height = content.boundingBox.height;
    cancelSign.boundingBox.left = 0;
    if (cancelSign.element !== null) {
      cancelSign.element.style.width = cancelSign.boundingBox.width;
      cancelSign.element.style.height = cancelSign.boundingBox.height;
    }
    let stretch = content.boundingBox.width / cancelSign.boundingBox.height;
    cancelSign.boundingBox.transformOrigin = "top left";
    cancelSign.boundingBox.transform = `matrix(1,0,${-stretch},1,${content.boundingBox.width},0)`;
  }
}

class MathNodeCancelUnderBox extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.cancelUnderBox);
  }
  /** @returns {boolean} whether reduction occurred. */
  applyBackspaceToTheLeft() {
    let cancel = this.parent;
    let indexCancel = cancel.indexInParent;
    let content = this.children[0];
    content.children[0].desiredCaretPosition = 0;
    let parent = cancel.parent;
    parent.replaceChildAtPosition(indexCancel, content.children[0]);
    parent.normalizeHorizontalMath();
    parent.updateDOM();
    parent.focusRestore();
    return true;
  }
}

class MathNodeSqrtSign extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.sqrtSign);
  }
}

class MathNodeSqrt extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.sqrt);
  }

  /** @returns {LatexWithAnnotation} */
  toLatexWithAnnotation(
    /**@type{ToLatexOptions|null} */
    options,
  ) {
    if (this.element === null) {
      return new LatexWithAnnotation("[null(]", - 1, - 1);
    }
    let result = new LatexWithAnnotation("", -1, -1);
    let exponent = null;
    let underTheRadical = null;
    if (this.children.length > 0) {
      exponent = this.children[0].toLatexWithAnnotation(options);
    }
    if (this.children.length > 2) {
      underTheRadical = this.children[2].toLatexWithAnnotation(options);
    }
    if (exponent !== null) {
      if (exponent.latex !== "") {
        result.latex = `\\sqrt[${exponent.latex}]{${underTheRadical.latex}}`;
        result.accountChild(exponent, 6);
        result.accountChild(underTheRadical, exponent.latex.length + 6 + 2);
        result.accountOwner(this);
        return result;
      }
    }
    result.latex = `\\sqrt{${underTheRadical.latex}}`;
    result.accountChild(underTheRadical, 6);
    result.accountOwner(this);
    return result;
  }
  applyBackspaceToTheRight() {
    return this.applyBackspaceToTheRightAsLeftArrow();
  }
}

class MathNodeOverLine extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.overLinedBox);
  }
}

class MathNodeOverBrace extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.overBrace);
  }
}

class MathNodeExponent extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.exponent);
  }
  applyBackspaceToTheLeft() {
    return this.applyBackspaceToTheLeftChildWithSiblingWrapper();
  }
}

class MathNodeSubscript extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.subscript);
  }
  applyBackspaceToTheLeft() {
    return this.applyBackspaceToTheLeftChildWithSiblingWrapper();
  }
}

class MathNodeBaseWithSubscript extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.baseWithSubscript);
  }

  /** @returns {LatexWithAnnotation} */
  toLatexWithAnnotation(
    /**@type{ToLatexOptions|null} */
    options,
  ) {
    return new LatexWithAnnotation(`{${this.children[0].toLatex()}}_{${this.children[1].toLatex()}}`, - 1, - 1);
  }

  applyBackspaceToTheRight() {
    return this.applyBackspaceToTheRightAsLeftArrow();
  }
}

class MathNodeLeftDelimiter extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.leftDelimiter);
  }

  /** @returns {LatexWithAnnotation} */
  toLatexWithAnnotation(
    /**@type{ToLatexOptions|null} */
    options,
  ) {
    /**@type{LatexWithAnnotation} */
    let result = null;
    if (this.children.length === 0) {
      result = new LatexWithAnnotation("\\left.", -1, -1);
    } else if (this.extraData === "{") {
      result = new LatexWithAnnotation("\\{", -1, -1);
    } else {
      result = new LatexWithAnnotation(this.extraData, - 1, - 1);
    }
    result.accountOwner(this);
    return result;
  }

  /** @returns {boolean} whether reduction occurred. */
  applyBackspaceToTheRight() {
    return this.applyBackspaceToTheRightDelimiter();
  }
}

class MathNodeRightDelimiter extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.rightDelimiter);
  }

  /** @returns {LatexWithAnnotation} */
  toLatexWithAnnotation(
    /**@type{ToLatexOptions|null} */
    options,
  ) {
    /**@type{LatexWithAnnotation} */
    let result = null;
    if (this.children.length === 0) {
      result = new LatexWithAnnotation("\\right.", -1, -1);
    } else if (this.extraData === "{") {
      result = new LatexWithAnnotation("\\}", -1, -1);
    } else {
      result = new LatexWithAnnotation(this.extraData, - 1, - 1);
    }
    result.accountOwner(this);
    return result;
  }

  /** @returns {boolean} whether reduction occurred. */
  applyBackspaceToTheRight() {
    return this.applyBackspaceToTheRightDelimiter();
  }
}

class MathNodeDelimiterMark extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
    /**@type {boolean} */
    left,
  ) {
    super(equationEditor, left ? knownTypes.leftDelimiterMark : knownTypes.rightDelimiterMark);
    this.parenthesisThickness = 0;
  }
  verticallyStretchCommon(
    /** @type {number}*/
    heightToEnclose,
    /** @type {number}*/
    fractionLineHeightEnclosed,
  ) {
    let scaleHeight = 1.1;
    this.parenthesisThickness = heightToEnclose / 24;
    this.parenthesisThickness = Math.min(3, this.parenthesisThickness);
    this.parenthesisThickness = Math.max(1.5, this.parenthesisThickness);
    heightToEnclose = Math.max(2 * fractionLineHeightEnclosed, 2 * (heightToEnclose - fractionLineHeightEnclosed));
    this.boundingBox.top = 0;
    this.boundingBox.height = heightToEnclose * scaleHeight;
    this.boundingBox.fractionLineHeight = this.boundingBox.height / 2;
  }
}

class MathNodeAbsoluteValue extends MathNodeDelimiterMark {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
    /**@type {boolean} */
    left,
  ) {
    super(equationEditor, left);
    this.left = left;
  }
  verticallyStretch(
    /** @type {number}*/
    heightToEnclose,
    /** @type {number}*/
    fractionLineHeightEnclosed,
  ) {
    this.verticallyStretchCommon(heightToEnclose, fractionLineHeightEnclosed);
    this.boundingBox.width = Math.max(heightToEnclose / 6, 3);
    this.element.style.borderWidth = `${this.parenthesisThickness}px`;
  }
}

class MathNodeSquareBrackets extends MathNodeDelimiterMark {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
    /**@type {boolean} */
    left,
  ) {
    super(equationEditor, left);
    this.left = left;
  }

  verticallyStretch(
    /** @type {number}*/
    heightToEnclose,
    /** @type {number}*/
    fractionLineHeightEnclosed,
  ) {
    this.verticallyStretchCommon(heightToEnclose, fractionLineHeightEnclosed);
    let shift = 2;
    this.boundingBox.width = Math.max(heightToEnclose / 6, 3);
    if (this.left) {
      this.boundingBox.left = shift;
    } else {
      this.boundingBox.left = - shift;
    }
    if (this.element !== null) {
      this.element.style.borderWidth = `${this.parenthesisThickness}px`;
      this.element.style.borderTop = `solid`;
      this.element.style.borderBottom = `solid`;
    }
  }
}

class MathNodeAngleBrackets extends MathNodeDelimiterMark {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
    /**@type {boolean} */
    left,
  ) {
    super(equationEditor, left);
    this.left = left;
  }

  verticallyStretch(
    /** @type {number}*/
    heightToEnclose,
    /** @type {number}*/
    fractionLineHeightEnclosed,
  ) {
    this.verticallyStretchCommon(heightToEnclose, fractionLineHeightEnclosed);
    let topBar = this.children[0];
    let bottomBar = this.children[1];
    let halfHeight = this.boundingBox.height / 2;
    let width = heightToEnclose / 6;
    topBar.boundingBox.height = halfHeight;
    bottomBar.boundingBox.height = halfHeight;
    topBar.boundingBox.width = this.parenthesisThickness;
    bottomBar.boundingBox.width = this.parenthesisThickness;
    bottomBar.boundingBox.top = halfHeight;

    let margin = 2;
    topBar.boundingBox.left = margin;
    bottomBar.boundingBox.left = margin;

    topBar.boundingBox.transformOrigin = "top left";
    bottomBar.boundingBox.transformOrigin = "top left";
    let scale = width / halfHeight;

    if (this.left) {
      topBar.boundingBox.transform = `matrix(1,0,${-scale},1,${width},0)`;
      bottomBar.boundingBox.transform = `matrix(1,0,${scale},1,0,0)`;
    } else {
      topBar.boundingBox.transform = `matrix(1,0,${scale},1,0,0)`;
      bottomBar.boundingBox.transform = `matrix(1,0,${-scale},1,${width},0)`;
    }
    this.element.style.borderLeft = "";
    this.element.style.borderRight = "";
    this.boundingBox.width = Math.max(width + 2 * margin + 2 * this.parenthesisThickness, 3);
    this.element.style.borderWidth = `${this.parenthesisThickness}px`;
  }
}

class MathNodeParenthesis extends MathNodeDelimiterMark {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
    /**@type {boolean} */
    left,
  ) {
    super(equationEditor, left);
    this.left = left;
  }
  verticallyStretch(
    /** @type {number}*/
    heightToEnclose,
    /** @type {number}*/
    fractionLineHeightEnclosed,
  ) {
    this.verticallyStretchCommon(heightToEnclose, fractionLineHeightEnclosed);
    this.boundingBox.width = Math.min(this.boundingBox.height / 4, 20);
    this.element.style.borderLeft = "";
    this.element.style.borderRight = "";
    let scale = this.boundingBox.width / this.boundingBox.height;

    let radius = this.boundingBox.height / 2;
    let child = this.children[0];
    child.element.style.borderRadius = `${radius}px`;
    child.element.style.borderWidth = `${this.parenthesisThickness / scale}px`;
    child.boundingBox.width = this.boundingBox.height;
    child.boundingBox.height = this.boundingBox.height;
    child.boundingBox.transformOrigin = "top left";
    let shift = this.boundingBox.width / 3.5;
    if (this.left) {
      child.boundingBox.left = shift;
    } else {
      child.boundingBox.left = - shift;
    }
    child.boundingBox.transform = `matrix(${scale},0,0,1,0,0)`;
  }
}

class MathNodeCurlyBrace extends MathNodeDelimiterMark {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
    /**@type {boolean} */
    left,
  ) {
    super(equationEditor, left);
    this.left = left;
  }
  verticallyStretch(
    /** @type {number}*/
    heightToEnclose,
    /** @type {number}*/
    fractionLineHeightEnclosed,
  ) {
    this.verticallyStretchCommon(heightToEnclose, fractionLineHeightEnclosed);
    let topBar = this.children[1];
    let bottomBar = this.children[4];
    let radius = Math.floor(this.boundingBox.height / 12);
    if (radius < 2) {
      radius = 2;
    }
    let heightBar = (this.boundingBox.height - 4 * radius) / 2;
    this.boundingBox.width = radius * 2 + 1;
    this.boundingBox.height += radius;
    let borderWidthString = `${this.parenthesisThickness}px`;

    topBar.boundingBox.width = this.parenthesisThickness;
    topBar.boundingBox.top = radius;
    topBar.boundingBox.height = heightBar;
    topBar.boundingBox.left = radius;
    topBar.element.style.borderWidth = borderWidthString;

    bottomBar.boundingBox.width = this.parenthesisThickness;
    bottomBar.boundingBox.height = heightBar;
    bottomBar.boundingBox.top = heightBar + radius * 3;
    bottomBar.boundingBox.left = radius;
    bottomBar.element.style.borderWidth = borderWidthString;
    let topQuarterCircle = this.children[0];
    let topMiddleQuarterCircle = this.children[2];
    let bottomMiddleQuarterCircle = this.children[3];
    let bottomQuarterCircle = this.children[5];
    let allQuarterCircles = [topQuarterCircle, topMiddleQuarterCircle, bottomMiddleQuarterCircle, bottomQuarterCircle];
    for (let i = 0; i < allQuarterCircles.length; i++) {
      let quarterCircle = allQuarterCircles[i];
      quarterCircle.boundingBox.width = radius;
      quarterCircle.boundingBox.height = radius;
      quarterCircle.element.style.borderWidth = borderWidthString;
    }
    let radiusString = `${radius}px`;
    topQuarterCircle.boundingBox.top = 0;
    topQuarterCircle.boundingBox.left = this.left ? radius : 0;

    topMiddleQuarterCircle.boundingBox.top = heightBar + radius;
    topMiddleQuarterCircle.boundingBox.left = this.left ? 0 : radius;

    bottomMiddleQuarterCircle.boundingBox.top = heightBar + 2 * radius;
    bottomMiddleQuarterCircle.boundingBox.left = this.left ? 0 : radiusString;

    bottomQuarterCircle.boundingBox.top = 2 * heightBar + 3 * radius;
    bottomQuarterCircle.boundingBox.left = this.left ? radius : 0;
    if (this.element !== null) {
      this.element.style.borderLeft = "";
      this.element.style.borderRight = "";
    }
    let borderStyleString = `solid ${borderWidthString}`;
    if (this.left) {
      topQuarterCircle.element.style.borderTopLeftRadius = radiusString;
      topQuarterCircle.element.style.borderLeft = borderStyleString;

      topMiddleQuarterCircle.element.style.borderBottomRightRadius = radiusString;
      topMiddleQuarterCircle.element.style.borderRight = borderStyleString;

      bottomMiddleQuarterCircle.element.style.borderTopRightRadius = radiusString;
      bottomMiddleQuarterCircle.element.style.borderRight = borderStyleString;

      bottomQuarterCircle.element.style.borderBottomLeftRadius = radiusString;
      bottomQuarterCircle.element.style.borderLeft = borderStyleString;
    } else {
      topQuarterCircle.element.style.borderTopRightRadius = radiusString;
      topQuarterCircle.element.style.borderRight = borderStyleString;

      topMiddleQuarterCircle.element.style.borderBottomLeftRadius = radiusString;
      topMiddleQuarterCircle.element.style.borderLeft = borderStyleString;

      bottomMiddleQuarterCircle.element.style.borderTopLeftRadius = radiusString;
      bottomMiddleQuarterCircle.element.style.borderLeft = borderStyleString;

      bottomQuarterCircle.element.style.borderBottomRightRadius = radiusString;
      bottomQuarterCircle.element.style.borderRight = borderStyleString;
    }
  }
}

class MathNodeMatrix extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.matrix);
  }

  /** @returns {LatexWithAnnotation} */
  toLatexWithAnnotation(
    /**@type{ToLatexOptions|null} */
    options,
  ) {
    if (this.element === null) {
      return new LatexWithAnnotation("[null)]", - 1, - 1);
    }
    let matrixContent = this.children[0].children[1];
    let result = [];
    result.push("\\begin{pmatrix}");
    let rows = [];
    for (let i = 0; i < matrixContent.children.length; i++) {
      let matrixRow = matrixContent.children[i];
      let currentRowStrings = [];
      for (let j = 0; j < matrixRow.children.length; j++) {
        let entry = matrixRow.children[j];
        currentRowStrings.push(entry.toLatex());
      }
      rows.push(currentRowStrings.join("&"));
    }
    result.push(rows.join("\\\\"));
    result.push("\\end{pmatrix}");
    return new LatexWithAnnotation(result.join(""), - 1, - 1);
  }

  applyBackspaceToTheRight() {
    let parent = this.parent;
    parent.removeChild(this.indexInParent);
    parent.normalizeHorizontalMath();
    parent.updateDOM();
    parent.focusRestore();
    return true;
  }
}

class MathNodeRadicalUnderBox extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.radicalUnderBox);
  }
  /** @returns {boolean} whether reduction occurred. */
  applyBackspaceToTheLeft() {
    let sqrt = this.parent;
    let indexSqrt = sqrt.indexInParent;
    let exponent = sqrt.children[0].children[0];
    this.children[0].children[0].desiredCaretPosition = 0;
    let parent = sqrt.parent;
    parent.replaceChildAtPositionWithChildren(indexSqrt, [exponent, sqrt.children[2].children[0]]);
    parent.normalizeHorizontalMath();
    parent.updateDOM();
    parent.focusRestore();
    return true;
  }
}

class MathNodeMatrixRow extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.matrixRow);
  }
}

class MathNodeRowEntry extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.matrixRowEntry);
  }
}

class MathNodeVerticalLine extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.verticalLineInTable);
  }
}

class MathNodeOperatorWithSuperAndSubscript extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.operatorWithSuperAndSubscript);
  }

  /** @returns {LatexWithAnnotation} */
  toLatexWithAnnotation(
    /**@type{ToLatexOptions|null} */
    options,

  ) {
    let top = this.children[0].toLatex();
    let result = this.children[1].toLatex();
    let bottom = this.children[2].toLatex();
    if (bottom !== "") {
      result += `_{${bottom}}`;
    }
    if (top !== "") {
      result += `^{${top}}`;
    }
    return new LatexWithAnnotation(result, - 1, - 1);
  }
  applyBackspaceToTheRight() {
    return this.applyBackspaceToTheRightAsLeftArrow();
  }
}

class MathNodeOperatorStandalone extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.operatorStandalone);
  }

  /** @returns {LatexWithAnnotation} */
  toLatexWithAnnotation(
    /**@type{ToLatexOptions|null} */
    options,
  ) {
    latexConstants.computeUtf16ToLatexMap();
    const content = this.textContentOrInitialContent();
    if (content in latexConstants.utf16ToLatexMap) {
      return new LatexWithAnnotation(latexConstants.utf16ToLatexMap[content]);
    }
    return new LatexWithAnnotation(`${content}`, - 1, - 1);
  }
}

class MathNodeOperatorWithSubscript extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.operatorWithSubscript);
  }
}

class MathNodeOperatorSubscript extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.operatorSubscript);
  }
  applyBackspaceToTheLeft() {
    return this.applyBackspaceToTheLeftEndOfOperatorSubscript();
  }
}

class MathNodeOperatorSuperscript extends MathNode {
  constructor(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    super(equationEditor, knownTypes.operatorSuperscript);
  }
  applyBackspaceToTheLeft() {
    return this.applyBackspaceToTheLeftEndOfOperatorSubscript();
  }
}

class VerticalBarData {
  constructor(
    /**@type {number} */
    columnIndex,
    /**@type {number} */
    stripIndex,
  ) {
    this.columnIndex = columnIndex;
    this.stripIndex = stripIndex;
  }
}

class LatexColumnStyleIterator {
  constructor(/**@type{string} */ style) {
    this.style = style;
    this.nextStyleStartCharacter = 0;
    this.currentColumnAlignment = "";
    this.verticalBarRightCount = 0;
    this.verticalBarLeftCount = 0;
    this.exhausted = false;
  }

  reset() {
    this.nextStyleStartCharacter = 0;
    this.currentColumnAlignment = "";
    this.verticalBarRightCount = 0;
    this.verticalBarLeftCount = 0;
    this.exhausted = false;
  }

  next() {
    this.currentColumnAlignment = "";
    this.verticalBarRightCount = 0;
    this.verticalBarLeftCount = 0;
    if (this.nextStyleStartCharacter >= this.style.length) {
      this.exhausted = true;
      return;
    }
    for (let i = this.nextStyleStartCharacter; i < this.style.length; i++) {
      let next = this.style[i];
      if (next === "c" || next === "r" || next === "l") {
        if (this.currentColumnAlignment !== "") {
          return;
        }
        this.currentColumnAlignment = next;
      }
      this.nextStyleStartCharacter = i + 1;
      if (next === "|") {
        if (this.currentColumnAlignment === "") {
          this.verticalBarLeftCount++;
        } else {
          this.verticalBarRightCount++;
        }
      }
    }
  }

  applyStyleToMatrix(
    /** @type{MathNode} */
    matrix,
  ) {
    if (matrix.type.type !== knownTypes.matrix.type) {
      return;
    }
    let matrixTable = matrix.children[0].children[1];
    // Expand rows to the colum count.
    for (let i = 0; i < matrixTable.children.length; i++) {
      let row = matrixTable.children[i];
      this.applyStyleToRow(row);
    }
  }

  applyStyleToRow(
    /** @type{MathNode} */
    row,
  ) {
    this.reset();
    this.next();
    for (let j = 0; j < row.children.length && !this.isExhausted(); j++, this.next()) {
      row.children[j].latexExtraStyle = this.currentColumnAlignment;
    }
  }

  /** @returns{MathNode[]} Given matrix column style such as {c|c}, generates the vertical bars.
   * Example: \begin{array}{c|c}1&2\end{array}.
   */
  verticalSeparators(
    /** @type {EquationEditor} */
    equationEditor,
  ) {
    this.reset();
    this.next();
    let result = [];
    let columnCount = 0;
    for (; !this.isExhausted(); this.next()) {
      for (let i = 0; i < this.verticalBarLeftCount; i++) {
        result.push(mathNodeFactory.matrixVerticalLine(
          equationEditor, columnCount, i,
        ));
      }
      columnCount++;
      for (let i = 0; i < this.verticalBarRightCount; i++) {
        result.push(mathNodeFactory.matrixVerticalLine(
          equationEditor, columnCount, i,
        ));
      }
    }
    return result;
  }

  /** @returns {string} */
  borderFromVerticalBarCount(
    /**@type {number} */
    verticalBars,
  ) {
    if (verticalBars <= 0) {
      return "";
    }
    if (verticalBars === 1) {
      return "1px solid black";
    }
    return "1px double black";
  }

  /**@returns {boolean} */
  isExhausted() {
    return this.exhausted;
  }
}

class ParentWithIndex {
  constructor(
    /** @type{MathNode} */
    parent,
    /**@type{number} */
    indexInParent,
  ) {
    /** @type{MathNode} */
    this.parent = parent;
    /** @type{number} */
    this.indexInParent = indexInParent;
  }
}

class MathTagData {
  constructor(
    /**@type {number} */
    startIndex,
    /**@type {number} */
    startIndexData,
    /**@type {number} */
    closeIndexData,
    /**@type {number} */
    closeIndex,
    /**@type{string} */
    ambientContent,
  ) {
    this.startIndex = startIndex;
    this.startIndexData = startIndexData;
    this.closeIndexData = closeIndexData;
    this.closeIndex = closeIndex;
    this.content = ambientContent.slice(this.startIndexData, closeIndexData + 1);
  }
}

class MathTagCoverter {
  constructor(
    /**@type{string} */
    style,
    /**@type{boolean} */
    sanitizeLatexSource,
    /**@type{boolean} whether to remove \\displaystyle from latex source.*/
    removeDisplayStyle,
    /**@type{boolean} whether to log timing information. */
    logTiming,
  ) {
    /**@type{HTMLElement|null} */
    this.elementProcessed = null;
    /**@type{number} */
    this.startTime = 0;
    /**@type{number} */
    this.lastTimeSample = 0;
    /**@type{number} */
    this.typesetTimeout = 50;
    /**@type{number} */
    this.elementsToTypeset = - 1;
    /**@type{number} */
    this.typesetTotal = 0;
    let styleComputer = document.createElement("DIV");
    styleComputer.style = style;
    /**@type{boolean} */
    this.sanitizeLatexSource = sanitizeLatexSource;
    /**@type{boolean} */
    this.removeDisplayStyle = removeDisplayStyle;
    /**@type{boolean} */
    this.logTiming = logTiming;
    this.style = {
      fontFamily: styleComputer.style.fontFamily,
      display: styleComputer.style.display,
      fontSize: styleComputer.style.fontSize,
      verticalAlign: styleComputer.style.verticalAlign,
      marginBottom: styleComputer.style.marginBottom,
    };
  }

  convertTags(
    /**@type{HTMLElement} */
    toBeModified,
    /**@type{MathTagData[]} */
    toBeConverted,
  ) {
    if (toBeConverted.length === 0) {
      return;
    }
    let content = toBeModified.textContent;
    let newChildren = [];
    for (let i = 0; i < toBeConverted.length; i++) {
      let previousIndex = 0;
      if (i > 0) {
        previousIndex = toBeConverted[i - 1].closeIndex + 1;
      }
      let intermediateContent = content.slice(previousIndex, toBeConverted[i].startIndex);
      if (intermediateContent.length > 0) {
        newChildren.push(document.createTextNode(intermediateContent));
      }
      let mathTag = document.createElement("DIV");
      mathTag.className = "mathcalculator";
      mathTag.textContent = toBeConverted[i].content;
      mathTag.style.fontFamily = this.style.fontFamily;
      mathTag.style.display = this.style.display;
      mathTag.style.fontSize = this.style.fontSize;
      mathTag.style.verticalAlign = this.style.verticalAlign;
      mathTag.style.marginBottom = this.style.marginBottom;
      newChildren.push(mathTag);
    }
    let previousIndex = toBeConverted[toBeConverted.length - 1].closeIndex + 1;
    let remainingContent = content.slice(previousIndex);
    if (remainingContent !== "" && remainingContent !== null) {
      newChildren.push(document.createTextNode(remainingContent));
    }
    toBeModified.textContent = "";
    let replacing = document.createElement("span");
    for (let i = 0; i < newChildren.length; i++) {
      replacing.appendChild(newChildren[i]);
    }
    toBeModified.parentElement.replaceChild(replacing, toBeModified);
  }

  processTextContent(
    /**@type{HTMLElement} */
    toBeModified,
  ) {
    if (toBeModified.textContent === "" || toBeModified.textContent === null) {
      return;
    }
    let content = toBeModified.textContent;
    let openIndex = - 1;
    /**@type{MathTagData[]} */
    let toBeConverted = [];
    for (let i = 1; i < content.length; i++) {
      let previous = content[i - 1];
      let current = content[i];
      if (previous === "\\") {
        if (openIndex === - 1) {
          if (current === "(") {
            openIndex = i;
            continue;
          }
        } else {
          if (current === ")") {
            toBeConverted.push(new MathTagData(openIndex - 1, openIndex + 1, i - 2, i, content));
            openIndex = - 1;
          }
        }
      }
    }
    this.convertTags(toBeModified, toBeConverted);
  }

  convertTagsRecursive(
    /**@type{HTMLElement} */
    toBeModified,
    /**@type{number} */
    recursionDepth,
  ) {
    if (recursionDepth > 40) {
      console.log("While converting mathtags, reached recursion depth limits");
      return;
    }
    if (toBeModified.childNodes.length === 0) {
      this.processTextContent(toBeModified);
      return;
    }
    for (let i = 0; i < toBeModified.childNodes.length; i++) {
      this.convertTagsRecursive(toBeModified.childNodes[i], recursionDepth + 1);
    }
  }

  typeset(
    /**@type{HTMLElement|null} */
    toBeModified,
  ) {
    this.elementProcessed = toBeModified;
    this.startTime = (new Date()).getTime();
    this.lastTimeSample = this.startTime;
    if (this.elementProcessed !== null) {
      this.convertTagsRecursive(this.elementProcessed, 0);
    }
    this.typesetMathTags();
  }

  /**@returns{boolean} */
  postponeTypeset() {
    let currentTime = (new Date()).getTime();
    let elapsedTime = currentTime - this.lastTimeSample;
    if (
      elapsedTime < this.typesetTimeout ||
      this.typesetTotal >= this.elementsToTypeset
    ) {
      return false;
    }
    this.lastTimeSample = currentTime;
    setTimeout(this.typesetMathTags.bind(this), 10);
    if (this.logTiming) {
      console.log(`Typeset ${this.typesetTotal} out of ${this.elementsToTypeset} elements.`);
    }
    return true;
  }

  typesetMathTags() {
    let mathElements = document.getElementsByClassName("mathcalculator");
    if (this.elementsToTypeset < 0) {
      this.elementsToTypeset = mathElements.length;
      this.typesetTotal = 0;
    }
    for (; this.typesetTotal < mathElements.length; this.typesetTotal++) {
      if (this.postponeTypeset()) {
        return;
      }
      /** @type {HTMLElement} */
      let element = mathElements[this.typesetTotal];
      if (element["typeset"] === "true") {
        continue;
      }
      element["typeset"] = "true";
      let startTime = (new Date()).getTime();
      mathFromElement(element, false, this.sanitizeLatexSource, this.removeDisplayStyle);
      let typeSetTime = (new Date()).getTime() - startTime;
      if (this.logTiming) {
        console.log(`Typeset of element ${this.typesetTotal + 1} out of ${this.elementsToTypeset} took ${typeSetTime} ms.`);
      }
    }
  }
}

function typeset(
  /**@type{HTMLElement} */
  toBeModified,
  /** @type {string} */
  style,
  /**@type{boolean} whether to convert the original latex to parsed one.*/
  sanitizeLatexSource,
  /**@type{boolean} whether to remove \\displaystyle from latex source.*/
  removeDisplayStyle,
  /**@type{boolean} whether to log in the console timing statistics.*/
  logTiming,
) {
  if (style === "") {
    style = "font-family:'Times New Roman'; display:inline-block;";
  }
  if (logTiming) {
    console.log("Logging parsing speed times; to turn off, set logTiming=false.")
  }
  new MathTagCoverter(style, sanitizeLatexSource, removeDisplayStyle, logTiming).typeset(toBeModified);
}

class EquationEditorAction {
  constructor(
    /**@type{string} */
    command,
    /**@type{boolean} */
    isKeyPress,
  ) {
    this.command = command;
    this.isKeyPress = isKeyPress;
  }

  execute(
    /**@type{EquationEditor} */
    editor,
  ) {
    if (!this.isKeyPress) {
      editor.writeLatexLastFocused(this.command);
    } else {
      editor.focusInformation.restoreSelection(editor);
      editor.dispatchKey(this.command);
    }
  }
}

class EquationEditorButtonFactory {
  constructor(
    /**@type{string} */
    command,
    /**@type{boolean} */
    isKeyPress,
    /**@type{string} */
    label,
    /**@type{string} */
    additionalStyle,
  ) {
    /**@type{EquationEditorAction[]} */
    this.commands = [];
    if (command !== "" && command !== null) {
      this.commands.push(new EquationEditorAction(command, isKeyPress));
    }
    this.label = label;
    /**@type {string} */
    this.additionalStyle = additionalStyle;
    if (this.additionalStyle === null || this.additionalStyle === undefined) {
      this.additionalStyle = "";
    }
  }

  addEditorAction(
    /**@type{EquationEditorAction}*/
    command,
  ) {
    this.commands.push(command);
  }

  /**@return {HTMLButtonElement} */
  getButton(
    /**@type{EquationEditor} */
    editor,
  ) {
    let result = document.createElement("button");
    if (this.additionalStyle !== undefined && this.additionalStyle !== null && this.additionalStyle !== "") {
      result.style = this.additionalStyle;
    }
    result.textContent = this.label;
    return this.attachToClick(result, editor);
  }

  /**@return {HTMLButtonElement} */
  attachToClick(
    /**@type{HTMLElement} */
    element,
    /**@type{EquationEditor} */
    editor,
  ) {
    element.addEventListener(
      'click', () => {
        this.clickFunction(editor);
      }
    );
    return element;
  }

  /**@return {HTMLButtonElement|null} */
  attachToClickById(
    /**@type{string} */
    buttonId,
    /**@type{EquationEditor} */
    editor,
  ) {
    let button = document.getElementById(buttonId);
    if (button === null) {
      return null;
    }
    return this.attachToClick(button, editor);
  }

  clickFunction(
    /**@type{EquationEditor} */
    editor,
  ) {
    for (let i = 0; i < this.commands.length; i++) {
      this.commands[i].execute(editor);
    }
  }
}

let buttonFactories = {
  "sqrt": new EquationEditorButtonFactory("\\sqrt", true, "\u221A", ""),
  "fraction": new EquationEditorButtonFactory("\\frac{\\caret}{}", false, "/", ""),
  "divide": new EquationEditorButtonFactory("/", true, "(\u2022)/(\u2022)", ""),
  "exponent": new EquationEditorButtonFactory("^", true, "^", ""),
  "matrix2x2": new EquationEditorButtonFactory("\\begin{pmatrix}\\caret&\\\\&\\end{pmatrix}", false, "2x2", ""),
};

module.exports = {
  typeset,
  EquationEditor,
  EquationEditorButtonFactory,
  EquationEditorAction,
  buttonFactories,
  EquationEditorOptions,
  mathFromLatex,
  mathFromElement,
  latexConstants,
};
},
"/calculator-html/login" : function(require, module, exports){
"use strict";
const submitRequests = require("./submit_requests");
const pathnames = require("./pathnames");
const ids = require("./ids_dom_elements");

function loginCalculator() {
  let password = document.getElementById("inputPassword").value;
  document.getElementById("inputPassword").value = "";
  let username = document.getElementById("inputUsername").value;
  let url = "";
  url += `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${pathnames.urlFields.requests.userInfoJSON}&`;
  url += `password=${password}&username=${username}&`;
  submitRequests.submitGET({
    url: url,
    callback: loginWithServerCallback,
    progress: ids.domElements.spanProgressReportGeneral
  });
}

function doReload() {
  location.reload();
}

var reloadPageTimer = null;

function reloadPage(reason, time) {
  clearTimeout(reloadPageTimer);
  reloadPageTimer = null;
  if (time < 0) {
    time = 0;
  }
  let timeRemaining = time / 1000;
  document.getElementById("spanLoginStatus").innerHTML = `${reason} [in ${timeRemaining} (s)]`;
  if (time <= 0) {
    doReload();
  } else {
    reloadPageTimer = setTimeout(reloadPage.bind(null, reason, time - 1000), 1000);
  }
}

var oldUserRole;
function logout() {
  let thePage = window.calculator.mainPage;
  thePage.storage.variables.user.name.setAndStore("");
  thePage.storage.variables.user.authenticationToken.setAndStore("");
  thePage.storage.variables.user.role.setAndStore("");
  hideLogoutButton();
  thePage.user.hideProfilePicture();
  thePage.user.flagLoggedIn = false;
  thePage.user.sectionsTaught = [];
  thePage.pages.problemPage.flagLoaded = false;
  document.getElementById("inputPassword").value = "";
  document.getElementById(ids.domElements.problemPageContentContainer).innerHTML = "";
  document.getElementById(ids.domElements.divCurrentCourseBody).innerHTML = "";
  logoutGoogle();
  logoutPartTwo();
}

function logoutPartTwo() {
  var thePage = window.calculator.mainPage;
  if (oldUserRole === "admin") {
    reloadPage("<b>Logging out admin: mandatory page reload. </b>", 0);
  } else {
    var loginStatus = "";
    loginStatus += `<b><a href='#' onclick = "window.calculator.login.reloadPage('<b>User requested reload. </b>', 0);">Reload page</a>`;
    loginStatus += ` for complete logout (when <span style='color:red'>using public computer</span>).</b>`;
    document.getElementById("spanLoginStatus").innerHTML = loginStatus;
    showLoginCalculatorButtons();
    toggleAccountPanels();
    setAdminPanels();
    thePage.selectPage(thePage.pages.login.name);
  }
}

function loginTry() {
  submitRequests.submitGET({
    url: `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${pathnames.urlFields.requests.userInfoJSON}`,
    callback: loginWithServerCallback,
    progress: ids.domElements.spanProgressReportGeneral
  });
  initGoogleLogin();
}

function toggleAccountPanels() {
  let thePage = window.calculator.mainPage;
  let accountPanels = document.getElementsByClassName("divAccountPanel");
  for (let counterPanels = 0; counterPanels < accountPanels.length; counterPanels++) {
    if (thePage.user.flagLoggedIn === true) {
      accountPanels[counterPanels].classList.remove("divInvisible");
      accountPanels[counterPanels].classList.add("divVisible");
    } else {
      accountPanels[counterPanels].classList.remove("divVisible");
      accountPanels[counterPanels].classList.add("divInvisible");
    }
  }
}

function setAdminPanels() {
  let thePage = window.calculator.mainPage;
  let adminPanels = document.getElementsByClassName("divAdminPanel");
  let currentRole = thePage.user.getRole();
  let studentView = thePage.studentView();
  for (let counterPanels = 0; counterPanels < adminPanels.length; counterPanels++) {
    if (currentRole === "admin" && !studentView) {
      adminPanels[counterPanels].classList.remove("divInvisible");
      adminPanels[counterPanels].classList.add("divVisible");
    } else {
      adminPanels[counterPanels].classList.remove("divVisible");
      adminPanels[counterPanels].classList.add("divInvisible");
    }
  }
  let studentViewPanel = document.getElementById(ids.domElements.spanStudentViewPanel);
  if (currentRole === "admin") {
    studentViewPanel.classList.remove("divInvisible")
    studentViewPanel.classList.add("divVisible");
  } else {
    studentViewPanel.classList.remove("divVisible");
    studentViewPanel.classList.add("divInvisible");
  }
}

function resetPagesNeedingReload() {
  window.calculator.selectCourse.pageSetup.needsLoad = true;
  window.calculator.coursePage.lastLoadedCourse.courseHome = null;
  window.calculator.coursePage.lastLoadedCourse.topicList = null;
}

function loginWithServerCallback(incomingString, result) {
  document.getElementById("spanLoginStatus").innerHTML = "";
  let thePage = window.calculator.mainPage;
  let success = false;
  let loginErrorMessage = "";
  let parsedAuthentication = JSON.parse(incomingString);
  resetPagesNeedingReload();
  if (parsedAuthentication["status"] === "logged in") {
    success = true;
  }
  let loginInfo = "";
  if (
    parsedAuthentication[pathnames.urlFields.requests.loginDisabledEveryoneIsAdmin] === "true" ||
    parsedAuthentication[pathnames.urlFields.requests.loginDisabledEveryoneIsAdmin] === true
  ) {
    parsedAuthentication[pathnames.urlFields.username] = "anonymous";
    parsedAuthentication[pathnames.urlFields.userRole] = "admin";
    loginInfo += "<b style = 'color:red'>DB inactive,<br>everyone is admin.</b>"
    success = true;
    thePage.user.flagDatabaseInactiveEveryoneIsAdmin = true;
  }
  if (
    parsedAuthentication[pathnames.urlFields.requests.httpsSupport] !== "true" &&
    parsedAuthentication[pathnames.urlFields.requests.httpsSupport] !== true
  ) {
    if (loginInfo !== "") {
      loginInfo += "<br>";
    }
    loginInfo += "<b style = 'color:red'>Https off.</b>";
  }
  if (
    parsedAuthentication[pathnames.urlFields.requests.useFallbackDatabase] === "true" ||
    parsedAuthentication[pathnames.urlFields.requests.useFallbackDatabase] === true
  ) {
    let databaseInfo = document.getElementById(ids.domElements.divLoginPanelDatabaseInfo);
    databaseInfo.innerHTML = "<b style = 'color:red'>Fallback database.</b>";
  }
  let loginExtraInfo = document.getElementById(ids.domElements.divLoginPanelExtraInfo);
  loginExtraInfo.innerHTML = loginInfo;
  if (success) {
    thePage.user.makeFromUserInfo(parsedAuthentication);
    toggleAccountPanels();
    setAdminPanels();
    hideLoginCalculatorButtons();
    showLogoutButton();
  } else if (parsedAuthentication["status"] === "not logged in") {
    if (parsedAuthentication["error"] !== undefined) {
      loginErrorMessage = parsedAuthentication["error"];
    }
  }
  if (!success) {
    if (loginErrorMessage !== undefined && loginErrorMessage !== "") {
      document.getElementById("spanLoginStatus").innerHTML = decodeURIComponent(loginErrorMessage);
    }
    thePage.storage.variables.user.authenticationToken.setAndStore("");
    thePage.storage.variables.user.name.setAndStore("");
    thePage.storage.variables.user.role.setAndStore("");
    thePage.user.flagLoggedIn = false;
    showLoginCalculatorButtons();
    toggleAccountPanels();
    setAdminPanels();
  }
}

function onGoogleSignIn(googleUser) {
  let theToken = googleUser.getAuthResponse().id_token;
  let thePage = window.calculator.mainPage;
  thePage.user.googleToken = theToken;
  thePage.storage.variables.user.name.setAndStore("");
  thePage.user.googleProfile = window.calculator.jwt.decode(theToken);
  thePage.showProfilePicture();
  showLogoutButton();
  let theURL = "";
  theURL += `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${pathnames.urlFields.requests.userInfoJSON}&`;
  theURL += `googleToken=${theToken}&`;
  submitRequests.submitGET({
    url: theURL,
    callback: loginWithServerCallback,
    progress: ids.domElements.spanProgressReportGeneral
  });
}

function initGoogleLogin() {
  if (typeof (gapi) === "undefined") {
    return;
  }
  let thePage = window.calculator.mainPage;
  if (thePage.pages.login.initialized === true) {
    return;
  }
  try {
    gapi.load('auth2', function () {
      //auth2Google =
      gapi.auth2.init({
        client_id: '538605306594-n43754vb0m48ir84g8vp5uj2u7klern3.apps.googleusercontent.com',
        // Scopes to request in addition to 'profile' and 'email'
        //scope: 'additional_scope'
      });
      gapi.signin2.render('divGoogleLoginButton', {
        scope: 'profile email',
        prompt: "select_account",
        onsuccess: onGoogleSignIn,
        onfailure: null
      });
    });
  } catch (e) {
    console.log("Failed to execute google auth service.");
  }
}

function showLoginCalculatorButtons() {
  document.getElementById(ids.domElements.pages.login.divLoginCalculatorPanel).classList.remove("divInvisible");
  document.getElementById(ids.domElements.pages.login.divLoginCalculatorPanel).classList.add("divVisible");
  document.getElementById(ids.domElements.pages.login.userNameReport).classList.remove("divVisible");
  document.getElementById(ids.domElements.pages.login.userNameReport).classList.add("divInvisible");
  document.getElementById(ids.domElements.divLoginPanelExtraInfo).classList.remove("divVisible");
  document.getElementById(ids.domElements.divLoginPanelExtraInfo).classList.add("divInvisible");
}

function hideLoginCalculatorButtons() {
  let thePage = window.calculator.mainPage;
  document.getElementById(ids.domElements.pages.login.divLoginCalculatorPanel).classList.remove("divVisible");
  document.getElementById(ids.domElements.pages.login.divLoginCalculatorPanel).classList.add("divInvisible");
  document.getElementById(ids.domElements.pages.login.userNameReport).innerHTML = thePage.storage.variables.user.name.value;
  document.getElementById(ids.domElements.pages.login.userNameReport).classList.remove("divInvisible");
  document.getElementById(ids.domElements.pages.login.userNameReport).classList.add("divVisible");
  document.getElementById(ids.domElements.divLoginPanelExtraInfo).classList.remove("divInvisible");
  document.getElementById(ids.domElements.divLoginPanelExtraInfo).classList.add("divVisible");
}

function showLogoutButton() {
  for (; ;) {
    let theLogoutLinks = document.getElementsByClassName("linkLogoutInactive");
    if (theLogoutLinks.length === 0) {
      break;
    }
    theLogoutLinks[0].classList.add("linkLogoutActive");
    theLogoutLinks[0].classList.remove("linkLogoutInactive");
  }
}

function hideLogoutButton() {
  for (; ;) {
    let theLogoutLinks = document.getElementsByClassName("linkLogoutActive");
    if (theLogoutLinks.length === 0) {
      break;
    }
    theLogoutLinks[0].classList.add("linkLogoutInactive");
    theLogoutLinks[0].classList.remove("linkLogoutActive");
  }
}

function logoutGoogle() {
  let thePage = window.calculator.mainPage;
  thePage.storage.variables.user.googleToken.setAndStore("");
  thePage.user.googleProfile = {};
  if (gapi !== undefined && gapi !== null) {
    gapi.auth2.getAuthInstance().signOut();
  }
}

function getQueryVariable(variable) {
  let query = window.location.search.substring(1);
  let vars = query.split('&');
  for (let i = 0; i < vars.length; i++) {
    let pair = vars[i].split('=');
    if (decodeURIComponent(pair[0]) === variable) {
      return decodeURIComponent(pair[1]);
    }
  }
  return null;
}

function init() {
  logoutRequestFromUrl = getQueryVariable("logout");
  locationRequestFromUrl = getQueryVariable("location");
  if (logoutRequestFromUrl === "true") {
    logout();
  }
}

module.exports = {
  resetPagesNeedingReload,
  reloadPage,
  init,
  logoutGoogle,
  logout,
  loginTry,
  setAdminPanels,
  loginCalculator,
};
},
"/calculator-html/signup" : function(require, module, exports){
"use strict";
const submitRequests = require("./submit_requests");
const ids = require("./ids_dom_elements");
const pathnames = require("./pathnames");

var recaptchaIdForSignUp = null;

function getRecaptchaId() {
  var localRecaptcha = '6LcSSSAUAAAAAIx541eeGZLoKx8iJehZPGrJkrql';
  var calculatorRecaptcha = "6LcgwR8UAAAAALQq02qZShfA1ZUZvZKRNWJ2CPPf";
  if (
    window.location.hostname == "localhost" ||
    window.location.hostname == "127.0.0.1"
  ) {
    return localRecaptcha;
  }
  if (
    window.location.hostname == "calculator-algebra.org" ||
    window.location.hostname == "www.calculator-algebra.org"
  ) {
    return calculatorRecaptcha;
  }
  throw (`Recaptcha not supported for your hostname: ${window.location.hostname}. Post an issue on our project's github if you need this feature. `)
  return "";
}

class SignUp {
  constructor() {

  }
  signUp() {

    if (recaptchaIdForSignUp === null) {
      recaptchaIdForSignUp = grecaptcha.render("recaptchaSignUp", { 'sitekey': getRecaptchaId() });
    }
  }

  resetRecaptchaOnLoad() {
    grecaptcha.reset();
  }

  submitSignUpInfo() {
    if (grecaptcha === undefined || grecaptcha === null) {
      document.getElementById('signUpResult').innerHTML = "<span style ='color:red'><b>The google captcha script appears to be missing (no Internet?). </b></span>";
      return false;
    }
    var desiredUsernameEncoded = encodeURIComponent(document.getElementById('desiredUsername').value);
    var desiredEmailEncoded = encodeURIComponent(document.getElementById('emailForSignUp').value);
    var theURL = `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${pathnames.urlFields.signUp}&desiredUsername=${desiredUsernameEncoded}&`;
    theURL += `email=${desiredEmailEncoded}&`;
    var theToken = grecaptcha.getResponse(recaptchaIdForSignUp);
    if (theToken === '' || theToken === null) {
      document.getElementById('signUpResult').innerHTML = "<span style ='color:red'><b>Please don't forget to solve the captcha. </b></span>";
      return false;
    }
    recaptchaIdForSignUp = null;
    theURL += `${pathnames.urlFields.recaptchaToken}=${encodeURIComponent(theToken)}&`;
    submitRequests.submitGET({
      url: theURL,
      callback: callbackSignUp,
      result: "signUpResultReport",
      progress: ids.domElements.spanProgressReportGeneral
    });
  }

}

function callbackSignUp(input, output) {
  if (typeof output === "string") {
    output = document.getElementById(output);
  }
  try {
    var inputParsed = JSON.parse(decodeURIComponent(input));
    var result = "";
    if (inputParsed.result !== undefined) {
      result += `${inputParsed.result}<hr>`;
    }
    if (inputParsed.error !== "") {
      result += `<span style = 'color:red; font-weight:bold;'>${inputParsed.error}</span>`;
    }
    if (inputParsed.comments !== "") {
      result += `<hr>${inputParsed.comments}`;
    }
    output.innerHTML = result;
  } catch (e) {
    output.innerHTML = `Result: ${input}. Error: ${e}. ${input}`;
  }
}

var signUp = new SignUp();

module.exports = {
  getRecaptchaId,
  signUp,
};

},
"/calculator-html/forgot_password" : function(require, module, exports){
"use strict";
const ids = require("./ids_dom_elements");
const pathnames = require("./pathnames");
const submitRequests = require("./submit_requests");
const signUp = require('./signup');

function callbackForgotLogin(input, output) {
  if (typeof output === "string") {
    output = document.getElementById(output);
  }
  output.innerHTML = input;
}

var recaptchaIdForForgotLogin = null;

class ForgotLogin {
  constructor() {

  }

  forgotLoginPage() {
    var thePage = window.calculator.mainPage;
    if (recaptchaIdForForgotLogin === null) {
      recaptchaIdForForgotLogin = grecaptcha.render("recaptchaForgotPassword", { sitekey: signUp.getRecaptchaId() });
    }
    thePage.selectPage(thePage.pages.forgotLogin.name);
  }

  submitForgotPassword() {
    if (grecaptcha === undefined || grecaptcha === null) {
      document.getElementById('signUpResult').innerHTML = "<span style ='color:red'><b>The google captcha script appears to be missing (no Internet?). </b></span>";
      return false;
    }
    var desiredEmailEncoded = encodeURIComponent(document.getElementById('emailForForgotLogin').value);
    var theURL = "";
    theURL += `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${pathnames.urlFields.requests.forgotLogin}&`
    theURL += `${pathnames.urlFields.email}=${desiredEmailEncoded}&`;
    var theToken = grecaptcha.getResponse(recaptchaIdForForgotLogin);
    if (theToken === '' || theToken === null) {
      document.getElementById('forgotLoginResult').innerHTML = "<span style ='color:red'><b>Please don't forget to solve the captcha. </b></span>";
      return false;
    }
    theURL += `${pathnames.urlFields.recaptchaToken}=${encodeURIComponent(theToken)}&`;
    submitRequests.submitGET({
      url: theURL,
      callback: callbackForgotLogin,
      result: "forgotLoginResult",
      progress: ids.domElements.spanProgressReportGeneral
    });
  }
}

var forgotLogin = new ForgotLogin();

module.exports = {
  forgotLogin
};
},
"/calculator-html/database" : function(require, module, exports){
"use strict";
const submitRequests = require("./submit_requests");
const ids = require("./ids_dom_elements");
const pathnames = require("./pathnames");
const jsonToHtml = require('./json_to_html');
const miscellaneous = require("./miscellaneous_frontend");
const panels = require('./panels');

function clickDatabaseTable(currentCollection) {
  window.calculator.mainPage.storage.variables.database.labels.setAndStore(JSON.stringify(currentCollection));
  updateDatabasePage();
}

function callbackFetchProblemData(button, input, output) {
  let inputParsed = JSON.parse(input);
  let panelId = button.getAttribute("panelId");
  let thePanel = new panels.PanelExpandable(panelId);
  let transformer = new jsonToHtml.JSONToHTML();
  let problemData = [];
  try {
    let inputParsed = JSON.parse(input);
    let problemDataRaw = inputParsed.rows[0].problemDataJSON;
    for (let label in problemDataRaw) {
      let incomingProblem = {
        problemName: label,
        problemInfo: problemDataRaw[label],
      }
      problemData.push(incomingProblem)
    }
  } catch (e) {
    problemData = {
      error: e,
      input: input,
    };
  }
  let resultHTML = transformer.getTableFromObject(problemData);
  thePanel.setPanelContent(resultHTML);
  thePanel.initialize(true);
  transformer.bindButtons();
  //thePanel.attributes.panelStatus = "collapsed";
  thePanel.doToggleContent();
  thePanel.matchPanelStatus();
}

function fetchProblemData() {
  let labelsString = this.getAttribute("labels");
  //let labels = JSON.parse(labelsString);
  let theURL = "";
  theURL += `${pathnames.urls.calculatorAPI}?`;
  theURL += `${pathnames.urlFields.request}=${pathnames.urlFields.requests.database}&`;
  theURL += `${pathnames.urlFields.database.operation}=${pathnames.urlFields.database.fetch}&`;
  theURL += `${pathnames.urlFields.database.labels}=${labelsString}&`;
  submitRequests.submitGET({
    url: theURL,
    progress: ids.domElements.spanProgressReportGeneral,
    callback: callbackFetchProblemData.bind(null, this),
  });
}

function deleteDatabaseItemCallback(
  /**@type {JSONToHTML} */
  transformer,
  deletedItem,
  labels,
  input,
  output,
) {
  document.getElementById(deletedItem).remove();
}

function deleteDatabaseItem(
  /**@type {JSONToHTML} */
  transformer,
  input,
  labels,
) {
  let finalSelector = {
    fields: labels
  };
  let theURL = `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=databaseDeleteOneEntry&item=${escape(JSON.stringify(finalSelector))}`;
  submitRequests.submitGET({
    url: theURL,
    callback: deleteDatabaseItemCallback.bind(null, transformer, input, labels),
    progress: ids.domElements.spanProgressReportGeneral
  });
}

function bounceString(input) {
  return input;
}

var transformersDatabase = {
  deleteProblemDataItem: {
    clickHandler: deleteDatabaseItem,
  },
  fetchProblemData: {
    clickHandler: fetchProblemData,
    transformer: bounceString.bind(null, "problem data"),
  },
};

var optionsDatabase = {
  transformers: {
    "users.${number}.problemDataJSON": transformersDatabase.fetchProblemData,
    "users.${number}.activationToken": jsonToHtml.transformersStandard.shortener,
    "users.${number}.authenticationToken": jsonToHtml.transformersStandard.shortener,
    "users.${number}.password": jsonToHtml.transformersStandard.shortener,
    "users.${number}._id": jsonToHtml.transformersStandard.shortener,
  },
};

function updateDatabasePageCallback(incoming, output) {
  let thePage = window.calculator.mainPage;
  let labelString = thePage.storage.variables.database.labels.getValue();
  let labels = [];
  try {
    labels = JSON.parse(labelString);
  } catch (e) {
    labels = [""];
  }
  let theParsed = miscellaneous.jsonUnescapeParse(incoming);
  let theOutput = document.getElementById(ids.domElements.divDatabaseOutput);
  if (
    theParsed.error !== undefined &&
    theParsed.error != null &&
    theParsed.error != ""
  ) {
    theOutput.innerHTML = miscellaneous.jsonParseGetHtmlStandard(incoming);
  } else if ("rows" in theParsed) {
    let transformer = new jsonToHtml.JSONToHTML();
    for (let i = 0; i < theParsed.rows.length; i++) {
      theParsed.rows[i]["problemDataJSON"] = "";
    }
    document.getElementById(ids.domElements.spanDatabaseComments).innerHTML = `${theParsed.rows.length} out of ${theParsed.totalRows} rows displayed.<br> `;
    theOutput.innerHTML = transformer.getTableFromObject(theParsed.rows, optionsDatabase, { table: labels[0] });
    transformer.bindButtons();
  } else {
    for (let counterCollection = 0; counterCollection < theParsed.collections.length; counterCollection++) {
      let currentCollection = theParsed.collections[counterCollection];
      let linkHTML = "";
      let urlObjectIncoming = miscellaneous.deepCopy(thePage.storage.urlObject);
      urlObjectIncoming.databaseLabels = currentCollection;
      linkHTML += `<a href = '#${JSON.stringify(urlObjectIncoming)}' onclick = 'window.calculator.database.clickDatabaseTable(["${currentCollection}"]);'>`;
      linkHTML += `${currentCollection}</a>`;
      theParsed.collections[counterCollection] = linkHTML;
    }
    let transformer = new jsonToHtml.JSONToHTML();
    theOutput.innerHTML = transformer.getTableFromObject(theParsed.collections);
    transformer.bindButtons();
  }
}

function updateDatabasePageResetCurrentTable() {
  let thePage = window.calculator.mainPage;
  thePage.storage.variables.database.labels.setAndStore("[]");
  updateDatabasePage();
}

function updateDatabasePage() {
  let thePage = window.calculator.mainPage;
  if (!thePage.isLoggedIn()) {
    document.getElementById(ids.domElements.divDatabaseOutput).innerHTML = "<b>Not logged-in.</b>";
    return;
  }
  let labels = thePage.storage.variables.database.labels.getValue();
  let theUrl = "";
  theUrl += `${pathnames.urls.calculatorAPI}?`;
  theUrl += `${pathnames.urlFields.request}=${pathnames.urlFields.requests.database}&`;
  theUrl += `${pathnames.urlFields.database.operation}=${pathnames.urlFields.database.fetch}&`;
  theUrl += `${pathnames.urlFields.database.labels}=${labels}&`;
  submitRequests.submitGET({
    url: theUrl,
    progress: ids.domElements.spanProgressReportGeneral,
    callback: updateDatabasePageCallback
  });
}

module.exports = {
  updateDatabasePage,
  clickDatabaseTable,
  updateDatabasePageResetCurrentTable
};
},
"/calculator-html/server_status" : function(require, module, exports){
"use strict";
const submitRequests = require("./submit_requests");
const pathnames = require("./pathnames");
const ids = require("./ids_dom_elements");

function updateServerStatus() {
  submitRequests.submitGET({
    url: `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${pathnames.urlFields.requests.serverStatusJSON}`,
    result: ids.domElements.serverStatus,
    progress: ids.domElements.spanProgressReportGeneral
  });
}

module.exports = {
  updateServerStatus,
};
},
"/calculator-html/account" : function(require, module, exports){
"use strict";
const ids = require("./ids_dom_elements");
const submitRequests = require("./submit_requests");
const pathnames = require("./pathnames");
const login = require('./login');
const miscellaneous = require("./miscellaneous_frontend");

function submitChangePassRequestCallback(result, outputComponent) {
  outputComponent = document.getElementById("spanVerification").innerHTML = miscellaneous.jsonParseGetHtmlStandard(result);
  document.getElementById("inputPassword").value = document.getElementById("inputNewPasswordInAccount").value;
  document.getElementById("inputOldPasswordInAccount").value = "";
  document.getElementById("inputNewPasswordInAccount").value = "";
  document.getElementById("inputReenteredPasswordInAccount").value = "";
  login.loginCalculator();
}

function submitChangePassRequest() {
  let inputOldPassword = document.getElementById("inputOldPasswordInAccount");
  let inputNewPassword = document.getElementById("inputNewPasswordInAccount");
  let inputReenteredPassword = document.getElementById("inputReenteredPasswordInAccount");
  let inputEmail = document.getElementById("inputEmail");
  let theURL = "";
  theURL += `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${pathnames.urlFields.changePassword}&`;
  theURL += `${pathnames.urlFields.password}=${encodeURIComponent(inputOldPassword.value)}&`;
  theURL += `${pathnames.urlFields.newPassword}=${encodeURIComponent(inputNewPassword.value)}&`;
  theURL += `${pathnames.urlFields.reenteredPassword}=${encodeURIComponent(inputReenteredPassword.value)}&`;
  theURL += `${pathnames.urlFields.email}=${encodeURIComponent(inputEmail.value)}&`;
  theURL += "doReload=false&"
  submitRequests.submitGET({
    url: theURL,
    callback: submitChangePassRequestCallback,
    progress: ids.domElements.spanProgressReportGeneral
  });
}

function updateAccountPage() {
  let thePage = window.calculator.mainPage;
  let usernameInput = document.getElementById("spanUserIdInAccountsPage");
  let emailSpan = document.getElementById(ids.domElements.spanOldEmail);
  usernameInput.innerHTML = thePage.storage.variables.user.name.getValue();
  emailSpan.innerHTML = thePage.storage.variables.user.email.getValue();
  let spanExtraInfo = document.getElementById(ids.domElements.spanUserExtraInfo);
  let extraInfo = "";
  extraInfo += "<table>";
  extraInfo += `<tr><td>Role: </td><td>${thePage.user.getRole()}</td><tr>`;
  if (thePage.user.sectionsTaught.length > 0 && !thePage.studentView()) {
    extraInfo += `<tr><td>Sections taught: </td><td>${thePage.user.sectionsTaught.join(", ")}</td><tr>`;
  }
  extraInfo += `<tr><td>Instructor: </td><td>${thePage.user.instructor}</td><tr>`;
  extraInfo += `<tr><td>Section in database: </td><td>${thePage.user.sectionInDB}</td><tr>`;
  extraInfo += `<tr><td>Section computed: </td><td>${thePage.user.sectionComputed}</td></tr>`;
  extraInfo += `<tr><td>Deadline schema: </td><td>${thePage.user.deadlineSchema}</td><tr>`;
  extraInfo += "</table>";
  spanExtraInfo.innerHTML = extraInfo;
}

module.exports = {
  updateAccountPage,
  submitChangePassRequest
};
},
"/calculator-html/account_activation" : function(require, module, exports){
"use strict";
const ids = require("./ids_dom_elements");
const submitRequests = require("./submit_requests");
const pathnames = require("./pathnames");

function submitAccountActivationRequestCallback(wipeOffActivationToken, result, outputComponent) {
  var thePage = window.calculator.mainPage;
  outputComponent = document.getElementById(ids.domElements.spanVerificationActivation).innerHTML = result;
  document.getElementById(ids.domElements.inputPassword).value = document.getElementById(
    ids.domElements.inputNewPasswordInActivationAccount
  ).value;
  document.getElementById(ids.domElements.inputNewPasswordInActivationAccount).value = "";
  document.getElementById(ids.domElements.inputReenteredPasswordInActivationAccount).value = "";
  if (wipeOffActivationToken === true) {
    thePage.storage.variables.user.activationToken.setAndStore("");
  }
  //loginCalculator();
}

function submitActivateAccountRequest() {
  var thePage = window.calculator.mainPage;
  var inputNewPassword = document.getElementById(ids.domElements.inputNewPasswordInActivationAccount).value;
  var inputNewPasswordReentered = document.getElementById(ids.domElements.inputReenteredPasswordInActivationAccount).value;
  var userName = thePage.storage.variables.user.name.getValue();
  var theURL = "";
  theURL += `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${pathnames.urlFields.changePassword}&`;
  theURL += `${pathnames.urlFields.newPassword}=${encodeURIComponent(inputNewPassword)}&`;
  theURL += `${pathnames.urlFields.reenteredPassword}=${encodeURIComponent(inputNewPasswordReentered)}&`;
  theURL += `${pathnames.urlFields.username}=${encodeURIComponent(userName)}&`;
  var activationToken = thePage.storage.variables.user.activationToken.getValue();
  if (activationToken !== "" && activationToken !== null && activationToken !== undefined) {
    theURL += `${pathnames.urlFields.activationToken}=${encodeURIComponent(activationToken)}&`;
  }
  theURL += `doReload=false&`;
  submitRequests.submitGET({
    url: theURL,
    callback: submitAccountActivationRequestCallback.bind(null, true),
    progress: ids.domElements.spanProgressReportGeneral
  });
}

function submitDoActivateAccount() {
  var thePage = window.calculator.mainPage;
  var inputNewPassword = document.getElementById(ids.domElements.inputNewPasswordInActivationAccount).value;
  var inputNewPasswordReentered = document.getElementById(ids.domElements.inputReenteredPasswordInActivationAccount).value;
  var activationToken = thePage.storage.variables.user.activationToken.getValue();
  var userName = thePage.storage.variables.user.name.getValue();
  var theURL = "";
  var email = thePage.storage.variables.user.email.getValue();
  theURL += `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=activateAccountJSON&`;
  theURL += `${pathnames.urlFields.activationToken}=${encodeURIComponent(activationToken)}&`;
  theURL += `${pathnames.urlFields.email}=${encodeURIComponent(email)}&`;
  theURL += `${pathnames.urlFields.newPassword}=${encodeURIComponent(inputNewPassword)}&`;
  theURL += `${pathnames.urlFields.reenteredPassword}=${encodeURIComponent(inputNewPasswordReentered)}&`;
  theURL += `${pathnames.urlFields.username}=${encodeURIComponent(userName)}&`;
  theURL += `doReload=false&`;
  submitRequests.submitGET({
    url: theURL,
    callback: submitAccountActivationRequestCallback.bind(null, false),
    progress: ids.domElements.spanProgressReportGeneral,
  });
}

function updateAccountActivationPage() {
  var thePage = window.calculator.mainPage;
  var emailSpan = document.getElementById(ids.domElements.spanCurrentActivationEmail);
  var activationTokenSpan = document.getElementById(ids.domElements.spanCurrentActivationToken);
  var usernameInput = document.getElementById(ids.domElements.spanUserIdInActivateAccountPage);
  usernameInput.innerHTML = thePage.storage.variables.user.name.getValue();
  emailSpan.innerHTML = thePage.storage.variables.user.email.getValue();
  var activationToken = thePage.storage.variables.user.activationToken.getValue();
  activationTokenSpan.innerHTML = activationToken;
  if (activationToken !== null && activationToken !== undefined && activationToken !== "") {
    submitDoActivateAccount();
  }
}

module.exports = {
  updateAccountActivationPage,
  submitActivateAccountRequest,
};

},
"/calculator-html/manage_accounts" : function(require, module, exports){
"use strict";
const submitRequests = require("./submit_requests");
const ids = require("./ids_dom_elements");
const pathnames = require("./pathnames");
const miscellaneous = require("./miscellaneous_frontend");

function getAccountsTable(inputAccounts) {
  var result = "";
  result += "<table><tr><th>username</th><th>Email</th><th>Activated?</th><th>Course</th><th>Section</th><th>Semester</th></tr>";
  for (var counterAccounts = 0; counterAccounts < inputAccounts.length; counterAccounts++) {
    result += "<tr>";
    var currentUser = inputAccounts[counterAccounts];
    //console.log("Current user: " + JSON.stringify(currentUser));
    result += `<td>${currentUser.username}</td>`;
    if (currentUser.email !== undefined) {
      result += `<td>${currentUser.email}</td>`;
    } else {
      result += `<td>-</td>`;
    }
    if (currentUser.activationToken === "activated") {
      result += `<td><span style = 'color:green'>${currentUser.activationToken}</span></td>`;
    } else {
      result += "<td><span style = 'color:red'>Not activated</span></td>";
    }
    if (currentUser.currentCourses !== undefined) {
      result += `<td>${currentUser.currentCourses}</td>`;
    } else {
      result += "<td>-</td>";
    }
    if (currentUser.studentSection !== undefined) {
      result += `<td>${currentUser.studentSection}</td>`;
    } else {
      result += "<td>-</td>";
    }
    if (currentUser.semester !== undefined) {
      result += `<td>${currentUser.semester}</td>`;
    } else {
      result += "<td>-</td>";
    }
    result += "</tr>";
  }
  result += "</table>";
  return result;
}

function updateAccountsPageCallback(input, notUsed) {
  var outputComponentAdmin = document.getElementById("idOutputAdmins");
  var outputComponentStudents = document.getElementById("idOutputStudents");
  var parsedUserInfo = null;
  try {
    parsedUserInfo = miscellaneous.jsonUnescapeParse(input);
    var admins = parsedUserInfo["admins"];
    var students = parsedUserInfo["students"];
    if (parsedUserInfo.error !== undefined && parsedUserInfo.error !== "") {
      outputComponentAdmin.innerHTML = parsedUserInfo.error;
    } else {
      outputComponentAdmin.innerHTML = getAccountsTable(admins);
      outputComponentStudents.innerHTML = getAccountsTable(students);
    }
  } catch (e) {
    outputComponentStudents.innerHTML = e;
    console.log(e);
  }
}

function callbackAddEmailsOrUsers(input, outputComponent) {
  if (typeof outputComponent == "string") {
    outputComponent = document.getElementById(outputComponent);
  }
  outputComponent.innerHTML = miscellaneous.jsonParseGetHtmlStandard(decodeURIComponent(input));
}

function addEmailsOrUsers(
  idEmailList,
  problemCollectionName,
  idOutput,
  userRole,
  idUserGroup,
  idPasswords,
  requestType
) {
  var spanEmailList = document.getElementById(idEmailList);
  var spanUserGroup = document.getElementById(idUserGroup);
  var spanPasswords = document.getElementById(idPasswords);
  var theURL = "";
  theURL += `${pathnames.urls.calculatorAPI}?`;
  theURL += `${pathnames.urlFields.request}=${requestType}&`;
  theURL += `${pathnames.urlFields.userRole}=${userRole}&`;
  theURL += `userList=${encodeURIComponent(spanEmailList.value)}&`;
  theURL += `studentSection=${encodeURIComponent(spanUserGroup.value)}&`;
  theURL += `passwordList=${encodeURIComponent(spanPasswords.value)}&`;
  theURL += `filterAccounts=&`;
  submitRequests.submitGET({
    url: theURL,
    progress: ids.domElements.spanProgressReportGeneral,
    result: idOutput,
    callback: callbackAddEmailsOrUsers
  });
}

function getTeachersStudentsCallback(input, output) {
  document.getElementById(output).innerHTML = miscellaneous.jsonParseGetHtmlStandard(decodeURIComponent(input));
}

function getTeachersStudents() {
  var theURL = `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${pathnames.urlFields.requests.setTeacher}&`;
  var inputSections = document.getElementById('inputSections').value;
  var inputTeachers = document.getElementById('inputSetTeacher').value;
  var teachersAndSections = {
    teachers: encodeURIComponent(inputTeachers),
    students: encodeURIComponent(inputSections)
  }
  theURL += `${pathnames.urlFields.teachersAndSections}=${encodeURIComponent(JSON.stringify(teachersAndSections))}&`;
  submitRequests.submitGET({
    url: theURL,
    progress: ids.domElements.spanProgressReportGeneral,
    result: "idOutputSections",
    callback: getTeachersStudentsCallback
  });

}

function updateAccountsPage() {
  var theURL = `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${pathnames.urlFields.accountsJSON}`;

  submitRequests.submitGET({
    url: theURL,
    callback: updateAccountsPageCallback,
    progress: ids.domElements.spanProgressReportGeneral,
  });

}

module.exports = {
  addEmailsOrUsers,
  updateAccountsPage,
  getTeachersStudents
};
},
"/calculator-html/edit_page" : function(require, module, exports){
"use strict";
const submitRequests = require("./submit_requests");
const pathnames = require("./pathnames");
// const calculatorPage = require('./calculator_page');
const ids = require("./ids_dom_elements");
const miscellaneous = require("./miscellaneous_frontend");

var staticWordCompleter = {
  getCompletions: function (editor, session, pos, prefix, callback) {
    var thePage = window.calculator.mainPage;
    callback(null, thePage.aceEditorAutoCompletionWordList.map(function (word) {
      return {
        caption: word,
        value: word,
        meta: "static"
      };
    }));
  }
}

function ctrlSPressAceEditorHandler(event) {
  if (event.ctrlKey !== true) {
    return;
  }
  if (event.keyCode !== 83) {
    return;
  }
  event.preventDefault();
  storeEditedPage();
}

/**@returns {HTMLElement[]} */
function getClonePanel(
  /**@type{string} */
  fileNameSource,
  /**@type{string} */
  fileNameTarget
) {
  if (fileNameSource === "" || fileNameSource === undefined || fileNameSource === null) {
    return [];
  }
  var idCloneInput = encodeURIComponent(`cloneButton${fileNameSource}`);
  var idSpanClonePageReport = encodeURIComponent(`cloneButtonReport${fileNameSource}`);
  var result = [];
  var table = document.createElement("table");
  var row = table.insertRow(- 1);
  var cellClone = row.insertCell(- 1);

  // result += "<table><tr><td>";
  var buttonClone = document.createElement("button");
  buttonClone.className = "buttonClone";
  buttonClone.style.width = "50px";
  buttonClone.addEventListener("click", window.calculator.editPage.handleClone.bind(null, fileNameSource, idCloneInput, idSpanClonePageReport));
  buttonClone.innerHTML = "Clone";
  cellClone.appendChild(buttonClone)
  var cellFileInfo = row.insertCell(- 1);
  var cellFileInfoTable = document.createElement("table");
  var cellFileInfoTableRow = cellFileInfoTable.insertRow(- 1);
  var nextCell = cellFileInfoTableRow.insertCell(- 1);
  nextCell.innerHTML = "from:";
  nextCell = cellFileInfoTableRow.insertCell(- 1);
  nextCell.innerHTML = `<b style = 'color: green'>${fileNameSource}</b></td>`;
  var sizeFile = fileNameTarget.length;
  cellFileInfoTableRow = cellFileInfoTable.insertRow(- 1);
  nextCell = cellFileInfoTableRow.insertCell(- 1);
  nextCell.innerHTML = "to:";
  nextCell = cellFileInfoTableRow.insertCell(- 1);
  nextCell.innerHTML = `<input type = "text" value = '${fileNameTarget}' size = '${sizeFile}' id = '${idCloneInput}'></input>`;
  cellFileInfo.append(cellFileInfoTable);
  result.push(table);
  var cloneReport = document.createElement("div");
  cloneReport.id = idSpanClonePageReport;
  result.push(cloneReport);
  return result;
}

/**@returns {HTMLElement} */
function getEditPanel(fileName) {
  var thePage = window.calculator.mainPage;
  var doGenerate = !thePage.flagProblemPageOnly;

  if (!thePage.flagProblemPageOnly) {
    if (!thePage.user.hasProblemEditRights() || thePage.studentView()) {
      doGenerate = false;
    }
  }
  if (!doGenerate) {
    return document.createTextNode("");
  }
  if (fileName === "" || fileName === undefined || fileName === null) {
    return document.createTextNode("");
  }
  var result = document.createElement("DIV");
  result.className = "spanFileInfo";
  var saveEdit = document.createElement("BUTTON");
  saveEdit.className = "buttonSaveEdit";
  saveEdit.innerHTML = "Edit";
  saveEdit.style.width = "50px";
  saveEdit.addEventListener('click', window.calculator.editPage.selectEditPage.bind(null, fileName));
  result.appendChild(saveEdit);
  result.appendChild(document.createTextNode(` ${fileName} `));
  var clonePanel = document.createElement("BUTTON");
  clonePanel.className = "accordionLike";
  clonePanel.innerHTML = "Clone panel &#9666;";
  clonePanel.addEventListener('click', window.calculator.editPage.toggleClonePanel.bind(null, clonePanel));
  result.appendChild(clonePanel);
  var panelElement = document.createElement("span");
  panelElement.className = "panelDeadlines";
  var panelContent = getClonePanel(fileName, fileName);
  for (var i = 0; i < panelContent.length; i++) {
    panelElement.appendChild(panelContent[i]);
  }
  result.appendChild(panelElement);
  return result;
}

function callbackClone(input, output) {
  if (typeof output === "string") {
    output = document.getElementById(output);
  }
  var inputParsed = JSON.parse(input);
  var errorFound = false;
  var result = "";
  if (inputParsed.error !== undefined && inputParsed.error !== "" && inputParsed !== null) {
    errorFound = true;
    result += `<b style = 'color:red'>Error.</b> ${inputParsed.error}`;
  }
  if (inputParsed.comments !== undefined && inputParsed.comments !== "") {
    result += inputParsed.comments;
  }
  if (!errorFound) {
    result += `<button class = 'buttonStandard' `;
    result += `onclick = "window.calculator.mainPage.pages.problemPage.flagLoaded=false; window.calculator.mainPage.selectPage('problemPage')"`;
    result += `>Force-reload problem</button>`;
  }
  output.innerHTML = result;
}

function handleClone(fileName, idCloneInput, idSpanClonePageReport) {
  var newFileName = document.getElementById(idCloneInput).value;
  var theURL = "";
  theURL += `${pathnames.urls.calculatorAPI}?`;
  theURL += `${pathnames.urlFields.request}=${pathnames.urlFields.requests.clonePage}`;
  theURL += `&${pathnames.urlFields.problem.fileNameTarget}=${newFileName}`;
  theURL += `&${pathnames.urlFields.problem.fileName}=${fileName}&`;
  submitRequests.submitGET({
    url: theURL,
    result: idSpanClonePageReport,
    callback: callbackClone
  });
}

function storeEditedPage() {
  var thePage = window.calculator.mainPage;
  var editor = thePage.pages.editPage.editor;
  var theURL = "";
  theURL += `${pathnames.urls.calculatorAPI}?`;
  var queryParameters = "";
  queryParameters += `${pathnames.urlFields.request}=${pathnames.urlFields.requests.modifyPage}`;
  var content = encodeURIComponent(editor.getValue());
  queryParameters += `&${pathnames.urlFields.requests.fileContent}=${content}`;
  queryParameters += `&${pathnames.urlFields.problem.fileName}=${thePage.storage.variables.editor.currentlyEditedPage.getValue()}`;
  thePage.pages.problemPage.flagLoaded = false;
  submitRequests.submitPOST({
    url: theURL,
    parameters: queryParameters,
    result: ids.domElements.spanSubmitEditPageReport,
  });
}

function initEditorAce() {
  var thePage = window.calculator.mainPage;
  var saveButton = document.getElementById(ids.domElements.buttonSaveEdit);
  saveButton.className = "buttonSaveEdit";
  saveButton.addEventListener("click", window.calculator.editPage.storeEditedPage);
  saveButton.innerHTML = "Save";
  var editor = document.getElementById(ids.domElements.divEditorAce);
  editor.addEventListener("keydown", window.calculator.editPage.ctrlSPressAceEditorHandler);
  thePage.pages.editPage.editor = ace.edit(ids.domElements.divEditorAce);
}

function selectEditPageCallback(input, outputComponent) {
  var thePage = window.calculator.mainPage;
  try {
    var parsedInput = miscellaneous.jsonUnescapeParse(input);
    ace.require("ace/ext/language_tools");
    if (thePage.pages.editPage.editor === null) {
      initEditorAce();
    }
    if (parsedInput.autoComplete !== null && parsedInput.autoComplete !== undefined) {
      thePage.aceEditorAutoCompletionWordList = parsedInput.autoComplete;
    }
    var editor = thePage.pages.editPage.editor;
    editor.$blockScrolling = Infinity;
    var incomingContent = "";
    var errorSpan = document.getElementById(ids.domElements.spanErrorsEditPage);
    if (parsedInput.error !== null && parsedInput.error !== undefined) {
      errorSpan.innerHTML = `<br>${parsedInput.error}`;
    } else {
      errorSpan.innerHTML = "";
    }
    if (parsedInput.content !== null && parsedInput.content !== undefined) {
      incomingContent = decodeURIComponent(parsedInput.content);
    }
    var problemIdURLed = thePage.storage.variables.editor.currentlyEditedPage.getValue();
    thePage.storage.variables.currentCourse.fileName.setAndStore(decodeURIComponent(problemIdURLed));
    editor.getSession().setValue(incomingContent);
    editor.setTheme("ace/theme/chrome");
    editor.getSession().setMode("ace/mode/xml");
    editor.setOptions({
      enableBasicAutocompletion: true,
      enableLiveAutocompletion: true,
    });
    editor.completers = [staticWordCompleter];
    editor.$blockScrolling = Infinity;
    editor.resize();
  } catch (e) {
    console.log(`Error: ${e}`);
  }
}

/**@returns {HTMLElement} */
function getNextEditButton(problemId) {
  return getNavigationEditButton(problemId, "&#8594;");
}

/** @returns {HTMLElement} */
function getPreviousEditButton(problemId) {
  return getNavigationEditButton(problemId, "&#8592;");
}

/** @returns {HTMLElement} */
function getNavigationEditButton(problemId, contentHTML) {
  if (
    problemId === null ||
    problemId === "" ||
    problemId === undefined
  ) {
    return document.createTextNode("");
  }
  var navigationButton = document.createElement("button");
  navigationButton.addEventListener(
    "click", selectEditPage.bind(null, problemId)
  );
  navigationButton.className = "buttonNavigationStandard";
  navigationButton.innerHTML = contentHTML;
  return navigationButton;
}

function writeNextPreviousEditButton(currentlyEditedPage) {
  var thePage = window.calculator.mainPage;
  let problem = thePage.getProblemByIdOrNull(currentlyEditedPage);
  if (problem === null) {
    return;
  }
  var previousButtonSpan = document.getElementById(ids.domElements.spanButtonPreviousEdit);
  var nextButtonSpan = document.getElementById(ids.domElements.spanButtonNextEdit);
  if (previousButtonSpan !== null) {
    previousButtonSpan.innerHTML = "";
    previousButtonSpan.appendChild(getPreviousEditButton(problem.previousProblemId));
  }
  if (nextButtonSpan !== null) {
    nextButtonSpan.innerHTML = "";
    nextButtonSpan.appendChild(getNextEditButton(problem.nextProblemId));
  }
}

function selectEditPage(currentlyEditedPage) {
  var thePage = window.calculator.mainPage;
  var storageVariables = thePage.storage.variables;
  var fileNameSources = [
    storageVariables.editor.currentlyEditedPage,
    storageVariables.currentCourse.problemFileName,
    storageVariables.currentCourse.fileName,
    storageVariables.currentCourse.courseHome,
    storageVariables.currentCourse.topicList,
  ];
  for (var i = 0; i < fileNameSources.length; i++) {
    if (
      (typeof currentlyEditedPage) === "string" &&
      currentlyEditedPage !== ""
    ) {
      break;
    }
    currentlyEditedPage = fileNameSources[i].getValue();
  }
  if (
    currentlyEditedPage === undefined ||
    currentlyEditedPage === null ||
    currentlyEditedPage === ""
  ) {
    currentlyEditedPage = "/coursesavailable/default.txt";
  }
  storageVariables.editor.currentlyEditedPage.setAndStore(currentlyEditedPage);
  if (!thePage.flagProblemPageOnly) {
    if (thePage.storage.variables.currentPage.getValue() !== thePage.pages.editPage.name) {
      thePage.selectPage(thePage.pages.editPage.name);
      return;
    }
  }
  writeNextPreviousEditButton(currentlyEditedPage);
  var theTopicTextArea = document.getElementById(ids.domElements.textAreaTopicListEntry);
  theTopicTextArea.value = `Title: ${currentlyEditedPage}\nProblem: ${currentlyEditedPage}`;
  theTopicTextArea.cols = currentlyEditedPage.length + 15;

  var theURL = `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${pathnames.urlFields.requestEditPage}&`;
  theURL += `${pathnames.urlFields.problem.fileName}=${thePage.storage.variables.editor.currentlyEditedPage.getValue()}`;
  submitRequests.submitGET({
    url: theURL,
    callback: selectEditPageCallback,
    progress: ids.domElements.spanProgressReportGeneral,
  });
}

function toggleClonePanel(button) {
  var thePanel = button.nextElementSibling;
  if (thePanel.style.maxHeight === '200px') {
    thePanel.style.opacity = '0';
    thePanel.style.maxHeight = '0';
    button.innerHTML = `Clone panel &#9666;`;
  } else {
    thePanel.style.opacity = '1';
    thePanel.style.maxHeight = '200px';
    button.innerHTML = `Clone panel &#9660;`;
  }
}

module.exports = {
  storeEditedPage,
  toggleClonePanel,
  selectEditPage,
  getEditPanel,
  getClonePanel,
  handleClone,
  ctrlSPressAceEditorHandler
};
},
"/calculator-html/calculator_page" : function(require, module, exports){
"use strict";
const submitRequests = require("./submit_requests");
const pathnames = require("./pathnames");
const drawing = require("./three-d").drawing;
const ids = require("./ids_dom_elements");
const miscellaneousFrontend = require("./miscellaneous_frontend");
const miscellaneous = require("./miscellaneous_frontend");
const BufferCalculator = require("./buffer").BufferCalculator;
const panels = require("./panels");
const typeset = require("./math_typeset");
const processMonitoring = require("./process_monitoring");
const InputPanelData = require("./initialize_buttons").InputPanelData;
const storage = require("./storage");
const autocomplete = require("./autocomplete");
const initializeButtons = require("./initialize_buttons");

class AtomHandler {
  constructor() {
    this.description = "";
    this.atom = "";
    this.example = "";
    this.composite = false;
    this.index = - 1;
    this.totalRules = 0;
  }

  fromObject(
    input,
    /**@type {number}*/ index,
    /**@type {number}*/ totalRules,
  ) {
    this.index = index;
    this.totalRules = totalRules;
    this.description = input.description;
    this.example = input.example;
    this.atom = input.atom;
    this.ruleName = input.ruleName;
    if (input.composite === "true" || input.composite === true) {
      this.composite = true;
    } else {
      this.composite = false;
    }
  }

  toString(
    /**@type {Calculator}*/
    calculator,
  ) {
    let resultString = "";
    resultString += `<calculatorAtom>${this.atom}</calculatorAtom>`;
    if (this.composite) {
      resultString += "<calculatorCompositeAtom>(composite)</calculatorCompositeAtom>";
    }
    resultString += ` (${this.index + 1} out of ${this.totalRules})`;
    let currentId = "example_";
    if (this.composite) {
      currentId += "t_";
    } else {
      currentId += "f_";
    }
    let encodedAtom = encodeURIComponent(this.atom);
    currentId += `${encodedAtom}_${this.index}_${this.totalRules}`;
    resultString += `<a href = '#' class = 'linkInfo' onclick = "window.calculator.miscellaneousFrontend.switchMenu('${currentId}')">info</a>`;
    resultString += `<calculatorExampleInfo id = "${currentId}" class = "hiddenClass">${this.description}`;
    resultString += `<br><b>Example:</b><br>${this.example}</calculatorExampleInfo>`;
    let theLink = calculator.getComputationLink(this.example);
    resultString += `<a href = '#${theLink}' class = "linkInfo">Example</a>`;
    resultString += ` [${this.ruleName}]`;
    return resultString;
  }
}

class Calculator {
  constructor() {
    this.parsedComputation = {};
    /** @type {panels.PanelExpandableData[]}*/
    this.panels = [];
    this.inputBoxNames = [];
    this.inputBoxToSliderUpdaters = {};
    this.canvases = null;
    this.examples = null;
    this.submissionCalculatorCounter = 0;
    this.lastSubmittedInput = "";
    this.numberOfCalculatorPanels = 0;
    processMonitoring.monitor.ownerCalculator = this;
    /**@type{boolean} */
    this.flagTypeset = false;
    /**@type{boolean} */
    this.initialized = false;
    /**@type{InputPanelData|null} */
    this.calculatorPanel = null;
  }

  updateCalculatorSliderEventHandler(inputBox) {
    event.preventDefault();
    let sliderName = this.inputBoxToSliderUpdaters[inputBox.name];
    let theSliders = document.getElementsByName(sliderName);
    for (let counterSlider = 0; counterSlider < theSliders.length; counterSlider++) {
      let currentSlider = theSliders[counterSlider];
      currentSlider.value = inputBox.value;
    }
    this.updateSliderToInputBox(inputBox.name, sliderName);
  }

  addListenersToInputBoxes() {
    //let theString=" updating: box names, slider names: ";
    for (let i = 0; i < this.inputBoxNames.length; i++) {
      let theBoxes = document.getElementsByName(this.inputBoxNames[i]);
      for (let j = 0; j < theBoxes.length; j++) {
        theBoxes[j].addEventListener("input", this.updateCalculatorSliderEventHandler.bind(this, theBoxes[j]));
      }
    }
  }

  updateSliderToInputBox(boxName, sliderName) {
    let theBoxes = document.getElementsByName(boxName);
    let theSliders = document.getElementsByName(sliderName);
    let sliderValue = theSliders[0].value;
    for (let i = 0; i < theBoxes.length; i++) {
      theBoxes[i].value = sliderValue;
    }
    let plodtId = drawing.plotUpdaters[sliderName];
    if (plodtId !== undefined) {
      let theCanvas = drawing.canvases[plodtId];
      if (theCanvas !== undefined) {
        if (theCanvas.canvasResetFunction !== null) {
          theCanvas.canvasResetFunction();
        }
      }
    }
  }

  processOneFunctionAtom(handlers) {
    let resultStrings = [];
    for (let i = 0; i < handlers.length; i++) {
      resultStrings.push("<br>");
      let handler = new AtomHandler();
      handler.fromObject(handlers[i], i, handlers.length);
      resultStrings.push(handler.toString(this));
    }
    return resultStrings.join("");
  }

  processExamples(inputJSONtext) {
    try {
      this.examples = miscellaneous.jsonUnescapeParse(inputJSONtext);
      let examplesString = "";
      let atomsSorted = Object.keys(this.examples).slice().sort();
      let numHandlers = 0;
      for (let i = 0; i < atomsSorted.length; i++) {
        let atom = atomsSorted[i];
        let currentExamples = this.examples[atom];
        examplesString += this.processOneFunctionAtom(currentExamples.regular);
        examplesString += this.processOneFunctionAtom(currentExamples.composite);
        numHandlers += this.examples[atom].regular.length + this.examples[atom].composite.length;
      }
      let resultString = `${atomsSorted.length} built-in atoms, ${numHandlers} handlers. `;
      resultString += examplesString;
      document.getElementById(ids.domElements.calculatorExamples).innerHTML = resultString;
    } catch (e) {
      console.log(`Bad json: ${e}\n Input JSON follows.`);
      console.log(inputJSONtext);
    }
  }

  submitCalculatorInputOnEnter(event) {
    if (event.keyCode !== 13 || !event.shiftKey) {
      return;
    }
    this.submitComputation();
    event.preventDefault();
  }

  toggleExamples(theButton) {
    let theExamples = document.getElementById(ids.domElements.calculatorExamples);
    let theURL = "";
    theURL += pathnames.urls.calculatorAPI;
    theURL += `?${pathnames.urlFields.request}=${pathnames.urlFields.requests.calculatorExamplesJSON}`;
    if (theExamples.innerHTML.length < 300) {
      submitRequests.submitGET({
        url: theURL,
        callback: this.processExamples.bind(this),
        progress: "spanProgressCalculatorExamples"
      });
      theButton.innerHTML = "&#9660;";
    } else {
      miscellaneousFrontend.switchMenu(ids.domElements.calculatorExamples);
      if (!theExamples.classList.contains("hiddenClass")) {
        theButton.innerHTML = "&#9660;";
      } else {
        theButton.innerHTML = "&#9656;";
      }
    }
  }

  initialize() {
    if (this.initialized) {
      return;
    }
    this.initialized = true;
    this.calculatorPanel = new InputPanelData({
      idEquationEditorElement: "mainInputEditorField",
      idEditorComments: "mqPanelComments",
      problemId: "",
      idPureLatex: ids.domElements.pages.calculator.inputMain,
      idButtonContainer: 'mainInputEditorFieldButtons',
      flagCalculatorPanel: true,
      valueChangeHandler: () => {
        this.equationEditorChangeCallback();
      },
    });
    this.calculatorPanel.initialize();
    document.getElementById(ids.domElements.pages.calculator.monitoring.buttonPauseToggle).addEventListener(
      "click", () => {
        processMonitoring.monitor.togglePause();
      }
    )
    let inputMain = document.getElementById(ids.domElements.pages.calculator.inputMain);
    inputMain.addEventListener("keypress", (e) => {
      this.submitCalculatorInputOnEnter(e);
    });
    inputMain.addEventListener("keyup", (e) => {
      autocomplete.suggestWord();
      this.calculatorPanel.editorHelpCalculator();
    });
    inputMain.addEventListener("keydown", (e) => {
      autocomplete.suggestWord();
      this.calculatorPanel.editorHelpCalculator();
      autocomplete.arrowAction(e);
    });
    inputMain.addEventListener("mouseup", (e) => {
      autocomplete.suggestWord();
      this.calculatorPanel.editorHelpCalculator();
    });
    inputMain.addEventListener("input", (e) => {
      autocomplete.suggestWord();
      this.calculatorPanel.editorHelpCalculator();
    });
  }
  selectCalculatorPage() {
    this.initialize();
    this.submitComputation();
  }

  submitComputation() {
    processMonitoring.monitor.clearTimeout();
    let calculatorInput = document.getElementById(ids.domElements.pages.calculator.inputMain).value;
    this.typeset();
    if (calculatorInput === this.lastSubmittedInput) {
      return;
    }
    this.lastSubmittedInput = calculatorInput;
    // submitComputationPartTwo is called by a callback in the function below:
    storage.storage.variables.calculator.input.setAndStore(this.lastSubmittedInput);
  }

  /**@returns {String} */
  getComputationLink(input) {
    let theURL = {
      currentPage: "calculator",
      calculatorInput: input,
    };
    let thePage = window.calculator.mainPage;
    let stringifiedHash = thePage.storage.getPercentEncodedURL(theURL);
    return stringifiedHash;
  }

  writeErrorsAndCrashes(
    /**@type {BufferCalculator} */
    buffer,
    inputParsed,
  ) {
    if (
      inputParsed.error !== undefined &&
      inputParsed.error !== null &&
      inputParsed.error !== ""
    ) {
      buffer.write("<b style = 'color:red'>Error.</b>");
      buffer.write(inputParsed.error);
    }
    if (
      inputParsed.crashReport !== undefined &&
      inputParsed.crashReport !== null &&
      inputParsed.crashReport !== ""
    ) {
      buffer.write(inputParsed.crashReport);
    }
  }

  writeResult(
    /**@type {BufferCalculator} */
    buffer,
    inputParsed,
    /** @type {panels.PanelExpandableData[]} */
    panelData,
  ) {
    if (inputParsed.commentsGlobal !== "" && inputParsed.commentsGlobal !== undefined) {
      buffer.write(inputParsed.commentsGlobal);
    }
    if (inputParsed.result === undefined && inputParsed.comments !== undefined) {
      buffer.write(inputParsed.comments);
    }
    this.writeErrorsAndCrashes(buffer, inputParsed);
    if (inputParsed.timeOut === true) {
      if (inputParsed.timeOutComments !== undefined) {
        buffer.write(inputParsed.timeOutComments);
      }
      processMonitoring.monitor.start(inputParsed.workerId);
      return;
    }
    if (inputParsed.result === undefined && inputParsed.resultHtml !== undefined) {
      buffer.write(inputParsed.resultHtml);
    }
    if (inputParsed.result === undefined) {
      return;
    }
    buffer.write(`<table><tr><td>`);
    if (inputParsed.syntaxErrors !== undefined) {
      buffer.write(inputParsed.syntaxErrors);
    }
    buffer.write(`<table class = "tableCalculatorOutput"><tr><th>Input</th><th>Output</th></tr>`);
    if (typeof inputParsed.result.input === "string") {
      inputParsed.result.input = [inputParsed.result.input];
    }
    if (typeof inputParsed.result.output === "string") {
      inputParsed.result.output = [inputParsed.result.output];
    }
    let numEntries = Math.max(inputParsed.result.input.length, inputParsed.result.output.length);
    for (let i = 0; i < numEntries; i++) {
      this.numberOfCalculatorPanels++;
      let inputPanelId = `calculatorInputPanel${this.numberOfCalculatorPanels}`;
      let outputPanelId = `calculatorOutputPanel${this.numberOfCalculatorPanels}`;
      if (i < inputParsed.result.input.length) {
        panelData.push(new panels.PanelExpandableData(
          inputParsed.result.input[i], inputPanelId, 150,
        ));
      }
      if (i < inputParsed.result.output.length) {
        panelData.push(new panels.PanelExpandableData(
          inputParsed.result.output[i], outputPanelId, 150,
        ));
      }
      buffer.write(`<tr>`);
      buffer.write(`<td class = "cellCalculatorInput"><div id = "${inputPanelId}"></div></td>`);
      buffer.write(`<td class = "cellCalculatorResult"><div id = "${outputPanelId}"></div></td>`);
      buffer.write(`</tr>`);
    }
    buffer.write(`</table>`);
    buffer.write(`</td><td><div class = "containerComments">`);
    buffer.write("<small>Double-click formulas: get LaTeX. Double-click back: hide. </small>");
    let performance = inputParsed[pathnames.urlFields.result.performance];
    if (performance !== undefined) {
      let content = performance[pathnames.urlFields.result.comments];
      let label = `<b style='color:blue'>${performance[pathnames.urlFields.result.computationTime]}</b>`;
      buffer.write(`<div id = '${ids.domElements.divPerformance}'></div>`);
      panelData.push(new panels.PanelExpandableData(
        content,
        ids.domElements.divPerformance,
        0,
        true,
        label
      ));
      buffer.write("<br>");
    }
    if (inputParsed.comments !== undefined) {
      buffer.write(inputParsed.comments);
    }
    buffer.write(`</div></td>`);
    let mainPage = window.calculator.mainPage;
    if (mainPage.storage.variables.flagDebug.isTrue() && inputParsed.debug !== undefined) {
      buffer.write(`<td>`);
      buffer.write(inputParsed.debug);
      buffer.write(`</td>`);
    }
    buffer.write(`</tr></table>`);
    if (inputParsed.parsingLog !== undefined) {
      buffer.write(inputParsed.parsingLog);
    }
  }

  typeset() {
    if (storage.storage.variables.currentPage.getValue() !== "calculator") {
      return;
    }
    if (this.flagTypeset === true) {
      return;
    }
    typeset.typesetter.typesetSoft(
      ids.domElements.spanCalculatorMainOutput,
      "font-size: 20px; font-family:'Times New Roman'; display:inline-block;",
    );
    this.flagTypeset = true;
  }

  afterWriteOutput() {
    for (let i = 0; i < this.panels.length; i++) {
      panels.makePanelFromData(this.panels[i]);
    }
    let spanVerification = document.getElementById(ids.domElements.spanCalculatorMainOutput);
    let incomingScripts = spanVerification.getElementsByTagName("script");
    let thePage = window.calculator.mainPage;
    let oldScripts = thePage.pages.calculator.scriptIds;
    thePage.removeScripts(oldScripts);
    this.inputBoxNames = [];
    this.inputBoxToSliderUpdaters = {};
    this.canvases = {};
    thePage.pages.calculator.sciptIds = [];
    for (let i = 0; i < incomingScripts.length; i++) {
      let newId = `calculatorMainPageId_${i}`;
      thePage.pages.calculator.sciptIds.push(newId);
      thePage.injectScript(newId, incomingScripts[i].innerHTML);
    }
    this.addListenersToInputBoxes();
    this.flagTypeset = false;
    this.typeset();
  }

  defaultOnLoadInjectScriptsAndProcessLaTeX(input, output) {
    let inputHtml = null;
    this.panels.length = 0;
    try {
      this.parsedComputation = miscellaneous.jsonUnescapeParse(input);
      let buffer = new BufferCalculator();
      let progReportTimer = document.getElementById(ids.domElements.pages.calculator.monitoring.progressTimer);
      progReportTimer.innerHTML = "";
      this.writeResult(buffer, this.parsedComputation, this.panels);
      inputHtml = buffer.toString();
    } catch (e) {
      inputHtml = input + "<br>" + e;
      console.log("Error processing calculator output: " + e);
    }
    let spanVerification = document.getElementById(ids.domElements.spanCalculatorMainOutput);
    spanVerification.innerHTML = inputHtml;
    this.afterWriteOutput();
  }

  helpCalculator() {
    if (!this.initialized) {
      return;
    }
    this.calculatorPanel.editorHelpCalculator();
  }

  submitComputationPartTwo(input) {
    //<- this function is called by a callback trigerred when calling
    //thePage.storage.variables.calculator.input.setAndStore(...)
    let thePage = window.calculator.mainPage;
    let urlCopy = Object.assign({}, thePage.storage.urlObject);
    urlCopy.inputFocus = true;
    let stringifiedHash = thePage.storage.getPercentEncodedURL(urlCopy);
    document.getElementById("spanComputationLink").innerHTML = `<a href = '#${stringifiedHash}'>Link to your input</a>`;
    setTimeout(() => {
      this.helpCalculator();
    }, 0);
    let url = pathnames.urls.calculatorAPI;
    let parameters = this.getQueryStringSubmitStringAsMainInput(input, pathnames.urlFields.calculatorCompute);
    submitRequests.submitPOST({
      url: url,
      parameters: parameters,
      callback: this.defaultOnLoadInjectScriptsAndProcessLaTeX.bind(this),
      progress: ids.domElements.pages.calculator.progress,
    });
  }

  getQueryStringSubmitStringAsMainInput(theString, requestType) {
    let inputParams = '';
    let thePage = window.calculator.mainPage;
    inputParams += `${pathnames.urlFields.request}=${requestType}&`;
    inputParams += `${pathnames.urlFields.requests.calculatorInput}=${encodeURIComponent(theString)}&`;
    if (thePage.storage.variables.flagDebug.isTrue()) {
      inputParams += `${pathnames.urlFields.debugFlag}=true&`;
    }
    if (thePage.storage.variables.calculator.monitoring.value === "false") {
      inputParams += `${pathnames.urlFields.requests.monitoring}=false&`;
    } else {
      inputParams += `${pathnames.urlFields.requests.monitoring}=true&`;
    }
    return inputParams;
  }

  submitStringAsMainInput(theString, idOutput, requestType, onLoadFunction, idStatus) {
    let inputParams = this.getQueryStringSubmitStringAsMainInput(theString, requestType);
    this.submitStringCalculatorArgument(inputParams, idOutput, onLoadFunction, idStatus);
  }

  equationEditorChangeCallback() {
    if (!this.calculatorPanel.flagCalculatorMQStringIsOK) {
      return;
    }
    let theBoxContent = this.equationEditor.rootNode.toLatex();
    if (this.calculatorLeftString === null || this.calculatorRightString === null) {
      this.editorHelpCalculator();
    }
    let theInserted = initializeButtons.processMathQuillLatex(theBoxContent);
    if (theInserted.length > 0 && startingCharacterSectionUnderMathQuillEdit.length > 0) {
      if (theInserted[0] !== ' ') {
        theInserted = ' ' + theInserted;
      }
    }
    latexBox.value = this.calculatorLeftString + theInserted + this.calculatorRightString;
  }
}

let calculator = new Calculator();

module.exports = {
  calculator,
};

},
"/calculator-html/app" : function(require, module, exports){
"use strict";
const mainPage = require("./page_navigation");

//declare globals:

function initializeGlobals() {
  let incomingGlobals = {
    mainPage: null,
    login: null,
    signUp: null,
    forgotLogin: null,
    calculator: null,
    autocomplete: null,
    initializeButtons: null,
    selectCourse: null,
    coursePage: null,
    problemPage: null,
    standAloneProblem: null,
    hardCodedProblems: null,
    submitRequests: null,
    editPage: null,
    drawing: null,
    miscellaneousFrontend: null,
    accountActivation: null,
    manageAccounts: null,
    panels: null,
    database: null,
    mathjax: null,
    storageVariables: null,
    graphicsNDimensions: null,
    account: null,
    jwt: null,
    processMonitoring: null,
    crypto: null,
    themes: null,
    pageNavigation: null,
    equationEditor: null,
    hardCodedServerAddress: "",
  };
  if (window.calculator === undefined || window.calculator === null) {
    window.calculator = {};
  }
  window.calculator = Object.assign(window.calculator, incomingGlobals);
  if (window.calculator.flagRunMainPage === undefined) {
    window.calculator.flagRunMainPage = true;
  }
}

function loadGlobals() {
  let calculator = window.calculator;
  calculator.login = require("./login");
  calculator.signUp = require("./signup").signUp;
  calculator.forgotLogin = require("./forgot_password").forgotLogin;
  calculator.calculator = require("./calculator_page").calculator;
  calculator.autocomplete = require("./autocomplete");
  calculator.initializeButtons = require("./initialize_buttons");
  calculator.selectCourse = require("./select_course");
  calculator.coursePage = require("./course_page");
  calculator.problemPage = require("./problem_page");
  calculator.submitRequests = require("./submit_requests");
  calculator.editPage = require("./edit_page");
  calculator.drawing = require("./three-d").drawing;
  calculator.miscellaneousFrontend = require("./miscellaneous_frontend");
  calculator.accountActivation = require("./account_activation");
  calculator.manageAccounts = require("./manage_accounts");
  calculator.hardCodedProblems = require("./hard_coded_problems");
  calculator.account = require("./account");
  calculator.panels = require("./panels");
  calculator.database = require("./database");
  calculator.themes = require("./themes");
  //calculator.mathjax = require("./mathjax-calculator-setup");
  calculator.graphicsNDimensions = require("./graphics_n_dimensions");
  calculator.processMonitoring = require("./process_monitoring");
  calculator.pageNavigation = require("./page_navigation");
  calculator.equationEditor = require("./equation_editor");
  //initialize everything not initilized while loading:
  calculator.crypto = require("./crypto");
  require("./external/build/output-min");
  calculator.mainPage = new mainPage.Page();
  if (calculator.flagRunMainPage) {
    calculator.mainPage.initializeCalculatorPage();
  }
}

initializeGlobals();
loadGlobals();
},
"/calculator-html/process_monitoring" : function(require, module, exports){
"use strict";
const pathnames = require("./pathnames");
const submitRequests = require("./submit_requests");
const ids = require("./ids_dom_elements");
const BufferCalculator = require("./buffer").BufferCalculator;
const miscellaneous = require("./miscellaneous_frontend");

class Monitor {
  constructor() {
    this.isPaused = false;
    this.isFinished = true;
    this.timeIncrement = 2;
    this.timeOutOldCounter = 0;
    this.timeOutCounter = 0;
    /**@type{string} */
    this.currentWorkerId = "";
    this.currentTimeOutHandler = null;
    this.ownerCalculator = null;
  }

  start(
    /**@type{String} */
    workerId,
  ) {
    this.isFinished = false;
    this.isPaused = false;
    this.timeOutCounter = 0;
    this.timeOutOldCounter = 0;
    this.currentWorkerId = workerId;
    document.getElementById(ids.domElements.pages.calculator.monitoring.buttonPauseToggle).innerHTML = "Pause";
    this.progressReport();
  }

  progressReport() {
    // Process monitor is started by
    if (this.isFinished) {
      return;
    }
    if (this.isPaused) {
      return;
    }
    this.timeOutOldCounter = this.timeOutCounter;
    this.timeOutCounter += this.timeIncrement;
    var sURL = "";
    sURL += `${pathnames.urls.calculatorAPI}?${pathnames.urlFields.request}=${pathnames.urlFields.requests.indicator}`;
    sURL += `&${pathnames.urlFields.requests.workerId}=${this.currentWorkerId}`;
    submitRequests.submitGET({
      url: sURL,
      progress: ids.domElements.pages.calculator.progress,
      callback: this.callbackPauseRequest.bind(this),
    });
    this.clearTimeout();
    this.currentTimeOutHandler = setTimeout(this.progressReport.bind(this), this.timeIncrement * 1000);
  }

  clearTimeout() {
    clearTimeout(this.currentTimeOutHandler);
  }

  callbackPauseRequest(input, output) {
    var progressReportContent = "";
    if (input === "") {
      this.clearTimeout();
      this.currentTimeOutHandler = setTimeout(this.progressReport.bind(this), this.timeIncrement * 1000);
      return;
    }
    var indicatorButton = document.getElementById(ids.domElements.pages.calculator.monitoring.buttonPauseToggle);
    this.ownerCalculator.parsedComputation = miscellaneous.jsonUnescapeParse(input);
    var status = this.ownerCalculator.parsedComputation.status;
    var doUpdateCalculatorPage = false;
    if (status === undefined || status === null) {
      if (this.ownerCalculator.parsedComputation.error !== null && this.ownerCalculator.parsedComputation.error !== undefined) {
        status = "error";
        progressReportContent += `<b>Error.</b> ${this.ownerCalculator.parsedComputation.error}`;
        progressReportContent += `<br>`;
      }
    }
    if (status === "error") {
      this.isFinished = true;
      this.isPaused = false;
      indicatorButton.innerHTML = "finished";
    } else if (status === "finished" || status === "crash") {
      this.isFinished = true;
      this.isPaused = false;
      indicatorButton.innerHTML = "finished";
      doUpdateCalculatorPage = true;
    } else if (status === "paused") {
      this.isPaused = true;
      indicatorButton.innerHTML = "Continue";
    } else {
      if (status === "noReport") {
        progressReportContent += "No report on last ping. ";
      } else if (status === "unpaused") {
        progressReportContent += "Recently unpaused.";
      } else {
        doUpdateCalculatorPage = true;
      }
      this.isPaused = false;
      indicatorButton.innerHTML = "Pause";
      this.clearTimeout();
      this.currentTimeOutHandler = setTimeout(this.progressReport.bind(this), this.timeIncrement * 1000);
    }
    progressReportContent += `Refreshing every ${this.timeIncrement} second(s). `;
    progressReportContent += `Client time: ~${Math.floor(this.timeOutOldCounter)} second(s)<br>`;
    var progReportTimer = document.getElementById(ids.domElements.pages.calculator.monitoring.progressTimer);
    progReportTimer.innerHTML = progressReportContent;

    if (doUpdateCalculatorPage) {
      this.ownerCalculator.panels.length = 0;
      var buffer = new BufferCalculator();
      this.ownerCalculator.writeResult(buffer, this.ownerCalculator.parsedComputation, this.ownerCalculator.panels);
      var resultComponent = document.getElementById(ids.domElements.spanCalculatorMainOutput);
      resultComponent.innerHTML = buffer.toString();
      this.ownerCalculator.afterWriteOutput();
    }
  }

  togglePause() {
    if (this.isFinished) {
      return;
    }
    var pauseURL = "";
    pauseURL += `${pathnames.urls.calculatorAPI}?`;
    if (!this.isPaused) {
      pauseURL += `${pathnames.urlFields.request}=${pathnames.urlFields.requests.pause}&`;
    } else {
      pauseURL += `${pathnames.urlFields.request}=${pathnames.urlFields.requests.unpause}&`;
    }
    pauseURL += `${pathnames.urlFields.requests.workerId}=${this.currentWorkerId}&`;
    submitRequests.submitGET({
      url: pauseURL,
      callback: this.callbackPauseRequest.bind(this),
      progress: ids.domElements.pages.calculator.progress
    });
  }
}

let monitor = new Monitor();

module.exports = {
  monitor
};
},
"/calculator-html/external/build/output-min" : function(require, module, exports){
!function(){function e(t,r,i){function n(o,s){if(!r[o]){if(!t[o]){var f="function"==typeof require&&require;if(!s&&f)return f(o,!0);if(a)return a(o,!0);var c=new Error("Cannot find module '"+o+"'");throw c.code="MODULE_NOT_FOUND",c}var u=r[o]={exports:{}};t[o][0].call(u.exports,function(e){var r=t[o][1][e];return n(r||e)},u,u.exports,e,t,r,i)}return r[o].exports}for(var a="function"==typeof require&&require,o=0;o<i.length;o++)n(i[o]);return n}return e}()({1:[function(e,t,r){"use strict";window.calculator.jwt=e("jsonwebtoken")},{jsonwebtoken:107}],2:[function(e,t,r){var i=r;i.bignum=e("bn.js"),i.define=e("./asn1/api").define,i.base=e("./asn1/base"),i.constants=e("./asn1/constants"),i.decoders=e("./asn1/decoders"),i.encoders=e("./asn1/encoders")},{"./asn1/api":3,"./asn1/base":5,"./asn1/constants":9,"./asn1/decoders":11,"./asn1/encoders":14,"bn.js":17}],3:[function(e,t,r){function i(e,t){this.name=e,this.body=t,this.decoders={},this.encoders={}}var n=e("../asn1"),a=e("inherits"),o=r;o.define=function(e,t){return new i(e,t)},i.prototype._createNamed=function(t){var r;try{r=e("vm").runInThisContext("(function "+this.name+"(entity) {\n  this._initNamed(entity);\n})")}catch(i){r=function(e){this._initNamed(e)}}return a(r,t),r.prototype._initNamed=function(e){t.call(this,e)},new r(this)},i.prototype._getDecoder=function(e){return e=e||"der",this.decoders.hasOwnProperty(e)||(this.decoders[e]=this._createNamed(n.decoders[e])),this.decoders[e]},i.prototype.decode=function(e,t,r){return this._getDecoder(t).decode(e,r)},i.prototype._getEncoder=function(e){return e=e||"der",this.encoders.hasOwnProperty(e)||(this.encoders[e]=this._createNamed(n.encoders[e])),this.encoders[e]},i.prototype.encode=function(e,t,r){return this._getEncoder(t).encode(e,r)}},{"../asn1":2,inherits:103,vm:182}],4:[function(e,t,r){function i(e,t){return o.call(this,t),s.isBuffer(e)?(this.base=e,this.offset=0,void(this.length=e.length)):void this.error("Input not Buffer")}function n(e,t){if(Array.isArray(e))this.length=0,this.value=e.map(function(e){return e instanceof n||(e=new n(e,t)),this.length+=e.length,e},this);else if("number"==typeof e){if(!(e>=0&&255>=e))return t.error("non-byte EncoderBuffer value");this.value=e,this.length=1}else if("string"==typeof e)this.value=e,this.length=s.byteLength(e);else{if(!s.isBuffer(e))return t.error("Unsupported type: "+typeof e);this.value=e,this.length=e.length}}var a=e("inherits"),o=e("../base").Reporter,s=e("buffer").Buffer;a(i,o),r.DecoderBuffer=i,i.prototype.save=function(){return{offset:this.offset,reporter:o.prototype.save.call(this)}},i.prototype.restore=function(e){var t=new i(this.base);return t.offset=e.offset,t.length=this.offset,this.offset=e.offset,o.prototype.restore.call(this,e.reporter),t},i.prototype.isEmpty=function(){return this.offset===this.length},i.prototype.readUInt8=function(e){return this.offset+1<=this.length?this.base.readUInt8(this.offset++,!0):this.error(e||"DecoderBuffer overrun")},i.prototype.skip=function(e,t){if(!(this.offset+e<=this.length))return this.error(t||"DecoderBuffer overrun");var r=new i(this.base);return r._reporterState=this._reporterState,r.offset=this.offset,r.length=this.offset+e,this.offset+=e,r},i.prototype.raw=function(e){return this.base.slice(e?e.offset:this.offset,this.length)},r.EncoderBuffer=n,n.prototype.join=function(e,t){return e||(e=new s(this.length)),t||(t=0),0===this.length?e:(Array.isArray(this.value)?this.value.forEach(function(r){r.join(e,t),t+=r.length}):("number"==typeof this.value?e[t]=this.value:"string"==typeof this.value?e.write(this.value,t):s.isBuffer(this.value)&&this.value.copy(e,t),t+=this.length),e)}},{"../base":5,buffer:49,inherits:103}],5:[function(e,t,r){var i=r;i.Reporter=e("./reporter").Reporter,i.DecoderBuffer=e("./buffer").DecoderBuffer,i.EncoderBuffer=e("./buffer").EncoderBuffer,i.Node=e("./node")},{"./buffer":4,"./node":6,"./reporter":7}],6:[function(e,t,r){function i(e,t){var r={};this._baseState=r,r.enc=e,r.parent=t||null,r.children=null,r.tag=null,r.args=null,r.reverseArgs=null,r.choice=null,r.optional=!1,r.any=!1,r.obj=!1,r.use=null,r.useDecoder=null,r.key=null,r["default"]=null,r.explicit=null,r.implicit=null,r.contains=null,r.parent||(r.children=[],this._wrap())}var n=e("../base").Reporter,a=e("../base").EncoderBuffer,o=e("../base").DecoderBuffer,s=e("minimalistic-assert"),f=["seq","seqof","set","setof","objid","bool","gentime","utctime","null_","enum","int","objDesc","bitstr","bmpstr","charstr","genstr","graphstr","ia5str","iso646str","numstr","octstr","printstr","t61str","unistr","utf8str","videostr"],c=["key","obj","use","optional","explicit","implicit","def","choice","any","contains"].concat(f),u=["_peekTag","_decodeTag","_use","_decodeStr","_decodeObjid","_decodeTime","_decodeNull","_decodeInt","_decodeBool","_decodeList","_encodeComposite","_encodeStr","_encodeObjid","_encodeTime","_encodeNull","_encodeInt","_encodeBool"];t.exports=i;var h=["enc","parent","children","tag","args","reverseArgs","choice","optional","any","obj","use","alteredUse","key","default","explicit","implicit","contains"];i.prototype.clone=function(){var e=this._baseState,t={};h.forEach(function(r){t[r]=e[r]});var r=new this.constructor(t.parent);return r._baseState=t,r},i.prototype._wrap=function(){var e=this._baseState;c.forEach(function(t){this[t]=function(){var r=new this.constructor(this);return e.children.push(r),r[t].apply(r,arguments)}},this)},i.prototype._init=function(e){var t=this._baseState;s(null===t.parent),e.call(this),t.children=t.children.filter(function(e){return e._baseState.parent===this},this),s.equal(t.children.length,1,"Root node can have only one child")},i.prototype._useArgs=function(e){var t=this._baseState,r=e.filter(function(e){return e instanceof this.constructor},this);e=e.filter(function(e){return!(e instanceof this.constructor)},this),0!==r.length&&(s(null===t.children),t.children=r,r.forEach(function(e){e._baseState.parent=this},this)),0!==e.length&&(s(null===t.args),t.args=e,t.reverseArgs=e.map(function(e){if("object"!=typeof e||e.constructor!==Object)return e;var t={};return Object.keys(e).forEach(function(r){r==(0|r)&&(r|=0);var i=e[r];t[i]=r}),t}))},u.forEach(function(e){i.prototype[e]=function(){var t=this._baseState;throw new Error(e+" not implemented for encoding: "+t.enc)}}),f.forEach(function(e){i.prototype[e]=function(){var t=this._baseState,r=Array.prototype.slice.call(arguments);return s(null===t.tag),t.tag=e,this._useArgs(r),this}}),i.prototype.use=function(e){s(e);var t=this._baseState;return s(null===t.use),t.use=e,this},i.prototype.optional=function(){var e=this._baseState;return e.optional=!0,this},i.prototype.def=function(e){var t=this._baseState;return s(null===t["default"]),t["default"]=e,t.optional=!0,this},i.prototype.explicit=function(e){var t=this._baseState;return s(null===t.explicit&&null===t.implicit),t.explicit=e,this},i.prototype.implicit=function(e){var t=this._baseState;return s(null===t.explicit&&null===t.implicit),t.implicit=e,this},i.prototype.obj=function(){var e=this._baseState,t=Array.prototype.slice.call(arguments);return e.obj=!0,0!==t.length&&this._useArgs(t),this},i.prototype.key=function(e){var t=this._baseState;return s(null===t.key),t.key=e,this},i.prototype.any=function(){var e=this._baseState;return e.any=!0,this},i.prototype.choice=function(e){var t=this._baseState;return s(null===t.choice),t.choice=e,this._useArgs(Object.keys(e).map(function(t){return e[t]})),this},i.prototype.contains=function(e){var t=this._baseState;return s(null===t.use),t.contains=e,this},i.prototype._decode=function(e,t){var r=this._baseState;if(null===r.parent)return e.wrapResult(r.children[0]._decode(e,t));var i=r["default"],n=!0,a=null;if(null!==r.key&&(a=e.enterKey(r.key)),r.optional){var s=null;if(null!==r.explicit?s=r.explicit:null!==r.implicit?s=r.implicit:null!==r.tag&&(s=r.tag),null!==s||r.any){if(n=this._peekTag(e,s,r.any),e.isError(n))return n}else{var f=e.save();try{null===r.choice?this._decodeGeneric(r.tag,e,t):this._decodeChoice(e,t),n=!0}catch(c){n=!1}e.restore(f)}}var u;if(r.obj&&n&&(u=e.enterObject()),n){if(null!==r.explicit){var h=this._decodeTag(e,r.explicit);if(e.isError(h))return h;e=h}var d=e.offset;if(null===r.use&&null===r.choice){if(r.any)var f=e.save();var l=this._decodeTag(e,null!==r.implicit?r.implicit:r.tag,r.any);if(e.isError(l))return l;r.any?i=e.raw(f):e=l}if(t&&t.track&&null!==r.tag&&t.track(e.path(),d,e.length,"tagged"),t&&t.track&&null!==r.tag&&t.track(e.path(),e.offset,e.length,"content"),i=r.any?i:null===r.choice?this._decodeGeneric(r.tag,e,t):this._decodeChoice(e,t),e.isError(i))return i;if(r.any||null!==r.choice||null===r.children||r.children.forEach(function(r){r._decode(e,t)}),r.contains&&("octstr"===r.tag||"bitstr"===r.tag)){var p=new o(i);i=this._getUse(r.contains,e._reporterState.obj)._decode(p,t)}}return r.obj&&n&&(i=e.leaveObject(u)),null===r.key||null===i&&n!==!0?null!==a&&e.exitKey(a):e.leaveKey(a,r.key,i),i},i.prototype._decodeGeneric=function(e,t,r){var i=this._baseState;return"seq"===e||"set"===e?null:"seqof"===e||"setof"===e?this._decodeList(t,e,i.args[0],r):/str$/.test(e)?this._decodeStr(t,e,r):"objid"===e&&i.args?this._decodeObjid(t,i.args[0],i.args[1],r):"objid"===e?this._decodeObjid(t,null,null,r):"gentime"===e||"utctime"===e?this._decodeTime(t,e,r):"null_"===e?this._decodeNull(t,r):"bool"===e?this._decodeBool(t,r):"objDesc"===e?this._decodeStr(t,e,r):"int"===e||"enum"===e?this._decodeInt(t,i.args&&i.args[0],r):null!==i.use?this._getUse(i.use,t._reporterState.obj)._decode(t,r):t.error("unknown tag: "+e)},i.prototype._getUse=function(e,t){var r=this._baseState;return r.useDecoder=this._use(e,t),s(null===r.useDecoder._baseState.parent),r.useDecoder=r.useDecoder._baseState.children[0],r.implicit!==r.useDecoder._baseState.implicit&&(r.useDecoder=r.useDecoder.clone(),r.useDecoder._baseState.implicit=r.implicit),r.useDecoder},i.prototype._decodeChoice=function(e,t){var r=this._baseState,i=null,n=!1;return Object.keys(r.choice).some(function(a){var o=e.save(),s=r.choice[a];try{var f=s._decode(e,t);if(e.isError(f))return!1;i={type:a,value:f},n=!0}catch(c){return e.restore(o),!1}return!0},this),n?i:e.error("Choice not matched")},i.prototype._createEncoderBuffer=function(e){return new a(e,this.reporter)},i.prototype._encode=function(e,t,r){var i=this._baseState;if(null===i["default"]||i["default"]!==e){var n=this._encodeValue(e,t,r);if(void 0!==n&&!this._skipDefault(n,t,r))return n}},i.prototype._encodeValue=function(e,t,r){var i=this._baseState;if(null===i.parent)return i.children[0]._encode(e,t||new n);var a=null;if(this.reporter=t,i.optional&&void 0===e){if(null===i["default"])return;e=i["default"]}var o=null,s=!1;if(i.any)a=this._createEncoderBuffer(e);else if(i.choice)a=this._encodeChoice(e,t);else if(i.contains)o=this._getUse(i.contains,r)._encode(e,t),s=!0;else if(i.children)o=i.children.map(function(r){if("null_"===r._baseState.tag)return r._encode(null,t,e);if(null===r._baseState.key)return t.error("Child should have a key");var i=t.enterKey(r._baseState.key);if("object"!=typeof e)return t.error("Child expected, but input is not object");var n=r._encode(e[r._baseState.key],t,e);return t.leaveKey(i),n},this).filter(function(e){return e}),o=this._createEncoderBuffer(o);else if("seqof"===i.tag||"setof"===i.tag){if(!i.args||1!==i.args.length)return t.error("Too many args for : "+i.tag);if(!Array.isArray(e))return t.error("seqof/setof, but data is not Array");var f=this.clone();f._baseState.implicit=null,o=this._createEncoderBuffer(e.map(function(r){var i=this._baseState;return this._getUse(i.args[0],e)._encode(r,t)},f))}else null!==i.use?a=this._getUse(i.use,r)._encode(e,t):(o=this._encodePrimitive(i.tag,e),s=!0);var a;if(!i.any&&null===i.choice){var c=null!==i.implicit?i.implicit:i.tag,u=null===i.implicit?"universal":"context";null===c?null===i.use&&t.error("Tag could be omitted only for .use()"):null===i.use&&(a=this._encodeComposite(c,s,u,o))}return null!==i.explicit&&(a=this._encodeComposite(i.explicit,!1,"context",a)),a},i.prototype._encodeChoice=function(e,t){var r=this._baseState,i=r.choice[e.type];return i||s(!1,e.type+" not found in "+JSON.stringify(Object.keys(r.choice))),i._encode(e.value,t)},i.prototype._encodePrimitive=function(e,t){var r=this._baseState;if(/str$/.test(e))return this._encodeStr(t,e);if("objid"===e&&r.args)return this._encodeObjid(t,r.reverseArgs[0],r.args[1]);if("objid"===e)return this._encodeObjid(t,null,null);if("gentime"===e||"utctime"===e)return this._encodeTime(t,e);if("null_"===e)return this._encodeNull();if("int"===e||"enum"===e)return this._encodeInt(t,r.args&&r.reverseArgs[0]);if("bool"===e)return this._encodeBool(t);if("objDesc"===e)return this._encodeStr(t,e);throw new Error("Unsupported tag: "+e)},i.prototype._isNumstr=function(e){return/^[0-9 ]*$/.test(e)},i.prototype._isPrintstr=function(e){return/^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(e)}},{"../base":5,"minimalistic-assert":129}],7:[function(e,t,r){function i(e){this._reporterState={obj:null,path:[],options:e||{},errors:[]}}function n(e,t){this.path=e,this.rethrow(t)}var a=e("inherits");r.Reporter=i,i.prototype.isError=function(e){return e instanceof n},i.prototype.save=function(){var e=this._reporterState;return{obj:e.obj,pathLen:e.path.length}},i.prototype.restore=function(e){var t=this._reporterState;t.obj=e.obj,t.path=t.path.slice(0,e.pathLen)},i.prototype.enterKey=function(e){return this._reporterState.path.push(e)},i.prototype.exitKey=function(e){var t=this._reporterState;t.path=t.path.slice(0,e-1)},i.prototype.leaveKey=function(e,t,r){var i=this._reporterState;this.exitKey(e),null!==i.obj&&(i.obj[t]=r)},i.prototype.path=function(){return this._reporterState.path.join("/")},i.prototype.enterObject=function(){var e=this._reporterState,t=e.obj;return e.obj={},t},i.prototype.leaveObject=function(e){var t=this._reporterState,r=t.obj;return t.obj=e,r},i.prototype.error=function(e){var t,r=this._reporterState,i=e instanceof n;if(t=i?e:new n(r.path.map(function(e){return"["+JSON.stringify(e)+"]"}).join(""),e.message||e,e.stack),!r.options.partial)throw t;return i||r.errors.push(t),t},i.prototype.wrapResult=function(e){var t=this._reporterState;return t.options.partial?{result:this.isError(e)?null:e,errors:t.errors}:e},a(n,Error),n.prototype.rethrow=function(e){if(this.message=e+" at: "+(this.path||"(shallow)"),Error.captureStackTrace&&Error.captureStackTrace(this,n),!this.stack)try{throw new Error(this.message)}catch(t){this.stack=t.stack}return this}},{inherits:103}],8:[function(e,t,r){var i=e("../constants");r.tagClass={0:"universal",1:"application",2:"context",3:"private"},r.tagClassByName=i._reverse(r.tagClass),r.tag={0:"end",1:"bool",2:"int",3:"bitstr",4:"octstr",5:"null_",6:"objid",7:"objDesc",8:"external",9:"real",10:"enum",11:"embed",12:"utf8str",13:"relativeOid",16:"seq",17:"set",18:"numstr",19:"printstr",20:"t61str",21:"videostr",22:"ia5str",23:"utctime",24:"gentime",25:"graphstr",26:"iso646str",27:"genstr",28:"unistr",29:"charstr",30:"bmpstr"},r.tagByName=i._reverse(r.tag)},{"../constants":9}],9:[function(e,t,r){var i=r;i._reverse=function(e){var t={};return Object.keys(e).forEach(function(r){(0|r)==r&&(r=0|r);var i=e[r];t[i]=r}),t},i.der=e("./der")},{"./der":8}],10:[function(e,t,r){function i(e){this.enc="der",this.name=e.name,this.entity=e,this.tree=new n,this.tree._init(e.body)}function n(e){c.Node.call(this,"der",e)}function a(e,t){var r=e.readUInt8(t);if(e.isError(r))return r;var i=h.tagClass[r>>6],n=0===(32&r);if(31===(31&r)){var a=r;for(r=0;128===(128&a);){if(a=e.readUInt8(t),e.isError(a))return a;r<<=7,r|=127&a}}else r&=31;var o=h.tag[r];return{cls:i,primitive:n,tag:r,tagStr:o}}function o(e,t,r){var i=e.readUInt8(r);if(e.isError(i))return i;if(!t&&128===i)return null;if(0===(128&i))return i;var n=127&i;if(n>4)return e.error("length octect is too long");i=0;for(var a=0;n>a;a++){i<<=8;var o=e.readUInt8(r);if(e.isError(o))return o;i|=o}return i}var s=e("inherits"),f=e("../../asn1"),c=f.base,u=f.bignum,h=f.constants.der;t.exports=i,i.prototype.decode=function(e,t){return e instanceof c.DecoderBuffer||(e=new c.DecoderBuffer(e,t)),this.tree._decode(e,t)},s(n,c.Node),n.prototype._peekTag=function(e,t,r){if(e.isEmpty())return!1;var i=e.save(),n=a(e,'Failed to peek tag: "'+t+'"');return e.isError(n)?n:(e.restore(i),n.tag===t||n.tagStr===t||n.tagStr+"of"===t||r)},n.prototype._decodeTag=function(e,t,r){var i=a(e,'Failed to decode tag of "'+t+'"');if(e.isError(i))return i;var n=o(e,i.primitive,'Failed to get length of "'+t+'"');if(e.isError(n))return n;if(!r&&i.tag!==t&&i.tagStr!==t&&i.tagStr+"of"!==t)return e.error('Failed to match tag: "'+t+'"');if(i.primitive||null!==n)return e.skip(n,'Failed to match body of: "'+t+'"');var s=e.save(),f=this._skipUntilEnd(e,'Failed to skip indefinite length body: "'+this.tag+'"');return e.isError(f)?f:(n=e.offset-s.offset,e.restore(s),e.skip(n,'Failed to match body of: "'+t+'"'))},n.prototype._skipUntilEnd=function(e,t){for(;;){var r=a(e,t);if(e.isError(r))return r;var i=o(e,r.primitive,t);if(e.isError(i))return i;var n;if(n=r.primitive||null!==i?e.skip(i):this._skipUntilEnd(e,t),e.isError(n))return n;if("end"===r.tagStr)break}},n.prototype._decodeList=function(e,t,r,i){for(var n=[];!e.isEmpty();){var a=this._peekTag(e,"end");if(e.isError(a))return a;var o=r.decode(e,"der",i);if(e.isError(o)&&a)break;n.push(o)}return n},n.prototype._decodeStr=function(e,t){if("bitstr"===t){var r=e.readUInt8();return e.isError(r)?r:{unused:r,data:e.raw()}}if("bmpstr"===t){var i=e.raw();if(i.length%2===1)return e.error("Decoding of string type: bmpstr length mismatch");for(var n="",a=0;a<i.length/2;a++)n+=String.fromCharCode(i.readUInt16BE(2*a));return n}if("numstr"===t){var o=e.raw().toString("ascii");return this._isNumstr(o)?o:e.error("Decoding of string type: numstr unsupported characters")}if("octstr"===t)return e.raw();if("objDesc"===t)return e.raw();if("printstr"===t){var s=e.raw().toString("ascii");return this._isPrintstr(s)?s:e.error("Decoding of string type: printstr unsupported characters")}return/str$/.test(t)?e.raw().toString():e.error("Decoding of string type: "+t+" unsupported")},n.prototype._decodeObjid=function(e,t,r){for(var i,n=[],a=0;!e.isEmpty();){var o=e.readUInt8();a<<=7,a|=127&o,0===(128&o)&&(n.push(a),a=0)}128&o&&n.push(a);var s=n[0]/40|0,f=n[0]%40;if(i=r?n:[s,f].concat(n.slice(1)),t){var c=t[i.join(" ")];void 0===c&&(c=t[i.join(".")]),void 0!==c&&(i=c)}return i},n.prototype._decodeTime=function(e,t){var r=e.raw().toString();if("gentime"===t)var i=0|r.slice(0,4),n=0|r.slice(4,6),a=0|r.slice(6,8),o=0|r.slice(8,10),s=0|r.slice(10,12),f=0|r.slice(12,14);else{if("utctime"!==t)return e.error("Decoding "+t+" time is not supported yet");var i=0|r.slice(0,2),n=0|r.slice(2,4),a=0|r.slice(4,6),o=0|r.slice(6,8),s=0|r.slice(8,10),f=0|r.slice(10,12);i=70>i?2e3+i:1900+i}return Date.UTC(i,n-1,a,o,s,f,0)},n.prototype._decodeNull=function(e){return null},n.prototype._decodeBool=function(e){var t=e.readUInt8();return e.isError(t)?t:0!==t},n.prototype._decodeInt=function(e,t){var r=e.raw(),i=new u(r);return t&&(i=t[i.toString(10)]||i),i},n.prototype._use=function(e,t){return"function"==typeof e&&(e=e(t)),e._getDecoder("der").tree}},{"../../asn1":2,inherits:103}],11:[function(e,t,r){var i=r;i.der=e("./der"),i.pem=e("./pem")},{"./der":10,"./pem":12}],12:[function(e,t,r){function i(e){o.call(this,e),this.enc="pem"}var n=e("inherits"),a=e("buffer").Buffer,o=e("./der");n(i,o),t.exports=i,i.prototype.decode=function(e,t){for(var r=e.toString().split(/[\r\n]+/g),i=t.label.toUpperCase(),n=/^-----(BEGIN|END) ([^-]+)-----$/,s=-1,f=-1,c=0;c<r.length;c++){var u=r[c].match(n);if(null!==u&&u[2]===i){if(-1!==s){if("END"!==u[1])break;f=c;break}if("BEGIN"!==u[1])break;s=c}}if(-1===s||-1===f)throw new Error("PEM section not found for: "+i);var h=r.slice(s+1,f).join("");h.replace(/[^a-z0-9\+\/=]+/gi,"");var d=new a(h,"base64");return o.prototype.decode.call(this,d,t)}},{"./der":10,buffer:49,inherits:103}],13:[function(e,t,r){function i(e){this.enc="der",this.name=e.name,this.entity=e,this.tree=new n,this.tree._init(e.body)}function n(e){u.Node.call(this,"der",e)}function a(e){return 10>e?"0"+e:e}function o(e,t,r,i){var n;if("seqof"===e?e="seq":"setof"===e&&(e="set"),h.tagByName.hasOwnProperty(e))n=h.tagByName[e];else{if("number"!=typeof e||(0|e)!==e)return i.error("Unknown tag: "+e);n=e}return n>=31?i.error("Multi-octet tag encoding unsupported"):(t||(n|=32),n|=h.tagClassByName[r||"universal"]<<6)}var s=e("inherits"),f=e("buffer").Buffer,c=e("../../asn1"),u=c.base,h=c.constants.der;t.exports=i,i.prototype.encode=function(e,t){return this.tree._encode(e,t).join()},s(n,u.Node),n.prototype._encodeComposite=function(e,t,r,i){var n=o(e,t,r,this.reporter);if(i.length<128){var a=new f(2);return a[0]=n,a[1]=i.length,this._createEncoderBuffer([a,i])}for(var s=1,c=i.length;c>=256;c>>=8)s++;var a=new f(2+s);a[0]=n,a[1]=128|s;for(var c=1+s,u=i.length;u>0;c--,u>>=8)a[c]=255&u;return this._createEncoderBuffer([a,i])},n.prototype._encodeStr=function(e,t){if("bitstr"===t)return this._createEncoderBuffer([0|e.unused,e.data]);if("bmpstr"===t){for(var r=new f(2*e.length),i=0;i<e.length;i++)r.writeUInt16BE(e.charCodeAt(i),2*i);return this._createEncoderBuffer(r)}return"numstr"===t?this._isNumstr(e)?this._createEncoderBuffer(e):this.reporter.error("Encoding of string type: numstr supports only digits and space"):"printstr"===t?this._isPrintstr(e)?this._createEncoderBuffer(e):this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark"):/str$/.test(t)?this._createEncoderBuffer(e):"objDesc"===t?this._createEncoderBuffer(e):this.reporter.error("Encoding of string type: "+t+" unsupported")},n.prototype._encodeObjid=function(e,t,r){if("string"==typeof e){if(!t)return this.reporter.error("string objid given, but no values map found");if(!t.hasOwnProperty(e))return this.reporter.error("objid not found in values map");e=t[e].split(/[\s\.]+/g);for(var i=0;i<e.length;i++)e[i]|=0}else if(Array.isArray(e)){e=e.slice();for(var i=0;i<e.length;i++)e[i]|=0}if(!Array.isArray(e))return this.reporter.error("objid() should be either array or string, got: "+JSON.stringify(e));if(!r){if(e[1]>=40)return this.reporter.error("Second objid identifier OOB");e.splice(0,2,40*e[0]+e[1])}for(var n=0,i=0;i<e.length;i++){var a=e[i];for(n++;a>=128;a>>=7)n++}for(var o=new f(n),s=o.length-1,i=e.length-1;i>=0;i--){var a=e[i];for(o[s--]=127&a;(a>>=7)>0;)o[s--]=128|127&a}return this._createEncoderBuffer(o)},n.prototype._encodeTime=function(e,t){var r,i=new Date(e);return"gentime"===t?r=[a(i.getFullYear()),a(i.getUTCMonth()+1),a(i.getUTCDate()),a(i.getUTCHours()),a(i.getUTCMinutes()),a(i.getUTCSeconds()),"Z"].join(""):"utctime"===t?r=[a(i.getFullYear()%100),a(i.getUTCMonth()+1),a(i.getUTCDate()),a(i.getUTCHours()),a(i.getUTCMinutes()),a(i.getUTCSeconds()),"Z"].join(""):this.reporter.error("Encoding "+t+" time is not supported yet"),this._encodeStr(r,"octstr")},n.prototype._encodeNull=function(){return this._createEncoderBuffer("")},n.prototype._encodeInt=function(e,t){if("string"==typeof e){if(!t)return this.reporter.error("String int or enum given, but no values map");if(!t.hasOwnProperty(e))return this.reporter.error("Values map doesn't contain: "+JSON.stringify(e));e=t[e]}if("number"!=typeof e&&!f.isBuffer(e)){var r=e.toArray();!e.sign&&128&r[0]&&r.unshift(0),e=new f(r)}if(f.isBuffer(e)){var i=e.length;0===e.length&&i++;var n=new f(i);return e.copy(n),0===e.length&&(n[0]=0),this._createEncoderBuffer(n)}if(128>e)return this._createEncoderBuffer(e);if(256>e)return this._createEncoderBuffer([0,e]);for(var i=1,a=e;a>=256;a>>=8)i++;for(var n=new Array(i),a=n.length-1;a>=0;a--)n[a]=255&e,e>>=8;return 128&n[0]&&n.unshift(0),this._createEncoderBuffer(new f(n))},n.prototype._encodeBool=function(e){return this._createEncoderBuffer(e?255:0)},n.prototype._use=function(e,t){return"function"==typeof e&&(e=e(t)),e._getEncoder("der").tree},n.prototype._skipDefault=function(e,t,r){var i,n=this._baseState;if(null===n["default"])return!1;var a=e.join();if(void 0===n.defaultBuffer&&(n.defaultBuffer=this._encodeValue(n["default"],t,r).join()),a.length!==n.defaultBuffer.length)return!1;for(i=0;i<a.length;i++)if(a[i]!==n.defaultBuffer[i])return!1;return!0}},{"../../asn1":2,buffer:49,inherits:103}],14:[function(e,t,r){var i=r;i.der=e("./der"),i.pem=e("./pem")},{"./der":13,"./pem":15}],15:[function(e,t,r){function i(e){a.call(this,e),this.enc="pem"}var n=e("inherits"),a=e("./der");n(i,a),t.exports=i,i.prototype.encode=function(e,t){for(var r=a.prototype.encode.call(this,e),i=r.toString("base64"),n=["-----BEGIN "+t.label+"-----"],o=0;o<i.length;o+=64)n.push(i.slice(o,o+64));return n.push("-----END "+t.label+"-----"),n.join("\n")}},{"./der":13,inherits:103}],16:[function(e,t,r){"use strict";function i(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");-1===r&&(r=t);var i=r===t?0:4-r%4;return[r,i]}function n(e){var t=i(e),r=t[0],n=t[1];return 3*(r+n)/4-n}function a(e,t,r){return 3*(t+r)/4-r}function o(e){for(var t,r=i(e),n=r[0],o=r[1],s=new d(a(e,n,o)),f=0,c=o>0?n-4:n,u=0;c>u;u+=4)t=h[e.charCodeAt(u)]<<18|h[e.charCodeAt(u+1)]<<12|h[e.charCodeAt(u+2)]<<6|h[e.charCodeAt(u+3)],s[f++]=t>>16&255,s[f++]=t>>8&255,s[f++]=255&t;return 2===o&&(t=h[e.charCodeAt(u)]<<2|h[e.charCodeAt(u+1)]>>4,s[f++]=255&t),1===o&&(t=h[e.charCodeAt(u)]<<10|h[e.charCodeAt(u+1)]<<4|h[e.charCodeAt(u+2)]>>2,s[f++]=t>>8&255,s[f++]=255&t),s}function s(e){return u[e>>18&63]+u[e>>12&63]+u[e>>6&63]+u[63&e]}function f(e,t,r){for(var i,n=[],a=t;r>a;a+=3)i=(e[a]<<16&16711680)+(e[a+1]<<8&65280)+(255&e[a+2]),n.push(s(i));return n.join("")}function c(e){for(var t,r=e.length,i=r%3,n=[],a=16383,o=0,s=r-i;s>o;o+=a)n.push(f(e,o,o+a>s?s:o+a));return 1===i?(t=e[r-1],n.push(u[t>>2]+u[t<<4&63]+"==")):2===i&&(t=(e[r-2]<<8)+e[r-1],n.push(u[t>>10]+u[t>>4&63]+u[t<<2&63]+"=")),n.join("")}r.byteLength=n,r.toByteArray=o,r.fromByteArray=c;for(var u=[],h=[],d="undefined"!=typeof Uint8Array?Uint8Array:Array,l="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",p=0,b=l.length;b>p;++p)u[p]=l[p],h[l.charCodeAt(p)]=p;h["-".charCodeAt(0)]=62,h["_".charCodeAt(0)]=63},{}],17:[function(e,t,r){!function(t,r){"use strict";function i(e,t){if(!e)throw new Error(t||"Assertion failed")}function n(e,t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}function a(e,t,r){return a.isBN(e)?e:(this.negative=0,this.words=null,this.length=0,this.red=null,void(null!==e&&(("le"===t||"be"===t)&&(r=t,t=10),this._init(e||0,t||10,r||"be"))))}function o(e,t,r){for(var i=0,n=Math.min(e.length,r),a=t;n>a;a++){var o=e.charCodeAt(a)-48;i<<=4,i|=o>=49&&54>=o?o-49+10:o>=17&&22>=o?o-17+10:15&o}return i}function s(e,t,r,i){for(var n=0,a=Math.min(e.length,r),o=t;a>o;o++){var s=e.charCodeAt(o)-48;n*=i,n+=s>=49?s-49+10:s>=17?s-17+10:s}return n}function f(e){for(var t=new Array(e.bitLength()),r=0;r<t.length;r++){var i=r/26|0,n=r%26;t[r]=(e.words[i]&1<<n)>>>n}return t}function c(e,t,r){r.negative=t.negative^e.negative;var i=e.length+t.length|0;r.length=i,i=i-1|0;var n=0|e.words[0],a=0|t.words[0],o=n*a,s=67108863&o,f=o/67108864|0;r.words[0]=s;for(var c=1;i>c;c++){for(var u=f>>>26,h=67108863&f,d=Math.min(c,t.length-1),l=Math.max(0,c-e.length+1);d>=l;l++){var p=c-l|0;n=0|e.words[p],a=0|t.words[l],o=n*a+h,u+=o/67108864|0,h=67108863&o}r.words[c]=0|h,f=0|u}return 0!==f?r.words[c]=0|f:r.length--,r.strip()}function u(e,t,r){r.negative=t.negative^e.negative,r.length=e.length+t.length;for(var i=0,n=0,a=0;a<r.length-1;a++){var o=n;n=0;for(var s=67108863&i,f=Math.min(a,t.length-1),c=Math.max(0,a-e.length+1);f>=c;c++){var u=a-c,h=0|e.words[u],d=0|t.words[c],l=h*d,p=67108863&l;o=o+(l/67108864|0)|0,p=p+s|0,s=67108863&p,o=o+(p>>>26)|0,n+=o>>>26,o&=67108863}r.words[a]=s,i=o,o=n}return 0!==i?r.words[a]=i:r.length--,r.strip()}function h(e,t,r){var i=new d;return i.mulp(e,t,r)}function d(e,t){this.x=e,this.y=t}function l(e,t){this.name=e,this.p=new a(t,16),this.n=this.p.bitLength(),this.k=new a(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}function p(){l.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}function b(){l.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}function y(){l.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}function m(){l.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}function g(e){if("string"==typeof e){var t=a._prime(e);this.m=t.p,this.prime=t}else i(e.gtn(1),"modulus must be greater than 1"),this.m=e,this.prime=null}function v(e){g.call(this,e),this.shift=this.m.bitLength(),this.shift%26!==0&&(this.shift+=26-this.shift%26),this.r=new a(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}"object"==typeof t?t.exports=a:r.BN=a,a.BN=a,a.wordSize=26;var w;try{w=e("buffer").Buffer}catch(_){}a.isBN=function(e){return e instanceof a?!0:null!==e&&"object"==typeof e&&e.constructor.wordSize===a.wordSize&&Array.isArray(e.words)},a.max=function(e,t){return e.cmp(t)>0?e:t},a.min=function(e,t){return e.cmp(t)<0?e:t},a.prototype._init=function(e,t,r){if("number"==typeof e)return this._initNumber(e,t,r);if("object"==typeof e)return this._initArray(e,t,r);"hex"===t&&(t=16),i(t===(0|t)&&t>=2&&36>=t),e=e.toString().replace(/\s+/g,"");var n=0;"-"===e[0]&&n++,16===t?this._parseHex(e,n):this._parseBase(e,t,n),"-"===e[0]&&(this.negative=1),this.strip(),"le"===r&&this._initArray(this.toArray(),t,r)},a.prototype._initNumber=function(e,t,r){0>e&&(this.negative=1,e=-e),67108864>e?(this.words=[67108863&e],this.length=1):4503599627370496>e?(this.words=[67108863&e,e/67108864&67108863],this.length=2):(i(9007199254740992>e),this.words=[67108863&e,e/67108864&67108863,1],this.length=3),"le"===r&&this._initArray(this.toArray(),t,r)},a.prototype._initArray=function(e,t,r){if(i("number"==typeof e.length),e.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(e.length/3),this.words=new Array(this.length);for(var n=0;n<this.length;n++)this.words[n]=0;var a,o,s=0;if("be"===r)for(n=e.length-1,a=0;n>=0;n-=3)o=e[n]|e[n-1]<<8|e[n-2]<<16,this.words[a]|=o<<s&67108863,this.words[a+1]=o>>>26-s&67108863,s+=24,s>=26&&(s-=26,a++);else if("le"===r)for(n=0,a=0;n<e.length;n+=3)o=e[n]|e[n+1]<<8|e[n+2]<<16,this.words[a]|=o<<s&67108863,this.words[a+1]=o>>>26-s&67108863,s+=24,s>=26&&(s-=26,a++);return this.strip()},a.prototype._parseHex=function(e,t){this.length=Math.ceil((e.length-t)/6),this.words=new Array(this.length);for(var r=0;r<this.length;r++)this.words[r]=0;var i,n,a=0;for(r=e.length-6,i=0;r>=t;r-=6)n=o(e,r,r+6),this.words[i]|=n<<a&67108863,this.words[i+1]|=n>>>26-a&4194303,a+=24,a>=26&&(a-=26,i++);r+6!==t&&(n=o(e,t,r+6),this.words[i]|=n<<a&67108863,this.words[i+1]|=n>>>26-a&4194303),this.strip()},a.prototype._parseBase=function(e,t,r){this.words=[0],this.length=1;for(var i=0,n=1;67108863>=n;n*=t)i++;i--,n=n/t|0;for(var a=e.length-r,o=a%i,f=Math.min(a,a-o)+r,c=0,u=r;f>u;u+=i)c=s(e,u,u+i,t),this.imuln(n),this.words[0]+c<67108864?this.words[0]+=c:this._iaddn(c);if(0!==o){var h=1;for(c=s(e,u,e.length,t),u=0;o>u;u++)h*=t;this.imuln(h),this.words[0]+c<67108864?this.words[0]+=c:this._iaddn(c)}},a.prototype.copy=function(e){e.words=new Array(this.length);for(var t=0;t<this.length;t++)e.words[t]=this.words[t];e.length=this.length,e.negative=this.negative,e.red=this.red},a.prototype.clone=function(){var e=new a(null);return this.copy(e),e},a.prototype._expand=function(e){for(;this.length<e;)this.words[this.length++]=0;return this},a.prototype.strip=function(){for(;this.length>1&&0===this.words[this.length-1];)this.length--;return this._normSign();
},a.prototype._normSign=function(){return 1===this.length&&0===this.words[0]&&(this.negative=0),this},a.prototype.inspect=function(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"};var S=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],M=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],E=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];a.prototype.toString=function(e,t){e=e||10,t=0|t||1;var r;if(16===e||"hex"===e){r="";for(var n=0,a=0,o=0;o<this.length;o++){var s=this.words[o],f=(16777215&(s<<n|a)).toString(16);a=s>>>24-n&16777215,r=0!==a||o!==this.length-1?S[6-f.length]+f+r:f+r,n+=2,n>=26&&(n-=26,o--)}for(0!==a&&(r=a.toString(16)+r);r.length%t!==0;)r="0"+r;return 0!==this.negative&&(r="-"+r),r}if(e===(0|e)&&e>=2&&36>=e){var c=M[e],u=E[e];r="";var h=this.clone();for(h.negative=0;!h.isZero();){var d=h.modn(u).toString(e);h=h.idivn(u),r=h.isZero()?d+r:S[c-d.length]+d+r}for(this.isZero()&&(r="0"+r);r.length%t!==0;)r="0"+r;return 0!==this.negative&&(r="-"+r),r}i(!1,"Base should be between 2 and 36")},a.prototype.toNumber=function(){var e=this.words[0];return 2===this.length?e+=67108864*this.words[1]:3===this.length&&1===this.words[2]?e+=4503599627370496+67108864*this.words[1]:this.length>2&&i(!1,"Number can only safely store up to 53 bits"),0!==this.negative?-e:e},a.prototype.toJSON=function(){return this.toString(16)},a.prototype.toBuffer=function(e,t){return i("undefined"!=typeof w),this.toArrayLike(w,e,t)},a.prototype.toArray=function(e,t){return this.toArrayLike(Array,e,t)},a.prototype.toArrayLike=function(e,t,r){var n=this.byteLength(),a=r||Math.max(1,n);i(a>=n,"byte array longer than desired length"),i(a>0,"Requested array length <= 0"),this.strip();var o,s,f="le"===t,c=new e(a),u=this.clone();if(f){for(s=0;!u.isZero();s++)o=u.andln(255),u.iushrn(8),c[s]=o;for(;a>s;s++)c[s]=0}else{for(s=0;a-n>s;s++)c[s]=0;for(s=0;!u.isZero();s++)o=u.andln(255),u.iushrn(8),c[a-s-1]=o}return c},Math.clz32?a.prototype._countBits=function(e){return 32-Math.clz32(e)}:a.prototype._countBits=function(e){var t=e,r=0;return t>=4096&&(r+=13,t>>>=13),t>=64&&(r+=7,t>>>=7),t>=8&&(r+=4,t>>>=4),t>=2&&(r+=2,t>>>=2),r+t},a.prototype._zeroBits=function(e){if(0===e)return 26;var t=e,r=0;return 0===(8191&t)&&(r+=13,t>>>=13),0===(127&t)&&(r+=7,t>>>=7),0===(15&t)&&(r+=4,t>>>=4),0===(3&t)&&(r+=2,t>>>=2),0===(1&t)&&r++,r},a.prototype.bitLength=function(){var e=this.words[this.length-1],t=this._countBits(e);return 26*(this.length-1)+t},a.prototype.zeroBits=function(){if(this.isZero())return 0;for(var e=0,t=0;t<this.length;t++){var r=this._zeroBits(this.words[t]);if(e+=r,26!==r)break}return e},a.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},a.prototype.toTwos=function(e){return 0!==this.negative?this.abs().inotn(e).iaddn(1):this.clone()},a.prototype.fromTwos=function(e){return this.testn(e-1)?this.notn(e).iaddn(1).ineg():this.clone()},a.prototype.isNeg=function(){return 0!==this.negative},a.prototype.neg=function(){return this.clone().ineg()},a.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},a.prototype.iuor=function(e){for(;this.length<e.length;)this.words[this.length++]=0;for(var t=0;t<e.length;t++)this.words[t]=this.words[t]|e.words[t];return this.strip()},a.prototype.ior=function(e){return i(0===(this.negative|e.negative)),this.iuor(e)},a.prototype.or=function(e){return this.length>e.length?this.clone().ior(e):e.clone().ior(this)},a.prototype.uor=function(e){return this.length>e.length?this.clone().iuor(e):e.clone().iuor(this)},a.prototype.iuand=function(e){var t;t=this.length>e.length?e:this;for(var r=0;r<t.length;r++)this.words[r]=this.words[r]&e.words[r];return this.length=t.length,this.strip()},a.prototype.iand=function(e){return i(0===(this.negative|e.negative)),this.iuand(e)},a.prototype.and=function(e){return this.length>e.length?this.clone().iand(e):e.clone().iand(this)},a.prototype.uand=function(e){return this.length>e.length?this.clone().iuand(e):e.clone().iuand(this)},a.prototype.iuxor=function(e){var t,r;this.length>e.length?(t=this,r=e):(t=e,r=this);for(var i=0;i<r.length;i++)this.words[i]=t.words[i]^r.words[i];if(this!==t)for(;i<t.length;i++)this.words[i]=t.words[i];return this.length=t.length,this.strip()},a.prototype.ixor=function(e){return i(0===(this.negative|e.negative)),this.iuxor(e)},a.prototype.xor=function(e){return this.length>e.length?this.clone().ixor(e):e.clone().ixor(this)},a.prototype.uxor=function(e){return this.length>e.length?this.clone().iuxor(e):e.clone().iuxor(this)},a.prototype.inotn=function(e){i("number"==typeof e&&e>=0);var t=0|Math.ceil(e/26),r=e%26;this._expand(t),r>0&&t--;for(var n=0;t>n;n++)this.words[n]=67108863&~this.words[n];return r>0&&(this.words[n]=~this.words[n]&67108863>>26-r),this.strip()},a.prototype.notn=function(e){return this.clone().inotn(e)},a.prototype.setn=function(e,t){i("number"==typeof e&&e>=0);var r=e/26|0,n=e%26;return this._expand(r+1),t?this.words[r]=this.words[r]|1<<n:this.words[r]=this.words[r]&~(1<<n),this.strip()},a.prototype.iadd=function(e){var t;if(0!==this.negative&&0===e.negative)return this.negative=0,t=this.isub(e),this.negative^=1,this._normSign();if(0===this.negative&&0!==e.negative)return e.negative=0,t=this.isub(e),e.negative=1,t._normSign();var r,i;this.length>e.length?(r=this,i=e):(r=e,i=this);for(var n=0,a=0;a<i.length;a++)t=(0|r.words[a])+(0|i.words[a])+n,this.words[a]=67108863&t,n=t>>>26;for(;0!==n&&a<r.length;a++)t=(0|r.words[a])+n,this.words[a]=67108863&t,n=t>>>26;if(this.length=r.length,0!==n)this.words[this.length]=n,this.length++;else if(r!==this)for(;a<r.length;a++)this.words[a]=r.words[a];return this},a.prototype.add=function(e){var t;return 0!==e.negative&&0===this.negative?(e.negative=0,t=this.sub(e),e.negative^=1,t):0===e.negative&&0!==this.negative?(this.negative=0,t=e.sub(this),this.negative=1,t):this.length>e.length?this.clone().iadd(e):e.clone().iadd(this)},a.prototype.isub=function(e){if(0!==e.negative){e.negative=0;var t=this.iadd(e);return e.negative=1,t._normSign()}if(0!==this.negative)return this.negative=0,this.iadd(e),this.negative=1,this._normSign();var r=this.cmp(e);if(0===r)return this.negative=0,this.length=1,this.words[0]=0,this;var i,n;r>0?(i=this,n=e):(i=e,n=this);for(var a=0,o=0;o<n.length;o++)t=(0|i.words[o])-(0|n.words[o])+a,a=t>>26,this.words[o]=67108863&t;for(;0!==a&&o<i.length;o++)t=(0|i.words[o])+a,a=t>>26,this.words[o]=67108863&t;if(0===a&&o<i.length&&i!==this)for(;o<i.length;o++)this.words[o]=i.words[o];return this.length=Math.max(this.length,o),i!==this&&(this.negative=1),this.strip()},a.prototype.sub=function(e){return this.clone().isub(e)};var k=function(e,t,r){var i,n,a,o=e.words,s=t.words,f=r.words,c=0,u=0|o[0],h=8191&u,d=u>>>13,l=0|o[1],p=8191&l,b=l>>>13,y=0|o[2],m=8191&y,g=y>>>13,v=0|o[3],w=8191&v,_=v>>>13,S=0|o[4],M=8191&S,E=S>>>13,k=0|o[5],x=8191&k,A=k>>>13,j=0|o[6],B=8191&j,I=j>>>13,R=0|o[7],C=8191&R,T=R>>>13,O=0|o[8],P=8191&O,D=O>>>13,L=0|o[9],N=8191&L,q=L>>>13,U=0|s[0],z=8191&U,K=U>>>13,F=0|s[1],H=8191&F,W=F>>>13,V=0|s[2],J=8191&V,X=V>>>13,G=0|s[3],Z=8191&G,Y=G>>>13,$=0|s[4],Q=8191&$,ee=$>>>13,te=0|s[5],re=8191&te,ie=te>>>13,ne=0|s[6],ae=8191&ne,oe=ne>>>13,se=0|s[7],fe=8191&se,ce=se>>>13,ue=0|s[8],he=8191&ue,de=ue>>>13,le=0|s[9],pe=8191&le,be=le>>>13;r.negative=e.negative^t.negative,r.length=19,i=Math.imul(h,z),n=Math.imul(h,K),n=n+Math.imul(d,z)|0,a=Math.imul(d,K);var ye=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(ye>>>26)|0,ye&=67108863,i=Math.imul(p,z),n=Math.imul(p,K),n=n+Math.imul(b,z)|0,a=Math.imul(b,K),i=i+Math.imul(h,H)|0,n=n+Math.imul(h,W)|0,n=n+Math.imul(d,H)|0,a=a+Math.imul(d,W)|0;var me=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(me>>>26)|0,me&=67108863,i=Math.imul(m,z),n=Math.imul(m,K),n=n+Math.imul(g,z)|0,a=Math.imul(g,K),i=i+Math.imul(p,H)|0,n=n+Math.imul(p,W)|0,n=n+Math.imul(b,H)|0,a=a+Math.imul(b,W)|0,i=i+Math.imul(h,J)|0,n=n+Math.imul(h,X)|0,n=n+Math.imul(d,J)|0,a=a+Math.imul(d,X)|0;var ge=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(ge>>>26)|0,ge&=67108863,i=Math.imul(w,z),n=Math.imul(w,K),n=n+Math.imul(_,z)|0,a=Math.imul(_,K),i=i+Math.imul(m,H)|0,n=n+Math.imul(m,W)|0,n=n+Math.imul(g,H)|0,a=a+Math.imul(g,W)|0,i=i+Math.imul(p,J)|0,n=n+Math.imul(p,X)|0,n=n+Math.imul(b,J)|0,a=a+Math.imul(b,X)|0,i=i+Math.imul(h,Z)|0,n=n+Math.imul(h,Y)|0,n=n+Math.imul(d,Z)|0,a=a+Math.imul(d,Y)|0;var ve=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(ve>>>26)|0,ve&=67108863,i=Math.imul(M,z),n=Math.imul(M,K),n=n+Math.imul(E,z)|0,a=Math.imul(E,K),i=i+Math.imul(w,H)|0,n=n+Math.imul(w,W)|0,n=n+Math.imul(_,H)|0,a=a+Math.imul(_,W)|0,i=i+Math.imul(m,J)|0,n=n+Math.imul(m,X)|0,n=n+Math.imul(g,J)|0,a=a+Math.imul(g,X)|0,i=i+Math.imul(p,Z)|0,n=n+Math.imul(p,Y)|0,n=n+Math.imul(b,Z)|0,a=a+Math.imul(b,Y)|0,i=i+Math.imul(h,Q)|0,n=n+Math.imul(h,ee)|0,n=n+Math.imul(d,Q)|0,a=a+Math.imul(d,ee)|0;var we=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(we>>>26)|0,we&=67108863,i=Math.imul(x,z),n=Math.imul(x,K),n=n+Math.imul(A,z)|0,a=Math.imul(A,K),i=i+Math.imul(M,H)|0,n=n+Math.imul(M,W)|0,n=n+Math.imul(E,H)|0,a=a+Math.imul(E,W)|0,i=i+Math.imul(w,J)|0,n=n+Math.imul(w,X)|0,n=n+Math.imul(_,J)|0,a=a+Math.imul(_,X)|0,i=i+Math.imul(m,Z)|0,n=n+Math.imul(m,Y)|0,n=n+Math.imul(g,Z)|0,a=a+Math.imul(g,Y)|0,i=i+Math.imul(p,Q)|0,n=n+Math.imul(p,ee)|0,n=n+Math.imul(b,Q)|0,a=a+Math.imul(b,ee)|0,i=i+Math.imul(h,re)|0,n=n+Math.imul(h,ie)|0,n=n+Math.imul(d,re)|0,a=a+Math.imul(d,ie)|0;var _e=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(_e>>>26)|0,_e&=67108863,i=Math.imul(B,z),n=Math.imul(B,K),n=n+Math.imul(I,z)|0,a=Math.imul(I,K),i=i+Math.imul(x,H)|0,n=n+Math.imul(x,W)|0,n=n+Math.imul(A,H)|0,a=a+Math.imul(A,W)|0,i=i+Math.imul(M,J)|0,n=n+Math.imul(M,X)|0,n=n+Math.imul(E,J)|0,a=a+Math.imul(E,X)|0,i=i+Math.imul(w,Z)|0,n=n+Math.imul(w,Y)|0,n=n+Math.imul(_,Z)|0,a=a+Math.imul(_,Y)|0,i=i+Math.imul(m,Q)|0,n=n+Math.imul(m,ee)|0,n=n+Math.imul(g,Q)|0,a=a+Math.imul(g,ee)|0,i=i+Math.imul(p,re)|0,n=n+Math.imul(p,ie)|0,n=n+Math.imul(b,re)|0,a=a+Math.imul(b,ie)|0,i=i+Math.imul(h,ae)|0,n=n+Math.imul(h,oe)|0,n=n+Math.imul(d,ae)|0,a=a+Math.imul(d,oe)|0;var Se=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(Se>>>26)|0,Se&=67108863,i=Math.imul(C,z),n=Math.imul(C,K),n=n+Math.imul(T,z)|0,a=Math.imul(T,K),i=i+Math.imul(B,H)|0,n=n+Math.imul(B,W)|0,n=n+Math.imul(I,H)|0,a=a+Math.imul(I,W)|0,i=i+Math.imul(x,J)|0,n=n+Math.imul(x,X)|0,n=n+Math.imul(A,J)|0,a=a+Math.imul(A,X)|0,i=i+Math.imul(M,Z)|0,n=n+Math.imul(M,Y)|0,n=n+Math.imul(E,Z)|0,a=a+Math.imul(E,Y)|0,i=i+Math.imul(w,Q)|0,n=n+Math.imul(w,ee)|0,n=n+Math.imul(_,Q)|0,a=a+Math.imul(_,ee)|0,i=i+Math.imul(m,re)|0,n=n+Math.imul(m,ie)|0,n=n+Math.imul(g,re)|0,a=a+Math.imul(g,ie)|0,i=i+Math.imul(p,ae)|0,n=n+Math.imul(p,oe)|0,n=n+Math.imul(b,ae)|0,a=a+Math.imul(b,oe)|0,i=i+Math.imul(h,fe)|0,n=n+Math.imul(h,ce)|0,n=n+Math.imul(d,fe)|0,a=a+Math.imul(d,ce)|0;var Me=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(Me>>>26)|0,Me&=67108863,i=Math.imul(P,z),n=Math.imul(P,K),n=n+Math.imul(D,z)|0,a=Math.imul(D,K),i=i+Math.imul(C,H)|0,n=n+Math.imul(C,W)|0,n=n+Math.imul(T,H)|0,a=a+Math.imul(T,W)|0,i=i+Math.imul(B,J)|0,n=n+Math.imul(B,X)|0,n=n+Math.imul(I,J)|0,a=a+Math.imul(I,X)|0,i=i+Math.imul(x,Z)|0,n=n+Math.imul(x,Y)|0,n=n+Math.imul(A,Z)|0,a=a+Math.imul(A,Y)|0,i=i+Math.imul(M,Q)|0,n=n+Math.imul(M,ee)|0,n=n+Math.imul(E,Q)|0,a=a+Math.imul(E,ee)|0,i=i+Math.imul(w,re)|0,n=n+Math.imul(w,ie)|0,n=n+Math.imul(_,re)|0,a=a+Math.imul(_,ie)|0,i=i+Math.imul(m,ae)|0,n=n+Math.imul(m,oe)|0,n=n+Math.imul(g,ae)|0,a=a+Math.imul(g,oe)|0,i=i+Math.imul(p,fe)|0,n=n+Math.imul(p,ce)|0,n=n+Math.imul(b,fe)|0,a=a+Math.imul(b,ce)|0,i=i+Math.imul(h,he)|0,n=n+Math.imul(h,de)|0,n=n+Math.imul(d,he)|0,a=a+Math.imul(d,de)|0;var Ee=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(Ee>>>26)|0,Ee&=67108863,i=Math.imul(N,z),n=Math.imul(N,K),n=n+Math.imul(q,z)|0,a=Math.imul(q,K),i=i+Math.imul(P,H)|0,n=n+Math.imul(P,W)|0,n=n+Math.imul(D,H)|0,a=a+Math.imul(D,W)|0,i=i+Math.imul(C,J)|0,n=n+Math.imul(C,X)|0,n=n+Math.imul(T,J)|0,a=a+Math.imul(T,X)|0,i=i+Math.imul(B,Z)|0,n=n+Math.imul(B,Y)|0,n=n+Math.imul(I,Z)|0,a=a+Math.imul(I,Y)|0,i=i+Math.imul(x,Q)|0,n=n+Math.imul(x,ee)|0,n=n+Math.imul(A,Q)|0,a=a+Math.imul(A,ee)|0,i=i+Math.imul(M,re)|0,n=n+Math.imul(M,ie)|0,n=n+Math.imul(E,re)|0,a=a+Math.imul(E,ie)|0,i=i+Math.imul(w,ae)|0,n=n+Math.imul(w,oe)|0,n=n+Math.imul(_,ae)|0,a=a+Math.imul(_,oe)|0,i=i+Math.imul(m,fe)|0,n=n+Math.imul(m,ce)|0,n=n+Math.imul(g,fe)|0,a=a+Math.imul(g,ce)|0,i=i+Math.imul(p,he)|0,n=n+Math.imul(p,de)|0,n=n+Math.imul(b,he)|0,a=a+Math.imul(b,de)|0,i=i+Math.imul(h,pe)|0,n=n+Math.imul(h,be)|0,n=n+Math.imul(d,pe)|0,a=a+Math.imul(d,be)|0;var ke=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(ke>>>26)|0,ke&=67108863,i=Math.imul(N,H),n=Math.imul(N,W),n=n+Math.imul(q,H)|0,a=Math.imul(q,W),i=i+Math.imul(P,J)|0,n=n+Math.imul(P,X)|0,n=n+Math.imul(D,J)|0,a=a+Math.imul(D,X)|0,i=i+Math.imul(C,Z)|0,n=n+Math.imul(C,Y)|0,n=n+Math.imul(T,Z)|0,a=a+Math.imul(T,Y)|0,i=i+Math.imul(B,Q)|0,n=n+Math.imul(B,ee)|0,n=n+Math.imul(I,Q)|0,a=a+Math.imul(I,ee)|0,i=i+Math.imul(x,re)|0,n=n+Math.imul(x,ie)|0,n=n+Math.imul(A,re)|0,a=a+Math.imul(A,ie)|0,i=i+Math.imul(M,ae)|0,n=n+Math.imul(M,oe)|0,n=n+Math.imul(E,ae)|0,a=a+Math.imul(E,oe)|0,i=i+Math.imul(w,fe)|0,n=n+Math.imul(w,ce)|0,n=n+Math.imul(_,fe)|0,a=a+Math.imul(_,ce)|0,i=i+Math.imul(m,he)|0,n=n+Math.imul(m,de)|0,n=n+Math.imul(g,he)|0,a=a+Math.imul(g,de)|0,i=i+Math.imul(p,pe)|0,n=n+Math.imul(p,be)|0,n=n+Math.imul(b,pe)|0,a=a+Math.imul(b,be)|0;var xe=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(xe>>>26)|0,xe&=67108863,i=Math.imul(N,J),n=Math.imul(N,X),n=n+Math.imul(q,J)|0,a=Math.imul(q,X),i=i+Math.imul(P,Z)|0,n=n+Math.imul(P,Y)|0,n=n+Math.imul(D,Z)|0,a=a+Math.imul(D,Y)|0,i=i+Math.imul(C,Q)|0,n=n+Math.imul(C,ee)|0,n=n+Math.imul(T,Q)|0,a=a+Math.imul(T,ee)|0,i=i+Math.imul(B,re)|0,n=n+Math.imul(B,ie)|0,n=n+Math.imul(I,re)|0,a=a+Math.imul(I,ie)|0,i=i+Math.imul(x,ae)|0,n=n+Math.imul(x,oe)|0,n=n+Math.imul(A,ae)|0,a=a+Math.imul(A,oe)|0,i=i+Math.imul(M,fe)|0,n=n+Math.imul(M,ce)|0,n=n+Math.imul(E,fe)|0,a=a+Math.imul(E,ce)|0,i=i+Math.imul(w,he)|0,n=n+Math.imul(w,de)|0,n=n+Math.imul(_,he)|0,a=a+Math.imul(_,de)|0,i=i+Math.imul(m,pe)|0,n=n+Math.imul(m,be)|0,n=n+Math.imul(g,pe)|0,a=a+Math.imul(g,be)|0;var Ae=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(Ae>>>26)|0,Ae&=67108863,i=Math.imul(N,Z),n=Math.imul(N,Y),n=n+Math.imul(q,Z)|0,a=Math.imul(q,Y),i=i+Math.imul(P,Q)|0,n=n+Math.imul(P,ee)|0,n=n+Math.imul(D,Q)|0,a=a+Math.imul(D,ee)|0,i=i+Math.imul(C,re)|0,n=n+Math.imul(C,ie)|0,n=n+Math.imul(T,re)|0,a=a+Math.imul(T,ie)|0,i=i+Math.imul(B,ae)|0,n=n+Math.imul(B,oe)|0,n=n+Math.imul(I,ae)|0,a=a+Math.imul(I,oe)|0,i=i+Math.imul(x,fe)|0,n=n+Math.imul(x,ce)|0,n=n+Math.imul(A,fe)|0,a=a+Math.imul(A,ce)|0,i=i+Math.imul(M,he)|0,n=n+Math.imul(M,de)|0,n=n+Math.imul(E,he)|0,a=a+Math.imul(E,de)|0,i=i+Math.imul(w,pe)|0,n=n+Math.imul(w,be)|0,n=n+Math.imul(_,pe)|0,a=a+Math.imul(_,be)|0;var je=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(je>>>26)|0,je&=67108863,i=Math.imul(N,Q),n=Math.imul(N,ee),n=n+Math.imul(q,Q)|0,a=Math.imul(q,ee),i=i+Math.imul(P,re)|0,n=n+Math.imul(P,ie)|0,n=n+Math.imul(D,re)|0,a=a+Math.imul(D,ie)|0,i=i+Math.imul(C,ae)|0,n=n+Math.imul(C,oe)|0,n=n+Math.imul(T,ae)|0,a=a+Math.imul(T,oe)|0,i=i+Math.imul(B,fe)|0,n=n+Math.imul(B,ce)|0,n=n+Math.imul(I,fe)|0,a=a+Math.imul(I,ce)|0,i=i+Math.imul(x,he)|0,n=n+Math.imul(x,de)|0,n=n+Math.imul(A,he)|0,a=a+Math.imul(A,de)|0,i=i+Math.imul(M,pe)|0,n=n+Math.imul(M,be)|0,n=n+Math.imul(E,pe)|0,a=a+Math.imul(E,be)|0;var Be=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(Be>>>26)|0,Be&=67108863,i=Math.imul(N,re),n=Math.imul(N,ie),n=n+Math.imul(q,re)|0,a=Math.imul(q,ie),i=i+Math.imul(P,ae)|0,n=n+Math.imul(P,oe)|0,n=n+Math.imul(D,ae)|0,a=a+Math.imul(D,oe)|0,i=i+Math.imul(C,fe)|0,n=n+Math.imul(C,ce)|0,n=n+Math.imul(T,fe)|0,a=a+Math.imul(T,ce)|0,i=i+Math.imul(B,he)|0,n=n+Math.imul(B,de)|0,n=n+Math.imul(I,he)|0,a=a+Math.imul(I,de)|0,i=i+Math.imul(x,pe)|0,n=n+Math.imul(x,be)|0,n=n+Math.imul(A,pe)|0,a=a+Math.imul(A,be)|0;var Ie=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(Ie>>>26)|0,Ie&=67108863,i=Math.imul(N,ae),n=Math.imul(N,oe),n=n+Math.imul(q,ae)|0,a=Math.imul(q,oe),i=i+Math.imul(P,fe)|0,n=n+Math.imul(P,ce)|0,n=n+Math.imul(D,fe)|0,a=a+Math.imul(D,ce)|0,i=i+Math.imul(C,he)|0,n=n+Math.imul(C,de)|0,n=n+Math.imul(T,he)|0,a=a+Math.imul(T,de)|0,i=i+Math.imul(B,pe)|0,n=n+Math.imul(B,be)|0,n=n+Math.imul(I,pe)|0,a=a+Math.imul(I,be)|0;var Re=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(Re>>>26)|0,Re&=67108863,i=Math.imul(N,fe),n=Math.imul(N,ce),n=n+Math.imul(q,fe)|0,a=Math.imul(q,ce),i=i+Math.imul(P,he)|0,n=n+Math.imul(P,de)|0,n=n+Math.imul(D,he)|0,a=a+Math.imul(D,de)|0,i=i+Math.imul(C,pe)|0,n=n+Math.imul(C,be)|0,n=n+Math.imul(T,pe)|0,a=a+Math.imul(T,be)|0;var Ce=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(Ce>>>26)|0,Ce&=67108863,i=Math.imul(N,he),n=Math.imul(N,de),n=n+Math.imul(q,he)|0,a=Math.imul(q,de),i=i+Math.imul(P,pe)|0,n=n+Math.imul(P,be)|0,n=n+Math.imul(D,pe)|0,a=a+Math.imul(D,be)|0;var Te=(c+i|0)+((8191&n)<<13)|0;c=(a+(n>>>13)|0)+(Te>>>26)|0,Te&=67108863,i=Math.imul(N,pe),n=Math.imul(N,be),n=n+Math.imul(q,pe)|0,a=Math.imul(q,be);var Oe=(c+i|0)+((8191&n)<<13)|0;return c=(a+(n>>>13)|0)+(Oe>>>26)|0,Oe&=67108863,f[0]=ye,f[1]=me,f[2]=ge,f[3]=ve,f[4]=we,f[5]=_e,f[6]=Se,f[7]=Me,f[8]=Ee,f[9]=ke,f[10]=xe,f[11]=Ae,f[12]=je,f[13]=Be,f[14]=Ie,f[15]=Re,f[16]=Ce,f[17]=Te,f[18]=Oe,0!==c&&(f[19]=c,r.length++),r};Math.imul||(k=c),a.prototype.mulTo=function(e,t){var r,i=this.length+e.length;return r=10===this.length&&10===e.length?k(this,e,t):63>i?c(this,e,t):1024>i?u(this,e,t):h(this,e,t)},d.prototype.makeRBT=function(e){for(var t=new Array(e),r=a.prototype._countBits(e)-1,i=0;e>i;i++)t[i]=this.revBin(i,r,e);return t},d.prototype.revBin=function(e,t,r){if(0===e||e===r-1)return e;for(var i=0,n=0;t>n;n++)i|=(1&e)<<t-n-1,e>>=1;return i},d.prototype.permute=function(e,t,r,i,n,a){for(var o=0;a>o;o++)i[o]=t[e[o]],n[o]=r[e[o]]},d.prototype.transform=function(e,t,r,i,n,a){this.permute(a,e,t,r,i,n);for(var o=1;n>o;o<<=1)for(var s=o<<1,f=Math.cos(2*Math.PI/s),c=Math.sin(2*Math.PI/s),u=0;n>u;u+=s)for(var h=f,d=c,l=0;o>l;l++){var p=r[u+l],b=i[u+l],y=r[u+l+o],m=i[u+l+o],g=h*y-d*m;m=h*m+d*y,y=g,r[u+l]=p+y,i[u+l]=b+m,r[u+l+o]=p-y,i[u+l+o]=b-m,l!==s&&(g=f*h-c*d,d=f*d+c*h,h=g)}},d.prototype.guessLen13b=function(e,t){var r=1|Math.max(t,e),i=1&r,n=0;for(r=r/2|0;r;r>>>=1)n++;return 1<<n+1+i},d.prototype.conjugate=function(e,t,r){if(!(1>=r))for(var i=0;r/2>i;i++){var n=e[i];e[i]=e[r-i-1],e[r-i-1]=n,n=t[i],t[i]=-t[r-i-1],t[r-i-1]=-n}},d.prototype.normalize13b=function(e,t){for(var r=0,i=0;t/2>i;i++){var n=8192*Math.round(e[2*i+1]/t)+Math.round(e[2*i]/t)+r;e[i]=67108863&n,r=67108864>n?0:n/67108864|0}return e},d.prototype.convert13b=function(e,t,r,n){for(var a=0,o=0;t>o;o++)a+=0|e[o],r[2*o]=8191&a,a>>>=13,r[2*o+1]=8191&a,a>>>=13;for(o=2*t;n>o;++o)r[o]=0;i(0===a),i(0===(-8192&a))},d.prototype.stub=function(e){for(var t=new Array(e),r=0;e>r;r++)t[r]=0;return t},d.prototype.mulp=function(e,t,r){var i=2*this.guessLen13b(e.length,t.length),n=this.makeRBT(i),a=this.stub(i),o=new Array(i),s=new Array(i),f=new Array(i),c=new Array(i),u=new Array(i),h=new Array(i),d=r.words;d.length=i,this.convert13b(e.words,e.length,o,i),this.convert13b(t.words,t.length,c,i),this.transform(o,a,s,f,i,n),this.transform(c,a,u,h,i,n);for(var l=0;i>l;l++){var p=s[l]*u[l]-f[l]*h[l];f[l]=s[l]*h[l]+f[l]*u[l],s[l]=p}return this.conjugate(s,f,i),this.transform(s,f,d,a,i,n),this.conjugate(d,a,i),this.normalize13b(d,i),r.negative=e.negative^t.negative,r.length=e.length+t.length,r.strip()},a.prototype.mul=function(e){var t=new a(null);return t.words=new Array(this.length+e.length),this.mulTo(e,t)},a.prototype.mulf=function(e){var t=new a(null);return t.words=new Array(this.length+e.length),h(this,e,t)},a.prototype.imul=function(e){return this.clone().mulTo(e,this)},a.prototype.imuln=function(e){i("number"==typeof e),i(67108864>e);for(var t=0,r=0;r<this.length;r++){var n=(0|this.words[r])*e,a=(67108863&n)+(67108863&t);t>>=26,t+=n/67108864|0,t+=a>>>26,this.words[r]=67108863&a}return 0!==t&&(this.words[r]=t,this.length++),this},a.prototype.muln=function(e){return this.clone().imuln(e)},a.prototype.sqr=function(){return this.mul(this)},a.prototype.isqr=function(){return this.imul(this.clone())},a.prototype.pow=function(e){var t=f(e);if(0===t.length)return new a(1);for(var r=this,i=0;i<t.length&&0===t[i];i++,r=r.sqr());if(++i<t.length)for(var n=r.sqr();i<t.length;i++,n=n.sqr())0!==t[i]&&(r=r.mul(n));return r},a.prototype.iushln=function(e){i("number"==typeof e&&e>=0);var t,r=e%26,n=(e-r)/26,a=67108863>>>26-r<<26-r;if(0!==r){var o=0;for(t=0;t<this.length;t++){var s=this.words[t]&a,f=(0|this.words[t])-s<<r;this.words[t]=f|o,o=s>>>26-r}o&&(this.words[t]=o,this.length++)}if(0!==n){for(t=this.length-1;t>=0;t--)this.words[t+n]=this.words[t];for(t=0;n>t;t++)this.words[t]=0;this.length+=n}return this.strip()},a.prototype.ishln=function(e){return i(0===this.negative),this.iushln(e)},a.prototype.iushrn=function(e,t,r){i("number"==typeof e&&e>=0);var n;n=t?(t-t%26)/26:0;var a=e%26,o=Math.min((e-a)/26,this.length),s=67108863^67108863>>>a<<a,f=r;if(n-=o,n=Math.max(0,n),f){for(var c=0;o>c;c++)f.words[c]=this.words[c];f.length=o}if(0===o);else if(this.length>o)for(this.length-=o,c=0;c<this.length;c++)this.words[c]=this.words[c+o];else this.words[0]=0,this.length=1;var u=0;for(c=this.length-1;c>=0&&(0!==u||c>=n);c--){var h=0|this.words[c];this.words[c]=u<<26-a|h>>>a,u=h&s}return f&&0!==u&&(f.words[f.length++]=u),0===this.length&&(this.words[0]=0,this.length=1),this.strip()},a.prototype.ishrn=function(e,t,r){return i(0===this.negative),this.iushrn(e,t,r)},a.prototype.shln=function(e){return this.clone().ishln(e)},a.prototype.ushln=function(e){return this.clone().iushln(e)},a.prototype.shrn=function(e){return this.clone().ishrn(e)},a.prototype.ushrn=function(e){return this.clone().iushrn(e)},a.prototype.testn=function(e){i("number"==typeof e&&e>=0);var t=e%26,r=(e-t)/26,n=1<<t;if(this.length<=r)return!1;var a=this.words[r];return!!(a&n)},a.prototype.imaskn=function(e){i("number"==typeof e&&e>=0);var t=e%26,r=(e-t)/26;if(i(0===this.negative,"imaskn works only with positive numbers"),this.length<=r)return this;if(0!==t&&r++,this.length=Math.min(r,this.length),0!==t){var n=67108863^67108863>>>t<<t;this.words[this.length-1]&=n}return this.strip()},a.prototype.maskn=function(e){return this.clone().imaskn(e)},a.prototype.iaddn=function(e){return i("number"==typeof e),i(67108864>e),0>e?this.isubn(-e):0!==this.negative?1===this.length&&(0|this.words[0])<e?(this.words[0]=e-(0|this.words[0]),this.negative=0,this):(this.negative=0,this.isubn(e),this.negative=1,this):this._iaddn(e)},a.prototype._iaddn=function(e){this.words[0]+=e;for(var t=0;t<this.length&&this.words[t]>=67108864;t++)this.words[t]-=67108864,t===this.length-1?this.words[t+1]=1:this.words[t+1]++;return this.length=Math.max(this.length,t+1),this},a.prototype.isubn=function(e){if(i("number"==typeof e),i(67108864>e),0>e)return this.iaddn(-e);if(0!==this.negative)return this.negative=0,this.iaddn(e),this.negative=1,this;if(this.words[0]-=e,1===this.length&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var t=0;t<this.length&&this.words[t]<0;t++)this.words[t]+=67108864,this.words[t+1]-=1;return this.strip()},a.prototype.addn=function(e){return this.clone().iaddn(e)},a.prototype.subn=function(e){return this.clone().isubn(e)},a.prototype.iabs=function(){return this.negative=0,this},a.prototype.abs=function(){return this.clone().iabs()},a.prototype._ishlnsubmul=function(e,t,r){var n,a=e.length+r;this._expand(a);var o,s=0;for(n=0;n<e.length;n++){o=(0|this.words[n+r])+s;var f=(0|e.words[n])*t;o-=67108863&f,s=(o>>26)-(f/67108864|0),this.words[n+r]=67108863&o}for(;n<this.length-r;n++)o=(0|this.words[n+r])+s,s=o>>26,this.words[n+r]=67108863&o;if(0===s)return this.strip();for(i(-1===s),s=0,n=0;n<this.length;n++)o=-(0|this.words[n])+s,s=o>>26,this.words[n]=67108863&o;return this.negative=1,this.strip()},a.prototype._wordDiv=function(e,t){var r=this.length-e.length,i=this.clone(),n=e,o=0|n.words[n.length-1],s=this._countBits(o);r=26-s,0!==r&&(n=n.ushln(r),i.iushln(r),o=0|n.words[n.length-1]);var f,c=i.length-n.length;if("mod"!==t){f=new a(null),f.length=c+1,f.words=new Array(f.length);for(var u=0;u<f.length;u++)f.words[u]=0}var h=i.clone()._ishlnsubmul(n,1,c);0===h.negative&&(i=h,f&&(f.words[c]=1));for(var d=c-1;d>=0;d--){var l=67108864*(0|i.words[n.length+d])+(0|i.words[n.length+d-1]);for(l=Math.min(l/o|0,67108863),i._ishlnsubmul(n,l,d);0!==i.negative;)l--,i.negative=0,i._ishlnsubmul(n,1,d),i.isZero()||(i.negative^=1);f&&(f.words[d]=l)}return f&&f.strip(),i.strip(),"div"!==t&&0!==r&&i.iushrn(r),{div:f||null,mod:i}},a.prototype.divmod=function(e,t,r){if(i(!e.isZero()),this.isZero())return{div:new a(0),mod:new a(0)};var n,o,s;return 0!==this.negative&&0===e.negative?(s=this.neg().divmod(e,t),"mod"!==t&&(n=s.div.neg()),"div"!==t&&(o=s.mod.neg(),r&&0!==o.negative&&o.iadd(e)),{div:n,mod:o}):0===this.negative&&0!==e.negative?(s=this.divmod(e.neg(),t),"mod"!==t&&(n=s.div.neg()),{div:n,mod:s.mod}):0!==(this.negative&e.negative)?(s=this.neg().divmod(e.neg(),t),"div"!==t&&(o=s.mod.neg(),r&&0!==o.negative&&o.isub(e)),{div:s.div,mod:o}):e.length>this.length||this.cmp(e)<0?{div:new a(0),mod:this}:1===e.length?"div"===t?{div:this.divn(e.words[0]),mod:null}:"mod"===t?{div:null,mod:new a(this.modn(e.words[0]))}:{div:this.divn(e.words[0]),mod:new a(this.modn(e.words[0]))}:this._wordDiv(e,t)},a.prototype.div=function(e){return this.divmod(e,"div",!1).div},a.prototype.mod=function(e){return this.divmod(e,"mod",!1).mod},a.prototype.umod=function(e){return this.divmod(e,"mod",!0).mod},a.prototype.divRound=function(e){var t=this.divmod(e);if(t.mod.isZero())return t.div;var r=0!==t.div.negative?t.mod.isub(e):t.mod,i=e.ushrn(1),n=e.andln(1),a=r.cmp(i);return 0>a||1===n&&0===a?t.div:0!==t.div.negative?t.div.isubn(1):t.div.iaddn(1)},a.prototype.modn=function(e){i(67108863>=e);for(var t=(1<<26)%e,r=0,n=this.length-1;n>=0;n--)r=(t*r+(0|this.words[n]))%e;return r},a.prototype.idivn=function(e){i(67108863>=e);for(var t=0,r=this.length-1;r>=0;r--){var n=(0|this.words[r])+67108864*t;this.words[r]=n/e|0,t=n%e}return this.strip()},a.prototype.divn=function(e){return this.clone().idivn(e)},a.prototype.egcd=function(e){i(0===e.negative),i(!e.isZero());var t=this,r=e.clone();t=0!==t.negative?t.umod(e):t.clone();for(var n=new a(1),o=new a(0),s=new a(0),f=new a(1),c=0;t.isEven()&&r.isEven();)t.iushrn(1),r.iushrn(1),++c;for(var u=r.clone(),h=t.clone();!t.isZero();){for(var d=0,l=1;0===(t.words[0]&l)&&26>d;++d,l<<=1);if(d>0)for(t.iushrn(d);d-->0;)(n.isOdd()||o.isOdd())&&(n.iadd(u),o.isub(h)),n.iushrn(1),o.iushrn(1);for(var p=0,b=1;0===(r.words[0]&b)&&26>p;++p,b<<=1);if(p>0)for(r.iushrn(p);p-->0;)(s.isOdd()||f.isOdd())&&(s.iadd(u),f.isub(h)),s.iushrn(1),f.iushrn(1);t.cmp(r)>=0?(t.isub(r),n.isub(s),o.isub(f)):(r.isub(t),s.isub(n),f.isub(o))}return{a:s,b:f,gcd:r.iushln(c)}},a.prototype._invmp=function(e){i(0===e.negative),i(!e.isZero());var t=this,r=e.clone();t=0!==t.negative?t.umod(e):t.clone();for(var n=new a(1),o=new a(0),s=r.clone();t.cmpn(1)>0&&r.cmpn(1)>0;){for(var f=0,c=1;0===(t.words[0]&c)&&26>f;++f,c<<=1);if(f>0)for(t.iushrn(f);f-->0;)n.isOdd()&&n.iadd(s),n.iushrn(1);for(var u=0,h=1;0===(r.words[0]&h)&&26>u;++u,h<<=1);if(u>0)for(r.iushrn(u);u-->0;)o.isOdd()&&o.iadd(s),o.iushrn(1);t.cmp(r)>=0?(t.isub(r),n.isub(o)):(r.isub(t),o.isub(n))}var d;return d=0===t.cmpn(1)?n:o,d.cmpn(0)<0&&d.iadd(e),d},a.prototype.gcd=function(e){if(this.isZero())return e.abs();if(e.isZero())return this.abs();var t=this.clone(),r=e.clone();t.negative=0,r.negative=0;for(var i=0;t.isEven()&&r.isEven();i++)t.iushrn(1),r.iushrn(1);for(;;){for(;t.isEven();)t.iushrn(1);for(;r.isEven();)r.iushrn(1);var n=t.cmp(r);if(0>n){var a=t;t=r,r=a}else if(0===n||0===r.cmpn(1))break;t.isub(r)}return r.iushln(i)},a.prototype.invm=function(e){return this.egcd(e).a.umod(e)},a.prototype.isEven=function(){return 0===(1&this.words[0])},a.prototype.isOdd=function(){return 1===(1&this.words[0])},a.prototype.andln=function(e){return this.words[0]&e},a.prototype.bincn=function(e){i("number"==typeof e);var t=e%26,r=(e-t)/26,n=1<<t;if(this.length<=r)return this._expand(r+1),this.words[r]|=n,this;for(var a=n,o=r;0!==a&&o<this.length;o++){var s=0|this.words[o];s+=a,a=s>>>26,s&=67108863,this.words[o]=s}return 0!==a&&(this.words[o]=a,this.length++),this},a.prototype.isZero=function(){return 1===this.length&&0===this.words[0]},a.prototype.cmpn=function(e){var t=0>e;if(0!==this.negative&&!t)return-1;if(0===this.negative&&t)return 1;this.strip();var r;if(this.length>1)r=1;else{t&&(e=-e),i(67108863>=e,"Number is too big");var n=0|this.words[0];r=n===e?0:e>n?-1:1}return 0!==this.negative?0|-r:r},a.prototype.cmp=function(e){if(0!==this.negative&&0===e.negative)return-1;if(0===this.negative&&0!==e.negative)return 1;var t=this.ucmp(e);return 0!==this.negative?0|-t:t},a.prototype.ucmp=function(e){if(this.length>e.length)return 1;if(this.length<e.length)return-1;for(var t=0,r=this.length-1;r>=0;r--){var i=0|this.words[r],n=0|e.words[r];if(i!==n){n>i?t=-1:i>n&&(t=1);break}}return t},a.prototype.gtn=function(e){return 1===this.cmpn(e)},a.prototype.gt=function(e){return 1===this.cmp(e)},a.prototype.gten=function(e){return this.cmpn(e)>=0},a.prototype.gte=function(e){return this.cmp(e)>=0},a.prototype.ltn=function(e){return-1===this.cmpn(e)},a.prototype.lt=function(e){return-1===this.cmp(e)},a.prototype.lten=function(e){return this.cmpn(e)<=0},a.prototype.lte=function(e){return this.cmp(e)<=0},a.prototype.eqn=function(e){return 0===this.cmpn(e)},a.prototype.eq=function(e){return 0===this.cmp(e)},a.red=function(e){return new g(e)},a.prototype.toRed=function(e){return i(!this.red,"Already a number in reduction context"),i(0===this.negative,"red works only with positives"),e.convertTo(this)._forceRed(e)},a.prototype.fromRed=function(){return i(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},a.prototype._forceRed=function(e){return this.red=e,this},a.prototype.forceRed=function(e){return i(!this.red,"Already a number in reduction context"),this._forceRed(e)},a.prototype.redAdd=function(e){return i(this.red,"redAdd works only with red numbers"),this.red.add(this,e)},a.prototype.redIAdd=function(e){return i(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,e)},a.prototype.redSub=function(e){return i(this.red,"redSub works only with red numbers"),this.red.sub(this,e)},a.prototype.redISub=function(e){return i(this.red,"redISub works only with red numbers"),this.red.isub(this,e)},a.prototype.redShl=function(e){return i(this.red,"redShl works only with red numbers"),this.red.shl(this,e)},a.prototype.redMul=function(e){return i(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.mul(this,e)},a.prototype.redIMul=function(e){return i(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.imul(this,e)},a.prototype.redSqr=function(){return i(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},a.prototype.redISqr=function(){return i(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},a.prototype.redSqrt=function(){return i(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},a.prototype.redInvm=function(){return i(this.red,"redInvm works only with red numbers"),
this.red._verify1(this),this.red.invm(this)},a.prototype.redNeg=function(){return i(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},a.prototype.redPow=function(e){return i(this.red&&!e.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,e)};var x={k256:null,p224:null,p192:null,p25519:null};l.prototype._tmp=function(){var e=new a(null);return e.words=new Array(Math.ceil(this.n/13)),e},l.prototype.ireduce=function(e){var t,r=e;do this.split(r,this.tmp),r=this.imulK(r),r=r.iadd(this.tmp),t=r.bitLength();while(t>this.n);var i=t<this.n?-1:r.ucmp(this.p);return 0===i?(r.words[0]=0,r.length=1):i>0?r.isub(this.p):r.strip(),r},l.prototype.split=function(e,t){e.iushrn(this.n,0,t)},l.prototype.imulK=function(e){return e.imul(this.k)},n(p,l),p.prototype.split=function(e,t){for(var r=4194303,i=Math.min(e.length,9),n=0;i>n;n++)t.words[n]=e.words[n];if(t.length=i,e.length<=9)return e.words[0]=0,void(e.length=1);var a=e.words[9];for(t.words[t.length++]=a&r,n=10;n<e.length;n++){var o=0|e.words[n];e.words[n-10]=(o&r)<<4|a>>>22,a=o}a>>>=22,e.words[n-10]=a,0===a&&e.length>10?e.length-=10:e.length-=9},p.prototype.imulK=function(e){e.words[e.length]=0,e.words[e.length+1]=0,e.length+=2;for(var t=0,r=0;r<e.length;r++){var i=0|e.words[r];t+=977*i,e.words[r]=67108863&t,t=64*i+(t/67108864|0)}return 0===e.words[e.length-1]&&(e.length--,0===e.words[e.length-1]&&e.length--),e},n(b,l),n(y,l),n(m,l),m.prototype.imulK=function(e){for(var t=0,r=0;r<e.length;r++){var i=19*(0|e.words[r])+t,n=67108863&i;i>>>=26,e.words[r]=n,t=i}return 0!==t&&(e.words[e.length++]=t),e},a._prime=function A(e){if(x[e])return x[e];var A;if("k256"===e)A=new p;else if("p224"===e)A=new b;else if("p192"===e)A=new y;else{if("p25519"!==e)throw new Error("Unknown prime "+e);A=new m}return x[e]=A,A},g.prototype._verify1=function(e){i(0===e.negative,"red works only with positives"),i(e.red,"red works only with red numbers")},g.prototype._verify2=function(e,t){i(0===(e.negative|t.negative),"red works only with positives"),i(e.red&&e.red===t.red,"red works only with red numbers")},g.prototype.imod=function(e){return this.prime?this.prime.ireduce(e)._forceRed(this):e.umod(this.m)._forceRed(this)},g.prototype.neg=function(e){return e.isZero()?e.clone():this.m.sub(e)._forceRed(this)},g.prototype.add=function(e,t){this._verify2(e,t);var r=e.add(t);return r.cmp(this.m)>=0&&r.isub(this.m),r._forceRed(this)},g.prototype.iadd=function(e,t){this._verify2(e,t);var r=e.iadd(t);return r.cmp(this.m)>=0&&r.isub(this.m),r},g.prototype.sub=function(e,t){this._verify2(e,t);var r=e.sub(t);return r.cmpn(0)<0&&r.iadd(this.m),r._forceRed(this)},g.prototype.isub=function(e,t){this._verify2(e,t);var r=e.isub(t);return r.cmpn(0)<0&&r.iadd(this.m),r},g.prototype.shl=function(e,t){return this._verify1(e),this.imod(e.ushln(t))},g.prototype.imul=function(e,t){return this._verify2(e,t),this.imod(e.imul(t))},g.prototype.mul=function(e,t){return this._verify2(e,t),this.imod(e.mul(t))},g.prototype.isqr=function(e){return this.imul(e,e.clone())},g.prototype.sqr=function(e){return this.mul(e,e)},g.prototype.sqrt=function(e){if(e.isZero())return e.clone();var t=this.m.andln(3);if(i(t%2===1),3===t){var r=this.m.add(new a(1)).iushrn(2);return this.pow(e,r)}for(var n=this.m.subn(1),o=0;!n.isZero()&&0===n.andln(1);)o++,n.iushrn(1);i(!n.isZero());var s=new a(1).toRed(this),f=s.redNeg(),c=this.m.subn(1).iushrn(1),u=this.m.bitLength();for(u=new a(2*u*u).toRed(this);0!==this.pow(u,c).cmp(f);)u.redIAdd(f);for(var h=this.pow(u,n),d=this.pow(e,n.addn(1).iushrn(1)),l=this.pow(e,n),p=o;0!==l.cmp(s);){for(var b=l,y=0;0!==b.cmp(s);y++)b=b.redSqr();i(p>y);var m=this.pow(h,new a(1).iushln(p-y-1));d=d.redMul(m),h=m.redSqr(),l=l.redMul(h),p=y}return d},g.prototype.invm=function(e){var t=e._invmp(this.m);return 0!==t.negative?(t.negative=0,this.imod(t).redNeg()):this.imod(t)},g.prototype.pow=function(e,t){if(t.isZero())return new a(1).toRed(this);if(0===t.cmpn(1))return e.clone();var r=4,i=new Array(1<<r);i[0]=new a(1).toRed(this),i[1]=e;for(var n=2;n<i.length;n++)i[n]=this.mul(i[n-1],e);var o=i[0],s=0,f=0,c=t.bitLength()%26;for(0===c&&(c=26),n=t.length-1;n>=0;n--){for(var u=t.words[n],h=c-1;h>=0;h--){var d=u>>h&1;o!==i[0]&&(o=this.sqr(o)),0!==d||0!==s?(s<<=1,s|=d,f++,(f===r||0===n&&0===h)&&(o=this.mul(o,i[s]),f=0,s=0)):f=0}c=26}return o},g.prototype.convertTo=function(e){var t=e.umod(this.m);return t===e?t.clone():t},g.prototype.convertFrom=function(e){var t=e.clone();return t.red=null,t},a.mont=function(e){return new v(e)},n(v,g),v.prototype.convertTo=function(e){return this.imod(e.ushln(this.shift))},v.prototype.convertFrom=function(e){var t=this.imod(e.mul(this.rinv));return t.red=null,t},v.prototype.imul=function(e,t){if(e.isZero()||t.isZero())return e.words[0]=0,e.length=1,e;var r=e.imul(t),i=r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),n=r.isub(i).iushrn(this.shift),a=n;return n.cmp(this.m)>=0?a=n.isub(this.m):n.cmpn(0)<0&&(a=n.iadd(this.m)),a._forceRed(this)},v.prototype.mul=function(e,t){if(e.isZero()||t.isZero())return new a(0)._forceRed(this);var r=e.mul(t),i=r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),n=r.isub(i).iushrn(this.shift),o=n;return n.cmp(this.m)>=0?o=n.isub(this.m):n.cmpn(0)<0&&(o=n.iadd(this.m)),o._forceRed(this)},v.prototype.invm=function(e){var t=this.imod(e._invmp(this.m).mul(this.r2));return t._forceRed(this)}}("undefined"==typeof t||t,this)},{buffer:19}],18:[function(e,t,r){function i(e){this.rand=e}var n;if(t.exports=function(e){return n||(n=new i(null)),n.generate(e)},t.exports.Rand=i,i.prototype.generate=function(e){return this._rand(e)},i.prototype._rand=function(e){if(this.rand.getBytes)return this.rand.getBytes(e);for(var t=new Uint8Array(e),r=0;r<t.length;r++)t[r]=this.rand.getByte();return t},"object"==typeof self)self.crypto&&self.crypto.getRandomValues?i.prototype._rand=function(e){var t=new Uint8Array(e);return self.crypto.getRandomValues(t),t}:self.msCrypto&&self.msCrypto.getRandomValues?i.prototype._rand=function(e){var t=new Uint8Array(e);return self.msCrypto.getRandomValues(t),t}:"object"==typeof window&&(i.prototype._rand=function(){throw new Error("Not implemented yet")});else try{var a=e("crypto");if("function"!=typeof a.randomBytes)throw new Error("Not supported");i.prototype._rand=function(e){return a.randomBytes(e)}}catch(o){}},{crypto:19}],19:[function(e,t,r){},{}],20:[function(e,t,r){function i(e){s.isBuffer(e)||(e=s.from(e));for(var t=e.length/4|0,r=new Array(t),i=0;t>i;i++)r[i]=e.readUInt32BE(4*i);return r}function n(e){for(var t=0;t<e.length;e++)e[t]=0}function a(e,t,r,i,n){for(var a,o,s,f,c=r[0],u=r[1],h=r[2],d=r[3],l=e[0]^t[0],p=e[1]^t[1],b=e[2]^t[2],y=e[3]^t[3],m=4,g=1;n>g;g++)a=c[l>>>24]^u[p>>>16&255]^h[b>>>8&255]^d[255&y]^t[m++],o=c[p>>>24]^u[b>>>16&255]^h[y>>>8&255]^d[255&l]^t[m++],s=c[b>>>24]^u[y>>>16&255]^h[l>>>8&255]^d[255&p]^t[m++],f=c[y>>>24]^u[l>>>16&255]^h[p>>>8&255]^d[255&b]^t[m++],l=a,p=o,b=s,y=f;return a=(i[l>>>24]<<24|i[p>>>16&255]<<16|i[b>>>8&255]<<8|i[255&y])^t[m++],o=(i[p>>>24]<<24|i[b>>>16&255]<<16|i[y>>>8&255]<<8|i[255&l])^t[m++],s=(i[b>>>24]<<24|i[y>>>16&255]<<16|i[l>>>8&255]<<8|i[255&p])^t[m++],f=(i[y>>>24]<<24|i[l>>>16&255]<<16|i[p>>>8&255]<<8|i[255&b])^t[m++],a>>>=0,o>>>=0,s>>>=0,f>>>=0,[a,o,s,f]}function o(e){this._key=i(e),this._reset()}var s=e("safe-buffer").Buffer,f=[0,1,2,4,8,16,32,64,128,27,54],c=function(){for(var e=new Array(256),t=0;256>t;t++)128>t?e[t]=t<<1:e[t]=t<<1^283;for(var r=[],i=[],n=[[],[],[],[]],a=[[],[],[],[]],o=0,s=0,f=0;256>f;++f){var c=s^s<<1^s<<2^s<<3^s<<4;c=c>>>8^255&c^99,r[o]=c,i[c]=o;var u=e[o],h=e[u],d=e[h],l=257*e[c]^16843008*c;n[0][o]=l<<24|l>>>8,n[1][o]=l<<16|l>>>16,n[2][o]=l<<8|l>>>24,n[3][o]=l,l=16843009*d^65537*h^257*u^16843008*o,a[0][c]=l<<24|l>>>8,a[1][c]=l<<16|l>>>16,a[2][c]=l<<8|l>>>24,a[3][c]=l,0===o?o=s=1:(o=u^e[e[e[d^u]]],s^=e[e[s]])}return{SBOX:r,INV_SBOX:i,SUB_MIX:n,INV_SUB_MIX:a}}();o.blockSize=16,o.keySize=32,o.prototype.blockSize=o.blockSize,o.prototype.keySize=o.keySize,o.prototype._reset=function(){for(var e=this._key,t=e.length,r=t+6,i=4*(r+1),n=[],a=0;t>a;a++)n[a]=e[a];for(a=t;i>a;a++){var o=n[a-1];a%t===0?(o=o<<8|o>>>24,o=c.SBOX[o>>>24]<<24|c.SBOX[o>>>16&255]<<16|c.SBOX[o>>>8&255]<<8|c.SBOX[255&o],o^=f[a/t|0]<<24):t>6&&a%t===4&&(o=c.SBOX[o>>>24]<<24|c.SBOX[o>>>16&255]<<16|c.SBOX[o>>>8&255]<<8|c.SBOX[255&o]),n[a]=n[a-t]^o}for(var s=[],u=0;i>u;u++){var h=i-u,d=n[h-(u%4?0:4)];4>u||4>=h?s[u]=d:s[u]=c.INV_SUB_MIX[0][c.SBOX[d>>>24]]^c.INV_SUB_MIX[1][c.SBOX[d>>>16&255]]^c.INV_SUB_MIX[2][c.SBOX[d>>>8&255]]^c.INV_SUB_MIX[3][c.SBOX[255&d]]}this._nRounds=r,this._keySchedule=n,this._invKeySchedule=s},o.prototype.encryptBlockRaw=function(e){return e=i(e),a(e,this._keySchedule,c.SUB_MIX,c.SBOX,this._nRounds)},o.prototype.encryptBlock=function(e){var t=this.encryptBlockRaw(e),r=s.allocUnsafe(16);return r.writeUInt32BE(t[0],0),r.writeUInt32BE(t[1],4),r.writeUInt32BE(t[2],8),r.writeUInt32BE(t[3],12),r},o.prototype.decryptBlock=function(e){e=i(e);var t=e[1];e[1]=e[3],e[3]=t;var r=a(e,this._invKeySchedule,c.INV_SUB_MIX,c.INV_SBOX,this._nRounds),n=s.allocUnsafe(16);return n.writeUInt32BE(r[0],0),n.writeUInt32BE(r[3],4),n.writeUInt32BE(r[2],8),n.writeUInt32BE(r[1],12),n},o.prototype.scrub=function(){n(this._keySchedule),n(this._invKeySchedule),n(this._key)},t.exports.AES=o},{"safe-buffer":167}],21:[function(e,t,r){function i(e,t){var r=0;e.length!==t.length&&r++;for(var i=Math.min(e.length,t.length),n=0;i>n;++n)r+=e[n]^t[n];return r}function n(e,t,r){if(12===t.length)return e._finID=s.concat([t,s.from([0,0,0,1])]),s.concat([t,s.from([0,0,0,2])]);var i=new u(r),n=t.length,a=n%16;i.update(t),a&&(a=16-a,i.update(s.alloc(a,0))),i.update(s.alloc(8,0));var o=8*n,f=s.alloc(8);f.writeUIntBE(o,0,8),i.update(f),e._finID=i.state;var c=s.from(e._finID);return d(c),c}function a(e,t,r,i){f.call(this);var a=s.alloc(4,0);this._cipher=new o.AES(t);var c=this._cipher.encryptBlock(a);this._ghash=new u(c),r=n(this,r,c),this._prev=s.from(r),this._cache=s.allocUnsafe(0),this._secCache=s.allocUnsafe(0),this._decrypt=i,this._alen=0,this._len=0,this._mode=e,this._authTag=null,this._called=!1}var o=e("./aes"),s=e("safe-buffer").Buffer,f=e("cipher-base"),c=e("inherits"),u=e("./ghash"),h=e("buffer-xor"),d=e("./incr32");c(a,f),a.prototype._update=function(e){if(!this._called&&this._alen){var t=16-this._alen%16;16>t&&(t=s.alloc(t,0),this._ghash.update(t))}this._called=!0;var r=this._mode.encrypt(this,e);return this._decrypt?this._ghash.update(e):this._ghash.update(r),this._len+=e.length,r},a.prototype._final=function(){if(this._decrypt&&!this._authTag)throw new Error("Unsupported state or unable to authenticate data");var e=h(this._ghash["final"](8*this._alen,8*this._len),this._cipher.encryptBlock(this._finID));if(this._decrypt&&i(e,this._authTag))throw new Error("Unsupported state or unable to authenticate data");this._authTag=e,this._cipher.scrub()},a.prototype.getAuthTag=function(){if(this._decrypt||!s.isBuffer(this._authTag))throw new Error("Attempting to get auth tag in unsupported state");return this._authTag},a.prototype.setAuthTag=function(e){if(!this._decrypt)throw new Error("Attempting to set auth tag in unsupported state");this._authTag=e},a.prototype.setAAD=function(e){if(this._called)throw new Error("Attempting to set AAD in unsupported state");this._ghash.update(e),this._alen+=e.length},t.exports=a},{"./aes":20,"./ghash":25,"./incr32":26,"buffer-xor":48,"cipher-base":50,inherits:103,"safe-buffer":167}],22:[function(e,t,r){function i(){return Object.keys(o)}var n=e("./encrypter"),a=e("./decrypter"),o=e("./modes/list.json");r.createCipher=r.Cipher=n.createCipher,r.createCipheriv=r.Cipheriv=n.createCipheriv,r.createDecipher=r.Decipher=a.createDecipher,r.createDecipheriv=r.Decipheriv=a.createDecipheriv,r.listCiphers=r.getCiphers=i},{"./decrypter":23,"./encrypter":24,"./modes/list.json":34}],23:[function(e,t,r){function i(e,t,r){d.call(this),this._cache=new n,this._last=void 0,this._cipher=new l.AES(t),this._prev=c.from(r),this._mode=e,this._autopadding=!0}function n(){this.cache=c.allocUnsafe(0)}function a(e){var t=e[15];if(1>t||t>16)throw new Error("unable to decrypt data");for(var r=-1;++r<t;)if(e[r+(16-t)]!==t)throw new Error("unable to decrypt data");return 16!==t?e.slice(0,16-t):void 0}function o(e,t,r){var n=u[e.toLowerCase()];if(!n)throw new TypeError("invalid suite type");if("string"==typeof r&&(r=c.from(r)),"GCM"!==n.mode&&r.length!==n.iv)throw new TypeError("invalid iv length "+r.length);if("string"==typeof t&&(t=c.from(t)),t.length!==n.key/8)throw new TypeError("invalid key length "+t.length);return"stream"===n.type?new h(n.module,t,r,!0):"auth"===n.type?new f(n.module,t,r,!0):new i(n.module,t,r)}function s(e,t){var r=u[e.toLowerCase()];if(!r)throw new TypeError("invalid suite type");var i=p(t,!1,r.key,r.iv);return o(e,i.key,i.iv)}var f=e("./authCipher"),c=e("safe-buffer").Buffer,u=e("./modes"),h=e("./streamCipher"),d=e("cipher-base"),l=e("./aes"),p=e("evp_bytestokey"),b=e("inherits");b(i,d),i.prototype._update=function(e){this._cache.add(e);for(var t,r,i=[];t=this._cache.get(this._autopadding);)r=this._mode.decrypt(this,t),i.push(r);return c.concat(i)},i.prototype._final=function(){var e=this._cache.flush();if(this._autopadding)return a(this._mode.decrypt(this,e));if(e)throw new Error("data not multiple of block length")},i.prototype.setAutoPadding=function(e){return this._autopadding=!!e,this},n.prototype.add=function(e){this.cache=c.concat([this.cache,e])},n.prototype.get=function(e){var t;if(e){if(this.cache.length>16)return t=this.cache.slice(0,16),this.cache=this.cache.slice(16),t}else if(this.cache.length>=16)return t=this.cache.slice(0,16),this.cache=this.cache.slice(16),t;return null},n.prototype.flush=function(){return this.cache.length?this.cache:void 0},r.createDecipher=s,r.createDecipheriv=o},{"./aes":20,"./authCipher":21,"./modes":33,"./streamCipher":36,"cipher-base":50,evp_bytestokey:87,inherits:103,"safe-buffer":167}],24:[function(e,t,r){function i(e,t,r){h.call(this),this._cache=new n,this._cipher=new d.AES(t),this._prev=c.from(r),this._mode=e,this._autopadding=!0}function n(){this.cache=c.allocUnsafe(0)}function a(e,t,r){var n=s[e.toLowerCase()];if(!n)throw new TypeError("invalid suite type");if("string"==typeof t&&(t=c.from(t)),t.length!==n.key/8)throw new TypeError("invalid key length "+t.length);if("string"==typeof r&&(r=c.from(r)),"GCM"!==n.mode&&r.length!==n.iv)throw new TypeError("invalid iv length "+r.length);return"stream"===n.type?new u(n.module,t,r):"auth"===n.type?new f(n.module,t,r):new i(n.module,t,r)}function o(e,t){var r=s[e.toLowerCase()];if(!r)throw new TypeError("invalid suite type");var i=l(t,!1,r.key,r.iv);return a(e,i.key,i.iv)}var s=e("./modes"),f=e("./authCipher"),c=e("safe-buffer").Buffer,u=e("./streamCipher"),h=e("cipher-base"),d=e("./aes"),l=e("evp_bytestokey"),p=e("inherits");p(i,h),i.prototype._update=function(e){this._cache.add(e);for(var t,r,i=[];t=this._cache.get();)r=this._mode.encrypt(this,t),i.push(r);return c.concat(i)};var b=c.alloc(16,16);i.prototype._final=function(){var e=this._cache.flush();if(this._autopadding)return e=this._mode.encrypt(this,e),this._cipher.scrub(),e;if(!e.equals(b))throw this._cipher.scrub(),new Error("data not multiple of block length")},i.prototype.setAutoPadding=function(e){return this._autopadding=!!e,this},n.prototype.add=function(e){this.cache=c.concat([this.cache,e])},n.prototype.get=function(){if(this.cache.length>15){var e=this.cache.slice(0,16);return this.cache=this.cache.slice(16),e}return null},n.prototype.flush=function(){for(var e=16-this.cache.length,t=c.allocUnsafe(e),r=-1;++r<e;)t.writeUInt8(e,r);return c.concat([this.cache,t])},r.createCipheriv=a,r.createCipher=o},{"./aes":20,"./authCipher":21,"./modes":33,"./streamCipher":36,"cipher-base":50,evp_bytestokey:87,inherits:103,"safe-buffer":167}],25:[function(e,t,r){function i(e){return[e.readUInt32BE(0),e.readUInt32BE(4),e.readUInt32BE(8),e.readUInt32BE(12)]}function n(e){var t=o.allocUnsafe(16);return t.writeUInt32BE(e[0]>>>0,0),t.writeUInt32BE(e[1]>>>0,4),t.writeUInt32BE(e[2]>>>0,8),t.writeUInt32BE(e[3]>>>0,12),t}function a(e){this.h=e,this.state=o.alloc(16,0),this.cache=o.allocUnsafe(0)}var o=e("safe-buffer").Buffer,s=o.alloc(16,0);a.prototype.ghash=function(e){for(var t=-1;++t<e.length;)this.state[t]^=e[t];this._multiply()},a.prototype._multiply=function(){for(var e,t,r,a=i(this.h),o=[0,0,0,0],s=-1;++s<128;){for(t=0!==(this.state[~~(s/8)]&1<<7-s%8),t&&(o[0]^=a[0],o[1]^=a[1],o[2]^=a[2],o[3]^=a[3]),r=0!==(1&a[3]),e=3;e>0;e--)a[e]=a[e]>>>1|(1&a[e-1])<<31;a[0]=a[0]>>>1,r&&(a[0]=a[0]^225<<24)}this.state=n(o)},a.prototype.update=function(e){this.cache=o.concat([this.cache,e]);for(var t;this.cache.length>=16;)t=this.cache.slice(0,16),this.cache=this.cache.slice(16),this.ghash(t)},a.prototype["final"]=function(e,t){return this.cache.length&&this.ghash(o.concat([this.cache,s],16)),this.ghash(n([0,e,0,t])),this.state},t.exports=a},{"safe-buffer":167}],26:[function(e,t,r){function i(e){for(var t,r=e.length;r--;){if(t=e.readUInt8(r),255!==t){t++,e.writeUInt8(t,r);break}e.writeUInt8(0,r)}}t.exports=i},{}],27:[function(e,t,r){var i=e("buffer-xor");r.encrypt=function(e,t){var r=i(t,e._prev);return e._prev=e._cipher.encryptBlock(r),e._prev},r.decrypt=function(e,t){var r=e._prev;e._prev=t;var n=e._cipher.decryptBlock(t);return i(n,r)}},{"buffer-xor":48}],28:[function(e,t,r){function i(e,t,r){var i=t.length,o=a(t,e._cache);return e._cache=e._cache.slice(i),e._prev=n.concat([e._prev,r?t:o]),o}var n=e("safe-buffer").Buffer,a=e("buffer-xor");r.encrypt=function(e,t,r){for(var a,o=n.allocUnsafe(0);t.length;){if(0===e._cache.length&&(e._cache=e._cipher.encryptBlock(e._prev),e._prev=n.allocUnsafe(0)),!(e._cache.length<=t.length)){o=n.concat([o,i(e,t,r)]);break}a=e._cache.length,o=n.concat([o,i(e,t.slice(0,a),r)]),t=t.slice(a)}return o}},{"buffer-xor":48,"safe-buffer":167}],29:[function(e,t,r){function i(e,t,r){for(var i,a,o,s=-1,f=8,c=0;++s<f;)i=e._cipher.encryptBlock(e._prev),a=t&1<<7-s?128:0,o=i[0]^a,c+=(128&o)>>s%8,e._prev=n(e._prev,r?a:o);return c}function n(e,t){var r=e.length,i=-1,n=a.allocUnsafe(e.length);for(e=a.concat([e,a.from([t])]);++i<r;)n[i]=e[i]<<1|e[i+1]>>7;return n}var a=e("safe-buffer").Buffer;r.encrypt=function(e,t,r){for(var n=t.length,o=a.allocUnsafe(n),s=-1;++s<n;)o[s]=i(e,t[s],r);return o}},{"safe-buffer":167}],30:[function(e,t,r){function i(e,t,r){var i=e._cipher.encryptBlock(e._prev),a=i[0]^t;return e._prev=n.concat([e._prev.slice(1),n.from([r?t:a])]),a}var n=e("safe-buffer").Buffer;r.encrypt=function(e,t,r){for(var a=t.length,o=n.allocUnsafe(a),s=-1;++s<a;)o[s]=i(e,t[s],r);return o}},{"safe-buffer":167}],31:[function(e,t,r){function i(e){var t=e._cipher.encryptBlockRaw(e._prev);return o(e._prev),t}var n=e("buffer-xor"),a=e("safe-buffer").Buffer,o=e("../incr32"),s=16;r.encrypt=function(e,t){var r=Math.ceil(t.length/s),o=e._cache.length;e._cache=a.concat([e._cache,a.allocUnsafe(r*s)]);for(var f=0;r>f;f++){var c=i(e),u=o+f*s;e._cache.writeUInt32BE(c[0],u+0),e._cache.writeUInt32BE(c[1],u+4),e._cache.writeUInt32BE(c[2],u+8),e._cache.writeUInt32BE(c[3],u+12)}var h=e._cache.slice(0,t.length);return e._cache=e._cache.slice(t.length),n(t,h)}},{"../incr32":26,"buffer-xor":48,"safe-buffer":167}],32:[function(e,t,r){r.encrypt=function(e,t){return e._cipher.encryptBlock(t)},r.decrypt=function(e,t){return e._cipher.decryptBlock(t)}},{}],33:[function(e,t,r){var i={ECB:e("./ecb"),CBC:e("./cbc"),CFB:e("./cfb"),CFB8:e("./cfb8"),CFB1:e("./cfb1"),OFB:e("./ofb"),CTR:e("./ctr"),GCM:e("./ctr")},n=e("./list.json");for(var a in n)n[a].module=i[n[a].mode];t.exports=n},{"./cbc":27,"./cfb":28,"./cfb1":29,"./cfb8":30,"./ctr":31,"./ecb":32,"./list.json":34,"./ofb":35}],34:[function(e,t,r){t.exports={"aes-128-ecb":{cipher:"AES",key:128,iv:0,mode:"ECB",type:"block"},"aes-192-ecb":{cipher:"AES",key:192,iv:0,mode:"ECB",type:"block"},"aes-256-ecb":{cipher:"AES",key:256,iv:0,mode:"ECB",type:"block"},"aes-128-cbc":{cipher:"AES",key:128,iv:16,mode:"CBC",type:"block"},"aes-192-cbc":{cipher:"AES",key:192,iv:16,mode:"CBC",type:"block"},"aes-256-cbc":{cipher:"AES",key:256,iv:16,mode:"CBC",type:"block"},aes128:{cipher:"AES",key:128,iv:16,mode:"CBC",type:"block"},aes192:{cipher:"AES",key:192,iv:16,mode:"CBC",type:"block"},aes256:{cipher:"AES",key:256,iv:16,mode:"CBC",type:"block"},"aes-128-cfb":{cipher:"AES",key:128,iv:16,mode:"CFB",type:"stream"},"aes-192-cfb":{cipher:"AES",key:192,iv:16,mode:"CFB",type:"stream"},"aes-256-cfb":{cipher:"AES",key:256,iv:16,mode:"CFB",type:"stream"},"aes-128-cfb8":{cipher:"AES",key:128,iv:16,mode:"CFB8",type:"stream"},"aes-192-cfb8":{cipher:"AES",key:192,iv:16,mode:"CFB8",type:"stream"},"aes-256-cfb8":{cipher:"AES",key:256,iv:16,mode:"CFB8",type:"stream"},"aes-128-cfb1":{cipher:"AES",key:128,iv:16,mode:"CFB1",type:"stream"},"aes-192-cfb1":{cipher:"AES",key:192,iv:16,mode:"CFB1",type:"stream"},"aes-256-cfb1":{cipher:"AES",key:256,iv:16,mode:"CFB1",type:"stream"},"aes-128-ofb":{cipher:"AES",key:128,iv:16,mode:"OFB",type:"stream"},"aes-192-ofb":{cipher:"AES",key:192,iv:16,mode:"OFB",type:"stream"},"aes-256-ofb":{cipher:"AES",key:256,iv:16,mode:"OFB",type:"stream"},"aes-128-ctr":{cipher:"AES",key:128,iv:16,mode:"CTR",type:"stream"},"aes-192-ctr":{cipher:"AES",key:192,iv:16,mode:"CTR",type:"stream"},"aes-256-ctr":{cipher:"AES",key:256,iv:16,mode:"CTR",type:"stream"},"aes-128-gcm":{cipher:"AES",key:128,iv:12,mode:"GCM",type:"auth"},"aes-192-gcm":{cipher:"AES",key:192,iv:12,mode:"GCM",type:"auth"},"aes-256-gcm":{cipher:"AES",key:256,iv:12,mode:"GCM",type:"auth"}}},{}],35:[function(e,t,r){(function(t){function i(e){return e._prev=e._cipher.encryptBlock(e._prev),e._prev}var n=e("buffer-xor");r.encrypt=function(e,r){for(;e._cache.length<r.length;)e._cache=t.concat([e._cache,i(e)]);var a=e._cache.slice(0,r.length);return e._cache=e._cache.slice(r.length),n(r,a)}}).call(this,e("buffer").Buffer)},{buffer:49,"buffer-xor":48}],36:[function(e,t,r){function i(e,t,r,i){o.call(this),this._cipher=new n.AES(t),this._prev=a.from(r),this._cache=a.allocUnsafe(0),this._secCache=a.allocUnsafe(0),this._decrypt=i,this._mode=e}var n=e("./aes"),a=e("safe-buffer").Buffer,o=e("cipher-base"),s=e("inherits");s(i,o),i.prototype._update=function(e){return this._mode.encrypt(this,e,this._decrypt)},i.prototype._final=function(){this._cipher.scrub()},t.exports=i},{"./aes":20,"cipher-base":50,inherits:103,"safe-buffer":167}],37:[function(e,t,r){function i(e,t){e=e.toLowerCase();var r,i;if(u[e])r=u[e].key,i=u[e].iv;else{if(!h[e])throw new TypeError("invalid suite type");r=8*h[e].key,i=h[e].iv}var n=d(t,!1,r,i);return a(e,n.key,n.iv)}function n(e,t){e=e.toLowerCase();var r,i;if(u[e])r=u[e].key,i=u[e].iv;else{if(!h[e])throw new TypeError("invalid suite type");r=8*h[e].key,i=h[e].iv}var n=d(t,!1,r,i);return o(e,n.key,n.iv)}function a(e,t,r){if(e=e.toLowerCase(),u[e])return c.createCipheriv(e,t,r);if(h[e])return new f({key:t,iv:r,mode:e});throw new TypeError("invalid suite type")}function o(e,t,r){if(e=e.toLowerCase(),u[e])return c.createDecipheriv(e,t,r);if(h[e])return new f({key:t,iv:r,mode:e,decrypt:!0});throw new TypeError("invalid suite type")}function s(){return Object.keys(h).concat(c.getCiphers())}var f=e("browserify-des"),c=e("browserify-aes/browser"),u=e("browserify-aes/modes"),h=e("browserify-des/modes"),d=e("evp_bytestokey");r.createCipher=r.Cipher=i,r.createCipheriv=r.Cipheriv=a,r.createDecipher=r.Decipher=n,r.createDecipheriv=r.Decipheriv=o,r.listCiphers=r.getCiphers=s},{"browserify-aes/browser":22,"browserify-aes/modes":33,"browserify-des":38,"browserify-des/modes":39,evp_bytestokey:87}],38:[function(e,t,r){function i(e){n.call(this);var t,r=e.mode.toLowerCase(),i=f[r];t=e.decrypt?"decrypt":"encrypt";var a=e.key;s.isBuffer(a)||(a=s.from(a)),("des-ede"===r||"des-ede-cbc"===r)&&(a=s.concat([a,a.slice(0,8)]));var o=e.iv;s.isBuffer(o)||(o=s.from(o)),this._des=i.create({key:a,iv:o,type:t})}var n=e("cipher-base"),a=e("des.js"),o=e("inherits"),s=e("safe-buffer").Buffer,f={"des-ede3-cbc":a.CBC.instantiate(a.EDE),"des-ede3":a.EDE,"des-ede-cbc":a.CBC.instantiate(a.EDE),"des-ede":a.EDE,"des-cbc":a.CBC.instantiate(a.DES),"des-ecb":a.DES};f.des=f["des-cbc"],f.des3=f["des-ede3-cbc"],t.exports=i,o(i,n),i.prototype._update=function(e){return s.from(this._des.update(e))},i.prototype._final=function(){return s.from(this._des["final"]())}},{"cipher-base":50,"des.js":58,inherits:103,"safe-buffer":167}],39:[function(e,t,r){r["des-ecb"]={key:8,iv:0},r["des-cbc"]=r.des={key:8,iv:8},r["des-ede3-cbc"]=r.des3={key:24,iv:8},r["des-ede3"]={key:24,iv:0},r["des-ede-cbc"]={key:16,iv:8},r["des-ede"]={key:16,iv:0}},{}],40:[function(e,t,r){(function(r){function i(e){var t=a(e),r=t.toRed(o.mont(e.modulus)).redPow(new o(e.publicExponent)).fromRed();return{blinder:r,unblinder:t.invm(e.modulus)}}function n(e,t){var n=i(t),a=t.modulus.byteLength(),s=(o.mont(t.modulus),new o(e).mul(n.blinder).umod(t.modulus)),f=s.toRed(o.mont(t.prime1)),c=s.toRed(o.mont(t.prime2)),u=t.coefficient,h=t.prime1,d=t.prime2,l=f.redPow(t.exponent1),p=c.redPow(t.exponent2);l=l.fromRed(),p=p.fromRed();var b=l.isub(p).imul(u).umod(h);return b.imul(d),p.iadd(b),new r(p.imul(n.unblinder).umod(t.modulus).toArray(!1,a))}function a(e){for(var t=e.modulus.byteLength(),r=new o(s(t));r.cmp(e.modulus)>=0||!r.umod(e.prime1)||!r.umod(e.prime2);)r=new o(s(t));return r}var o=e("bn.js"),s=e("randombytes");t.exports=n,n.getr=a}).call(this,e("buffer").Buffer)},{"bn.js":17,buffer:49,randombytes:150}],41:[function(e,t,r){t.exports=e("./browser/algorithms.json")},{"./browser/algorithms.json":42}],42:[function(e,t,r){t.exports={sha224WithRSAEncryption:{sign:"rsa",hash:"sha224",id:"302d300d06096086480165030402040500041c"},"RSA-SHA224":{sign:"ecdsa/rsa",hash:"sha224",id:"302d300d06096086480165030402040500041c"},sha256WithRSAEncryption:{sign:"rsa",hash:"sha256",id:"3031300d060960864801650304020105000420"},"RSA-SHA256":{sign:"ecdsa/rsa",hash:"sha256",id:"3031300d060960864801650304020105000420"},sha384WithRSAEncryption:{sign:"rsa",hash:"sha384",id:"3041300d060960864801650304020205000430"},"RSA-SHA384":{sign:"ecdsa/rsa",hash:"sha384",id:"3041300d060960864801650304020205000430"},sha512WithRSAEncryption:{sign:"rsa",hash:"sha512",id:"3051300d060960864801650304020305000440"},"RSA-SHA512":{sign:"ecdsa/rsa",hash:"sha512",id:"3051300d060960864801650304020305000440"},"RSA-SHA1":{sign:"rsa",hash:"sha1",id:"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{sign:"ecdsa",hash:"sha1",id:""},sha256:{sign:"ecdsa",hash:"sha256",id:""},sha224:{sign:"ecdsa",hash:"sha224",id:""},sha384:{sign:"ecdsa",hash:"sha384",id:""},sha512:{sign:"ecdsa",hash:"sha512",id:""},"DSA-SHA":{sign:"dsa",hash:"sha1",id:""},"DSA-SHA1":{sign:"dsa",hash:"sha1",id:""},DSA:{sign:"dsa",hash:"sha1",id:""},"DSA-WITH-SHA224":{sign:"dsa",hash:"sha224",id:""},"DSA-SHA224":{sign:"dsa",hash:"sha224",id:""},"DSA-WITH-SHA256":{sign:"dsa",hash:"sha256",id:""},"DSA-SHA256":{sign:"dsa",hash:"sha256",id:""},"DSA-WITH-SHA384":{sign:"dsa",hash:"sha384",id:""},"DSA-SHA384":{sign:"dsa",hash:"sha384",id:""},"DSA-WITH-SHA512":{sign:"dsa",hash:"sha512",id:""},"DSA-SHA512":{sign:"dsa",hash:"sha512",id:""},"DSA-RIPEMD160":{sign:"dsa",hash:"rmd160",id:""},ripemd160WithRSA:{sign:"rsa",hash:"rmd160",id:"3021300906052b2403020105000414"},"RSA-RIPEMD160":{sign:"rsa",hash:"rmd160",id:"3021300906052b2403020105000414"},md5WithRSAEncryption:{sign:"rsa",hash:"md5",id:"3020300c06082a864886f70d020505000410"},"RSA-MD5":{sign:"rsa",hash:"md5",id:"3020300c06082a864886f70d020505000410"}}},{}],43:[function(e,t,r){t.exports={"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"}},{}],44:[function(e,t,r){(function(r){function i(e){f.Writable.call(this);var t=d[e];if(!t)throw new Error("Unknown message digest");this._hashType=t.hash,this._hash=s(t.hash),this._tag=t.id,this._signType=t.sign}function n(e){f.Writable.call(this);var t=d[e];if(!t)throw new Error("Unknown message digest");this._hash=s(t.hash),this._tag=t.id,this._signType=t.sign}function a(e){return new i(e)}function o(e){return new n(e)}var s=e("create-hash"),f=e("stream"),c=e("inherits"),u=e("./sign"),h=e("./verify"),d=e("./algorithms.json");Object.keys(d).forEach(function(e){d[e].id=new r(d[e].id,"hex"),d[e.toLowerCase()]=d[e]}),c(i,f.Writable),i.prototype._write=function(e,t,r){this._hash.update(e),r()},i.prototype.update=function(e,t){return"string"==typeof e&&(e=new r(e,t)),this._hash.update(e),this},i.prototype.sign=function(e,t){this.end();var r=this._hash.digest(),i=u(r,e,this._hashType,this._signType,this._tag);return t?i.toString(t):i},c(n,f.Writable),n.prototype._write=function(e,t,r){this._hash.update(e),r()},n.prototype.update=function(e,t){return"string"==typeof e&&(e=new r(e,t)),this._hash.update(e),this},n.prototype.verify=function(e,t,i){"string"==typeof t&&(t=new r(t,i)),this.end();var n=this._hash.digest();return h(t,n,e,this._signType,this._tag)},t.exports={Sign:a,Verify:o,createSign:a,createVerify:o}}).call(this,e("buffer").Buffer)},{"./algorithms.json":42,"./sign":45,"./verify":46,buffer:49,"create-hash":53,inherits:103,stream:176}],45:[function(e,t,r){(function(r){function i(e,t,i,o,s){var f=y(t);if(f.curve){if("ecdsa"!==o&&"ecdsa/rsa"!==o)throw new Error("wrong private key type");return n(e,f)}if("dsa"===f.type){if("dsa"!==o)throw new Error("wrong private key type");return a(e,f,i)}if("rsa"!==o&&"ecdsa/rsa"!==o)throw new Error("wrong private key type");e=r.concat([s,e]);for(var c=f.modulus.byteLength(),u=[0,1];e.length+u.length+1<c;)u.push(255);u.push(0);for(var h=-1;++h<e.length;)u.push(e[h]);var d=l(u,f);return d}function n(e,t){var i=m[t.curve.join(".")];if(!i)throw new Error("unknown curve "+t.curve.join("."));var n=new p(i),a=n.keyFromPrivate(t.privateKey),o=a.sign(e);return new r(o.toDER())}function a(e,t,r){for(var i,n=t.params.priv_key,a=t.params.p,c=t.params.q,d=t.params.g,l=new b(0),p=f(e,c).mod(c),y=!1,m=s(n,c,e,r);y===!1;)i=u(c,m,r),l=h(d,i,a,c),y=i.invm(c).imul(p.add(n.mul(l))).mod(c),0===y.cmpn(0)&&(y=!1,l=new b(0));return o(l,y)}function o(e,t){e=e.toArray(),t=t.toArray(),128&e[0]&&(e=[0].concat(e)),128&t[0]&&(t=[0].concat(t));var i=e.length+t.length+4,n=[48,i,2,e.length];return n=n.concat(e,[2,t.length],t),new r(n)}function s(e,t,i,n){if(e=new r(e.toArray()),e.length<t.byteLength()){var a=new r(t.byteLength()-e.length);a.fill(0),e=r.concat([a,e])}var o=i.length,s=c(i,t),f=new r(o);f.fill(1);var u=new r(o);return u.fill(0),u=d(n,u).update(f).update(new r([0])).update(e).update(s).digest(),f=d(n,u).update(f).digest(),u=d(n,u).update(f).update(new r([1])).update(e).update(s).digest(),f=d(n,u).update(f).digest(),{k:u,v:f}}function f(e,t){var r=new b(e),i=(e.length<<3)-t.bitLength();return i>0&&r.ishrn(i),r}function c(e,t){e=f(e,t),e=e.mod(t);var i=new r(e.toArray());if(i.length<t.byteLength()){var n=new r(t.byteLength()-i.length);n.fill(0),i=r.concat([n,i])}return i}function u(e,t,i){var n,a;do{for(n=new r(0);8*n.length<e.bitLength();)t.v=d(i,t.k).update(t.v).digest(),n=r.concat([n,t.v]);a=f(n,e),t.k=d(i,t.k).update(t.v).update(new r([0])).digest(),t.v=d(i,t.k).update(t.v).digest()}while(-1!==a.cmp(e));return a}function h(e,t,r,i){return e.toRed(b.mont(r)).redPow(t).fromRed().mod(i)}var d=e("create-hmac"),l=e("browserify-rsa"),p=e("elliptic").ec,b=e("bn.js"),y=e("parse-asn1"),m=e("./curves.json");t.exports=i,t.exports.getKey=s,t.exports.makeKey=u}).call(this,e("buffer").Buffer)},{"./curves.json":43,"bn.js":17,"browserify-rsa":40,buffer:49,"create-hmac":55,elliptic:70,"parse-asn1":136}],46:[function(e,t,r){(function(r){function i(e,t,i,o,f){var u=c(i);if("ec"===u.type){if("ecdsa"!==o&&"ecdsa/rsa"!==o)throw new Error("wrong public key type");return n(e,t,u)}if("dsa"===u.type){if("dsa"!==o)throw new Error("wrong public key type");return a(e,t,u)}if("rsa"!==o&&"ecdsa/rsa"!==o)throw new Error("wrong public key type");t=r.concat([f,t]);for(var h=u.modulus.byteLength(),d=[1],l=0;t.length+d.length+2<h;)d.push(255),
l++;d.push(0);for(var p=-1;++p<t.length;)d.push(t[p]);d=new r(d);var b=s.mont(u.modulus);e=new s(e).toRed(b),e=e.redPow(new s(u.publicExponent)),e=new r(e.fromRed().toArray());var y=8>l?1:0;for(h=Math.min(e.length,d.length),e.length!==d.length&&(y=1),p=-1;++p<h;)y|=e[p]^d[p];return 0===y}function n(e,t,r){var i=u[r.data.algorithm.curve.join(".")];if(!i)throw new Error("unknown curve "+r.data.algorithm.curve.join("."));var n=new f(i),a=r.data.subjectPrivateKey.data;return n.verify(t,e,a)}function a(e,t,r){var i=r.data.p,n=r.data.q,a=r.data.g,f=r.data.pub_key,u=c.signature.decode(e,"der"),h=u.s,d=u.r;o(h,n),o(d,n);var l=s.mont(i),p=h.invm(n),b=a.toRed(l).redPow(new s(t).mul(p).mod(n)).fromRed().mul(f.toRed(l).redPow(d.mul(p).mod(n)).fromRed()).mod(i).mod(n);return 0===b.cmp(d)}function o(e,t){if(e.cmpn(0)<=0)throw new Error("invalid sig");if(e.cmp(t)>=t)throw new Error("invalid sig")}var s=e("bn.js"),f=e("elliptic").ec,c=e("parse-asn1"),u=e("./curves.json");t.exports=i}).call(this,e("buffer").Buffer)},{"./curves.json":43,"bn.js":17,buffer:49,elliptic:70,"parse-asn1":136}],47:[function(e,t,r){"use strict";function i(e,t){if(!n.isBuffer(e)||!n.isBuffer(t))return!1;if(e.length!==t.length)return!1;for(var r=0,i=0;i<e.length;i++)r|=e[i]^t[i];return 0===r}var n=e("buffer").Buffer,a=e("buffer").SlowBuffer;t.exports=i,i.install=function(){n.prototype.equal=a.prototype.equal=function(e){return i(this,e)}};var o=n.prototype.equal,s=a.prototype.equal;i.restore=function(){n.prototype.equal=o,a.prototype.equal=s}},{buffer:49}],48:[function(e,t,r){(function(e){t.exports=function(t,r){for(var i=Math.min(t.length,r.length),n=new e(i),a=0;i>a;++a)n[a]=t[a]^r[a];return n}}).call(this,e("buffer").Buffer)},{buffer:49}],49:[function(e,t,r){"use strict";function i(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()}catch(t){return!1}}function n(e){if(e>Z)throw new RangeError('The value "'+e+'" is invalid for option "size"');var t=new Uint8Array(e);return t.__proto__=a.prototype,t}function a(e,t,r){if("number"==typeof e){if("string"==typeof t)throw new TypeError('The "string" argument must be of type string. Received type number');return c(e)}return o(e,t,r)}function o(e,t,r){if("string"==typeof e)return u(e,t);if(ArrayBuffer.isView(e))return h(e);if(null==e)throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(V(e,ArrayBuffer)||e&&V(e.buffer,ArrayBuffer))return d(e,t,r);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');var i=e.valueOf&&e.valueOf();if(null!=i&&i!==e)return a.from(i,t,r);var n=l(e);if(n)return n;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return a.from(e[Symbol.toPrimitive]("string"),t,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function s(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(0>e)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function f(e,t,r){return s(e),0>=e?n(e):void 0!==t?"string"==typeof r?n(e).fill(t,r):n(e).fill(t):n(e)}function c(e){return s(e),n(0>e?0:0|p(e))}function u(e,t){if(("string"!=typeof t||""===t)&&(t="utf8"),!a.isEncoding(t))throw new TypeError("Unknown encoding: "+t);var r=0|y(e,t),i=n(r),o=i.write(e,t);return o!==r&&(i=i.slice(0,o)),i}function h(e){for(var t=e.length<0?0:0|p(e.length),r=n(t),i=0;t>i;i+=1)r[i]=255&e[i];return r}function d(e,t,r){if(0>t||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(r||0))throw new RangeError('"length" is outside of buffer bounds');var i;return i=void 0===t&&void 0===r?new Uint8Array(e):void 0===r?new Uint8Array(e,t):new Uint8Array(e,t,r),i.__proto__=a.prototype,i}function l(e){if(a.isBuffer(e)){var t=0|p(e.length),r=n(t);return 0===r.length?r:(e.copy(r,0,0,t),r)}return void 0!==e.length?"number"!=typeof e.length||J(e.length)?n(0):h(e):"Buffer"===e.type&&Array.isArray(e.data)?h(e.data):void 0}function p(e){if(e>=Z)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+Z.toString(16)+" bytes");return 0|e}function b(e){return+e!=e&&(e=0),a.alloc(+e)}function y(e,t){if(a.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||V(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);var r=e.length,i=arguments.length>2&&arguments[2]===!0;if(!i&&0===r)return 0;for(var n=!1;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return z(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return H(e).length;default:if(n)return i?-1:z(e).length;t=(""+t).toLowerCase(),n=!0}}function m(e,t,r){var i=!1;if((void 0===t||0>t)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),0>=r)return"";if(r>>>=0,t>>>=0,t>=r)return"";for(e||(e="utf8");;)switch(e){case"hex":return C(this,t,r);case"utf8":case"utf-8":return j(this,t,r);case"ascii":return I(this,t,r);case"latin1":case"binary":return R(this,t,r);case"base64":return A(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return T(this,t,r);default:if(i)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),i=!0}}function g(e,t,r){var i=e[t];e[t]=e[r],e[r]=i}function v(e,t,r,i,n){if(0===e.length)return-1;if("string"==typeof r?(i=r,r=0):r>2147483647?r=2147483647:-2147483648>r&&(r=-2147483648),r=+r,J(r)&&(r=n?0:e.length-1),0>r&&(r=e.length+r),r>=e.length){if(n)return-1;r=e.length-1}else if(0>r){if(!n)return-1;r=0}if("string"==typeof t&&(t=a.from(t,i)),a.isBuffer(t))return 0===t.length?-1:w(e,t,r,i,n);if("number"==typeof t)return t=255&t,"function"==typeof Uint8Array.prototype.indexOf?n?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):w(e,[t],r,i,n);throw new TypeError("val must be string, number or Buffer")}function w(e,t,r,i,n){function a(e,t){return 1===o?e[t]:e.readUInt16BE(t*o)}var o=1,s=e.length,f=t.length;if(void 0!==i&&(i=String(i).toLowerCase(),"ucs2"===i||"ucs-2"===i||"utf16le"===i||"utf-16le"===i)){if(e.length<2||t.length<2)return-1;o=2,s/=2,f/=2,r/=2}var c;if(n){var u=-1;for(c=r;s>c;c++)if(a(e,c)===a(t,-1===u?0:c-u)){if(-1===u&&(u=c),c-u+1===f)return u*o}else-1!==u&&(c-=c-u),u=-1}else for(r+f>s&&(r=s-f),c=r;c>=0;c--){for(var h=!0,d=0;f>d;d++)if(a(e,c+d)!==a(t,d)){h=!1;break}if(h)return c}return-1}function _(e,t,r,i){r=Number(r)||0;var n=e.length-r;i?(i=Number(i),i>n&&(i=n)):i=n;var a=t.length;i>a/2&&(i=a/2);for(var o=0;i>o;++o){var s=parseInt(t.substr(2*o,2),16);if(J(s))return o;e[r+o]=s}return o}function S(e,t,r,i){return W(z(t,e.length-r),e,r,i)}function M(e,t,r,i){return W(K(t),e,r,i)}function E(e,t,r,i){return M(e,t,r,i)}function k(e,t,r,i){return W(H(t),e,r,i)}function x(e,t,r,i){return W(F(t,e.length-r),e,r,i)}function A(e,t,r){return 0===t&&r===e.length?X.fromByteArray(e):X.fromByteArray(e.slice(t,r))}function j(e,t,r){r=Math.min(e.length,r);for(var i=[],n=t;r>n;){var a=e[n],o=null,s=a>239?4:a>223?3:a>191?2:1;if(r>=n+s){var f,c,u,h;switch(s){case 1:128>a&&(o=a);break;case 2:f=e[n+1],128===(192&f)&&(h=(31&a)<<6|63&f,h>127&&(o=h));break;case 3:f=e[n+1],c=e[n+2],128===(192&f)&&128===(192&c)&&(h=(15&a)<<12|(63&f)<<6|63&c,h>2047&&(55296>h||h>57343)&&(o=h));break;case 4:f=e[n+1],c=e[n+2],u=e[n+3],128===(192&f)&&128===(192&c)&&128===(192&u)&&(h=(15&a)<<18|(63&f)<<12|(63&c)<<6|63&u,h>65535&&1114112>h&&(o=h))}}null===o?(o=65533,s=1):o>65535&&(o-=65536,i.push(o>>>10&1023|55296),o=56320|1023&o),i.push(o),n+=s}return B(i)}function B(e){var t=e.length;if(Y>=t)return String.fromCharCode.apply(String,e);for(var r="",i=0;t>i;)r+=String.fromCharCode.apply(String,e.slice(i,i+=Y));return r}function I(e,t,r){var i="";r=Math.min(e.length,r);for(var n=t;r>n;++n)i+=String.fromCharCode(127&e[n]);return i}function R(e,t,r){var i="";r=Math.min(e.length,r);for(var n=t;r>n;++n)i+=String.fromCharCode(e[n]);return i}function C(e,t,r){var i=e.length;(!t||0>t)&&(t=0),(!r||0>r||r>i)&&(r=i);for(var n="",a=t;r>a;++a)n+=U(e[a]);return n}function T(e,t,r){for(var i=e.slice(t,r),n="",a=0;a<i.length;a+=2)n+=String.fromCharCode(i[a]+256*i[a+1]);return n}function O(e,t,r){if(e%1!==0||0>e)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function P(e,t,r,i,n,o){if(!a.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>n||o>t)throw new RangeError('"value" argument is out of bounds');if(r+i>e.length)throw new RangeError("Index out of range")}function D(e,t,r,i,n,a){if(r+i>e.length)throw new RangeError("Index out of range");if(0>r)throw new RangeError("Index out of range")}function L(e,t,r,i,n){return t=+t,r>>>=0,n||D(e,t,r,4,3.4028234663852886e38,-3.4028234663852886e38),G.write(e,t,r,i,23,4),r+4}function N(e,t,r,i,n){return t=+t,r>>>=0,n||D(e,t,r,8,1.7976931348623157e308,-1.7976931348623157e308),G.write(e,t,r,i,52,8),r+8}function q(e){if(e=e.split("=")[0],e=e.trim().replace($,""),e.length<2)return"";for(;e.length%4!==0;)e+="=";return e}function U(e){return 16>e?"0"+e.toString(16):e.toString(16)}function z(e,t){t=t||1/0;for(var r,i=e.length,n=null,a=[],o=0;i>o;++o){if(r=e.charCodeAt(o),r>55295&&57344>r){if(!n){if(r>56319){(t-=3)>-1&&a.push(239,191,189);continue}if(o+1===i){(t-=3)>-1&&a.push(239,191,189);continue}n=r;continue}if(56320>r){(t-=3)>-1&&a.push(239,191,189),n=r;continue}r=(n-55296<<10|r-56320)+65536}else n&&(t-=3)>-1&&a.push(239,191,189);if(n=null,128>r){if((t-=1)<0)break;a.push(r)}else if(2048>r){if((t-=2)<0)break;a.push(r>>6|192,63&r|128)}else if(65536>r){if((t-=3)<0)break;a.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(1114112>r))throw new Error("Invalid code point");if((t-=4)<0)break;a.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return a}function K(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}function F(e,t){for(var r,i,n,a=[],o=0;o<e.length&&!((t-=2)<0);++o)r=e.charCodeAt(o),i=r>>8,n=r%256,a.push(n),a.push(i);return a}function H(e){return X.toByteArray(q(e))}function W(e,t,r,i){for(var n=0;i>n&&!(n+r>=t.length||n>=e.length);++n)t[n+r]=e[n];return n}function V(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function J(e){return e!==e}var X=e("base64-js"),G=e("ieee754");r.Buffer=a,r.SlowBuffer=b,r.INSPECT_MAX_BYTES=50;var Z=2147483647;r.kMaxLength=Z,a.TYPED_ARRAY_SUPPORT=i(),a.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(a.prototype,"parent",{enumerable:!0,get:function(){return a.isBuffer(this)?this.buffer:void 0}}),Object.defineProperty(a.prototype,"offset",{enumerable:!0,get:function(){return a.isBuffer(this)?this.byteOffset:void 0}}),"undefined"!=typeof Symbol&&null!=Symbol.species&&a[Symbol.species]===a&&Object.defineProperty(a,Symbol.species,{value:null,configurable:!0,enumerable:!1,writable:!1}),a.poolSize=8192,a.from=function(e,t,r){return o(e,t,r)},a.prototype.__proto__=Uint8Array.prototype,a.__proto__=Uint8Array,a.alloc=function(e,t,r){return f(e,t,r)},a.allocUnsafe=function(e){return c(e)},a.allocUnsafeSlow=function(e){return c(e)},a.isBuffer=function(e){return null!=e&&e._isBuffer===!0&&e!==a.prototype},a.compare=function(e,t){if(V(e,Uint8Array)&&(e=a.from(e,e.offset,e.byteLength)),V(t,Uint8Array)&&(t=a.from(t,t.offset,t.byteLength)),!a.isBuffer(e)||!a.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;for(var r=e.length,i=t.length,n=0,o=Math.min(r,i);o>n;++n)if(e[n]!==t[n]){r=e[n],i=t[n];break}return i>r?-1:r>i?1:0},a.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},a.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return a.alloc(0);var r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var i=a.allocUnsafe(t),n=0;for(r=0;r<e.length;++r){var o=e[r];if(V(o,Uint8Array)&&(o=a.from(o)),!a.isBuffer(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(i,n),n+=o.length}return i},a.byteLength=y,a.prototype._isBuffer=!0,a.prototype.swap16=function(){var e=this.length;if(e%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;e>t;t+=2)g(this,t,t+1);return this},a.prototype.swap32=function(){var e=this.length;if(e%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;e>t;t+=4)g(this,t,t+3),g(this,t+1,t+2);return this},a.prototype.swap64=function(){var e=this.length;if(e%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;e>t;t+=8)g(this,t,t+7),g(this,t+1,t+6),g(this,t+2,t+5),g(this,t+3,t+4);return this},a.prototype.toString=function(){var e=this.length;return 0===e?"":0===arguments.length?j(this,0,e):m.apply(this,arguments)},a.prototype.toLocaleString=a.prototype.toString,a.prototype.equals=function(e){if(!a.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e?!0:0===a.compare(this,e)},a.prototype.inspect=function(){var e="",t=r.INSPECT_MAX_BYTES;return e=this.toString("hex",0,t).replace(/(.{2})/g,"$1 ").trim(),this.length>t&&(e+=" ... "),"<Buffer "+e+">"},a.prototype.compare=function(e,t,r,i,n){if(V(e,Uint8Array)&&(e=a.from(e,e.offset,e.byteLength)),!a.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===i&&(i=0),void 0===n&&(n=this.length),0>t||r>e.length||0>i||n>this.length)throw new RangeError("out of range index");if(i>=n&&t>=r)return 0;if(i>=n)return-1;if(t>=r)return 1;if(t>>>=0,r>>>=0,i>>>=0,n>>>=0,this===e)return 0;for(var o=n-i,s=r-t,f=Math.min(o,s),c=this.slice(i,n),u=e.slice(t,r),h=0;f>h;++h)if(c[h]!==u[h]){o=c[h],s=u[h];break}return s>o?-1:o>s?1:0},a.prototype.includes=function(e,t,r){return-1!==this.indexOf(e,t,r)},a.prototype.indexOf=function(e,t,r){return v(this,e,t,r,!0)},a.prototype.lastIndexOf=function(e,t,r){return v(this,e,t,r,!1)},a.prototype.write=function(e,t,r,i){if(void 0===t)i="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)i=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(r)?(r>>>=0,void 0===i&&(i="utf8")):(i=r,r=void 0)}var n=this.length-t;if((void 0===r||r>n)&&(r=n),e.length>0&&(0>r||0>t)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");i||(i="utf8");for(var a=!1;;)switch(i){case"hex":return _(this,e,t,r);case"utf8":case"utf-8":return S(this,e,t,r);case"ascii":return M(this,e,t,r);case"latin1":case"binary":return E(this,e,t,r);case"base64":return k(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return x(this,e,t,r);default:if(a)throw new TypeError("Unknown encoding: "+i);i=(""+i).toLowerCase(),a=!0}},a.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var Y=4096;a.prototype.slice=function(e,t){var r=this.length;e=~~e,t=void 0===t?r:~~t,0>e?(e+=r,0>e&&(e=0)):e>r&&(e=r),0>t?(t+=r,0>t&&(t=0)):t>r&&(t=r),e>t&&(t=e);var i=this.subarray(e,t);return i.__proto__=a.prototype,i},a.prototype.readUIntLE=function(e,t,r){e>>>=0,t>>>=0,r||O(e,t,this.length);for(var i=this[e],n=1,a=0;++a<t&&(n*=256);)i+=this[e+a]*n;return i},a.prototype.readUIntBE=function(e,t,r){e>>>=0,t>>>=0,r||O(e,t,this.length);for(var i=this[e+--t],n=1;t>0&&(n*=256);)i+=this[e+--t]*n;return i},a.prototype.readUInt8=function(e,t){return e>>>=0,t||O(e,1,this.length),this[e]},a.prototype.readUInt16LE=function(e,t){return e>>>=0,t||O(e,2,this.length),this[e]|this[e+1]<<8},a.prototype.readUInt16BE=function(e,t){return e>>>=0,t||O(e,2,this.length),this[e]<<8|this[e+1]},a.prototype.readUInt32LE=function(e,t){return e>>>=0,t||O(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},a.prototype.readUInt32BE=function(e,t){return e>>>=0,t||O(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},a.prototype.readIntLE=function(e,t,r){e>>>=0,t>>>=0,r||O(e,t,this.length);for(var i=this[e],n=1,a=0;++a<t&&(n*=256);)i+=this[e+a]*n;return n*=128,i>=n&&(i-=Math.pow(2,8*t)),i},a.prototype.readIntBE=function(e,t,r){e>>>=0,t>>>=0,r||O(e,t,this.length);for(var i=t,n=1,a=this[e+--i];i>0&&(n*=256);)a+=this[e+--i]*n;return n*=128,a>=n&&(a-=Math.pow(2,8*t)),a},a.prototype.readInt8=function(e,t){return e>>>=0,t||O(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},a.prototype.readInt16LE=function(e,t){e>>>=0,t||O(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},a.prototype.readInt16BE=function(e,t){e>>>=0,t||O(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},a.prototype.readInt32LE=function(e,t){return e>>>=0,t||O(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},a.prototype.readInt32BE=function(e,t){return e>>>=0,t||O(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},a.prototype.readFloatLE=function(e,t){return e>>>=0,t||O(e,4,this.length),G.read(this,e,!0,23,4)},a.prototype.readFloatBE=function(e,t){return e>>>=0,t||O(e,4,this.length),G.read(this,e,!1,23,4)},a.prototype.readDoubleLE=function(e,t){return e>>>=0,t||O(e,8,this.length),G.read(this,e,!0,52,8)},a.prototype.readDoubleBE=function(e,t){return e>>>=0,t||O(e,8,this.length),G.read(this,e,!1,52,8)},a.prototype.writeUIntLE=function(e,t,r,i){if(e=+e,t>>>=0,r>>>=0,!i){var n=Math.pow(2,8*r)-1;P(this,e,t,r,n,0)}var a=1,o=0;for(this[t]=255&e;++o<r&&(a*=256);)this[t+o]=e/a&255;return t+r},a.prototype.writeUIntBE=function(e,t,r,i){if(e=+e,t>>>=0,r>>>=0,!i){var n=Math.pow(2,8*r)-1;P(this,e,t,r,n,0)}var a=r-1,o=1;for(this[t+a]=255&e;--a>=0&&(o*=256);)this[t+a]=e/o&255;return t+r},a.prototype.writeUInt8=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,1,255,0),this[t]=255&e,t+1},a.prototype.writeUInt16LE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},a.prototype.writeUInt16BE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},a.prototype.writeUInt32LE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},a.prototype.writeUInt32BE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},a.prototype.writeIntLE=function(e,t,r,i){if(e=+e,t>>>=0,!i){var n=Math.pow(2,8*r-1);P(this,e,t,r,n-1,-n)}var a=0,o=1,s=0;for(this[t]=255&e;++a<r&&(o*=256);)0>e&&0===s&&0!==this[t+a-1]&&(s=1),this[t+a]=(e/o>>0)-s&255;return t+r},a.prototype.writeIntBE=function(e,t,r,i){if(e=+e,t>>>=0,!i){var n=Math.pow(2,8*r-1);P(this,e,t,r,n-1,-n)}var a=r-1,o=1,s=0;for(this[t+a]=255&e;--a>=0&&(o*=256);)0>e&&0===s&&0!==this[t+a+1]&&(s=1),this[t+a]=(e/o>>0)-s&255;return t+r},a.prototype.writeInt8=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,1,127,-128),0>e&&(e=255+e+1),this[t]=255&e,t+1},a.prototype.writeInt16LE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},a.prototype.writeInt16BE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},a.prototype.writeInt32LE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},a.prototype.writeInt32BE=function(e,t,r){return e=+e,t>>>=0,r||P(this,e,t,4,2147483647,-2147483648),0>e&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},a.prototype.writeFloatLE=function(e,t,r){return L(this,e,t,!0,r)},a.prototype.writeFloatBE=function(e,t,r){return L(this,e,t,!1,r)},a.prototype.writeDoubleLE=function(e,t,r){return N(this,e,t,!0,r)},a.prototype.writeDoubleBE=function(e,t,r){return N(this,e,t,!1,r)},a.prototype.copy=function(e,t,r,i){if(!a.isBuffer(e))throw new TypeError("argument should be a Buffer");if(r||(r=0),i||0===i||(i=this.length),t>=e.length&&(t=e.length),t||(t=0),i>0&&r>i&&(i=r),i===r)return 0;if(0===e.length||0===this.length)return 0;if(0>t)throw new RangeError("targetStart out of bounds");if(0>r||r>=this.length)throw new RangeError("Index out of range");if(0>i)throw new RangeError("sourceEnd out of bounds");i>this.length&&(i=this.length),e.length-t<i-r&&(i=e.length-t+r);var n=i-r;if(this===e&&"function"==typeof Uint8Array.prototype.copyWithin)this.copyWithin(t,r,i);else if(this===e&&t>r&&i>t)for(var o=n-1;o>=0;--o)e[o+t]=this[o+r];else Uint8Array.prototype.set.call(e,this.subarray(r,i),t);return n},a.prototype.fill=function(e,t,r,i){if("string"==typeof e){if("string"==typeof t?(i=t,t=0,r=this.length):"string"==typeof r&&(i=r,r=this.length),void 0!==i&&"string"!=typeof i)throw new TypeError("encoding must be a string");if("string"==typeof i&&!a.isEncoding(i))throw new TypeError("Unknown encoding: "+i);if(1===e.length){var n=e.charCodeAt(0);("utf8"===i&&128>n||"latin1"===i)&&(e=n)}}else"number"==typeof e&&(e=255&e);if(0>t||this.length<t||this.length<r)throw new RangeError("Out of range index");if(t>=r)return this;t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0);var o;if("number"==typeof e)for(o=t;r>o;++o)this[o]=e;else{var s=a.isBuffer(e)?e:a.from(e,i),f=s.length;if(0===f)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(o=0;r-t>o;++o)this[o+t]=s[o%f]}return this};var $=/[^+\/0-9A-Za-z-_]/g},{"base64-js":16,ieee754:102}],50:[function(e,t,r){function i(e){a.call(this),this.hashMode="string"==typeof e,this.hashMode?this[e]=this._finalOrDigest:this["final"]=this._finalOrDigest,this._final&&(this.__final=this._final,this._final=null),this._decoder=null,this._encoding=null}var n=e("safe-buffer").Buffer,a=e("stream").Transform,o=e("string_decoder").StringDecoder,s=e("inherits");s(i,a),i.prototype.update=function(e,t,r){"string"==typeof e&&(e=n.from(e,t));var i=this._update(e);return this.hashMode?this:(r&&(i=this._toString(i,r)),i)},i.prototype.setAutoPadding=function(){},i.prototype.getAuthTag=function(){throw new Error("trying to get auth tag in unsupported state")},i.prototype.setAuthTag=function(){throw new Error("trying to set auth tag in unsupported state")},i.prototype.setAAD=function(){throw new Error("trying to set aad in unsupported state")},i.prototype._transform=function(e,t,r){var i;try{this.hashMode?this._update(e):this.push(this._update(e))}catch(n){i=n}finally{r(i)}},i.prototype._flush=function(e){var t;try{this.push(this.__final())}catch(r){t=r}e(t)},i.prototype._finalOrDigest=function(e){var t=this.__final()||n.alloc(0);return e&&(t=this._toString(t,e,!0)),t},i.prototype._toString=function(e,t,r){if(this._decoder||(this._decoder=new o(t),this._encoding=t),this._encoding!==t)throw new Error("can't switch encodings");var i=this._decoder.write(e);return r&&(i+=this._decoder.end()),i},t.exports=i},{inherits:103,"safe-buffer":167,stream:176,string_decoder:177}],51:[function(e,t,r){(function(e){function t(e){return Array.isArray?Array.isArray(e):"[object Array]"===y(e)}function i(e){return"boolean"==typeof e}function n(e){return null===e}function a(e){return null==e}function o(e){return"number"==typeof e}function s(e){return"string"==typeof e}function f(e){return"symbol"==typeof e}function c(e){return void 0===e}function u(e){return"[object RegExp]"===y(e)}function h(e){return"object"==typeof e&&null!==e}function d(e){return"[object Date]"===y(e)}function l(e){return"[object Error]"===y(e)||e instanceof Error}function p(e){return"function"==typeof e}function b(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||"undefined"==typeof e}function y(e){return Object.prototype.toString.call(e)}r.isArray=t,r.isBoolean=i,r.isNull=n,r.isNullOrUndefined=a,r.isNumber=o,r.isString=s,r.isSymbol=f,r.isUndefined=c,r.isRegExp=u,r.isObject=h,r.isDate=d,r.isError=l,r.isFunction=p,r.isPrimitive=b,r.isBuffer=e.isBuffer}).call(this,{isBuffer:e("../../is-buffer/index.js")})},{"../../is-buffer/index.js":104}],52:[function(e,t,r){(function(r){function i(e){this.curveType=s[e],this.curveType||(this.curveType={name:e}),this.curve=new a.ec(this.curveType.name),this.keys=void 0}function n(e,t,i){Array.isArray(e)||(e=e.toArray());var n=new r(e);if(i&&n.length<i){var a=new r(i-n.length);a.fill(0),n=r.concat([a,n])}return t?n.toString(t):n}var a=e("elliptic"),o=e("bn.js");t.exports=function(e){return new i(e)};var s={secp256k1:{name:"secp256k1",byteLength:32},secp224r1:{name:"p224",byteLength:28},prime256v1:{name:"p256",byteLength:32},prime192v1:{name:"p192",byteLength:24},ed25519:{name:"ed25519",byteLength:32},secp384r1:{name:"p384",byteLength:48},secp521r1:{name:"p521",byteLength:66}};s.p224=s.secp224r1,s.p256=s.secp256r1=s.prime256v1,s.p192=s.secp192r1=s.prime192v1,s.p384=s.secp384r1,s.p521=s.secp521r1,i.prototype.generateKeys=function(e,t){return this.keys=this.curve.genKeyPair(),this.getPublicKey(e,t)},i.prototype.computeSecret=function(e,t,i){t=t||"utf8",r.isBuffer(e)||(e=new r(e,t));var a=this.curve.keyFromPublic(e).getPublic(),o=a.mul(this.keys.getPrivate()).getX();return n(o,i,this.curveType.byteLength)},i.prototype.getPublicKey=function(e,t){var r=this.keys.getPublic("compressed"===t,!0);return"hybrid"===t&&(r[r.length-1]%2?r[0]=7:r[0]=6),n(r,e)},i.prototype.getPrivateKey=function(e){return n(this.keys.getPrivate(),e)},i.prototype.setPublicKey=function(e,t){return t=t||"utf8",r.isBuffer(e)||(e=new r(e,t)),this.keys._importPublic(e),this},i.prototype.setPrivateKey=function(e,t){t=t||"utf8",r.isBuffer(e)||(e=new r(e,t));var i=new o(e);return i=i.toString(16),this.keys=this.curve.genKeyPair(),this.keys._importPrivate(i),this}}).call(this,e("buffer").Buffer)},{"bn.js":17,buffer:49,elliptic:70}],53:[function(e,t,r){"use strict";function i(e){f.call(this,"digest"),this._hash=e}var n=e("inherits"),a=e("md5.js"),o=e("ripemd160"),s=e("sha.js"),f=e("cipher-base");n(i,f),i.prototype._update=function(e){this._hash.update(e)},i.prototype._final=function(){return this._hash.digest()},t.exports=function(e){return e=e.toLowerCase(),"md5"===e?new a:"rmd160"===e||"ripemd160"===e?new o:new i(s(e))}},{"cipher-base":50,inherits:103,"md5.js":127,ripemd160:166,"sha.js":169}],54:[function(e,t,r){var i=e("md5.js");t.exports=function(e){return(new i).update(e).digest()}},{"md5.js":127}],55:[function(e,t,r){"use strict";function i(e,t){o.call(this,"digest"),"string"==typeof t&&(t=s.from(t));var r="sha512"===e||"sha384"===e?128:64;if(this._alg=e,this._key=t,t.length>r){var i="rmd160"===e?new c:u(e);t=i.update(t).digest()}else t.length<r&&(t=s.concat([t,h],r));for(var n=this._ipad=s.allocUnsafe(r),a=this._opad=s.allocUnsafe(r),f=0;r>f;f++)n[f]=54^t[f],a[f]=92^t[f];this._hash="rmd160"===e?new c:u(e),this._hash.update(n)}var n=e("inherits"),a=e("./legacy"),o=e("cipher-base"),s=e("safe-buffer").Buffer,f=e("create-hash/md5"),c=e("ripemd160"),u=e("sha.js"),h=s.alloc(128);n(i,o),i.prototype._update=function(e){this._hash.update(e)},i.prototype._final=function(){var e=this._hash.digest(),t="rmd160"===this._alg?new c:u(this._alg);return t.update(this._opad).update(e).digest()},t.exports=function(e,t){return e=e.toLowerCase(),"rmd160"===e||"ripemd160"===e?new i("rmd160",t):"md5"===e?new a(f,t):new i(e,t)}},{"./legacy":56,"cipher-base":50,"create-hash/md5":54,inherits:103,ripemd160:166,"safe-buffer":167,"sha.js":169}],56:[function(e,t,r){"use strict";function i(e,t){o.call(this,"digest"),"string"==typeof t&&(t=a.from(t)),this._alg=e,this._key=t,t.length>f?t=e(t):t.length<f&&(t=a.concat([t,s],f));for(var r=this._ipad=a.allocUnsafe(f),i=this._opad=a.allocUnsafe(f),n=0;f>n;n++)r[n]=54^t[n],i[n]=92^t[n];this._hash=[r]}var n=e("inherits"),a=e("safe-buffer").Buffer,o=e("cipher-base"),s=a.alloc(128),f=64;n(i,o),i.prototype._update=function(e){this._hash.push(e)},i.prototype._final=function(){var e=this._alg(a.concat(this._hash));return this._alg(a.concat([this._opad,e]))},t.exports=i},{"cipher-base":50,inherits:103,"safe-buffer":167}],57:[function(e,t,r){"use strict";r.randomBytes=r.rng=r.pseudoRandomBytes=r.prng=e("randombytes"),r.createHash=r.Hash=e("create-hash"),r.createHmac=r.Hmac=e("create-hmac");var i=e("browserify-sign/algos"),n=Object.keys(i),a=["sha1","sha224","sha256","sha384","sha512","md5","rmd160"].concat(n);r.getHashes=function(){return a};var o=e("pbkdf2");r.pbkdf2=o.pbkdf2,r.pbkdf2Sync=o.pbkdf2Sync;var s=e("browserify-cipher");r.Cipher=s.Cipher,r.createCipher=s.createCipher,r.Cipheriv=s.Cipheriv,r.createCipheriv=s.createCipheriv,r.Decipher=s.Decipher,r.createDecipher=s.createDecipher,r.Decipheriv=s.Decipheriv,r.createDecipheriv=s.createDecipheriv,r.getCiphers=s.getCiphers,r.listCiphers=s.listCiphers;var f=e("diffie-hellman");r.DiffieHellmanGroup=f.DiffieHellmanGroup,r.createDiffieHellmanGroup=f.createDiffieHellmanGroup,r.getDiffieHellman=f.getDiffieHellman,r.createDiffieHellman=f.createDiffieHellman,r.DiffieHellman=f.DiffieHellman;var c=e("browserify-sign");r.createSign=c.createSign,r.Sign=c.Sign,r.createVerify=c.createVerify,r.Verify=c.Verify,r.createECDH=e("create-ecdh");var u=e("public-encrypt");r.publicEncrypt=u.publicEncrypt,r.privateEncrypt=u.privateEncrypt,r.publicDecrypt=u.publicDecrypt,r.privateDecrypt=u.privateDecrypt;var h=e("randomfill");r.randomFill=h.randomFill,r.randomFillSync=h.randomFillSync,r.createCredentials=function(){throw new Error(["sorry, createCredentials is not implemented yet","we accept pull requests","https://github.com/crypto-browserify/crypto-browserify"].join("\n"))},r.constants={DH_CHECK_P_NOT_SAFE_PRIME:2,DH_CHECK_P_NOT_PRIME:1,DH_UNABLE_TO_CHECK_GENERATOR:4,DH_NOT_SUITABLE_GENERATOR:8,NPN_ENABLED:1,ALPN_ENABLED:1,RSA_PKCS1_PADDING:1,RSA_SSLV23_PADDING:2,RSA_NO_PADDING:3,RSA_PKCS1_OAEP_PADDING:4,RSA_X931_PADDING:5,RSA_PKCS1_PSS_PADDING:6,POINT_CONVERSION_COMPRESSED:2,POINT_CONVERSION_UNCOMPRESSED:4,POINT_CONVERSION_HYBRID:6}},{"browserify-cipher":37,"browserify-sign":44,"browserify-sign/algos":41,"create-ecdh":52,"create-hash":53,"create-hmac":55,"diffie-hellman":64,pbkdf2:137,"public-encrypt":144,randombytes:150,randomfill:151}],58:[function(e,t,r){"use strict";r.utils=e("./des/utils"),r.Cipher=e("./des/cipher"),r.DES=e("./des/des"),r.CBC=e("./des/cbc"),r.EDE=e("./des/ede")},{"./des/cbc":59,"./des/cipher":60,"./des/des":61,"./des/ede":62,"./des/utils":63}],59:[function(e,t,r){"use strict";function i(e){a.equal(e.length,8,"Invalid IV length"),this.iv=new Array(8);for(var t=0;t<this.iv.length;t++)this.iv[t]=e[t]}function n(e){function t(t){e.call(this,t),this._cbcInit()}o(t,e);for(var r=Object.keys(s),i=0;i<r.length;i++){var n=r[i];t.prototype[n]=s[n]}return t.create=function(e){return new t(e)},t}var a=e("minimalistic-assert"),o=e("inherits"),s={};r.instantiate=n,s._cbcInit=function(){var e=new i(this.options.iv);this._cbcState=e},s._update=function(e,t,r,i){var n=this._cbcState,a=this.constructor.super_.prototype,o=n.iv;if("encrypt"===this.type){for(var s=0;s<this.blockSize;s++)o[s]^=e[t+s];a._update.call(this,o,0,r,i);for(var s=0;s<this.blockSize;s++)o[s]=r[i+s]}else{a._update.call(this,e,t,r,i);for(var s=0;s<this.blockSize;s++)r[i+s]^=o[s];for(var s=0;s<this.blockSize;s++)o[s]=e[t+s]}}},{inherits:103,"minimalistic-assert":129}],60:[function(e,t,r){"use strict";function i(e){this.options=e,this.type=this.options.type,this.blockSize=8,this._init(),this.buffer=new Array(this.blockSize),
this.bufferOff=0}var n=e("minimalistic-assert");t.exports=i,i.prototype._init=function(){},i.prototype.update=function(e){return 0===e.length?[]:"decrypt"===this.type?this._updateDecrypt(e):this._updateEncrypt(e)},i.prototype._buffer=function(e,t){for(var r=Math.min(this.buffer.length-this.bufferOff,e.length-t),i=0;r>i;i++)this.buffer[this.bufferOff+i]=e[t+i];return this.bufferOff+=r,r},i.prototype._flushBuffer=function(e,t){return this._update(this.buffer,0,e,t),this.bufferOff=0,this.blockSize},i.prototype._updateEncrypt=function(e){var t=0,r=0,i=(this.bufferOff+e.length)/this.blockSize|0,n=new Array(i*this.blockSize);0!==this.bufferOff&&(t+=this._buffer(e,t),this.bufferOff===this.buffer.length&&(r+=this._flushBuffer(n,r)));for(var a=e.length-(e.length-t)%this.blockSize;a>t;t+=this.blockSize)this._update(e,t,n,r),r+=this.blockSize;for(;t<e.length;t++,this.bufferOff++)this.buffer[this.bufferOff]=e[t];return n},i.prototype._updateDecrypt=function(e){for(var t=0,r=0,i=Math.ceil((this.bufferOff+e.length)/this.blockSize)-1,n=new Array(i*this.blockSize);i>0;i--)t+=this._buffer(e,t),r+=this._flushBuffer(n,r);return t+=this._buffer(e,t),n},i.prototype["final"]=function(e){var t;e&&(t=this.update(e));var r;return r="encrypt"===this.type?this._finalEncrypt():this._finalDecrypt(),t?t.concat(r):r},i.prototype._pad=function(e,t){if(0===t)return!1;for(;t<e.length;)e[t++]=0;return!0},i.prototype._finalEncrypt=function(){if(!this._pad(this.buffer,this.bufferOff))return[];var e=new Array(this.blockSize);return this._update(this.buffer,0,e,0),e},i.prototype._unpad=function(e){return e},i.prototype._finalDecrypt=function(){n.equal(this.bufferOff,this.blockSize,"Not enough data to decrypt");var e=new Array(this.blockSize);return this._flushBuffer(e,0),this._unpad(e)}},{"minimalistic-assert":129}],61:[function(e,t,r){"use strict";function i(){this.tmp=new Array(2),this.keys=null}function n(e){c.call(this,e);var t=new i;this._desState=t,this.deriveKeys(t,e.key)}var a=e("minimalistic-assert"),o=e("inherits"),s=e("../des"),f=s.utils,c=s.Cipher;o(n,c),t.exports=n,n.create=function(e){return new n(e)};var u=[1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1];n.prototype.deriveKeys=function(e,t){e.keys=new Array(32),a.equal(t.length,this.blockSize,"Invalid key length");var r=f.readUInt32BE(t,0),i=f.readUInt32BE(t,4);f.pc1(r,i,e.tmp,0),r=e.tmp[0],i=e.tmp[1];for(var n=0;n<e.keys.length;n+=2){var o=u[n>>>1];r=f.r28shl(r,o),i=f.r28shl(i,o),f.pc2(r,i,e.keys,n)}},n.prototype._update=function(e,t,r,i){var n=this._desState,a=f.readUInt32BE(e,t),o=f.readUInt32BE(e,t+4);f.ip(a,o,n.tmp,0),a=n.tmp[0],o=n.tmp[1],"encrypt"===this.type?this._encrypt(n,a,o,n.tmp,0):this._decrypt(n,a,o,n.tmp,0),a=n.tmp[0],o=n.tmp[1],f.writeUInt32BE(r,a,i),f.writeUInt32BE(r,o,i+4)},n.prototype._pad=function(e,t){for(var r=e.length-t,i=t;i<e.length;i++)e[i]=r;return!0},n.prototype._unpad=function(e){for(var t=e[e.length-1],r=e.length-t;r<e.length;r++)a.equal(e[r],t);return e.slice(0,e.length-t)},n.prototype._encrypt=function(e,t,r,i,n){for(var a=t,o=r,s=0;s<e.keys.length;s+=2){var c=e.keys[s],u=e.keys[s+1];f.expand(o,e.tmp,0),c^=e.tmp[0],u^=e.tmp[1];var h=f.substitute(c,u),d=f.permute(h),l=o;o=(a^d)>>>0,a=l}f.rip(o,a,i,n)},n.prototype._decrypt=function(e,t,r,i,n){for(var a=r,o=t,s=e.keys.length-2;s>=0;s-=2){var c=e.keys[s],u=e.keys[s+1];f.expand(a,e.tmp,0),c^=e.tmp[0],u^=e.tmp[1];var h=f.substitute(c,u),d=f.permute(h),l=a;a=(o^d)>>>0,o=l}f.rip(a,o,i,n)}},{"../des":58,inherits:103,"minimalistic-assert":129}],62:[function(e,t,r){"use strict";function i(e,t){a.equal(t.length,24,"Invalid key length");var r=t.slice(0,8),i=t.slice(8,16),n=t.slice(16,24);"encrypt"===e?this.ciphers=[c.create({type:"encrypt",key:r}),c.create({type:"decrypt",key:i}),c.create({type:"encrypt",key:n})]:this.ciphers=[c.create({type:"decrypt",key:n}),c.create({type:"encrypt",key:i}),c.create({type:"decrypt",key:r})]}function n(e){f.call(this,e);var t=new i(this.type,this.options.key);this._edeState=t}var a=e("minimalistic-assert"),o=e("inherits"),s=e("../des"),f=s.Cipher,c=s.DES;o(n,f),t.exports=n,n.create=function(e){return new n(e)},n.prototype._update=function(e,t,r,i){var n=this._edeState;n.ciphers[0]._update(e,t,r,i),n.ciphers[1]._update(r,i,r,i),n.ciphers[2]._update(r,i,r,i)},n.prototype._pad=c.prototype._pad,n.prototype._unpad=c.prototype._unpad},{"../des":58,inherits:103,"minimalistic-assert":129}],63:[function(e,t,r){"use strict";r.readUInt32BE=function(e,t){var r=e[0+t]<<24|e[1+t]<<16|e[2+t]<<8|e[3+t];return r>>>0},r.writeUInt32BE=function(e,t,r){e[0+r]=t>>>24,e[1+r]=t>>>16&255,e[2+r]=t>>>8&255,e[3+r]=255&t},r.ip=function(e,t,r,i){for(var n=0,a=0,o=6;o>=0;o-=2){for(var s=0;24>=s;s+=8)n<<=1,n|=t>>>s+o&1;for(var s=0;24>=s;s+=8)n<<=1,n|=e>>>s+o&1}for(var o=6;o>=0;o-=2){for(var s=1;25>=s;s+=8)a<<=1,a|=t>>>s+o&1;for(var s=1;25>=s;s+=8)a<<=1,a|=e>>>s+o&1}r[i+0]=n>>>0,r[i+1]=a>>>0},r.rip=function(e,t,r,i){for(var n=0,a=0,o=0;4>o;o++)for(var s=24;s>=0;s-=8)n<<=1,n|=t>>>s+o&1,n<<=1,n|=e>>>s+o&1;for(var o=4;8>o;o++)for(var s=24;s>=0;s-=8)a<<=1,a|=t>>>s+o&1,a<<=1,a|=e>>>s+o&1;r[i+0]=n>>>0,r[i+1]=a>>>0},r.pc1=function(e,t,r,i){for(var n=0,a=0,o=7;o>=5;o--){for(var s=0;24>=s;s+=8)n<<=1,n|=t>>s+o&1;for(var s=0;24>=s;s+=8)n<<=1,n|=e>>s+o&1}for(var s=0;24>=s;s+=8)n<<=1,n|=t>>s+o&1;for(var o=1;3>=o;o++){for(var s=0;24>=s;s+=8)a<<=1,a|=t>>s+o&1;for(var s=0;24>=s;s+=8)a<<=1,a|=e>>s+o&1}for(var s=0;24>=s;s+=8)a<<=1,a|=e>>s+o&1;r[i+0]=n>>>0,r[i+1]=a>>>0},r.r28shl=function(e,t){return e<<t&268435455|e>>>28-t};var i=[14,11,17,4,27,23,25,0,13,22,7,18,5,9,16,24,2,20,12,21,1,8,15,26,15,4,25,19,9,1,26,16,5,11,23,8,12,7,17,0,22,3,10,14,6,20,27,24];r.pc2=function(e,t,r,n){for(var a=0,o=0,s=i.length>>>1,f=0;s>f;f++)a<<=1,a|=e>>>i[f]&1;for(var f=s;f<i.length;f++)o<<=1,o|=t>>>i[f]&1;r[n+0]=a>>>0,r[n+1]=o>>>0},r.expand=function(e,t,r){var i=0,n=0;i=(1&e)<<5|e>>>27;for(var a=23;a>=15;a-=4)i<<=6,i|=e>>>a&63;for(var a=11;a>=3;a-=4)n|=e>>>a&63,n<<=6;n|=(31&e)<<1|e>>>31,t[r+0]=i>>>0,t[r+1]=n>>>0};var n=[14,0,4,15,13,7,1,4,2,14,15,2,11,13,8,1,3,10,10,6,6,12,12,11,5,9,9,5,0,3,7,8,4,15,1,12,14,8,8,2,13,4,6,9,2,1,11,7,15,5,12,11,9,3,7,14,3,10,10,0,5,6,0,13,15,3,1,13,8,4,14,7,6,15,11,2,3,8,4,14,9,12,7,0,2,1,13,10,12,6,0,9,5,11,10,5,0,13,14,8,7,10,11,1,10,3,4,15,13,4,1,2,5,11,8,6,12,7,6,12,9,0,3,5,2,14,15,9,10,13,0,7,9,0,14,9,6,3,3,4,15,6,5,10,1,2,13,8,12,5,7,14,11,12,4,11,2,15,8,1,13,1,6,10,4,13,9,0,8,6,15,9,3,8,0,7,11,4,1,15,2,14,12,3,5,11,10,5,14,2,7,12,7,13,13,8,14,11,3,5,0,6,6,15,9,0,10,3,1,4,2,7,8,2,5,12,11,1,12,10,4,14,15,9,10,3,6,15,9,0,0,6,12,10,11,1,7,13,13,8,15,9,1,4,3,5,14,11,5,12,2,7,8,2,4,14,2,14,12,11,4,2,1,12,7,4,10,7,11,13,6,1,8,5,5,0,3,15,15,10,13,3,0,9,14,8,9,6,4,11,2,8,1,12,11,7,10,1,13,14,7,2,8,13,15,6,9,15,12,0,5,9,6,10,3,4,0,5,14,3,12,10,1,15,10,4,15,2,9,7,2,12,6,9,8,5,0,6,13,1,3,13,4,14,14,0,7,11,5,3,11,8,9,4,14,3,15,2,5,12,2,9,8,5,12,15,3,10,7,11,0,14,4,1,10,7,1,6,13,0,11,8,6,13,4,13,11,0,2,11,14,7,15,4,0,9,8,1,13,10,3,14,12,3,9,5,7,12,5,2,10,15,6,8,1,6,1,6,4,11,11,13,13,8,12,1,3,4,7,10,14,7,10,9,15,5,6,0,8,15,0,14,5,2,9,3,2,12,13,1,2,15,8,13,4,8,6,10,15,3,11,7,1,4,10,12,9,5,3,6,14,11,5,0,0,14,12,9,7,2,7,2,11,1,4,14,1,7,9,4,12,10,14,8,2,13,0,15,6,12,10,9,13,0,15,3,3,5,5,6,8,11];r.substitute=function(e,t){for(var r=0,i=0;4>i;i++){var a=e>>>18-6*i&63,o=n[64*i+a];r<<=4,r|=o}for(var i=0;4>i;i++){var a=t>>>18-6*i&63,o=n[256+64*i+a];r<<=4,r|=o}return r>>>0};var a=[16,25,12,11,3,20,4,15,31,17,9,6,27,14,1,22,30,24,8,18,0,5,29,23,13,19,2,26,10,21,28,7];r.permute=function(e){for(var t=0,r=0;r<a.length;r++)t<<=1,t|=e>>>a[r]&1;return t>>>0},r.padSplit=function(e,t,r){for(var i=e.toString(2);i.length<t;)i="0"+i;for(var n=[],a=0;t>a;a+=r)n.push(i.slice(a,a+r));return n.join(" ")}},{}],64:[function(e,t,r){(function(t){function i(e){var r=new t(o[e].prime,"hex"),i=new t(o[e].gen,"hex");return new s(r,i)}function n(e,r,i,o){return t.isBuffer(r)||void 0===f[r]?n(e,"binary",r,i):(r=r||"binary",o=o||"binary",i=i||new t([2]),t.isBuffer(i)||(i=new t(i,o)),"number"==typeof e?new s(a(e,i),i,!0):(t.isBuffer(e)||(e=new t(e,r)),new s(e,i,!0)))}var a=e("./lib/generatePrime"),o=e("./lib/primes.json"),s=e("./lib/dh"),f={binary:!0,hex:!0,base64:!0};r.DiffieHellmanGroup=r.createDiffieHellmanGroup=r.getDiffieHellman=i,r.createDiffieHellman=r.DiffieHellman=n}).call(this,e("buffer").Buffer)},{"./lib/dh":65,"./lib/generatePrime":66,"./lib/primes.json":67,buffer:49}],65:[function(e,t,r){(function(r){function i(e,t){return t=t||"utf8",r.isBuffer(e)||(e=new r(e,t)),this._pub=new f(e),this}function n(e,t){return t=t||"utf8",r.isBuffer(e)||(e=new r(e,t)),this._priv=new f(e),this}function a(e,t){var r=t.toString("hex"),i=[r,e.toString(16)].join("_");if(i in g)return g[i];var n=0;if(e.isEven()||!y.simpleSieve||!y.fermatTest(e)||!u.test(e))return n+=1,n+="02"===r||"05"===r?8:4,g[i]=n,n;u.test(e.shrn(1))||(n+=2);var a;switch(r){case"02":e.mod(h).cmp(d)&&(n+=8);break;case"05":a=e.mod(l),a.cmp(p)&&a.cmp(b)&&(n+=8);break;default:n+=4}return g[i]=n,n}function o(e,t,r){this.setGenerator(t),this.__prime=new f(e),this._prime=f.mont(this.__prime),this._primeLen=e.length,this._pub=void 0,this._priv=void 0,this._primeCode=void 0,r?(this.setPublicKey=i,this.setPrivateKey=n):this._primeCode=8}function s(e,t){var i=new r(e.toArray());return t?i.toString(t):i}var f=e("bn.js"),c=e("miller-rabin"),u=new c,h=new f(24),d=new f(11),l=new f(10),p=new f(3),b=new f(7),y=e("./generatePrime"),m=e("randombytes");t.exports=o;var g={};Object.defineProperty(o.prototype,"verifyError",{enumerable:!0,get:function(){return"number"!=typeof this._primeCode&&(this._primeCode=a(this.__prime,this.__gen)),this._primeCode}}),o.prototype.generateKeys=function(){return this._priv||(this._priv=new f(m(this._primeLen))),this._pub=this._gen.toRed(this._prime).redPow(this._priv).fromRed(),this.getPublicKey()},o.prototype.computeSecret=function(e){e=new f(e),e=e.toRed(this._prime);var t=e.redPow(this._priv).fromRed(),i=new r(t.toArray()),n=this.getPrime();if(i.length<n.length){var a=new r(n.length-i.length);a.fill(0),i=r.concat([a,i])}return i},o.prototype.getPublicKey=function(e){return s(this._pub,e)},o.prototype.getPrivateKey=function(e){return s(this._priv,e)},o.prototype.getPrime=function(e){return s(this.__prime,e)},o.prototype.getGenerator=function(e){return s(this._gen,e)},o.prototype.setGenerator=function(e,t){return t=t||"utf8",r.isBuffer(e)||(e=new r(e,t)),this.__gen=e,this._gen=new f(e),this}}).call(this,e("buffer").Buffer)},{"./generatePrime":66,"bn.js":17,buffer:49,"miller-rabin":128,randombytes:150}],66:[function(e,t,r){function i(){if(null!==v)return v;var e=1048576,t=[];t[0]=2;for(var r=1,i=3;e>i;i+=2){for(var n=Math.ceil(Math.sqrt(i)),a=0;r>a&&t[a]<=n&&i%t[a]!==0;a++);r!==a&&t[a]<=n||(t[r++]=i)}return v=t,t}function n(e){for(var t=i(),r=0;r<t.length;r++)if(0===e.modn(t[r]))return 0===e.cmpn(t[r])?!0:!1;return!0}function a(e){var t=f.mont(e);return 0===l.toRed(t).redPow(e.subn(1)).fromRed().cmpn(1)}function o(e,t){if(16>e)return new f(2===t||5===t?[140,123]:[140,39]);t=new f(t);for(var r,i;;){for(r=new f(s(Math.ceil(e/8)));r.bitLength()>e;)r.ishrn(1);if(r.isEven()&&r.iadd(d),r.testn(1)||r.iadd(l),t.cmp(l)){if(!t.cmp(p))for(;r.mod(b).cmp(y);)r.iadd(g)}else for(;r.mod(c).cmp(m);)r.iadd(g);if(i=r.shrn(1),n(i)&&n(r)&&a(i)&&a(r)&&h.test(i)&&h.test(r))return r}}var s=e("randombytes");t.exports=o,o.simpleSieve=n,o.fermatTest=a;var f=e("bn.js"),c=new f(24),u=e("miller-rabin"),h=new u,d=new f(1),l=new f(2),p=new f(5),b=(new f(16),new f(8),new f(10)),y=new f(3),m=(new f(7),new f(11)),g=new f(4),v=(new f(12),null)},{"bn.js":17,"miller-rabin":128,randombytes:150}],67:[function(e,t,r){t.exports={modp1:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},modp2:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},modp5:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},modp14:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},modp15:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},modp16:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},modp17:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},modp18:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}}},{}],68:[function(e,t,r){"use strict";function i(e){return e.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function n(e){if(f.isBuffer(e))return e;if("string"==typeof e)return f.from(e,"base64");throw new TypeError("ECDSA signature must be a Base64 string or a Buffer")}function a(e,t){e=n(e);var r=c(t),a=r+1,o=e.length,s=0;if(e[s++]!==b)throw new Error('Could not find expected "seq"');var h=e[s++];if(h===(1|u)&&(h=e[s++]),h>o-s)throw new Error('"seq" specified length of "'+h+'", only "'+(o-s)+'" remaining');if(e[s++]!==y)throw new Error('Could not find expected "int" for "r"');var d=e[s++];if(d>o-s-2)throw new Error('"r" specified length of "'+d+'", only "'+(o-s-2)+'" available');if(d>a)throw new Error('"r" specified length of "'+d+'", max of "'+a+'" is acceptable');var l=s;if(s+=d,e[s++]!==y)throw new Error('Could not find expected "int" for "s"');var p=e[s++];if(o-s!==p)throw new Error('"s" specified length of "'+p+'", expected "'+(o-s)+'"');if(p>a)throw new Error('"s" specified length of "'+p+'", max of "'+a+'" is acceptable');var m=s;if(s+=p,s!==o)throw new Error('Expected to consume entire buffer, but "'+(o-s)+'" bytes remain');var g=r-d,v=r-p,w=f.allocUnsafe(g+d+v+p);for(s=0;g>s;++s)w[s]=0;e.copy(w,s,l+Math.max(-g,0),l+d),s=r;for(var _=s;_+v>s;++s)w[s]=0;return e.copy(w,s,m+Math.max(-v,0),m+p),w=w.toString("base64"),w=i(w)}function o(e,t,r){for(var i=0;r>t+i&&0===e[t+i];)++i;var n=e[t+i]>=u;return n&&--i,i}function s(e,t){e=n(e);var r=c(t),i=e.length;if(i!==2*r)throw new TypeError('"'+t+'" signatures must be "'+2*r+'" bytes, saw "'+i+'"');var a=o(e,0,r),s=o(e,r,e.length),h=r-a,d=r-s,l=2+h+1+1+d,p=u>l,m=f.allocUnsafe((p?2:3)+l),g=0;return m[g++]=b,p?m[g++]=l:(m[g++]=1|u,m[g++]=255&l),m[g++]=y,m[g++]=h,0>a?(m[g++]=0,g+=e.copy(m,g,0,r)):g+=e.copy(m,g,a,r),m[g++]=y,m[g++]=d,0>s?(m[g++]=0,e.copy(m,g,r)):e.copy(m,g,r+s),m}var f=e("safe-buffer").Buffer,c=e("./param-bytes-for-alg"),u=128,h=0,d=32,l=16,p=2,b=l|d|h<<6,y=p|h<<6;t.exports={derToJose:a,joseToDer:s}},{"./param-bytes-for-alg":69,"safe-buffer":167}],69:[function(e,t,r){"use strict";function i(e){var t=(e/8|0)+(e%8===0?0:1);return t}function n(e){var t=a[e];if(t)return t;throw new Error('Unknown algorithm "'+e+'"')}var a={ES256:i(256),ES384:i(384),ES512:i(521)};t.exports=n},{}],70:[function(e,t,r){"use strict";var i=r;i.version=e("../package.json").version,i.utils=e("./elliptic/utils"),i.rand=e("brorand"),i.curve=e("./elliptic/curve"),i.curves=e("./elliptic/curves"),i.ec=e("./elliptic/ec"),i.eddsa=e("./elliptic/eddsa")},{"../package.json":85,"./elliptic/curve":73,"./elliptic/curves":76,"./elliptic/ec":77,"./elliptic/eddsa":80,"./elliptic/utils":84,brorand:18}],71:[function(e,t,r){"use strict";function i(e,t){this.type=e,this.p=new a(t.p,16),this.red=t.prime?a.red(t.prime):a.mont(this.p),this.zero=new a(0).toRed(this.red),this.one=new a(1).toRed(this.red),this.two=new a(2).toRed(this.red),this.n=t.n&&new a(t.n,16),this.g=t.g&&this.pointFromJSON(t.g,t.gRed),this._wnafT1=new Array(4),this._wnafT2=new Array(4),this._wnafT3=new Array(4),this._wnafT4=new Array(4);var r=this.n&&this.p.div(this.n);!r||r.cmpn(100)>0?this.redN=null:(this._maxwellTrick=!0,this.redN=this.n.toRed(this.red))}function n(e,t){this.curve=e,this.type=t,this.precomputed=null}var a=e("bn.js"),o=e("../../elliptic"),s=o.utils,f=s.getNAF,c=s.getJSF,u=s.assert;t.exports=i,i.prototype.point=function(){throw new Error("Not implemented")},i.prototype.validate=function(){throw new Error("Not implemented")},i.prototype._fixedNafMul=function(e,t){u(e.precomputed);var r=e._getDoubles(),i=f(t,1),n=(1<<r.step+1)-(r.step%2===0?2:1);n/=3;for(var a=[],o=0;o<i.length;o+=r.step){for(var s=0,t=o+r.step-1;t>=o;t--)s=(s<<1)+i[t];a.push(s)}for(var c=this.jpoint(null,null,null),h=this.jpoint(null,null,null),d=n;d>0;d--){for(var o=0;o<a.length;o++){var s=a[o];s===d?h=h.mixedAdd(r.points[o]):s===-d&&(h=h.mixedAdd(r.points[o].neg()))}c=c.add(h)}return c.toP()},i.prototype._wnafMul=function(e,t){var r=4,i=e._getNAFPoints(r);r=i.wnd;for(var n=i.points,a=f(t,r),o=this.jpoint(null,null,null),s=a.length-1;s>=0;s--){for(var t=0;s>=0&&0===a[s];s--)t++;if(s>=0&&t++,o=o.dblp(t),0>s)break;var c=a[s];u(0!==c),o="affine"===e.type?c>0?o.mixedAdd(n[c-1>>1]):o.mixedAdd(n[-c-1>>1].neg()):c>0?o.add(n[c-1>>1]):o.add(n[-c-1>>1].neg())}return"affine"===e.type?o.toP():o},i.prototype._wnafMulAdd=function(e,t,r,i,n){for(var a=this._wnafT1,o=this._wnafT2,s=this._wnafT3,u=0,h=0;i>h;h++){var d=t[h],l=d._getNAFPoints(e);a[h]=l.wnd,o[h]=l.points}for(var h=i-1;h>=1;h-=2){var p=h-1,b=h;if(1===a[p]&&1===a[b]){var y=[t[p],null,null,t[b]];0===t[p].y.cmp(t[b].y)?(y[1]=t[p].add(t[b]),y[2]=t[p].toJ().mixedAdd(t[b].neg())):0===t[p].y.cmp(t[b].y.redNeg())?(y[1]=t[p].toJ().mixedAdd(t[b]),y[2]=t[p].add(t[b].neg())):(y[1]=t[p].toJ().mixedAdd(t[b]),y[2]=t[p].toJ().mixedAdd(t[b].neg()));var m=[-3,-1,-5,-7,0,7,5,1,3],g=c(r[p],r[b]);u=Math.max(g[0].length,u),s[p]=new Array(u),s[b]=new Array(u);for(var v=0;u>v;v++){var w=0|g[0][v],_=0|g[1][v];s[p][v]=m[3*(w+1)+(_+1)],s[b][v]=0,o[p]=y}}else s[p]=f(r[p],a[p]),s[b]=f(r[b],a[b]),u=Math.max(s[p].length,u),u=Math.max(s[b].length,u)}for(var S=this.jpoint(null,null,null),M=this._wnafT4,h=u;h>=0;h--){for(var E=0;h>=0;){for(var k=!0,v=0;i>v;v++)M[v]=0|s[v][h],0!==M[v]&&(k=!1);if(!k)break;E++,h--}if(h>=0&&E++,S=S.dblp(E),0>h)break;for(var v=0;i>v;v++){var d,x=M[v];0!==x&&(x>0?d=o[v][x-1>>1]:0>x&&(d=o[v][-x-1>>1].neg()),S="affine"===d.type?S.mixedAdd(d):S.add(d))}}for(var h=0;i>h;h++)o[h]=null;return n?S:S.toP()},i.BasePoint=n,n.prototype.eq=function(){throw new Error("Not implemented")},n.prototype.validate=function(){return this.curve.validate(this)},i.prototype.decodePoint=function(e,t){e=s.toArray(e,t);var r=this.p.byteLength();if((4===e[0]||6===e[0]||7===e[0])&&e.length-1===2*r){6===e[0]?u(e[e.length-1]%2===0):7===e[0]&&u(e[e.length-1]%2===1);var i=this.point(e.slice(1,1+r),e.slice(1+r,1+2*r));return i}if((2===e[0]||3===e[0])&&e.length-1===r)return this.pointFromX(e.slice(1,1+r),3===e[0]);throw new Error("Unknown point format")},n.prototype.encodeCompressed=function(e){return this.encode(e,!0)},n.prototype._encode=function(e){var t=this.curve.p.byteLength(),r=this.getX().toArray("be",t);return e?[this.getY().isEven()?2:3].concat(r):[4].concat(r,this.getY().toArray("be",t))},n.prototype.encode=function(e,t){return s.encode(this._encode(t),e)},n.prototype.precompute=function(e){if(this.precomputed)return this;var t={doubles:null,naf:null,beta:null};return t.naf=this._getNAFPoints(8),t.doubles=this._getDoubles(4,e),t.beta=this._getBeta(),this.precomputed=t,this},n.prototype._hasDoubles=function(e){if(!this.precomputed)return!1;var t=this.precomputed.doubles;return t?t.points.length>=Math.ceil((e.bitLength()+1)/t.step):!1},n.prototype._getDoubles=function(e,t){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;for(var r=[this],i=this,n=0;t>n;n+=e){for(var a=0;e>a;a++)i=i.dbl();r.push(i)}return{step:e,points:r}},n.prototype._getNAFPoints=function(e){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;for(var t=[this],r=(1<<e)-1,i=1===r?null:this.dbl(),n=1;r>n;n++)t[n]=t[n-1].add(i);return{wnd:e,points:t}},n.prototype._getBeta=function(){return null},n.prototype.dblp=function(e){for(var t=this,r=0;e>r;r++)t=t.dbl();return t}},{"../../elliptic":70,"bn.js":17}],72:[function(e,t,r){"use strict";function i(e){this.twisted=1!==(0|e.a),this.mOneA=this.twisted&&-1===(0|e.a),this.extended=this.mOneA,c.call(this,"edwards",e),this.a=new s(e.a,16).umod(this.red.m),this.a=this.a.toRed(this.red),this.c=new s(e.c,16).toRed(this.red),this.c2=this.c.redSqr(),this.d=new s(e.d,16).toRed(this.red),this.dd=this.d.redAdd(this.d),u(!this.twisted||0===this.c.fromRed().cmpn(1)),this.oneC=1===(0|e.c)}function n(e,t,r,i,n){c.BasePoint.call(this,e,"projective"),null===t&&null===r&&null===i?(this.x=this.curve.zero,this.y=this.curve.one,this.z=this.curve.one,this.t=this.curve.zero,this.zOne=!0):(this.x=new s(t,16),this.y=new s(r,16),this.z=i?new s(i,16):this.curve.one,this.t=n&&new s(n,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.t&&!this.t.red&&(this.t=this.t.toRed(this.curve.red)),this.zOne=this.z===this.curve.one,this.curve.extended&&!this.t&&(this.t=this.x.redMul(this.y),this.zOne||(this.t=this.t.redMul(this.z.redInvm()))))}var a=e("../curve"),o=e("../../elliptic"),s=e("bn.js"),f=e("inherits"),c=a.base,u=o.utils.assert;f(i,c),t.exports=i,i.prototype._mulA=function(e){return this.mOneA?e.redNeg():this.a.redMul(e)},i.prototype._mulC=function(e){return this.oneC?e:this.c.redMul(e)},i.prototype.jpoint=function(e,t,r,i){return this.point(e,t,r,i)},i.prototype.pointFromX=function(e,t){e=new s(e,16),e.red||(e=e.toRed(this.red));var r=e.redSqr(),i=this.c2.redSub(this.a.redMul(r)),n=this.one.redSub(this.c2.redMul(this.d).redMul(r)),a=i.redMul(n.redInvm()),o=a.redSqrt();if(0!==o.redSqr().redSub(a).cmp(this.zero))throw new Error("invalid point");var f=o.fromRed().isOdd();return(t&&!f||!t&&f)&&(o=o.redNeg()),this.point(e,o)},i.prototype.pointFromY=function(e,t){e=new s(e,16),e.red||(e=e.toRed(this.red));var r=e.redSqr(),i=r.redSub(this.c2),n=r.redMul(this.d).redMul(this.c2).redSub(this.a),a=i.redMul(n.redInvm());if(0===a.cmp(this.zero)){if(t)throw new Error("invalid point");return this.point(this.zero,e)}var o=a.redSqrt();if(0!==o.redSqr().redSub(a).cmp(this.zero))throw new Error("invalid point");return o.fromRed().isOdd()!==t&&(o=o.redNeg()),this.point(o,e)},i.prototype.validate=function(e){if(e.isInfinity())return!0;e.normalize();var t=e.x.redSqr(),r=e.y.redSqr(),i=t.redMul(this.a).redAdd(r),n=this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(r)));return 0===i.cmp(n)},f(n,c.BasePoint),i.prototype.pointFromJSON=function(e){return n.fromJSON(this,e)},i.prototype.point=function(e,t,r,i){return new n(this,e,t,r,i)},n.fromJSON=function(e,t){return new n(e,t[0],t[1],t[2])},n.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},n.prototype.isInfinity=function(){return 0===this.x.cmpn(0)&&(0===this.y.cmp(this.z)||this.zOne&&0===this.y.cmp(this.curve.c))},n.prototype._extDbl=function(){var e=this.x.redSqr(),t=this.y.redSqr(),r=this.z.redSqr();r=r.redIAdd(r);var i=this.curve._mulA(e),n=this.x.redAdd(this.y).redSqr().redISub(e).redISub(t),a=i.redAdd(t),o=a.redSub(r),s=i.redSub(t),f=n.redMul(o),c=a.redMul(s),u=n.redMul(s),h=o.redMul(a);return this.curve.point(f,c,h,u)},n.prototype._projDbl=function(){var e,t,r,i=this.x.redAdd(this.y).redSqr(),n=this.x.redSqr(),a=this.y.redSqr();if(this.curve.twisted){var o=this.curve._mulA(n),s=o.redAdd(a);if(this.zOne)e=i.redSub(n).redSub(a).redMul(s.redSub(this.curve.two)),t=s.redMul(o.redSub(a)),r=s.redSqr().redSub(s).redSub(s);else{var f=this.z.redSqr(),c=s.redSub(f).redISub(f);e=i.redSub(n).redISub(a).redMul(c),t=s.redMul(o.redSub(a)),r=s.redMul(c)}}else{var o=n.redAdd(a),f=this.curve._mulC(this.z).redSqr(),c=o.redSub(f).redSub(f);e=this.curve._mulC(i.redISub(o)).redMul(c),t=this.curve._mulC(o).redMul(n.redISub(a)),r=o.redMul(c)}return this.curve.point(e,t,r)},n.prototype.dbl=function(){return this.isInfinity()?this:this.curve.extended?this._extDbl():this._projDbl()},n.prototype._extAdd=function(e){var t=this.y.redSub(this.x).redMul(e.y.redSub(e.x)),r=this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),i=this.t.redMul(this.curve.dd).redMul(e.t),n=this.z.redMul(e.z.redAdd(e.z)),a=r.redSub(t),o=n.redSub(i),s=n.redAdd(i),f=r.redAdd(t),c=a.redMul(o),u=s.redMul(f),h=a.redMul(f),d=o.redMul(s);return this.curve.point(c,u,d,h)},n.prototype._projAdd=function(e){var t,r,i=this.z.redMul(e.z),n=i.redSqr(),a=this.x.redMul(e.x),o=this.y.redMul(e.y),s=this.curve.d.redMul(a).redMul(o),f=n.redSub(s),c=n.redAdd(s),u=this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(a).redISub(o),h=i.redMul(f).redMul(u);return this.curve.twisted?(t=i.redMul(c).redMul(o.redSub(this.curve._mulA(a))),r=f.redMul(c)):(t=i.redMul(c).redMul(o.redSub(a)),r=this.curve._mulC(f).redMul(c)),this.curve.point(h,t,r)},n.prototype.add=function(e){return this.isInfinity()?e:e.isInfinity()?this:this.curve.extended?this._extAdd(e):this._projAdd(e)},n.prototype.mul=function(e){return this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve._wnafMul(this,e)},n.prototype.mulAdd=function(e,t,r){return this.curve._wnafMulAdd(1,[this,t],[e,r],2,!1)},n.prototype.jmulAdd=function(e,t,r){return this.curve._wnafMulAdd(1,[this,t],[e,r],2,!0)},n.prototype.normalize=function(){if(this.zOne)return this;var e=this.z.redInvm();return this.x=this.x.redMul(e),this.y=this.y.redMul(e),this.t&&(this.t=this.t.redMul(e)),this.z=this.curve.one,this.zOne=!0,this},n.prototype.neg=function(){return this.curve.point(this.x.redNeg(),this.y,this.z,this.t&&this.t.redNeg())},n.prototype.getX=function(){return this.normalize(),this.x.fromRed()},n.prototype.getY=function(){return this.normalize(),this.y.fromRed()},n.prototype.eq=function(e){return this===e||0===this.getX().cmp(e.getX())&&0===this.getY().cmp(e.getY())},n.prototype.eqXToP=function(e){var t=e.toRed(this.curve.red).redMul(this.z);if(0===this.x.cmp(t))return!0;for(var r=e.clone(),i=this.curve.redN.redMul(this.z);;){if(r.iadd(this.curve.n),r.cmp(this.curve.p)>=0)return!1;if(t.redIAdd(i),0===this.x.cmp(t))return!0}},n.prototype.toP=n.prototype.normalize,
n.prototype.mixedAdd=n.prototype.add},{"../../elliptic":70,"../curve":73,"bn.js":17,inherits:103}],73:[function(e,t,r){"use strict";var i=r;i.base=e("./base"),i["short"]=e("./short"),i.mont=e("./mont"),i.edwards=e("./edwards")},{"./base":71,"./edwards":72,"./mont":74,"./short":75}],74:[function(e,t,r){"use strict";function i(e){f.call(this,"mont",e),this.a=new o(e.a,16).toRed(this.red),this.b=new o(e.b,16).toRed(this.red),this.i4=new o(4).toRed(this.red).redInvm(),this.two=new o(2).toRed(this.red),this.a24=this.i4.redMul(this.a.redAdd(this.two))}function n(e,t,r){f.BasePoint.call(this,e,"projective"),null===t&&null===r?(this.x=this.curve.one,this.z=this.curve.zero):(this.x=new o(t,16),this.z=new o(r,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)))}var a=e("../curve"),o=e("bn.js"),s=e("inherits"),f=a.base,c=e("../../elliptic"),u=c.utils;s(i,f),t.exports=i,i.prototype.validate=function(e){var t=e.normalize().x,r=t.redSqr(),i=r.redMul(t).redAdd(r.redMul(this.a)).redAdd(t),n=i.redSqrt();return 0===n.redSqr().cmp(i)},s(n,f.BasePoint),i.prototype.decodePoint=function(e,t){return this.point(u.toArray(e,t),1)},i.prototype.point=function(e,t){return new n(this,e,t)},i.prototype.pointFromJSON=function(e){return n.fromJSON(this,e)},n.prototype.precompute=function(){},n.prototype._encode=function(){return this.getX().toArray("be",this.curve.p.byteLength())},n.fromJSON=function(e,t){return new n(e,t[0],t[1]||e.one)},n.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},n.prototype.isInfinity=function(){return 0===this.z.cmpn(0)},n.prototype.dbl=function(){var e=this.x.redAdd(this.z),t=e.redSqr(),r=this.x.redSub(this.z),i=r.redSqr(),n=t.redSub(i),a=t.redMul(i),o=n.redMul(i.redAdd(this.curve.a24.redMul(n)));return this.curve.point(a,o)},n.prototype.add=function(){throw new Error("Not supported on Montgomery curve")},n.prototype.diffAdd=function(e,t){var r=this.x.redAdd(this.z),i=this.x.redSub(this.z),n=e.x.redAdd(e.z),a=e.x.redSub(e.z),o=a.redMul(r),s=n.redMul(i),f=t.z.redMul(o.redAdd(s).redSqr()),c=t.x.redMul(o.redISub(s).redSqr());return this.curve.point(f,c)},n.prototype.mul=function(e){for(var t=e.clone(),r=this,i=this.curve.point(null,null),n=this,a=[];0!==t.cmpn(0);t.iushrn(1))a.push(t.andln(1));for(var o=a.length-1;o>=0;o--)0===a[o]?(r=r.diffAdd(i,n),i=i.dbl()):(i=r.diffAdd(i,n),r=r.dbl());return i},n.prototype.mulAdd=function(){throw new Error("Not supported on Montgomery curve")},n.prototype.jumlAdd=function(){throw new Error("Not supported on Montgomery curve")},n.prototype.eq=function(e){return 0===this.getX().cmp(e.getX())},n.prototype.normalize=function(){return this.x=this.x.redMul(this.z.redInvm()),this.z=this.curve.one,this},n.prototype.getX=function(){return this.normalize(),this.x.fromRed()}},{"../../elliptic":70,"../curve":73,"bn.js":17,inherits:103}],75:[function(e,t,r){"use strict";function i(e){u.call(this,"short",e),this.a=new f(e.a,16).toRed(this.red),this.b=new f(e.b,16).toRed(this.red),this.tinv=this.two.redInvm(),this.zeroA=0===this.a.fromRed().cmpn(0),this.threeA=0===this.a.fromRed().sub(this.p).cmpn(-3),this.endo=this._getEndomorphism(e),this._endoWnafT1=new Array(4),this._endoWnafT2=new Array(4)}function n(e,t,r,i){u.BasePoint.call(this,e,"affine"),null===t&&null===r?(this.x=null,this.y=null,this.inf=!0):(this.x=new f(t,16),this.y=new f(r,16),i&&(this.x.forceRed(this.curve.red),this.y.forceRed(this.curve.red)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.inf=!1)}function a(e,t,r,i){u.BasePoint.call(this,e,"jacobian"),null===t&&null===r&&null===i?(this.x=this.curve.one,this.y=this.curve.one,this.z=new f(0)):(this.x=new f(t,16),this.y=new f(r,16),this.z=new f(i,16)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.zOne=this.z===this.curve.one}var o=e("../curve"),s=e("../../elliptic"),f=e("bn.js"),c=e("inherits"),u=o.base,h=s.utils.assert;c(i,u),t.exports=i,i.prototype._getEndomorphism=function(e){if(this.zeroA&&this.g&&this.n&&1===this.p.modn(3)){var t,r;if(e.beta)t=new f(e.beta,16).toRed(this.red);else{var i=this._getEndoRoots(this.p);t=i[0].cmp(i[1])<0?i[0]:i[1],t=t.toRed(this.red)}if(e.lambda)r=new f(e.lambda,16);else{var n=this._getEndoRoots(this.n);0===this.g.mul(n[0]).x.cmp(this.g.x.redMul(t))?r=n[0]:(r=n[1],h(0===this.g.mul(r).x.cmp(this.g.x.redMul(t))))}var a;return a=e.basis?e.basis.map(function(e){return{a:new f(e.a,16),b:new f(e.b,16)}}):this._getEndoBasis(r),{beta:t,lambda:r,basis:a}}},i.prototype._getEndoRoots=function(e){var t=e===this.p?this.red:f.mont(e),r=new f(2).toRed(t).redInvm(),i=r.redNeg(),n=new f(3).toRed(t).redNeg().redSqrt().redMul(r),a=i.redAdd(n).fromRed(),o=i.redSub(n).fromRed();return[a,o]},i.prototype._getEndoBasis=function(e){for(var t,r,i,n,a,o,s,c,u,h=this.n.ushrn(Math.floor(this.n.bitLength()/2)),d=e,l=this.n.clone(),p=new f(1),b=new f(0),y=new f(0),m=new f(1),g=0;0!==d.cmpn(0);){var v=l.div(d);c=l.sub(v.mul(d)),u=y.sub(v.mul(p));var w=m.sub(v.mul(b));if(!i&&c.cmp(h)<0)t=s.neg(),r=p,i=c.neg(),n=u;else if(i&&2===++g)break;s=c,l=d,d=c,y=p,p=u,m=b,b=w}a=c.neg(),o=u;var _=i.sqr().add(n.sqr()),S=a.sqr().add(o.sqr());return S.cmp(_)>=0&&(a=t,o=r),i.negative&&(i=i.neg(),n=n.neg()),a.negative&&(a=a.neg(),o=o.neg()),[{a:i,b:n},{a:a,b:o}]},i.prototype._endoSplit=function(e){var t=this.endo.basis,r=t[0],i=t[1],n=i.b.mul(e).divRound(this.n),a=r.b.neg().mul(e).divRound(this.n),o=n.mul(r.a),s=a.mul(i.a),f=n.mul(r.b),c=a.mul(i.b),u=e.sub(o).sub(s),h=f.add(c).neg();return{k1:u,k2:h}},i.prototype.pointFromX=function(e,t){e=new f(e,16),e.red||(e=e.toRed(this.red));var r=e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),i=r.redSqrt();if(0!==i.redSqr().redSub(r).cmp(this.zero))throw new Error("invalid point");var n=i.fromRed().isOdd();return(t&&!n||!t&&n)&&(i=i.redNeg()),this.point(e,i)},i.prototype.validate=function(e){if(e.inf)return!0;var t=e.x,r=e.y,i=this.a.redMul(t),n=t.redSqr().redMul(t).redIAdd(i).redIAdd(this.b);return 0===r.redSqr().redISub(n).cmpn(0)},i.prototype._endoWnafMulAdd=function(e,t,r){for(var i=this._endoWnafT1,n=this._endoWnafT2,a=0;a<e.length;a++){var o=this._endoSplit(t[a]),s=e[a],f=s._getBeta();o.k1.negative&&(o.k1.ineg(),s=s.neg(!0)),o.k2.negative&&(o.k2.ineg(),f=f.neg(!0)),i[2*a]=s,i[2*a+1]=f,n[2*a]=o.k1,n[2*a+1]=o.k2}for(var c=this._wnafMulAdd(1,i,n,2*a,r),u=0;2*a>u;u++)i[u]=null,n[u]=null;return c},c(n,u.BasePoint),i.prototype.point=function(e,t,r){return new n(this,e,t,r)},i.prototype.pointFromJSON=function(e,t){return n.fromJSON(this,e,t)},n.prototype._getBeta=function(){if(this.curve.endo){var e=this.precomputed;if(e&&e.beta)return e.beta;var t=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);if(e){var r=this.curve,i=function(e){return r.point(e.x.redMul(r.endo.beta),e.y)};e.beta=t,t.precomputed={beta:null,naf:e.naf&&{wnd:e.naf.wnd,points:e.naf.points.map(i)},doubles:e.doubles&&{step:e.doubles.step,points:e.doubles.points.map(i)}}}return t}},n.prototype.toJSON=function(){return this.precomputed?[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}]:[this.x,this.y]},n.fromJSON=function(e,t,r){function i(t){return e.point(t[0],t[1],r)}"string"==typeof t&&(t=JSON.parse(t));var n=e.point(t[0],t[1],r);if(!t[2])return n;var a=t[2];return n.precomputed={beta:null,doubles:a.doubles&&{step:a.doubles.step,points:[n].concat(a.doubles.points.map(i))},naf:a.naf&&{wnd:a.naf.wnd,points:[n].concat(a.naf.points.map(i))}},n},n.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+">"},n.prototype.isInfinity=function(){return this.inf},n.prototype.add=function(e){if(this.inf)return e;if(e.inf)return this;if(this.eq(e))return this.dbl();if(this.neg().eq(e))return this.curve.point(null,null);if(0===this.x.cmp(e.x))return this.curve.point(null,null);var t=this.y.redSub(e.y);0!==t.cmpn(0)&&(t=t.redMul(this.x.redSub(e.x).redInvm()));var r=t.redSqr().redISub(this.x).redISub(e.x),i=t.redMul(this.x.redSub(r)).redISub(this.y);return this.curve.point(r,i)},n.prototype.dbl=function(){if(this.inf)return this;var e=this.y.redAdd(this.y);if(0===e.cmpn(0))return this.curve.point(null,null);var t=this.curve.a,r=this.x.redSqr(),i=e.redInvm(),n=r.redAdd(r).redIAdd(r).redIAdd(t).redMul(i),a=n.redSqr().redISub(this.x.redAdd(this.x)),o=n.redMul(this.x.redSub(a)).redISub(this.y);return this.curve.point(a,o)},n.prototype.getX=function(){return this.x.fromRed()},n.prototype.getY=function(){return this.y.fromRed()},n.prototype.mul=function(e){return e=new f(e,16),this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve.endo?this.curve._endoWnafMulAdd([this],[e]):this.curve._wnafMul(this,e)},n.prototype.mulAdd=function(e,t,r){var i=[this,t],n=[e,r];return this.curve.endo?this.curve._endoWnafMulAdd(i,n):this.curve._wnafMulAdd(1,i,n,2)},n.prototype.jmulAdd=function(e,t,r){var i=[this,t],n=[e,r];return this.curve.endo?this.curve._endoWnafMulAdd(i,n,!0):this.curve._wnafMulAdd(1,i,n,2,!0)},n.prototype.eq=function(e){return this===e||this.inf===e.inf&&(this.inf||0===this.x.cmp(e.x)&&0===this.y.cmp(e.y))},n.prototype.neg=function(e){if(this.inf)return this;var t=this.curve.point(this.x,this.y.redNeg());if(e&&this.precomputed){var r=this.precomputed,i=function(e){return e.neg()};t.precomputed={naf:r.naf&&{wnd:r.naf.wnd,points:r.naf.points.map(i)},doubles:r.doubles&&{step:r.doubles.step,points:r.doubles.points.map(i)}}}return t},n.prototype.toJ=function(){if(this.inf)return this.curve.jpoint(null,null,null);var e=this.curve.jpoint(this.x,this.y,this.curve.one);return e},c(a,u.BasePoint),i.prototype.jpoint=function(e,t,r){return new a(this,e,t,r)},a.prototype.toP=function(){if(this.isInfinity())return this.curve.point(null,null);var e=this.z.redInvm(),t=e.redSqr(),r=this.x.redMul(t),i=this.y.redMul(t).redMul(e);return this.curve.point(r,i)},a.prototype.neg=function(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)},a.prototype.add=function(e){if(this.isInfinity())return e;if(e.isInfinity())return this;var t=e.z.redSqr(),r=this.z.redSqr(),i=this.x.redMul(t),n=e.x.redMul(r),a=this.y.redMul(t.redMul(e.z)),o=e.y.redMul(r.redMul(this.z)),s=i.redSub(n),f=a.redSub(o);if(0===s.cmpn(0))return 0!==f.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();var c=s.redSqr(),u=c.redMul(s),h=i.redMul(c),d=f.redSqr().redIAdd(u).redISub(h).redISub(h),l=f.redMul(h.redISub(d)).redISub(a.redMul(u)),p=this.z.redMul(e.z).redMul(s);return this.curve.jpoint(d,l,p)},a.prototype.mixedAdd=function(e){if(this.isInfinity())return e.toJ();if(e.isInfinity())return this;var t=this.z.redSqr(),r=this.x,i=e.x.redMul(t),n=this.y,a=e.y.redMul(t).redMul(this.z),o=r.redSub(i),s=n.redSub(a);if(0===o.cmpn(0))return 0!==s.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();var f=o.redSqr(),c=f.redMul(o),u=r.redMul(f),h=s.redSqr().redIAdd(c).redISub(u).redISub(u),d=s.redMul(u.redISub(h)).redISub(n.redMul(c)),l=this.z.redMul(o);return this.curve.jpoint(h,d,l)},a.prototype.dblp=function(e){if(0===e)return this;if(this.isInfinity())return this;if(!e)return this.dbl();if(this.curve.zeroA||this.curve.threeA){for(var t=this,r=0;e>r;r++)t=t.dbl();return t}for(var i=this.curve.a,n=this.curve.tinv,a=this.x,o=this.y,s=this.z,f=s.redSqr().redSqr(),c=o.redAdd(o),r=0;e>r;r++){var u=a.redSqr(),h=c.redSqr(),d=h.redSqr(),l=u.redAdd(u).redIAdd(u).redIAdd(i.redMul(f)),p=a.redMul(h),b=l.redSqr().redISub(p.redAdd(p)),y=p.redISub(b),m=l.redMul(y);m=m.redIAdd(m).redISub(d);var g=c.redMul(s);e>r+1&&(f=f.redMul(d)),a=b,s=g,c=m}return this.curve.jpoint(a,c.redMul(n),s)},a.prototype.dbl=function(){return this.isInfinity()?this:this.curve.zeroA?this._zeroDbl():this.curve.threeA?this._threeDbl():this._dbl()},a.prototype._zeroDbl=function(){var e,t,r;if(this.zOne){var i=this.x.redSqr(),n=this.y.redSqr(),a=n.redSqr(),o=this.x.redAdd(n).redSqr().redISub(i).redISub(a);o=o.redIAdd(o);var s=i.redAdd(i).redIAdd(i),f=s.redSqr().redISub(o).redISub(o),c=a.redIAdd(a);c=c.redIAdd(c),c=c.redIAdd(c),e=f,t=s.redMul(o.redISub(f)).redISub(c),r=this.y.redAdd(this.y)}else{var u=this.x.redSqr(),h=this.y.redSqr(),d=h.redSqr(),l=this.x.redAdd(h).redSqr().redISub(u).redISub(d);l=l.redIAdd(l);var p=u.redAdd(u).redIAdd(u),b=p.redSqr(),y=d.redIAdd(d);y=y.redIAdd(y),y=y.redIAdd(y),e=b.redISub(l).redISub(l),t=p.redMul(l.redISub(e)).redISub(y),r=this.y.redMul(this.z),r=r.redIAdd(r)}return this.curve.jpoint(e,t,r)},a.prototype._threeDbl=function(){var e,t,r;if(this.zOne){var i=this.x.redSqr(),n=this.y.redSqr(),a=n.redSqr(),o=this.x.redAdd(n).redSqr().redISub(i).redISub(a);o=o.redIAdd(o);var s=i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),f=s.redSqr().redISub(o).redISub(o);e=f;var c=a.redIAdd(a);c=c.redIAdd(c),c=c.redIAdd(c),t=s.redMul(o.redISub(f)).redISub(c),r=this.y.redAdd(this.y)}else{var u=this.z.redSqr(),h=this.y.redSqr(),d=this.x.redMul(h),l=this.x.redSub(u).redMul(this.x.redAdd(u));l=l.redAdd(l).redIAdd(l);var p=d.redIAdd(d);p=p.redIAdd(p);var b=p.redAdd(p);e=l.redSqr().redISub(b),r=this.y.redAdd(this.z).redSqr().redISub(h).redISub(u);var y=h.redSqr();y=y.redIAdd(y),y=y.redIAdd(y),y=y.redIAdd(y),t=l.redMul(p.redISub(e)).redISub(y)}return this.curve.jpoint(e,t,r)},a.prototype._dbl=function(){var e=this.curve.a,t=this.x,r=this.y,i=this.z,n=i.redSqr().redSqr(),a=t.redSqr(),o=r.redSqr(),s=a.redAdd(a).redIAdd(a).redIAdd(e.redMul(n)),f=t.redAdd(t);f=f.redIAdd(f);var c=f.redMul(o),u=s.redSqr().redISub(c.redAdd(c)),h=c.redISub(u),d=o.redSqr();d=d.redIAdd(d),d=d.redIAdd(d),d=d.redIAdd(d);var l=s.redMul(h).redISub(d),p=r.redAdd(r).redMul(i);return this.curve.jpoint(u,l,p)},a.prototype.trpl=function(){if(!this.curve.zeroA)return this.dbl().add(this);var e=this.x.redSqr(),t=this.y.redSqr(),r=this.z.redSqr(),i=t.redSqr(),n=e.redAdd(e).redIAdd(e),a=n.redSqr(),o=this.x.redAdd(t).redSqr().redISub(e).redISub(i);o=o.redIAdd(o),o=o.redAdd(o).redIAdd(o),o=o.redISub(a);var s=o.redSqr(),f=i.redIAdd(i);f=f.redIAdd(f),f=f.redIAdd(f),f=f.redIAdd(f);var c=n.redIAdd(o).redSqr().redISub(a).redISub(s).redISub(f),u=t.redMul(c);u=u.redIAdd(u),u=u.redIAdd(u);var h=this.x.redMul(s).redISub(u);h=h.redIAdd(h),h=h.redIAdd(h);var d=this.y.redMul(c.redMul(f.redISub(c)).redISub(o.redMul(s)));d=d.redIAdd(d),d=d.redIAdd(d),d=d.redIAdd(d);var l=this.z.redAdd(o).redSqr().redISub(r).redISub(s);return this.curve.jpoint(h,d,l)},a.prototype.mul=function(e,t){return e=new f(e,t),this.curve._wnafMul(this,e)},a.prototype.eq=function(e){if("affine"===e.type)return this.eq(e.toJ());if(this===e)return!0;var t=this.z.redSqr(),r=e.z.redSqr();if(0!==this.x.redMul(r).redISub(e.x.redMul(t)).cmpn(0))return!1;var i=t.redMul(this.z),n=r.redMul(e.z);return 0===this.y.redMul(n).redISub(e.y.redMul(i)).cmpn(0)},a.prototype.eqXToP=function(e){var t=this.z.redSqr(),r=e.toRed(this.curve.red).redMul(t);if(0===this.x.cmp(r))return!0;for(var i=e.clone(),n=this.curve.redN.redMul(t);;){if(i.iadd(this.curve.n),i.cmp(this.curve.p)>=0)return!1;if(r.redIAdd(n),0===this.x.cmp(r))return!0}},a.prototype.inspect=function(){return this.isInfinity()?"<EC JPoint Infinity>":"<EC JPoint x: "+this.x.toString(16,2)+" y: "+this.y.toString(16,2)+" z: "+this.z.toString(16,2)+">"},a.prototype.isInfinity=function(){return 0===this.z.cmpn(0)}},{"../../elliptic":70,"../curve":73,"bn.js":17,inherits:103}],76:[function(e,t,r){"use strict";function i(e){"short"===e.type?this.curve=new s.curve["short"](e):"edwards"===e.type?this.curve=new s.curve.edwards(e):this.curve=new s.curve.mont(e),this.g=this.curve.g,this.n=this.curve.n,this.hash=e.hash,f(this.g.validate(),"Invalid curve"),f(this.g.mul(this.n).isInfinity(),"Invalid curve, G*N != O")}function n(e,t){Object.defineProperty(a,e,{configurable:!0,enumerable:!0,get:function(){var r=new i(t);return Object.defineProperty(a,e,{configurable:!0,enumerable:!0,value:r}),r}})}var a=r,o=e("hash.js"),s=e("../elliptic"),f=s.utils.assert;a.PresetCurve=i,n("p192",{type:"short",prime:"p192",p:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",a:"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",b:"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",n:"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",hash:o.sha256,gRed:!1,g:["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012","07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]}),n("p224",{type:"short",prime:"p224",p:"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",a:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",b:"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",n:"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",hash:o.sha256,gRed:!1,g:["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21","bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]}),n("p256",{type:"short",prime:null,p:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",a:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",b:"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",n:"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",hash:o.sha256,gRed:!1,g:["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296","4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]}),n("p384",{type:"short",prime:null,p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",a:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",b:"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",n:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",hash:o.sha384,gRed:!1,g:["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7","3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]}),n("p521",{type:"short",prime:null,p:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",a:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",b:"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",n:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",hash:o.sha512,gRed:!1,g:["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66","00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]}),n("curve25519",{type:"mont",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"76d06",b:"1",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:o.sha256,gRed:!1,g:["9"]}),n("ed25519",{type:"edwards",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"-1",c:"1",d:"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:o.sha256,gRed:!1,g:["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a","6666666666666666666666666666666666666666666666666666666666666658"]});var c;try{c=e("./precomputed/secp256k1")}catch(u){c=void 0}n("secp256k1",{type:"short",prime:"k256",p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",a:"0",b:"7",n:"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",h:"1",hash:o.sha256,beta:"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",lambda:"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],gRed:!1,g:["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",c]})},{"../elliptic":70,"./precomputed/secp256k1":83,"hash.js":89}],77:[function(e,t,r){"use strict";function i(e){return this instanceof i?("string"==typeof e&&(f(o.curves.hasOwnProperty(e),"Unknown curve "+e),e=o.curves[e]),e instanceof o.curves.PresetCurve&&(e={curve:e}),this.curve=e.curve.curve,this.n=this.curve.n,this.nh=this.n.ushrn(1),this.g=this.curve.g,this.g=e.curve.g,this.g.precompute(e.curve.n.bitLength()+1),void(this.hash=e.hash||e.curve.hash)):new i(e)}var n=e("bn.js"),a=e("hmac-drbg"),o=e("../../elliptic"),s=o.utils,f=s.assert,c=e("./key"),u=e("./signature");t.exports=i,i.prototype.keyPair=function(e){return new c(this,e)},i.prototype.keyFromPrivate=function(e,t){return c.fromPrivate(this,e,t)},i.prototype.keyFromPublic=function(e,t){return c.fromPublic(this,e,t)},i.prototype.genKeyPair=function(e){e||(e={});for(var t=new a({hash:this.hash,pers:e.pers,persEnc:e.persEnc||"utf8",entropy:e.entropy||o.rand(this.hash.hmacStrength),entropyEnc:e.entropy&&e.entropyEnc||"utf8",nonce:this.n.toArray()}),r=this.n.byteLength(),i=this.n.sub(new n(2));;){var s=new n(t.generate(r));if(!(s.cmp(i)>0))return s.iaddn(1),this.keyFromPrivate(s)}},i.prototype._truncateToN=function(e,t){var r=8*e.byteLength()-this.n.bitLength();return r>0&&(e=e.ushrn(r)),!t&&e.cmp(this.n)>=0?e.sub(this.n):e},i.prototype.sign=function(e,t,r,i){"object"==typeof r&&(i=r,r=null),i||(i={}),t=this.keyFromPrivate(t,r),e=this._truncateToN(new n(e,16));for(var o=this.n.byteLength(),s=t.getPrivate().toArray("be",o),f=e.toArray("be",o),c=new a({hash:this.hash,entropy:s,nonce:f,pers:i.pers,persEnc:i.persEnc||"utf8"}),h=this.n.sub(new n(1)),d=0;!0;d++){var l=i.k?i.k(d):new n(c.generate(this.n.byteLength()));if(l=this._truncateToN(l,!0),!(l.cmpn(1)<=0||l.cmp(h)>=0)){var p=this.g.mul(l);if(!p.isInfinity()){var b=p.getX(),y=b.umod(this.n);if(0!==y.cmpn(0)){var m=l.invm(this.n).mul(y.mul(t.getPrivate()).iadd(e));if(m=m.umod(this.n),0!==m.cmpn(0)){var g=(p.getY().isOdd()?1:0)|(0!==b.cmp(y)?2:0);return i.canonical&&m.cmp(this.nh)>0&&(m=this.n.sub(m),g^=1),new u({r:y,s:m,recoveryParam:g})}}}}}},i.prototype.verify=function(e,t,r,i){e=this._truncateToN(new n(e,16)),r=this.keyFromPublic(r,i),t=new u(t,"hex");var a=t.r,o=t.s;if(a.cmpn(1)<0||a.cmp(this.n)>=0)return!1;if(o.cmpn(1)<0||o.cmp(this.n)>=0)return!1;var s=o.invm(this.n),f=s.mul(e).umod(this.n),c=s.mul(a).umod(this.n);if(!this.curve._maxwellTrick){var h=this.g.mulAdd(f,r.getPublic(),c);return h.isInfinity()?!1:0===h.getX().umod(this.n).cmp(a)}var h=this.g.jmulAdd(f,r.getPublic(),c);return h.isInfinity()?!1:h.eqXToP(a)},i.prototype.recoverPubKey=function(e,t,r,i){f((3&r)===r,"The recovery param is more than two bits"),t=new u(t,i);var a=this.n,o=new n(e),s=t.r,c=t.s,h=1&r,d=r>>1;if(s.cmp(this.curve.p.umod(this.curve.n))>=0&&d)throw new Error("Unable to find sencond key candinate");s=d?this.curve.pointFromX(s.add(this.curve.n),h):this.curve.pointFromX(s,h);var l=t.r.invm(a),p=a.sub(o).mul(l).umod(a),b=c.mul(l).umod(a);return this.g.mulAdd(p,s,b)},i.prototype.getKeyRecoveryParam=function(e,t,r,i){if(t=new u(t,i),null!==t.recoveryParam)return t.recoveryParam;for(var n=0;4>n;n++){var a;try{a=this.recoverPubKey(e,t,n)}catch(e){continue}if(a.eq(r))return n}throw new Error("Unable to find valid recovery factor")}},{"../../elliptic":70,"./key":78,"./signature":79,"bn.js":17,"hmac-drbg":101}],78:[function(e,t,r){"use strict";function i(e,t){this.ec=e,this.priv=null,this.pub=null,t.priv&&this._importPrivate(t.priv,t.privEnc),t.pub&&this._importPublic(t.pub,t.pubEnc)}var n=e("bn.js"),a=e("../../elliptic"),o=a.utils,s=o.assert;t.exports=i,i.fromPublic=function(e,t,r){return t instanceof i?t:new i(e,{pub:t,pubEnc:r})},i.fromPrivate=function(e,t,r){return t instanceof i?t:new i(e,{priv:t,privEnc:r})},i.prototype.validate=function(){var e=this.getPublic();return e.isInfinity()?{result:!1,reason:"Invalid public key"}:e.validate()?e.mul(this.ec.curve.n).isInfinity()?{result:!0,reason:null}:{result:!1,reason:"Public key * N != O"}:{result:!1,reason:"Public key is not a point"}},i.prototype.getPublic=function(e,t){return"string"==typeof e&&(t=e,e=null),this.pub||(this.pub=this.ec.g.mul(this.priv)),t?this.pub.encode(t,e):this.pub},i.prototype.getPrivate=function(e){return"hex"===e?this.priv.toString(16,2):this.priv},i.prototype._importPrivate=function(e,t){this.priv=new n(e,t||16),this.priv=this.priv.umod(this.ec.curve.n)},i.prototype._importPublic=function(e,t){return e.x||e.y?("mont"===this.ec.curve.type?s(e.x,"Need x coordinate"):("short"===this.ec.curve.type||"edwards"===this.ec.curve.type)&&s(e.x&&e.y,"Need both x and y coordinate"),void(this.pub=this.ec.curve.point(e.x,e.y))):void(this.pub=this.ec.curve.decodePoint(e,t))},i.prototype.derive=function(e){return e.mul(this.priv).getX()},i.prototype.sign=function(e,t,r){return this.ec.sign(e,this,t,r)},i.prototype.verify=function(e,t){return this.ec.verify(e,t,this)},i.prototype.inspect=function(){return"<Key priv: "+(this.priv&&this.priv.toString(16,2))+" pub: "+(this.pub&&this.pub.inspect())+" >"}},{"../../elliptic":70,"bn.js":17}],79:[function(e,t,r){"use strict";function i(e,t){return e instanceof i?e:void(this._importDER(e,t)||(h(e.r&&e.s,"Signature without r or s"),this.r=new f(e.r,16),this.s=new f(e.s,16),void 0===e.recoveryParam?this.recoveryParam=null:this.recoveryParam=e.recoveryParam))}function n(){this.place=0}function a(e,t){var r=e[t.place++];if(!(128&r))return r;for(var i=15&r,n=0,a=0,o=t.place;i>a;a++,o++)n<<=8,n|=e[o];return t.place=o,n}function o(e){for(var t=0,r=e.length-1;!e[t]&&!(128&e[t+1])&&r>t;)t++;return 0===t?e:e.slice(t)}function s(e,t){if(128>t)return void e.push(t);var r=1+(Math.log(t)/Math.LN2>>>3);for(e.push(128|r);--r;)e.push(t>>>(r<<3)&255);e.push(t)}var f=e("bn.js"),c=e("../../elliptic"),u=c.utils,h=u.assert;t.exports=i,i.prototype._importDER=function(e,t){e=u.toArray(e,t);var r=new n;if(48!==e[r.place++])return!1;var i=a(e,r);if(i+r.place!==e.length)return!1;if(2!==e[r.place++])return!1;var o=a(e,r),s=e.slice(r.place,o+r.place);if(r.place+=o,2!==e[r.place++])return!1;var c=a(e,r);if(e.length!==c+r.place)return!1;var h=e.slice(r.place,c+r.place);return 0===s[0]&&128&s[1]&&(s=s.slice(1)),0===h[0]&&128&h[1]&&(h=h.slice(1)),this.r=new f(s),this.s=new f(h),this.recoveryParam=null,!0},i.prototype.toDER=function(e){var t=this.r.toArray(),r=this.s.toArray();for(128&t[0]&&(t=[0].concat(t)),128&r[0]&&(r=[0].concat(r)),t=o(t),r=o(r);!(r[0]||128&r[1]);)r=r.slice(1);var i=[2];s(i,t.length),i=i.concat(t),i.push(2),s(i,r.length);var n=i.concat(r),a=[48];return s(a,n.length),a=a.concat(n),u.encode(a,e)}},{"../../elliptic":70,"bn.js":17}],80:[function(e,t,r){"use strict";function i(e){if(s("ed25519"===e,"only tested with ed25519 so far"),!(this instanceof i))return new i(e);var e=a.curves[e].curve;this.curve=e,this.g=e.g,this.g.precompute(e.n.bitLength()+1),this.pointClass=e.point().constructor,this.encodingLength=Math.ceil(e.n.bitLength()/8),this.hash=n.sha512}var n=e("hash.js"),a=e("../../elliptic"),o=a.utils,s=o.assert,f=o.parseBytes,c=e("./key"),u=e("./signature");t.exports=i,i.prototype.sign=function(e,t){e=f(e);var r=this.keyFromSecret(t),i=this.hashInt(r.messagePrefix(),e),n=this.g.mul(i),a=this.encodePoint(n),o=this.hashInt(a,r.pubBytes(),e).mul(r.priv()),s=i.add(o).umod(this.curve.n);return this.makeSignature({R:n,S:s,Rencoded:a})},i.prototype.verify=function(e,t,r){e=f(e),t=this.makeSignature(t);var i=this.keyFromPublic(r),n=this.hashInt(t.Rencoded(),i.pubBytes(),e),a=this.g.mul(t.S()),o=t.R().add(i.pub().mul(n));return o.eq(a)},i.prototype.hashInt=function(){for(var e=this.hash(),t=0;t<arguments.length;t++)e.update(arguments[t]);return o.intFromLE(e.digest()).umod(this.curve.n)},i.prototype.keyFromPublic=function(e){return c.fromPublic(this,e)},i.prototype.keyFromSecret=function(e){return c.fromSecret(this,e)},i.prototype.makeSignature=function(e){return e instanceof u?e:new u(this,e)},i.prototype.encodePoint=function(e){var t=e.getY().toArray("le",this.encodingLength);return t[this.encodingLength-1]|=e.getX().isOdd()?128:0,t},i.prototype.decodePoint=function(e){e=o.parseBytes(e);var t=e.length-1,r=e.slice(0,t).concat(-129&e[t]),i=0!==(128&e[t]),n=o.intFromLE(r);return this.curve.pointFromY(n,i)},i.prototype.encodeInt=function(e){return e.toArray("le",this.encodingLength)},i.prototype.decodeInt=function(e){return o.intFromLE(e)},i.prototype.isPoint=function(e){return e instanceof this.pointClass}},{"../../elliptic":70,"./key":81,"./signature":82,"hash.js":89}],81:[function(e,t,r){"use strict";function i(e,t){this.eddsa=e,this._secret=s(t.secret),e.isPoint(t.pub)?this._pub=t.pub:this._pubBytes=s(t.pub)}var n=e("../../elliptic"),a=n.utils,o=a.assert,s=a.parseBytes,f=a.cachedProperty;i.fromPublic=function(e,t){return t instanceof i?t:new i(e,{pub:t})},i.fromSecret=function(e,t){return t instanceof i?t:new i(e,{secret:t})},i.prototype.secret=function(){return this._secret},f(i,"pubBytes",function(){return this.eddsa.encodePoint(this.pub())}),f(i,"pub",function(){return this._pubBytes?this.eddsa.decodePoint(this._pubBytes):this.eddsa.g.mul(this.priv())}),f(i,"privBytes",function(){var e=this.eddsa,t=this.hash(),r=e.encodingLength-1,i=t.slice(0,e.encodingLength);return i[0]&=248,i[r]&=127,i[r]|=64,i}),f(i,"priv",function(){return this.eddsa.decodeInt(this.privBytes())}),f(i,"hash",function(){return this.eddsa.hash().update(this.secret()).digest()}),f(i,"messagePrefix",function(){return this.hash().slice(this.eddsa.encodingLength)}),i.prototype.sign=function(e){return o(this._secret,"KeyPair can only verify"),this.eddsa.sign(e,this)},i.prototype.verify=function(e,t){return this.eddsa.verify(e,t,this)},i.prototype.getSecret=function(e){return o(this._secret,"KeyPair is public only"),a.encode(this.secret(),e)},i.prototype.getPublic=function(e){return a.encode(this.pubBytes(),e)},t.exports=i},{"../../elliptic":70}],82:[function(e,t,r){"use strict";function i(e,t){this.eddsa=e,"object"!=typeof t&&(t=c(t)),Array.isArray(t)&&(t={R:t.slice(0,e.encodingLength),S:t.slice(e.encodingLength)}),s(t.R&&t.S,"Signature without R or S"),e.isPoint(t.R)&&(this._R=t.R),t.S instanceof n&&(this._S=t.S),this._Rencoded=Array.isArray(t.R)?t.R:t.Rencoded,this._Sencoded=Array.isArray(t.S)?t.S:t.Sencoded}var n=e("bn.js"),a=e("../../elliptic"),o=a.utils,s=o.assert,f=o.cachedProperty,c=o.parseBytes;f(i,"S",function(){return this.eddsa.decodeInt(this.Sencoded())}),f(i,"R",function(){return this.eddsa.decodePoint(this.Rencoded())}),f(i,"Rencoded",function(){return this.eddsa.encodePoint(this.R())}),f(i,"Sencoded",function(){return this.eddsa.encodeInt(this.S())}),i.prototype.toBytes=function(){return this.Rencoded().concat(this.Sencoded())},i.prototype.toHex=function(){return o.encode(this.toBytes(),"hex").toUpperCase()},t.exports=i},{"../../elliptic":70,"bn.js":17}],83:[function(e,t,r){t.exports={doubles:{step:4,points:[["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a","f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508","11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739","d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640","4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c","4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda","96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa","5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0","cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d","9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d","e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1","9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0","5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047","10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862","283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7","7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd","56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83","7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a","53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8","bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d","4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725","7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754","4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c","17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6","6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39","c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891","893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b","febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03","2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d","eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070","7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4","e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da","662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11","1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e","efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41","2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef","67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8","db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d","648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96","35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd","ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5","9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266","40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71","34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac","c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751","1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e","493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241","c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3","be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f","4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19","aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be","b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9","6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2","8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13","7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c","ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba","2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151","e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073","d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458","38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b","69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366","d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa","40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0","620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787","7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e","ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]
},naf:{wnd:7,points:[["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9","388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4","d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc","6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe","cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb","d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8","ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e","581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34","4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c","85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5","321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f","2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714","73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729","a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db","2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4","e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5","b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479","2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d","80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f","1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb","d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9","eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963","758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74","958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530","e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b","5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247","cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1","cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120","4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435","91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18","673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8","59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb","3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f","55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143","efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba","e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45","f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a","744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e","c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8","e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c","30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519","e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab","100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca","ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf","8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610","68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4","f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c","d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940","edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980","a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3","66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf","9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63","4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448","fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf","5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5","8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6","8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5","5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99","f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51","f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5","42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5","204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997","4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881","73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5","39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66","d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726","ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede","6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94","60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31","3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51","b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252","ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5","cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b","6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4","322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f","6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889","2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246","b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984","998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a","b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030","bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197","6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593","c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef","21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38","60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a","49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111","5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502","7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea","be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26","8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986","39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e","62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4","25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda","ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859","cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f","f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c","6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942","fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a","1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80","5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d","438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1","cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63","c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352","6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193","ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00","9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58","ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7","d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8","c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e","67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d","cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b","299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f","f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6","462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297","62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a","7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c","ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52","4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb","bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065","bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917","603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9","cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3","553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57","712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66","ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8","9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721","9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180","4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]}}},{}],84:[function(e,t,r){"use strict";function i(e,t){for(var r=[],i=1<<t+1,n=e.clone();n.cmpn(1)>=0;){var a;if(n.isOdd()){var o=n.andln(i-1);a=o>(i>>1)-1?(i>>1)-o:o,n.isubn(a)}else a=0;r.push(a);for(var s=0!==n.cmpn(0)&&0===n.andln(i-1)?t+1:1,f=1;s>f;f++)r.push(0);n.iushrn(s)}return r}function n(e,t){var r=[[],[]];e=e.clone(),t=t.clone();for(var i=0,n=0;e.cmpn(-i)>0||t.cmpn(-n)>0;){var a=e.andln(3)+i&3,o=t.andln(3)+n&3;3===a&&(a=-1),3===o&&(o=-1);var s;if(0===(1&a))s=0;else{var f=e.andln(7)+i&7;s=3!==f&&5!==f||2!==o?a:-a}r[0].push(s);var c;if(0===(1&o))c=0;else{var f=t.andln(7)+n&7;c=3!==f&&5!==f||2!==a?o:-o}r[1].push(c),2*i===s+1&&(i=1-i),2*n===c+1&&(n=1-n),e.iushrn(1),t.iushrn(1)}return r}function a(e,t,r){var i="_"+t;e.prototype[t]=function(){return void 0!==this[i]?this[i]:this[i]=r.call(this)}}function o(e){return"string"==typeof e?f.toArray(e,"hex"):e}function s(e){return new c(e,"hex","le")}var f=r,c=e("bn.js"),u=e("minimalistic-assert"),h=e("minimalistic-crypto-utils");f.assert=u,f.toArray=h.toArray,f.zero2=h.zero2,f.toHex=h.toHex,f.encode=h.encode,f.getNAF=i,f.getJSF=n,f.cachedProperty=a,f.parseBytes=o,f.intFromLE=s},{"bn.js":17,"minimalistic-assert":129,"minimalistic-crypto-utils":130}],85:[function(e,t,r){t.exports={_from:"elliptic@^6.0.0",_id:"elliptic@6.4.1",_inBundle:!1,_integrity:"sha512-BsXLz5sqX8OHcsh7CqBMztyXARmGQ3LWPtGjJi6DiJHq5C/qvi9P3OqgswKSDftbu8+IoI/QDTAm2fFnQ9SZSQ==",_location:"/elliptic",_phantomChildren:{},_requested:{type:"range",registry:!0,raw:"elliptic@^6.0.0",name:"elliptic",escapedName:"elliptic",rawSpec:"^6.0.0",saveSpec:null,fetchSpec:"^6.0.0"},_requiredBy:["/browserify-sign","/create-ecdh"],_resolved:"https://registry.npmjs.org/elliptic/-/elliptic-6.4.1.tgz",_shasum:"c2d0b7776911b86722c632c3c06c60f2f819939a",_spec:"elliptic@^6.0.0",_where:"/home/todor/math/courses/calculator/calculator-html/external/node_modules/browserify-sign",author:{name:"Fedor Indutny",email:"fedor@indutny.com"},bugs:{url:"https://github.com/indutny/elliptic/issues"},bundleDependencies:!1,dependencies:{"bn.js":"^4.4.0",brorand:"^1.0.1","hash.js":"^1.0.0","hmac-drbg":"^1.0.0",inherits:"^2.0.1","minimalistic-assert":"^1.0.0","minimalistic-crypto-utils":"^1.0.0"},deprecated:!1,description:"EC cryptography",devDependencies:{brfs:"^1.4.3",coveralls:"^2.11.3",grunt:"^0.4.5","grunt-browserify":"^5.0.0","grunt-cli":"^1.2.0","grunt-contrib-connect":"^1.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^1.0.1","grunt-mocha-istanbul":"^3.0.1","grunt-saucelabs":"^8.6.2",istanbul:"^0.4.2",jscs:"^2.9.0",jshint:"^2.6.0",mocha:"^2.1.0"},files:["lib"],homepage:"https://github.com/indutny/elliptic",keywords:["EC","Elliptic","curve","Cryptography"],license:"MIT",main:"lib/elliptic.js",name:"elliptic",repository:{type:"git",url:"git+ssh://git@github.com/indutny/elliptic.git"},scripts:{jscs:"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",jshint:"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",lint:"npm run jscs && npm run jshint",test:"npm run lint && npm run unit",unit:"istanbul test _mocha --reporter=spec test/index.js",version:"grunt dist && git add dist/"},version:"6.4.1"}},{}],86:[function(e,t,r){function i(){this._events&&Object.prototype.hasOwnProperty.call(this,"_events")||(this._events=_(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0}function n(e){return void 0===e._maxListeners?i.defaultMaxListeners:e._maxListeners}function a(e,t,r){if(t)e.call(r);else for(var i=e.length,n=y(e,i),a=0;i>a;++a)n[a].call(r)}function o(e,t,r,i){if(t)e.call(r,i);else for(var n=e.length,a=y(e,n),o=0;n>o;++o)a[o].call(r,i)}function s(e,t,r,i,n){if(t)e.call(r,i,n);else for(var a=e.length,o=y(e,a),s=0;a>s;++s)o[s].call(r,i,n)}function f(e,t,r,i,n,a){if(t)e.call(r,i,n,a);else for(var o=e.length,s=y(e,o),f=0;o>f;++f)s[f].call(r,i,n,a)}function c(e,t,r,i){if(t)e.apply(r,i);else for(var n=e.length,a=y(e,n),o=0;n>o;++o)a[o].apply(r,i)}function u(e,t,r,i){var a,o,s;if("function"!=typeof r)throw new TypeError('"listener" argument must be a function');if(o=e._events,o?(o.newListener&&(e.emit("newListener",t,r.listener?r.listener:r),o=e._events),s=o[t]):(o=e._events=_(null),e._eventsCount=0),s){if("function"==typeof s?s=o[t]=i?[r,s]:[s,r]:i?s.unshift(r):s.push(r),!s.warned&&(a=n(e),a&&a>0&&s.length>a)){s.warned=!0;var f=new Error("Possible EventEmitter memory leak detected. "+s.length+' "'+String(t)+'" listeners added. Use emitter.setMaxListeners() to increase limit.');f.name="MaxListenersExceededWarning",f.emitter=e,f.type=t,f.count=s.length,"object"==typeof console&&console.warn&&console.warn("%s: %s",f.name,f.message)}}else s=o[t]=r,++e._eventsCount;return e}function h(){if(!this.fired)switch(this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length){case 0:return this.listener.call(this.target);case 1:return this.listener.call(this.target,arguments[0]);case 2:return this.listener.call(this.target,arguments[0],arguments[1]);case 3:return this.listener.call(this.target,arguments[0],arguments[1],arguments[2]);default:for(var e=new Array(arguments.length),t=0;t<e.length;++t)e[t]=arguments[t];this.listener.apply(this.target,e)}}function d(e,t,r){var i={fired:!1,wrapFn:void 0,target:e,type:t,listener:r},n=M.call(h,i);return n.listener=r,i.wrapFn=n,n}function l(e,t,r){var i=e._events;if(!i)return[];var n=i[t];return n?"function"==typeof n?r?[n.listener||n]:[n]:r?m(n):y(n,n.length):[]}function p(e){var t=this._events;if(t){var r=t[e];if("function"==typeof r)return 1;if(r)return r.length}return 0}function b(e,t){for(var r=t,i=r+1,n=e.length;n>i;r+=1,i+=1)e[r]=e[i];e.pop()}function y(e,t){for(var r=new Array(t),i=0;t>i;++i)r[i]=e[i];return r}function m(e){for(var t=new Array(e.length),r=0;r<t.length;++r)t[r]=e[r].listener||e[r];return t}function g(e){var t=function(){};return t.prototype=e,new t}function v(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.push(r);return r}function w(e){var t=this;return function(){return t.apply(e,arguments)}}var _=Object.create||g,S=Object.keys||v,M=Function.prototype.bind||w;t.exports=i,i.EventEmitter=i,i.prototype._events=void 0,i.prototype._maxListeners=void 0;var E,k=10;try{var x={};Object.defineProperty&&Object.defineProperty(x,"x",{value:0}),E=0===x.x}catch(A){E=!1}E?Object.defineProperty(i,"defaultMaxListeners",{enumerable:!0,get:function(){return k},set:function(e){if("number"!=typeof e||0>e||e!==e)throw new TypeError('"defaultMaxListeners" must be a positive number');k=e}}):i.defaultMaxListeners=k,i.prototype.setMaxListeners=function(e){if("number"!=typeof e||0>e||isNaN(e))throw new TypeError('"n" argument must be a positive number');return this._maxListeners=e,this},i.prototype.getMaxListeners=function(){return n(this)},i.prototype.emit=function(e){var t,r,i,n,u,h,d="error"===e;if(h=this._events)d=d&&null==h.error;else if(!d)return!1;if(d){if(arguments.length>1&&(t=arguments[1]),t instanceof Error)throw t;var l=new Error('Unhandled "error" event. ('+t+")");throw l.context=t,l}if(r=h[e],!r)return!1;var p="function"==typeof r;switch(i=arguments.length){case 1:a(r,p,this);break;case 2:o(r,p,this,arguments[1]);break;case 3:s(r,p,this,arguments[1],arguments[2]);break;case 4:f(r,p,this,arguments[1],arguments[2],arguments[3]);break;default:for(n=new Array(i-1),u=1;i>u;u++)n[u-1]=arguments[u];c(r,p,this,n)}return!0},i.prototype.addListener=function(e,t){return u(this,e,t,!1)},i.prototype.on=i.prototype.addListener,i.prototype.prependListener=function(e,t){return u(this,e,t,!0)},i.prototype.once=function(e,t){if("function"!=typeof t)throw new TypeError('"listener" argument must be a function');return this.on(e,d(this,e,t)),this},i.prototype.prependOnceListener=function(e,t){if("function"!=typeof t)throw new TypeError('"listener" argument must be a function');return this.prependListener(e,d(this,e,t)),this},i.prototype.removeListener=function(e,t){var r,i,n,a,o;if("function"!=typeof t)throw new TypeError('"listener" argument must be a function');if(i=this._events,!i)return this;if(r=i[e],!r)return this;if(r===t||r.listener===t)0===--this._eventsCount?this._events=_(null):(delete i[e],i.removeListener&&this.emit("removeListener",e,r.listener||t));else if("function"!=typeof r){for(n=-1,a=r.length-1;a>=0;a--)if(r[a]===t||r[a].listener===t){o=r[a].listener,n=a;break}if(0>n)return this;0===n?r.shift():b(r,n),1===r.length&&(i[e]=r[0]),i.removeListener&&this.emit("removeListener",e,o||t)}return this},i.prototype.removeAllListeners=function(e){var t,r,i;if(r=this._events,!r)return this;if(!r.removeListener)return 0===arguments.length?(this._events=_(null),this._eventsCount=0):r[e]&&(0===--this._eventsCount?this._events=_(null):delete r[e]),this;if(0===arguments.length){var n,a=S(r);for(i=0;i<a.length;++i)n=a[i],"removeListener"!==n&&this.removeAllListeners(n);return this.removeAllListeners("removeListener"),this._events=_(null),this._eventsCount=0,this}if(t=r[e],"function"==typeof t)this.removeListener(e,t);else if(t)for(i=t.length-1;i>=0;i--)this.removeListener(e,t[i]);return this},i.prototype.listeners=function(e){return l(this,e,!0)},i.prototype.rawListeners=function(e){return l(this,e,!1)},i.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):p.call(e,t)},i.prototype.listenerCount=p,i.prototype.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]}},{}],87:[function(e,t,r){function i(e,t,r,i){if(n.isBuffer(e)||(e=n.from(e,"binary")),t&&(n.isBuffer(t)||(t=n.from(t,"binary")),8!==t.length))throw new RangeError("salt should be Buffer with 8 byte length");for(var o=r/8,s=n.alloc(o),f=n.alloc(i||0),c=n.alloc(0);o>0||i>0;){var u=new a;u.update(c),u.update(e),t&&u.update(t),c=u.digest();var h=0;if(o>0){var d=s.length-o;h=Math.min(o,c.length),c.copy(s,d,0,h),o-=h}if(h<c.length&&i>0){var l=f.length-i,p=Math.min(i,c.length-h);c.copy(f,l,h,h+p),i-=p}}return c.fill(0),{key:s,iv:f}}var n=e("safe-buffer").Buffer,a=e("md5.js");t.exports=i},{"md5.js":127,"safe-buffer":167}],88:[function(e,t,r){"use strict";function i(e,t){if(!a.isBuffer(e)&&"string"!=typeof e)throw new TypeError(t+" must be a string or a buffer")}function n(e){o.call(this),this._block=a.allocUnsafe(e),this._blockSize=e,this._blockOffset=0,this._length=[0,0,0,0],this._finalized=!1}var a=e("safe-buffer").Buffer,o=e("stream").Transform,s=e("inherits");s(n,o),n.prototype._transform=function(e,t,r){var i=null;try{this.update(e,t)}catch(n){i=n}r(i)},n.prototype._flush=function(e){var t=null;try{this.push(this.digest())}catch(r){t=r}e(t)},n.prototype.update=function(e,t){if(i(e,"Data"),this._finalized)throw new Error("Digest already called");a.isBuffer(e)||(e=a.from(e,t));for(var r=this._block,n=0;this._blockOffset+e.length-n>=this._blockSize;){for(var o=this._blockOffset;o<this._blockSize;)r[o++]=e[n++];this._update(),this._blockOffset=0}for(;n<e.length;)r[this._blockOffset++]=e[n++];for(var s=0,f=8*e.length;f>0;++s)this._length[s]+=f,f=this._length[s]/4294967296|0,f>0&&(this._length[s]-=4294967296*f);return this},n.prototype._update=function(){throw new Error("_update is not implemented")},n.prototype.digest=function(e){if(this._finalized)throw new Error("Digest already called");this._finalized=!0;var t=this._digest();void 0!==e&&(t=t.toString(e)),this._block.fill(0),this._blockOffset=0;for(var r=0;4>r;++r)this._length[r]=0;return t},n.prototype._digest=function(){throw new Error("_digest is not implemented")},t.exports=n},{inherits:103,"safe-buffer":167,stream:176}],89:[function(e,t,r){var i=r;i.utils=e("./hash/utils"),i.common=e("./hash/common"),i.sha=e("./hash/sha"),i.ripemd=e("./hash/ripemd"),i.hmac=e("./hash/hmac"),i.sha1=i.sha.sha1,i.sha256=i.sha.sha256,i.sha224=i.sha.sha224,i.sha384=i.sha.sha384,i.sha512=i.sha.sha512,i.ripemd160=i.ripemd.ripemd160},{"./hash/common":90,"./hash/hmac":91,"./hash/ripemd":92,"./hash/sha":93,"./hash/utils":100}],90:[function(e,t,r){"use strict";function i(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}var n=e("./utils"),a=e("minimalistic-assert");r.BlockHash=i,i.prototype.update=function(e,t){if(e=n.toArray(e,t),this.pending?this.pending=this.pending.concat(e):this.pending=e,this.pendingTotal+=e.length,this.pending.length>=this._delta8){e=this.pending;var r=e.length%this._delta8;this.pending=e.slice(e.length-r,e.length),0===this.pending.length&&(this.pending=null),e=n.join32(e,0,e.length-r,this.endian);for(var i=0;i<e.length;i+=this._delta32)this._update(e,i,i+this._delta32)}return this},i.prototype.digest=function(e){return this.update(this._pad()),a(null===this.pending),this._digest(e)},i.prototype._pad=function(){var e=this.pendingTotal,t=this._delta8,r=t-(e+this.padLength)%t,i=new Array(r+this.padLength);i[0]=128;for(var n=1;r>n;n++)i[n]=0;if(e<<=3,"big"===this.endian){for(var a=8;a<this.padLength;a++)i[n++]=0;i[n++]=0,i[n++]=0,i[n++]=0,i[n++]=0,i[n++]=e>>>24&255,i[n++]=e>>>16&255,i[n++]=e>>>8&255,i[n++]=255&e}else for(i[n++]=255&e,i[n++]=e>>>8&255,i[n++]=e>>>16&255,i[n++]=e>>>24&255,i[n++]=0,i[n++]=0,i[n++]=0,i[n++]=0,a=8;a<this.padLength;a++)i[n++]=0;return i}},{"./utils":100,"minimalistic-assert":129}],91:[function(e,t,r){"use strict";function i(e,t,r){return this instanceof i?(this.Hash=e,this.blockSize=e.blockSize/8,this.outSize=e.outSize/8,this.inner=null,this.outer=null,void this._init(n.toArray(t,r))):new i(e,t,r)}var n=e("./utils"),a=e("minimalistic-assert");t.exports=i,i.prototype._init=function(e){e.length>this.blockSize&&(e=(new this.Hash).update(e).digest()),a(e.length<=this.blockSize);for(var t=e.length;t<this.blockSize;t++)e.push(0);for(t=0;t<e.length;t++)e[t]^=54;for(this.inner=(new this.Hash).update(e),t=0;t<e.length;t++)e[t]^=106;this.outer=(new this.Hash).update(e)},i.prototype.update=function(e,t){return this.inner.update(e,t),this},i.prototype.digest=function(e){return this.outer.update(this.inner.digest()),this.outer.digest(e)}},{"./utils":100,"minimalistic-assert":129}],92:[function(e,t,r){"use strict";function i(){return this instanceof i?(l.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],void(this.endian="little")):new i}function n(e,t,r,i){return 15>=e?t^r^i:31>=e?t&r|~t&i:47>=e?(t|~r)^i:63>=e?t&i|r&~i:t^(r|~i)}function a(e){return 15>=e?0:31>=e?1518500249:47>=e?1859775393:63>=e?2400959708:2840853838}function o(e){return 15>=e?1352829926:31>=e?1548603684:47>=e?1836072691:63>=e?2053994217:0}var s=e("./utils"),f=e("./common"),c=s.rotl32,u=s.sum32,h=s.sum32_3,d=s.sum32_4,l=f.BlockHash;s.inherits(i,l),
r.ripemd160=i,i.blockSize=512,i.outSize=160,i.hmacStrength=192,i.padLength=64,i.prototype._update=function(e,t){for(var r=this.h[0],i=this.h[1],s=this.h[2],f=this.h[3],l=this.h[4],g=r,v=i,w=s,_=f,S=l,M=0;80>M;M++){var E=u(c(d(r,n(M,i,s,f),e[p[M]+t],a(M)),y[M]),l);r=l,l=f,f=c(s,10),s=i,i=E,E=u(c(d(g,n(79-M,v,w,_),e[b[M]+t],o(M)),m[M]),S),g=S,S=_,_=c(w,10),w=v,v=E}E=h(this.h[1],s,_),this.h[1]=h(this.h[2],f,S),this.h[2]=h(this.h[3],l,g),this.h[3]=h(this.h[4],r,v),this.h[4]=h(this.h[0],i,w),this.h[0]=E},i.prototype._digest=function(e){return"hex"===e?s.toHex32(this.h,"little"):s.split32(this.h,"little")};var p=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],b=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],y=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],m=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]},{"./common":90,"./utils":100}],93:[function(e,t,r){"use strict";r.sha1=e("./sha/1"),r.sha224=e("./sha/224"),r.sha256=e("./sha/256"),r.sha384=e("./sha/384"),r.sha512=e("./sha/512")},{"./sha/1":94,"./sha/224":95,"./sha/256":96,"./sha/384":97,"./sha/512":98}],94:[function(e,t,r){"use strict";function i(){return this instanceof i?(h.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],void(this.W=new Array(80))):new i}var n=e("../utils"),a=e("../common"),o=e("./common"),s=n.rotl32,f=n.sum32,c=n.sum32_5,u=o.ft_1,h=a.BlockHash,d=[1518500249,1859775393,2400959708,3395469782];n.inherits(i,h),t.exports=i,i.blockSize=512,i.outSize=160,i.hmacStrength=80,i.padLength=64,i.prototype._update=function(e,t){for(var r=this.W,i=0;16>i;i++)r[i]=e[t+i];for(;i<r.length;i++)r[i]=s(r[i-3]^r[i-8]^r[i-14]^r[i-16],1);var n=this.h[0],a=this.h[1],o=this.h[2],h=this.h[3],l=this.h[4];for(i=0;i<r.length;i++){var p=~~(i/20),b=c(s(n,5),u(p,a,o,h),l,r[i],d[p]);l=h,h=o,o=s(a,30),a=n,n=b}this.h[0]=f(this.h[0],n),this.h[1]=f(this.h[1],a),this.h[2]=f(this.h[2],o),this.h[3]=f(this.h[3],h),this.h[4]=f(this.h[4],l)},i.prototype._digest=function(e){return"hex"===e?n.toHex32(this.h,"big"):n.split32(this.h,"big")}},{"../common":90,"../utils":100,"./common":99}],95:[function(e,t,r){"use strict";function i(){return this instanceof i?(a.call(this),void(this.h=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])):new i}var n=e("../utils"),a=e("./256");n.inherits(i,a),t.exports=i,i.blockSize=512,i.outSize=224,i.hmacStrength=192,i.padLength=64,i.prototype._digest=function(e){return"hex"===e?n.toHex32(this.h.slice(0,7),"big"):n.split32(this.h.slice(0,7),"big")}},{"../utils":100,"./256":96}],96:[function(e,t,r){"use strict";function i(){return this instanceof i?(m.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=g,void(this.W=new Array(64))):new i}var n=e("../utils"),a=e("../common"),o=e("./common"),s=e("minimalistic-assert"),f=n.sum32,c=n.sum32_4,u=n.sum32_5,h=o.ch32,d=o.maj32,l=o.s0_256,p=o.s1_256,b=o.g0_256,y=o.g1_256,m=a.BlockHash,g=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];n.inherits(i,m),t.exports=i,i.blockSize=512,i.outSize=256,i.hmacStrength=192,i.padLength=64,i.prototype._update=function(e,t){for(var r=this.W,i=0;16>i;i++)r[i]=e[t+i];for(;i<r.length;i++)r[i]=c(y(r[i-2]),r[i-7],b(r[i-15]),r[i-16]);var n=this.h[0],a=this.h[1],o=this.h[2],m=this.h[3],g=this.h[4],v=this.h[5],w=this.h[6],_=this.h[7];for(s(this.k.length===r.length),i=0;i<r.length;i++){var S=u(_,p(g),h(g,v,w),this.k[i],r[i]),M=f(l(n),d(n,a,o));_=w,w=v,v=g,g=f(m,S),m=o,o=a,a=n,n=f(S,M)}this.h[0]=f(this.h[0],n),this.h[1]=f(this.h[1],a),this.h[2]=f(this.h[2],o),this.h[3]=f(this.h[3],m),this.h[4]=f(this.h[4],g),this.h[5]=f(this.h[5],v),this.h[6]=f(this.h[6],w),this.h[7]=f(this.h[7],_)},i.prototype._digest=function(e){return"hex"===e?n.toHex32(this.h,"big"):n.split32(this.h,"big")}},{"../common":90,"../utils":100,"./common":99,"minimalistic-assert":129}],97:[function(e,t,r){"use strict";function i(){return this instanceof i?(a.call(this),void(this.h=[3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428])):new i}var n=e("../utils"),a=e("./512");n.inherits(i,a),t.exports=i,i.blockSize=1024,i.outSize=384,i.hmacStrength=192,i.padLength=128,i.prototype._digest=function(e){return"hex"===e?n.toHex32(this.h.slice(0,12),"big"):n.split32(this.h.slice(0,12),"big")}},{"../utils":100,"./512":98}],98:[function(e,t,r){"use strict";function i(){return this instanceof i?(I.call(this),this.h=[1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209],this.k=R,void(this.W=new Array(160))):new i}function n(e,t,r,i,n){var a=e&r^~e&n;return 0>a&&(a+=4294967296),a}function a(e,t,r,i,n,a){var o=t&i^~t&a;return 0>o&&(o+=4294967296),o}function o(e,t,r,i,n){var a=e&r^e&n^r&n;return 0>a&&(a+=4294967296),a}function s(e,t,r,i,n,a){var o=t&i^t&a^i&a;return 0>o&&(o+=4294967296),o}function f(e,t){var r=v(e,t,28),i=v(t,e,2),n=v(t,e,7),a=r^i^n;return 0>a&&(a+=4294967296),a}function c(e,t){var r=w(e,t,28),i=w(t,e,2),n=w(t,e,7),a=r^i^n;return 0>a&&(a+=4294967296),a}function u(e,t){var r=v(e,t,14),i=v(e,t,18),n=v(t,e,9),a=r^i^n;return 0>a&&(a+=4294967296),a}function h(e,t){var r=w(e,t,14),i=w(e,t,18),n=w(t,e,9),a=r^i^n;return 0>a&&(a+=4294967296),a}function d(e,t){var r=v(e,t,1),i=v(e,t,8),n=_(e,t,7),a=r^i^n;return 0>a&&(a+=4294967296),a}function l(e,t){var r=w(e,t,1),i=w(e,t,8),n=S(e,t,7),a=r^i^n;return 0>a&&(a+=4294967296),a}function p(e,t){var r=v(e,t,19),i=v(t,e,29),n=_(e,t,6),a=r^i^n;return 0>a&&(a+=4294967296),a}function b(e,t){var r=w(e,t,19),i=w(t,e,29),n=S(e,t,6),a=r^i^n;return 0>a&&(a+=4294967296),a}var y=e("../utils"),m=e("../common"),g=e("minimalistic-assert"),v=y.rotr64_hi,w=y.rotr64_lo,_=y.shr64_hi,S=y.shr64_lo,M=y.sum64,E=y.sum64_hi,k=y.sum64_lo,x=y.sum64_4_hi,A=y.sum64_4_lo,j=y.sum64_5_hi,B=y.sum64_5_lo,I=m.BlockHash,R=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];y.inherits(i,I),t.exports=i,i.blockSize=1024,i.outSize=512,i.hmacStrength=192,i.padLength=128,i.prototype._prepareBlock=function(e,t){for(var r=this.W,i=0;32>i;i++)r[i]=e[t+i];for(;i<r.length;i+=2){var n=p(r[i-4],r[i-3]),a=b(r[i-4],r[i-3]),o=r[i-14],s=r[i-13],f=d(r[i-30],r[i-29]),c=l(r[i-30],r[i-29]),u=r[i-32],h=r[i-31];r[i]=x(n,a,o,s,f,c,u,h),r[i+1]=A(n,a,o,s,f,c,u,h)}},i.prototype._update=function(e,t){this._prepareBlock(e,t);var r=this.W,i=this.h[0],d=this.h[1],l=this.h[2],p=this.h[3],b=this.h[4],y=this.h[5],m=this.h[6],v=this.h[7],w=this.h[8],_=this.h[9],S=this.h[10],x=this.h[11],A=this.h[12],I=this.h[13],R=this.h[14],C=this.h[15];g(this.k.length===r.length);for(var T=0;T<r.length;T+=2){var O=R,P=C,D=u(w,_),L=h(w,_),N=n(w,_,S,x,A,I),q=a(w,_,S,x,A,I),U=this.k[T],z=this.k[T+1],K=r[T],F=r[T+1],H=j(O,P,D,L,N,q,U,z,K,F),W=B(O,P,D,L,N,q,U,z,K,F);O=f(i,d),P=c(i,d),D=o(i,d,l,p,b,y),L=s(i,d,l,p,b,y);var V=E(O,P,D,L),J=k(O,P,D,L);R=A,C=I,A=S,I=x,S=w,x=_,w=E(m,v,H,W),_=k(v,v,H,W),m=b,v=y,b=l,y=p,l=i,p=d,i=E(H,W,V,J),d=k(H,W,V,J)}M(this.h,0,i,d),M(this.h,2,l,p),M(this.h,4,b,y),M(this.h,6,m,v),M(this.h,8,w,_),M(this.h,10,S,x),M(this.h,12,A,I),M(this.h,14,R,C)},i.prototype._digest=function(e){return"hex"===e?y.toHex32(this.h,"big"):y.split32(this.h,"big")}},{"../common":90,"../utils":100,"minimalistic-assert":129}],99:[function(e,t,r){"use strict";function i(e,t,r,i){return 0===e?n(t,r,i):1===e||3===e?o(t,r,i):2===e?a(t,r,i):void 0}function n(e,t,r){return e&t^~e&r}function a(e,t,r){return e&t^e&r^t&r}function o(e,t,r){return e^t^r}function s(e){return d(e,2)^d(e,13)^d(e,22)}function f(e){return d(e,6)^d(e,11)^d(e,25)}function c(e){return d(e,7)^d(e,18)^e>>>3}function u(e){return d(e,17)^d(e,19)^e>>>10}var h=e("../utils"),d=h.rotr32;r.ft_1=i,r.ch32=n,r.maj32=a,r.p32=o,r.s0_256=s,r.s1_256=f,r.g0_256=c,r.g1_256=u},{"../utils":100}],100:[function(e,t,r){"use strict";function i(e,t){return 55296!==(64512&e.charCodeAt(t))?!1:0>t||t+1>=e.length?!1:56320===(64512&e.charCodeAt(t+1))}function n(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var r=[];if("string"==typeof e)if(t){if("hex"===t)for(e=e.replace(/[^a-z0-9]+/gi,""),e.length%2!==0&&(e="0"+e),a=0;a<e.length;a+=2)r.push(parseInt(e[a]+e[a+1],16))}else for(var n=0,a=0;a<e.length;a++){var o=e.charCodeAt(a);128>o?r[n++]=o:2048>o?(r[n++]=o>>6|192,r[n++]=63&o|128):i(e,a)?(o=65536+((1023&o)<<10)+(1023&e.charCodeAt(++a)),r[n++]=o>>18|240,r[n++]=o>>12&63|128,r[n++]=o>>6&63|128,r[n++]=63&o|128):(r[n++]=o>>12|224,r[n++]=o>>6&63|128,r[n++]=63&o|128)}else for(a=0;a<e.length;a++)r[a]=0|e[a];return r}function a(e){for(var t="",r=0;r<e.length;r++)t+=f(e[r].toString(16));return t}function o(e){var t=e>>>24|e>>>8&65280|e<<8&16711680|(255&e)<<24;return t>>>0}function s(e,t){for(var r="",i=0;i<e.length;i++){var n=e[i];"little"===t&&(n=o(n)),r+=c(n.toString(16))}return r}function f(e){return 1===e.length?"0"+e:e}function c(e){return 7===e.length?"0"+e:6===e.length?"00"+e:5===e.length?"000"+e:4===e.length?"0000"+e:3===e.length?"00000"+e:2===e.length?"000000"+e:1===e.length?"0000000"+e:e}function u(e,t,r,i){var n=r-t;B(n%4===0);for(var a=new Array(n/4),o=0,s=t;o<a.length;o++,s+=4){var f;f="big"===i?e[s]<<24|e[s+1]<<16|e[s+2]<<8|e[s+3]:e[s+3]<<24|e[s+2]<<16|e[s+1]<<8|e[s],a[o]=f>>>0}return a}function h(e,t){for(var r=new Array(4*e.length),i=0,n=0;i<e.length;i++,n+=4){var a=e[i];"big"===t?(r[n]=a>>>24,r[n+1]=a>>>16&255,r[n+2]=a>>>8&255,r[n+3]=255&a):(r[n+3]=a>>>24,r[n+2]=a>>>16&255,r[n+1]=a>>>8&255,r[n]=255&a)}return r}function d(e,t){return e>>>t|e<<32-t}function l(e,t){return e<<t|e>>>32-t}function p(e,t){return e+t>>>0}function b(e,t,r){return e+t+r>>>0}function y(e,t,r,i){return e+t+r+i>>>0}function m(e,t,r,i,n){return e+t+r+i+n>>>0}function g(e,t,r,i){var n=e[t],a=e[t+1],o=i+a>>>0,s=(i>o?1:0)+r+n;e[t]=s>>>0,e[t+1]=o}function v(e,t,r,i){var n=t+i>>>0,a=(t>n?1:0)+e+r;return a>>>0}function w(e,t,r,i){var n=t+i;return n>>>0}function _(e,t,r,i,n,a,o,s){var f=0,c=t;c=c+i>>>0,f+=t>c?1:0,c=c+a>>>0,f+=a>c?1:0,c=c+s>>>0,f+=s>c?1:0;var u=e+r+n+o+f;return u>>>0}function S(e,t,r,i,n,a,o,s){var f=t+i+a+s;return f>>>0}function M(e,t,r,i,n,a,o,s,f,c){var u=0,h=t;h=h+i>>>0,u+=t>h?1:0,h=h+a>>>0,u+=a>h?1:0,h=h+s>>>0,u+=s>h?1:0,h=h+c>>>0,u+=c>h?1:0;var d=e+r+n+o+f+u;return d>>>0}function E(e,t,r,i,n,a,o,s,f,c){var u=t+i+a+s+c;return u>>>0}function k(e,t,r){var i=t<<32-r|e>>>r;return i>>>0}function x(e,t,r){var i=e<<32-r|t>>>r;return i>>>0}function A(e,t,r){return e>>>r}function j(e,t,r){var i=e<<32-r|t>>>r;return i>>>0}var B=e("minimalistic-assert"),I=e("inherits");r.inherits=I,r.toArray=n,r.toHex=a,r.htonl=o,r.toHex32=s,r.zero2=f,r.zero8=c,r.join32=u,r.split32=h,r.rotr32=d,r.rotl32=l,r.sum32=p,r.sum32_3=b,r.sum32_4=y,r.sum32_5=m,r.sum64=g,r.sum64_hi=v,r.sum64_lo=w,r.sum64_4_hi=_,r.sum64_4_lo=S,r.sum64_5_hi=M,r.sum64_5_lo=E,r.rotr64_hi=k,r.rotr64_lo=x,r.shr64_hi=A,r.shr64_lo=j},{inherits:103,"minimalistic-assert":129}],101:[function(e,t,r){"use strict";function i(e){if(!(this instanceof i))return new i(e);this.hash=e.hash,this.predResist=!!e.predResist,this.outLen=this.hash.outSize,this.minEntropy=e.minEntropy||this.hash.hmacStrength,this._reseed=null,this.reseedInterval=null,this.K=null,this.V=null;var t=a.toArray(e.entropy,e.entropyEnc||"hex"),r=a.toArray(e.nonce,e.nonceEnc||"hex"),n=a.toArray(e.pers,e.persEnc||"hex");o(t.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._init(t,r,n)}var n=e("hash.js"),a=e("minimalistic-crypto-utils"),o=e("minimalistic-assert");t.exports=i,i.prototype._init=function(e,t,r){var i=e.concat(t).concat(r);this.K=new Array(this.outLen/8),this.V=new Array(this.outLen/8);for(var n=0;n<this.V.length;n++)this.K[n]=0,this.V[n]=1;this._update(i),this._reseed=1,this.reseedInterval=281474976710656},i.prototype._hmac=function(){return new n.hmac(this.hash,this.K)},i.prototype._update=function(e){var t=this._hmac().update(this.V).update([0]);e&&(t=t.update(e)),this.K=t.digest(),this.V=this._hmac().update(this.V).digest(),e&&(this.K=this._hmac().update(this.V).update([1]).update(e).digest(),this.V=this._hmac().update(this.V).digest())},i.prototype.reseed=function(e,t,r,i){"string"!=typeof t&&(i=r,r=t,t=null),e=a.toArray(e,t),r=a.toArray(r,i),o(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._update(e.concat(r||[])),this._reseed=1},i.prototype.generate=function(e,t,r,i){if(this._reseed>this.reseedInterval)throw new Error("Reseed is required");"string"!=typeof t&&(i=r,r=t,t=null),r&&(r=a.toArray(r,i||"hex"),this._update(r));for(var n=[];n.length<e;)this.V=this._hmac().update(this.V).digest(),n=n.concat(this.V);var o=n.slice(0,e);return this._update(r),this._reseed++,a.encode(o,t)}},{"hash.js":89,"minimalistic-assert":129,"minimalistic-crypto-utils":130}],102:[function(e,t,r){r.read=function(e,t,r,i,n){var a,o,s=8*n-i-1,f=(1<<s)-1,c=f>>1,u=-7,h=r?n-1:0,d=r?-1:1,l=e[t+h];for(h+=d,a=l&(1<<-u)-1,l>>=-u,u+=s;u>0;a=256*a+e[t+h],h+=d,u-=8);for(o=a&(1<<-u)-1,a>>=-u,u+=i;u>0;o=256*o+e[t+h],h+=d,u-=8);if(0===a)a=1-c;else{if(a===f)return o?NaN:(l?-1:1)*(1/0);o+=Math.pow(2,i),a-=c}return(l?-1:1)*o*Math.pow(2,a-i)},r.write=function(e,t,r,i,n,a){var o,s,f,c=8*a-n-1,u=(1<<c)-1,h=u>>1,d=23===n?Math.pow(2,-24)-Math.pow(2,-77):0,l=i?0:a-1,p=i?1:-1,b=0>t||0===t&&0>1/t?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,o=u):(o=Math.floor(Math.log(t)/Math.LN2),t*(f=Math.pow(2,-o))<1&&(o--,f*=2),t+=o+h>=1?d/f:d*Math.pow(2,1-h),t*f>=2&&(o++,f/=2),o+h>=u?(s=0,o=u):o+h>=1?(s=(t*f-1)*Math.pow(2,n),o+=h):(s=t*Math.pow(2,h-1)*Math.pow(2,n),o=0));n>=8;e[r+l]=255&s,l+=p,s/=256,n-=8);for(o=o<<n|s,c+=n;c>0;e[r+l]=255&o,l+=p,o/=256,c-=8);e[r+l-p]|=128*b}},{}],103:[function(e,t,r){"function"==typeof Object.create?t.exports=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:t.exports=function(e,t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}},{}],104:[function(e,t,r){function i(e){return!!e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}function n(e){return"function"==typeof e.readFloatLE&&"function"==typeof e.slice&&i(e.slice(0,0))}t.exports=function(e){return null!=e&&(i(e)||n(e)||!!e._isBuffer)}},{}],105:[function(e,t,r){var i={}.toString;t.exports=Array.isArray||function(e){return"[object Array]"==i.call(e)}},{}],106:[function(e,t,r){var i=e("jws");t.exports=function(e,t){t=t||{};var r=i.decode(e,t);if(!r)return null;var n=r.payload;if("string"==typeof n)try{var a=JSON.parse(n);null!==a&&"object"==typeof a&&(n=a)}catch(o){}return t.complete===!0?{header:r.header,payload:n,signature:r.signature}:n}},{jws:115}],107:[function(e,t,r){t.exports={decode:e("./decode"),verify:e("./verify"),sign:e("./sign"),JsonWebTokenError:e("./lib/JsonWebTokenError"),NotBeforeError:e("./lib/NotBeforeError"),TokenExpiredError:e("./lib/TokenExpiredError")}},{"./decode":106,"./lib/JsonWebTokenError":108,"./lib/NotBeforeError":109,"./lib/TokenExpiredError":110,"./sign":112,"./verify":113}],108:[function(e,t,r){var i=function(e,t){Error.call(this,e),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name="JsonWebTokenError",this.message=e,t&&(this.inner=t)};i.prototype=Object.create(Error.prototype),i.prototype.constructor=i,t.exports=i},{}],109:[function(e,t,r){var i=e("./JsonWebTokenError"),n=function(e,t){i.call(this,e),this.name="NotBeforeError",this.date=t};n.prototype=Object.create(i.prototype),n.prototype.constructor=n,t.exports=n},{"./JsonWebTokenError":108}],110:[function(e,t,r){var i=e("./JsonWebTokenError"),n=function(e,t){i.call(this,e),this.name="TokenExpiredError",this.expiredAt=t};n.prototype=Object.create(i.prototype),n.prototype.constructor=n,t.exports=n},{"./JsonWebTokenError":108}],111:[function(e,t,r){var i=e("ms");t.exports=function(e,t){var r=t||Math.floor(Date.now()/1e3);if("string"==typeof e){var n=i(e);if("undefined"==typeof n)return;return Math.floor(r+n/1e3)}return"number"==typeof e?r+e:void 0}},{ms:131}],112:[function(e,t,r){(function(r){function i(e,t,r,i){if(!d(r))throw new Error('Expected "'+i+'" to be a plain object.');Object.keys(r).forEach(function(n){var a=e[n];if(a){if(!a.isValid(r[n]))throw new Error(a.message)}else if(!t)throw new Error('"'+n+'" is not allowed in "'+i+'"')})}function n(e){return i(b,!1,e,"options")}function a(e){return i(y,!0,e,"payload")}var o=e("./lib/timespan"),s=e("jws"),f=e("lodash.includes"),c=e("lodash.isboolean"),u=e("lodash.isinteger"),h=e("lodash.isnumber"),d=e("lodash.isplainobject"),l=e("lodash.isstring"),p=e("lodash.once"),b={expiresIn:{isValid:function(e){return u(e)||l(e)&&e},message:'"expiresIn" should be a number of seconds or string representing a timespan'},notBefore:{isValid:function(e){return u(e)||l(e)&&e},message:'"notBefore" should be a number of seconds or string representing a timespan'},audience:{isValid:function(e){return l(e)||Array.isArray(e)},message:'"audience" must be a string or array'},algorithm:{isValid:f.bind(null,["RS256","RS384","RS512","ES256","ES384","ES512","HS256","HS384","HS512","none"]),message:'"algorithm" must be a valid string enum value'},header:{isValid:d,message:'"header" must be an object'},encoding:{isValid:l,message:'"encoding" must be a string'},issuer:{isValid:l,message:'"issuer" must be a string'},subject:{isValid:l,message:'"subject" must be a string'},jwtid:{isValid:l,message:'"jwtid" must be a string'},noTimestamp:{isValid:c,message:'"noTimestamp" must be a boolean'},keyid:{isValid:l,message:'"keyid" must be a string'},mutatePayload:{isValid:c,message:'"mutatePayload" must be a boolean'}},y={iat:{isValid:h,message:'"iat" should be a number of seconds'},exp:{isValid:h,message:'"exp" should be a number of seconds'},nbf:{isValid:h,message:'"nbf" should be a number of seconds'}},m={audience:"aud",issuer:"iss",subject:"sub",jwtid:"jti"},g=["expiresIn","notBefore","noTimestamp","audience","issuer","subject","jwtid"];t.exports=function(e,t,i,f){function c(e){if(f)return f(e);throw e}"function"==typeof i?(f=i,i={}):i=i||{};var u="object"==typeof e&&!r.isBuffer(e),h=Object.assign({alg:i.algorithm||"HS256",typ:u?"JWT":void 0,kid:i.keyid},i.header);if(!t&&"none"!==i.algorithm)return c(new Error("secretOrPrivateKey must have a value"));if("undefined"==typeof e)return c(new Error("payload is required"));if(u){try{a(e)}catch(d){return c(d)}i.mutatePayload||(e=Object.assign({},e))}else{var l=g.filter(function(e){return"undefined"!=typeof i[e]});if(l.length>0)return c(new Error("invalid "+l.join(",")+" option for "+typeof e+" payload"))}if("undefined"!=typeof e.exp&&"undefined"!=typeof i.expiresIn)return c(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));if("undefined"!=typeof e.nbf&&"undefined"!=typeof i.notBefore)return c(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));try{n(i)}catch(d){return c(d)}var b=e.iat||Math.floor(Date.now()/1e3);if(i.noTimestamp?delete e.iat:e.iat=b,"undefined"!=typeof i.notBefore){try{e.nbf=o(i.notBefore,b)}catch(y){return c(y)}if("undefined"==typeof e.nbf)return c(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'))}if("undefined"!=typeof i.expiresIn&&"object"==typeof e){try{e.exp=o(i.expiresIn,b)}catch(y){return c(y)}if("undefined"==typeof e.exp)return c(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'))}Object.keys(m).forEach(function(t){var r=m[t];if("undefined"!=typeof i[t]){if("undefined"!=typeof e[r])return c(new Error('Bad "options.'+t+'" option. The payload already has an "'+r+'" property.'));e[r]=i[t]}});var v=i.encoding||"utf8";return"function"!=typeof f?s.sign({header:h,payload:e,secret:t,encoding:v}):(f=f&&p(f),void s.createSign({header:h,privateKey:t,payload:e,encoding:v}).once("error",f).once("done",function(e){f(null,e)}))}}).call(this,{isBuffer:e("../is-buffer/index.js")})},{"../is-buffer/index.js":104,"./lib/timespan":111,jws:115,"lodash.includes":120,"lodash.isboolean":121,"lodash.isinteger":122,"lodash.isnumber":123,"lodash.isplainobject":124,"lodash.isstring":125,"lodash.once":126}],113:[function(e,t,r){var i=e("./lib/JsonWebTokenError"),n=e("./lib/NotBeforeError"),a=e("./lib/TokenExpiredError"),o=e("./decode"),s=e("./lib/timespan"),f=e("jws");t.exports=function(e,t,r,c){"function"!=typeof r||c||(c=r,r={}),r||(r={}),r=Object.assign({},r);var u;if(u=c?c:function(e,t){if(e)throw e;return t},r.clockTimestamp&&"number"!=typeof r.clockTimestamp)return u(new i("clockTimestamp must be a number"));if(void 0!==r.nonce&&("string"!=typeof r.nonce||""===r.nonce.trim()))return u(new i("nonce must be a non-empty string"));var h=r.clockTimestamp||Math.floor(Date.now()/1e3);if(!e)return u(new i("jwt must be provided"));if("string"!=typeof e)return u(new i("jwt must be a string"));var d=e.split(".");if(3!==d.length)return u(new i("jwt malformed"));var l;try{l=o(e,{complete:!0})}catch(p){return u(p)}if(!l)return u(new i("invalid token"));var b,y=l.header;if("function"==typeof t){if(!c)return u(new i("verify must be called asynchronous if secret or public key is provided as a callback"));b=t}else b=function(e,r){return r(null,t)};return b(y,function(t,o){if(t)return u(new i("error in secret or public key callback: "+t.message));var c=""!==d[2].trim();if(!c&&o)return u(new i("jwt signature is required"));if(c&&!o)return u(new i("secret or public key must be provided"));if(c||r.algorithms||(r.algorithms=["none"]),r.algorithms||(r.algorithms=~o.toString().indexOf("BEGIN CERTIFICATE")||~o.toString().indexOf("BEGIN PUBLIC KEY")?["RS256","RS384","RS512","ES256","ES384","ES512"]:~o.toString().indexOf("BEGIN RSA PUBLIC KEY")?["RS256","RS384","RS512"]:["HS256","HS384","HS512"]),!~r.algorithms.indexOf(l.header.alg))return u(new i("invalid algorithm"));var p;try{p=f.verify(e,l.header.alg,o)}catch(b){return u(b)}if(!p)return u(new i("invalid signature"));var y=l.payload;if("undefined"!=typeof y.nbf&&!r.ignoreNotBefore){if("number"!=typeof y.nbf)return u(new i("invalid nbf value"));if(y.nbf>h+(r.clockTolerance||0))return u(new n("jwt not active",new Date(1e3*y.nbf)))}if("undefined"!=typeof y.exp&&!r.ignoreExpiration){if("number"!=typeof y.exp)return u(new i("invalid exp value"));if(h>=y.exp+(r.clockTolerance||0))return u(new a("jwt expired",new Date(1e3*y.exp)))}if(r.audience){var m=Array.isArray(r.audience)?r.audience:[r.audience],g=Array.isArray(y.aud)?y.aud:[y.aud],v=g.some(function(e){return m.some(function(t){return t instanceof RegExp?t.test(e):t===e})});if(!v)return u(new i("jwt audience invalid. expected: "+m.join(" or ")))}if(r.issuer){var w="string"==typeof r.issuer&&y.iss!==r.issuer||Array.isArray(r.issuer)&&-1===r.issuer.indexOf(y.iss);if(w)return u(new i("jwt issuer invalid. expected: "+r.issuer))}if(r.subject&&y.sub!==r.subject)return u(new i("jwt subject invalid. expected: "+r.subject));if(r.jwtid&&y.jti!==r.jwtid)return u(new i("jwt jwtid invalid. expected: "+r.jwtid));if(r.nonce&&y.nonce!==r.nonce)return u(new i("jwt nonce invalid. expected: "+r.nonce));if(r.maxAge){if("number"!=typeof y.iat)return u(new i("iat required when maxAge is specified"));var _=s(r.maxAge,y.iat);if("undefined"==typeof _)return u(new i('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));if(h>=_+(r.clockTolerance||0))return u(new a("maxAge exceeded",new Date(1e3*_)))}return u(null,y)})}},{"./decode":106,"./lib/JsonWebTokenError":108,"./lib/NotBeforeError":109,"./lib/TokenExpiredError":110,"./lib/timespan":111,jws:115}],114:[function(e,t,r){function i(e){return e.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function n(e){e=e.toString();var t=4-e.length%4;if(4!==t)for(var r=0;t>r;++r)e+="=";return e.replace(/\-/g,"+").replace(/_/g,"/")}function a(e){var t=[].slice.call(arguments,1),r=w.format.bind(w,e).apply(null,t);return new TypeError(r)}function o(e){return m.isBuffer(e)||"string"==typeof e}function s(e){return o(e)||(e=JSON.stringify(e)),e}function f(e){return function(t,r){if(!o(r))throw a(S);t=s(t);var n=g.createHmac("sha"+e,r),f=(n.update(t),n.digest("base64"));return i(f)}}function c(e){return function(t,r,i){var n=f(e)(t,i);return y(m.from(r),m.from(n))}}function u(e){return function(t,r){if(!o(r)&&"object"!=typeof r)throw a(E);t=s(t);var n=g.createSign("RSA-SHA"+e),f=(n.update(t),n.sign(r,"base64"));return i(f)}}function h(e){return function(t,r,i){if(!o(i))throw a(M);t=s(t),r=n(r);var f=g.createVerify("RSA-SHA"+e);return f.update(t),f.verify(i,r,"base64")}}function d(e){var t=u(e);return function(){var r=t.apply(null,arguments);return r=v.derToJose(r,"ES"+e)}}function l(e){var t=h(e);return function(r,i,n){i=v.joseToDer(i,"ES"+e).toString("base64");var a=t(r,i,n);return a}}function p(){return function(){return""}}function b(){return function(e,t){return""===t}}var y=e("buffer-equal-constant-time"),m=e("safe-buffer").Buffer,g=e("crypto"),v=e("ecdsa-sig-formatter"),w=e("util"),_='"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512" and "none".',S="secret must be a string or buffer",M="key must be a string or a buffer",E="key must be a string, a buffer or an object";t.exports=function(e){var t={hs:f,rs:u,es:d,none:p},r={hs:c,rs:h,es:l,none:b},i=e.match(/^(RS|ES|HS)(256|384|512)$|^(none)$/i);if(!i)throw a(_,e);var n=(i[1]||i[3]).toLowerCase(),o=i[2];return{sign:t[n](o),verify:r[n](o)}}},{"buffer-equal-constant-time":47,crypto:57,"ecdsa-sig-formatter":68,"safe-buffer":167,util:181}],115:[function(e,t,r){var i=e("./lib/sign-stream"),n=e("./lib/verify-stream"),a=["HS256","HS384","HS512","RS256","RS384","RS512","ES256","ES384","ES512"];r.ALGORITHMS=a,r.sign=i.sign,r.verify=n.verify,r.decode=n.decode,r.isValid=n.isValid,r.createSign=function(e){return new i(e)},r.createVerify=function(e){return new n(e)}},{"./lib/sign-stream":117,"./lib/verify-stream":119}],116:[function(e,t,r){(function(r){function i(e){if(this.buffer=null,this.writable=!0,this.readable=!0,!e)return this.buffer=n.alloc(0),this;if("function"==typeof e.pipe)return this.buffer=n.alloc(0),e.pipe(this),this;if(e.length||"object"==typeof e)return this.buffer=e,this.writable=!1,r.nextTick(function(){this.emit("end",e),this.readable=!1,this.emit("close")}.bind(this)),this;throw new TypeError("Unexpected data type ("+typeof e+")")}var n=e("safe-buffer").Buffer,a=e("stream"),o=e("util");o.inherits(i,a),i.prototype.write=function(e){this.buffer=n.concat([this.buffer,n.from(e)]),this.emit("data",e)},i.prototype.end=function(e){e&&this.write(e),this.emit("end",e),this.emit("close"),this.writable=!1,this.readable=!1},t.exports=i}).call(this,e("_process"))},{_process:143,"safe-buffer":167,stream:176,util:181}],117:[function(e,t,r){function i(e,t){return s.from(e,t).toString("base64").replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function n(e,t,r){r=r||"utf8";var n=i(h(e),"binary"),a=i(h(t),r);return d.format("%s.%s",n,a)}function a(e){var t=e.header,r=e.payload,i=e.secret||e.privateKey,a=e.encoding,o=c(t.alg),s=n(t,r,a),f=o.sign(s,i);return d.format("%s.%s",s,f)}function o(e){var t=e.secret||e.privateKey||e.key,r=new f(t);this.readable=!0,this.header=e.header,this.encoding=e.encoding,this.secret=this.privateKey=this.key=r,this.payload=new f(e.payload),this.secret.once("close",function(){!this.payload.writable&&this.readable&&this.sign()}.bind(this)),this.payload.once("close",function(){!this.secret.writable&&this.readable&&this.sign()}.bind(this))}var s=e("safe-buffer").Buffer,f=e("./data-stream"),c=e("jwa"),u=e("stream"),h=e("./tostring"),d=e("util");d.inherits(o,u),o.prototype.sign=function(){try{var e=a({header:this.header,payload:this.payload.buffer,secret:this.secret.buffer,encoding:this.encoding});return this.emit("done",e),this.emit("data",e),this.emit("end"),this.readable=!1,e}catch(t){this.readable=!1,this.emit("error",t),this.emit("close")}},o.sign=a,t.exports=o},{"./data-stream":116,"./tostring":118,jwa:114,"safe-buffer":167,stream:176,util:181}],118:[function(e,t,r){var i=e("buffer").Buffer;t.exports=function(e){return"string"==typeof e?e:"number"==typeof e||i.isBuffer(e)?e.toString():JSON.stringify(e)}},{buffer:49}],119:[function(e,t,r){function i(e){return"[object Object]"===Object.prototype.toString.call(e)}function n(e){if(i(e))return e;try{return JSON.parse(e)}catch(t){return void 0}}function a(e){var t=e.split(".",1)[0];return n(l.from(t,"base64").toString("binary"))}function o(e){return e.split(".",2).join(".")}function s(e){return e.split(".")[2]}function f(e,t){t=t||"utf8";var r=e.split(".")[1];return l.from(r,"base64").toString(t)}function c(e){return v.test(e)&&!!a(e)}function u(e,t,r){if(!t){var i=new Error("Missing algorithm parameter for jws.verify");throw i.code="MISSING_ALGORITHM",i}e=m(e);var n=s(e),a=o(e),f=b(t);return f.verify(a,n,r)}function h(e,t){if(t=t||{},e=m(e),!c(e))return null;var r=a(e);if(!r)return null;var i=f(e);return("JWT"===r.typ||t.json)&&(i=JSON.parse(i,t.encoding)),
{header:r,payload:i,signature:s(e)}}function d(e){e=e||{};var t=e.secret||e.publicKey||e.key,r=new p(t);this.readable=!0,this.algorithm=e.algorithm,this.encoding=e.encoding,this.secret=this.publicKey=this.key=r,this.signature=new p(e.signature),this.secret.once("close",function(){!this.signature.writable&&this.readable&&this.verify()}.bind(this)),this.signature.once("close",function(){!this.secret.writable&&this.readable&&this.verify()}.bind(this))}var l=e("safe-buffer").Buffer,p=e("./data-stream"),b=e("jwa"),y=e("stream"),m=e("./tostring"),g=e("util"),v=/^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;g.inherits(d,y),d.prototype.verify=function(){try{var e=u(this.signature.buffer,this.algorithm,this.key.buffer),t=h(this.signature.buffer,this.encoding);return this.emit("done",e,t),this.emit("data",e),this.emit("end"),this.readable=!1,e}catch(r){this.readable=!1,this.emit("error",r),this.emit("close")}},d.decode=h,d.isValid=c,d.verify=u,t.exports=d},{"./data-stream":116,"./tostring":118,jwa:114,"safe-buffer":167,stream:176,util:181}],120:[function(e,t,r){function i(e,t){for(var r=-1,i=e?e.length:0,n=Array(i);++r<i;)n[r]=t(e[r],r,e);return n}function n(e,t,r,i){for(var n=e.length,a=r+(i?1:-1);i?a--:++a<n;)if(t(e[a],a,e))return a;return-1}function a(e,t,r){if(t!==t)return n(e,o,r);for(var i=r-1,a=e.length;++i<a;)if(e[i]===t)return i;return-1}function o(e){return e!==e}function s(e,t){for(var r=-1,i=Array(e);++r<e;)i[r]=t(r);return i}function f(e,t){return i(t,function(t){return e[t]})}function c(e,t){return function(r){return e(t(r))}}function u(e,t){var r=Z(e)||b(e)?s(e.length,String):[],i=r.length,n=!!i;for(var a in e)!t&&!W.call(e,a)||n&&("length"==a||d(a,i))||r.push(a);return r}function h(e){if(!l(e))return X(e);var t=[];for(var r in Object(e))W.call(e,r)&&"constructor"!=r&&t.push(r);return t}function d(e,t){return t=null==t?I:t,!!t&&("number"==typeof e||K.test(e))&&e>-1&&e%1==0&&t>e}function l(e){var t=e&&e.constructor,r="function"==typeof t&&t.prototype||H;return e===r}function p(e,t,r,i){e=y(e)?e:j(e),r=r&&!i?k(r):0;var n=e.length;return 0>r&&(r=G(n+r,0)),S(e)?n>=r&&e.indexOf(t,r)>-1:!!n&&a(e,t,r)>-1}function b(e){return m(e)&&W.call(e,"callee")&&(!J.call(e,"callee")||V.call(e)==T)}function y(e){return null!=e&&v(e.length)&&!g(e)}function m(e){return _(e)&&y(e)}function g(e){var t=w(e)?V.call(e):"";return t==O||t==P}function v(e){return"number"==typeof e&&e>-1&&e%1==0&&I>=e}function w(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function _(e){return!!e&&"object"==typeof e}function S(e){return"string"==typeof e||!Z(e)&&_(e)&&V.call(e)==D}function M(e){return"symbol"==typeof e||_(e)&&V.call(e)==L}function E(e){if(!e)return 0===e?e:0;if(e=x(e),e===B||e===-B){var t=0>e?-1:1;return t*R}return e===e?e:0}function k(e){var t=E(e),r=t%1;return t===t?r?t-r:t:0}function x(e){if("number"==typeof e)return e;if(M(e))return C;if(w(e)){var t="function"==typeof e.valueOf?e.valueOf():e;e=w(t)?t+"":t}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(N,"");var r=U.test(e);return r||z.test(e)?F(e.slice(2),r?2:8):q.test(e)?C:+e}function A(e){return y(e)?u(e):h(e)}function j(e){return e?f(e,A(e)):[]}var B=1/0,I=9007199254740991,R=1.7976931348623157e308,C=NaN,T="[object Arguments]",O="[object Function]",P="[object GeneratorFunction]",D="[object String]",L="[object Symbol]",N=/^\s+|\s+$/g,q=/^[-+]0x[0-9a-f]+$/i,U=/^0b[01]+$/i,z=/^0o[0-7]+$/i,K=/^(?:0|[1-9]\d*)$/,F=parseInt,H=Object.prototype,W=H.hasOwnProperty,V=H.toString,J=H.propertyIsEnumerable,X=c(Object.keys,Object),G=Math.max,Z=Array.isArray;t.exports=p},{}],121:[function(e,t,r){function i(e){return e===!0||e===!1||n(e)&&s.call(e)==a}function n(e){return!!e&&"object"==typeof e}var a="[object Boolean]",o=Object.prototype,s=o.toString;t.exports=i},{}],122:[function(e,t,r){function i(e){return"number"==typeof e&&e==f(e)}function n(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function a(e){return!!e&&"object"==typeof e}function o(e){return"symbol"==typeof e||a(e)&&w.call(e)==l}function s(e){if(!e)return 0===e?e:0;if(e=c(e),e===u||e===-u){var t=0>e?-1:1;return t*h}return e===e?e:0}function f(e){var t=s(e),r=t%1;return t===t?r?t-r:t:0}function c(e){if("number"==typeof e)return e;if(o(e))return d;if(n(e)){var t="function"==typeof e.valueOf?e.valueOf():e;e=n(t)?t+"":t}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(p,"");var r=y.test(e);return r||m.test(e)?g(e.slice(2),r?2:8):b.test(e)?d:+e}var u=1/0,h=1.7976931348623157e308,d=NaN,l="[object Symbol]",p=/^\s+|\s+$/g,b=/^[-+]0x[0-9a-f]+$/i,y=/^0b[01]+$/i,m=/^0o[0-7]+$/i,g=parseInt,v=Object.prototype,w=v.toString;t.exports=i},{}],123:[function(e,t,r){function i(e){return!!e&&"object"==typeof e}function n(e){return"number"==typeof e||i(e)&&s.call(e)==a}var a="[object Number]",o=Object.prototype,s=o.toString;t.exports=n},{}],124:[function(e,t,r){function i(e){var t=!1;if(null!=e&&"function"!=typeof e.toString)try{t=!!(e+"")}catch(r){}return t}function n(e,t){return function(r){return e(t(r))}}function a(e){return!!e&&"object"==typeof e}function o(e){if(!a(e)||l.call(e)!=s||i(e))return!1;var t=p(e);if(null===t)return!0;var r=h.call(t,"constructor")&&t.constructor;return"function"==typeof r&&r instanceof r&&u.call(r)==d}var s="[object Object]",f=Function.prototype,c=Object.prototype,u=f.toString,h=c.hasOwnProperty,d=u.call(Object),l=c.toString,p=n(Object.getPrototypeOf,Object);t.exports=o},{}],125:[function(e,t,r){function i(e){return!!e&&"object"==typeof e}function n(e){return"string"==typeof e||!f(e)&&i(e)&&s.call(e)==a}var a="[object String]",o=Object.prototype,s=o.toString,f=Array.isArray;t.exports=n},{}],126:[function(e,t,r){function i(e,t){var r;if("function"!=typeof t)throw new TypeError(h);return e=c(e),function(){return--e>0&&(r=t.apply(this,arguments)),1>=e&&(t=void 0),r}}function n(e){return i(2,e)}function a(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function o(e){return!!e&&"object"==typeof e}function s(e){return"symbol"==typeof e||o(e)&&S.call(e)==b}function f(e){if(!e)return 0===e?e:0;if(e=u(e),e===d||e===-d){var t=0>e?-1:1;return t*l}return e===e?e:0}function c(e){var t=f(e),r=t%1;return t===t?r?t-r:t:0}function u(e){if("number"==typeof e)return e;if(s(e))return p;if(a(e)){var t="function"==typeof e.valueOf?e.valueOf():e;e=a(t)?t+"":t}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(y,"");var r=g.test(e);return r||v.test(e)?w(e.slice(2),r?2:8):m.test(e)?p:+e}var h="Expected a function",d=1/0,l=1.7976931348623157e308,p=NaN,b="[object Symbol]",y=/^\s+|\s+$/g,m=/^[-+]0x[0-9a-f]+$/i,g=/^0b[01]+$/i,v=/^0o[0-7]+$/i,w=parseInt,_=Object.prototype,S=_.toString;t.exports=n},{}],127:[function(e,t,r){"use strict";function i(){u.call(this,64),this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878}function n(e,t){return e<<t|e>>>32-t}function a(e,t,r,i,a,o,s){return n(e+(t&r|~t&i)+a+o|0,s)+t|0}function o(e,t,r,i,a,o,s){return n(e+(t&i|r&~i)+a+o|0,s)+t|0}function s(e,t,r,i,a,o,s){return n(e+(t^r^i)+a+o|0,s)+t|0}function f(e,t,r,i,a,o,s){return n(e+(r^(t|~i))+a+o|0,s)+t|0}var c=e("inherits"),u=e("hash-base"),h=e("safe-buffer").Buffer,d=new Array(16);c(i,u),i.prototype._update=function(){for(var e=d,t=0;16>t;++t)e[t]=this._block.readInt32LE(4*t);var r=this._a,i=this._b,n=this._c,c=this._d;r=a(r,i,n,c,e[0],3614090360,7),c=a(c,r,i,n,e[1],3905402710,12),n=a(n,c,r,i,e[2],606105819,17),i=a(i,n,c,r,e[3],3250441966,22),r=a(r,i,n,c,e[4],4118548399,7),c=a(c,r,i,n,e[5],1200080426,12),n=a(n,c,r,i,e[6],2821735955,17),i=a(i,n,c,r,e[7],4249261313,22),r=a(r,i,n,c,e[8],1770035416,7),c=a(c,r,i,n,e[9],2336552879,12),n=a(n,c,r,i,e[10],4294925233,17),i=a(i,n,c,r,e[11],2304563134,22),r=a(r,i,n,c,e[12],1804603682,7),c=a(c,r,i,n,e[13],4254626195,12),n=a(n,c,r,i,e[14],2792965006,17),i=a(i,n,c,r,e[15],1236535329,22),r=o(r,i,n,c,e[1],4129170786,5),c=o(c,r,i,n,e[6],3225465664,9),n=o(n,c,r,i,e[11],643717713,14),i=o(i,n,c,r,e[0],3921069994,20),r=o(r,i,n,c,e[5],3593408605,5),c=o(c,r,i,n,e[10],38016083,9),n=o(n,c,r,i,e[15],3634488961,14),i=o(i,n,c,r,e[4],3889429448,20),r=o(r,i,n,c,e[9],568446438,5),c=o(c,r,i,n,e[14],3275163606,9),n=o(n,c,r,i,e[3],4107603335,14),i=o(i,n,c,r,e[8],1163531501,20),r=o(r,i,n,c,e[13],2850285829,5),c=o(c,r,i,n,e[2],4243563512,9),n=o(n,c,r,i,e[7],1735328473,14),i=o(i,n,c,r,e[12],2368359562,20),r=s(r,i,n,c,e[5],4294588738,4),c=s(c,r,i,n,e[8],2272392833,11),n=s(n,c,r,i,e[11],1839030562,16),i=s(i,n,c,r,e[14],4259657740,23),r=s(r,i,n,c,e[1],2763975236,4),c=s(c,r,i,n,e[4],1272893353,11),n=s(n,c,r,i,e[7],4139469664,16),i=s(i,n,c,r,e[10],3200236656,23),r=s(r,i,n,c,e[13],681279174,4),c=s(c,r,i,n,e[0],3936430074,11),n=s(n,c,r,i,e[3],3572445317,16),i=s(i,n,c,r,e[6],76029189,23),r=s(r,i,n,c,e[9],3654602809,4),c=s(c,r,i,n,e[12],3873151461,11),n=s(n,c,r,i,e[15],530742520,16),i=s(i,n,c,r,e[2],3299628645,23),r=f(r,i,n,c,e[0],4096336452,6),c=f(c,r,i,n,e[7],1126891415,10),n=f(n,c,r,i,e[14],2878612391,15),i=f(i,n,c,r,e[5],4237533241,21),r=f(r,i,n,c,e[12],1700485571,6),c=f(c,r,i,n,e[3],2399980690,10),n=f(n,c,r,i,e[10],4293915773,15),i=f(i,n,c,r,e[1],2240044497,21),r=f(r,i,n,c,e[8],1873313359,6),c=f(c,r,i,n,e[15],4264355552,10),n=f(n,c,r,i,e[6],2734768916,15),i=f(i,n,c,r,e[13],1309151649,21),r=f(r,i,n,c,e[4],4149444226,6),c=f(c,r,i,n,e[11],3174756917,10),n=f(n,c,r,i,e[2],718787259,15),i=f(i,n,c,r,e[9],3951481745,21),this._a=this._a+r|0,this._b=this._b+i|0,this._c=this._c+n|0,this._d=this._d+c|0},i.prototype._digest=function(){this._block[this._blockOffset++]=128,this._blockOffset>56&&(this._block.fill(0,this._blockOffset,64),this._update(),this._blockOffset=0),this._block.fill(0,this._blockOffset,56),this._block.writeUInt32LE(this._length[0],56),this._block.writeUInt32LE(this._length[1],60),this._update();var e=h.allocUnsafe(16);return e.writeInt32LE(this._a,0),e.writeInt32LE(this._b,4),e.writeInt32LE(this._c,8),e.writeInt32LE(this._d,12),e},t.exports=i},{"hash-base":88,inherits:103,"safe-buffer":167}],128:[function(e,t,r){function i(e){this.rand=e||new a.Rand}var n=e("bn.js"),a=e("brorand");t.exports=i,i.create=function(e){return new i(e)},i.prototype._randbelow=function(e){var t=e.bitLength(),r=Math.ceil(t/8);do var i=new n(this.rand.generate(r));while(i.cmp(e)>=0);return i},i.prototype._randrange=function(e,t){var r=t.sub(e);return e.add(this._randbelow(r))},i.prototype.test=function(e,t,r){var i=e.bitLength(),a=n.mont(e),o=new n(1).toRed(a);t||(t=Math.max(1,i/48|0));for(var s=e.subn(1),f=0;!s.testn(f);f++);for(var c=e.shrn(f),u=s.toRed(a),h=!0;t>0;t--){var d=this._randrange(new n(2),s);r&&r(d);var l=d.toRed(a).redPow(c);if(0!==l.cmp(o)&&0!==l.cmp(u)){for(var p=1;f>p;p++){if(l=l.redSqr(),0===l.cmp(o))return!1;if(0===l.cmp(u))break}if(p===f)return!1}}return h},i.prototype.getDivisor=function(e,t){var r=e.bitLength(),i=n.mont(e),a=new n(1).toRed(i);t||(t=Math.max(1,r/48|0));for(var o=e.subn(1),s=0;!o.testn(s);s++);for(var f=e.shrn(s),c=o.toRed(i);t>0;t--){var u=this._randrange(new n(2),o),h=e.gcd(u);if(0!==h.cmpn(1))return h;var d=u.toRed(i).redPow(f);if(0!==d.cmp(a)&&0!==d.cmp(c)){for(var l=1;s>l;l++){if(d=d.redSqr(),0===d.cmp(a))return d.fromRed().subn(1).gcd(e);if(0===d.cmp(c))break}if(l===s)return d=d.redSqr(),d.fromRed().subn(1).gcd(e)}}return!1}},{"bn.js":17,brorand:18}],129:[function(e,t,r){function i(e,t){if(!e)throw new Error(t||"Assertion failed")}t.exports=i,i.equal=function(e,t,r){if(e!=t)throw new Error(r||"Assertion failed: "+e+" != "+t)}},{}],130:[function(e,t,r){"use strict";function i(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var r=[];if("string"!=typeof e){for(var i=0;i<e.length;i++)r[i]=0|e[i];return r}if("hex"===t){e=e.replace(/[^a-z0-9]+/gi,""),e.length%2!==0&&(e="0"+e);for(var i=0;i<e.length;i+=2)r.push(parseInt(e[i]+e[i+1],16))}else for(var i=0;i<e.length;i++){var n=e.charCodeAt(i),a=n>>8,o=255&n;a?r.push(a,o):r.push(o)}return r}function n(e){return 1===e.length?"0"+e:e}function a(e){for(var t="",r=0;r<e.length;r++)t+=n(e[r].toString(16));return t}var o=r;o.toArray=i,o.zero2=n,o.toHex=a,o.encode=function(e,t){return"hex"===t?a(e):e}},{}],131:[function(e,t,r){function i(e){if(e=String(e),!(e.length>100)){var t=/^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(t){var r=parseFloat(t[1]),i=(t[2]||"ms").toLowerCase();switch(i){case"years":case"year":case"yrs":case"yr":case"y":return r*d;case"weeks":case"week":case"w":return r*h;case"days":case"day":case"d":return r*u;case"hours":case"hour":case"hrs":case"hr":case"h":return r*c;case"minutes":case"minute":case"mins":case"min":case"m":return r*f;case"seconds":case"second":case"secs":case"sec":case"s":return r*s;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return r;default:return void 0}}}}function n(e){var t=Math.abs(e);return t>=u?Math.round(e/u)+"d":t>=c?Math.round(e/c)+"h":t>=f?Math.round(e/f)+"m":t>=s?Math.round(e/s)+"s":e+"ms"}function a(e){var t=Math.abs(e);return t>=u?o(e,t,u,"day"):t>=c?o(e,t,c,"hour"):t>=f?o(e,t,f,"minute"):t>=s?o(e,t,s,"second"):e+" ms"}function o(e,t,r,i){var n=t>=1.5*r;return Math.round(e/r)+" "+i+(n?"s":"")}var s=1e3,f=60*s,c=60*f,u=24*c,h=7*u,d=365.25*u;t.exports=function(e,t){t=t||{};var r=typeof e;if("string"===r&&e.length>0)return i(e);if("number"===r&&isNaN(e)===!1)return t["long"]?a(e):n(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}},{}],132:[function(e,t,r){t.exports={"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"}},{}],133:[function(e,t,r){"use strict";var i=e("asn1.js");r.certificate=e("./certificate");var n=i.define("RSAPrivateKey",function(){this.seq().obj(this.key("version")["int"](),this.key("modulus")["int"](),this.key("publicExponent")["int"](),this.key("privateExponent")["int"](),this.key("prime1")["int"](),this.key("prime2")["int"](),this.key("exponent1")["int"](),this.key("exponent2")["int"](),this.key("coefficient")["int"]())});r.RSAPrivateKey=n;var a=i.define("RSAPublicKey",function(){this.seq().obj(this.key("modulus")["int"](),this.key("publicExponent")["int"]())});r.RSAPublicKey=a;var o=i.define("SubjectPublicKeyInfo",function(){this.seq().obj(this.key("algorithm").use(s),this.key("subjectPublicKey").bitstr())});r.PublicKey=o;var s=i.define("AlgorithmIdentifier",function(){this.seq().obj(this.key("algorithm").objid(),this.key("none").null_().optional(),this.key("curve").objid().optional(),this.key("params").seq().obj(this.key("p")["int"](),this.key("q")["int"](),this.key("g")["int"]()).optional())}),f=i.define("PrivateKeyInfo",function(){this.seq().obj(this.key("version")["int"](),this.key("algorithm").use(s),this.key("subjectPrivateKey").octstr())});r.PrivateKey=f;var c=i.define("EncryptedPrivateKeyInfo",function(){this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(),this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(),this.key("kdeparams").seq().obj(this.key("salt").octstr(),this.key("iters")["int"]())),this.key("cipher").seq().obj(this.key("algo").objid(),this.key("iv").octstr()))),this.key("subjectPrivateKey").octstr())});r.EncryptedPrivateKey=c;var u=i.define("DSAPrivateKey",function(){this.seq().obj(this.key("version")["int"](),this.key("p")["int"](),this.key("q")["int"](),this.key("g")["int"](),this.key("pub_key")["int"](),this.key("priv_key")["int"]())});r.DSAPrivateKey=u,r.DSAparam=i.define("DSAparam",function(){this["int"]()});var h=i.define("ECPrivateKey",function(){this.seq().obj(this.key("version")["int"](),this.key("privateKey").octstr(),this.key("parameters").optional().explicit(0).use(d),this.key("publicKey").optional().explicit(1).bitstr())});r.ECPrivateKey=h;var d=i.define("ECParameters",function(){this.choice({namedCurve:this.objid()})});r.signature=i.define("signature",function(){this.seq().obj(this.key("r")["int"](),this.key("s")["int"]())})},{"./certificate":134,"asn1.js":2}],134:[function(e,t,r){"use strict";var i=e("asn1.js"),n=i.define("Time",function(){this.choice({utcTime:this.utctime(),generalTime:this.gentime()})}),a=i.define("AttributeTypeValue",function(){this.seq().obj(this.key("type").objid(),this.key("value").any())}),o=i.define("AlgorithmIdentifier",function(){this.seq().obj(this.key("algorithm").objid(),this.key("parameters").optional(),this.key("curve").objid().optional())}),s=i.define("SubjectPublicKeyInfo",function(){this.seq().obj(this.key("algorithm").use(o),this.key("subjectPublicKey").bitstr())}),f=i.define("RelativeDistinguishedName",function(){this.setof(a)}),c=i.define("RDNSequence",function(){this.seqof(f)}),u=i.define("Name",function(){this.choice({rdnSequence:this.use(c)})}),h=i.define("Validity",function(){this.seq().obj(this.key("notBefore").use(n),this.key("notAfter").use(n))}),d=i.define("Extension",function(){this.seq().obj(this.key("extnID").objid(),this.key("critical").bool().def(!1),this.key("extnValue").octstr())}),l=i.define("TBSCertificate",function(){this.seq().obj(this.key("version").explicit(0)["int"]().optional(),this.key("serialNumber")["int"](),this.key("signature").use(o),this.key("issuer").use(u),this.key("validity").use(h),this.key("subject").use(u),this.key("subjectPublicKeyInfo").use(s),this.key("issuerUniqueID").implicit(1).bitstr().optional(),this.key("subjectUniqueID").implicit(2).bitstr().optional(),this.key("extensions").explicit(3).seqof(d).optional())}),p=i.define("X509Certificate",function(){this.seq().obj(this.key("tbsCertificate").use(l),this.key("signatureAlgorithm").use(o),this.key("signatureValue").bitstr())});t.exports=p},{"asn1.js":2}],135:[function(e,t,r){(function(r){var i=/Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m,n=/^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----/m,a=/^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m,o=e("evp_bytestokey"),s=e("browserify-aes");t.exports=function(e,t){var f,c=e.toString(),u=c.match(i);if(u){var h="aes"+u[1],d=new r(u[2],"hex"),l=new r(u[3].replace(/[\r\n]/g,""),"base64"),p=o(t,d.slice(0,8),parseInt(u[1],10)).key,b=[],y=s.createDecipheriv(h,p,d);b.push(y.update(l)),b.push(y["final"]()),f=r.concat(b)}else{var m=c.match(a);f=new r(m[2].replace(/[\r\n]/g,""),"base64")}var g=c.match(n)[1];return{tag:g,data:f}}}).call(this,e("buffer").Buffer)},{"browserify-aes":22,buffer:49,evp_bytestokey:87}],136:[function(e,t,r){function i(e){var t;"object"!=typeof e||u.isBuffer(e)||(t=e.passphrase,e=e.key),"string"==typeof e&&(e=u.from(e));var r,i,o=s(e,t),f=o.tag,c=o.data;switch(f){case"CERTIFICATE":i=a.certificate.decode(c,"der").tbsCertificate.subjectPublicKeyInfo;case"PUBLIC KEY":switch(i||(i=a.PublicKey.decode(c,"der")),r=i.algorithm.algorithm.join(".")){case"1.2.840.113549.1.1.1":return a.RSAPublicKey.decode(i.subjectPublicKey.data,"der");case"1.2.840.10045.2.1":return i.subjectPrivateKey=i.subjectPublicKey,{type:"ec",data:i};case"1.2.840.10040.4.1":return i.algorithm.params.pub_key=a.DSAparam.decode(i.subjectPublicKey.data,"der"),{type:"dsa",data:i.algorithm.params};default:throw new Error("unknown key id "+r)}throw new Error("unknown key type "+f);case"ENCRYPTED PRIVATE KEY":c=a.EncryptedPrivateKey.decode(c,"der"),c=n(c,t);case"PRIVATE KEY":switch(i=a.PrivateKey.decode(c,"der"),r=i.algorithm.algorithm.join(".")){case"1.2.840.113549.1.1.1":return a.RSAPrivateKey.decode(i.subjectPrivateKey,"der");case"1.2.840.10045.2.1":return{curve:i.algorithm.curve,privateKey:a.ECPrivateKey.decode(i.subjectPrivateKey,"der").privateKey};case"1.2.840.10040.4.1":return i.algorithm.params.priv_key=a.DSAparam.decode(i.subjectPrivateKey,"der"),{type:"dsa",params:i.algorithm.params};default:throw new Error("unknown key id "+r)}throw new Error("unknown key type "+f);case"RSA PUBLIC KEY":return a.RSAPublicKey.decode(c,"der");case"RSA PRIVATE KEY":return a.RSAPrivateKey.decode(c,"der");case"DSA PRIVATE KEY":return{type:"dsa",params:a.DSAPrivateKey.decode(c,"der")};case"EC PRIVATE KEY":return c=a.ECPrivateKey.decode(c,"der"),{curve:c.parameters.value,privateKey:c.privateKey};default:throw new Error("unknown key type "+f)}}function n(e,t){var r=e.algorithm.decrypt.kde.kdeparams.salt,i=parseInt(e.algorithm.decrypt.kde.kdeparams.iters.toString(),10),n=o[e.algorithm.decrypt.cipher.algo.join(".")],a=e.algorithm.decrypt.cipher.iv,s=e.subjectPrivateKey,h=parseInt(n.split("-")[1],10)/8,d=c.pbkdf2Sync(t,r,i,h,"sha1"),l=f.createDecipheriv(n,d,a),p=[];return p.push(l.update(s)),p.push(l["final"]()),u.concat(p)}var a=e("./asn1"),o=e("./aesid.json"),s=e("./fixProc"),f=e("browserify-aes"),c=e("pbkdf2"),u=e("safe-buffer").Buffer;t.exports=i,i.signature=a.signature},{"./aesid.json":132,"./asn1":133,"./fixProc":135,"browserify-aes":22,pbkdf2:137,"safe-buffer":167}],137:[function(e,t,r){r.pbkdf2=e("./lib/async"),r.pbkdf2Sync=e("./lib/sync")},{"./lib/async":138,"./lib/sync":141}],138:[function(e,t,r){(function(r,i){function n(e){if(i.process&&!i.process.browser)return Promise.resolve(!1);if(!d||!d.importKey||!d.deriveBits)return Promise.resolve(!1);if(void 0!==p[e])return p[e];s=s||h.alloc(8);var t=a(s,s,10,128,e).then(function(){return!0})["catch"](function(){return!1});return p[e]=t,t}function a(e,t,r,i,n){return d.importKey("raw",e,{name:"PBKDF2"},!1,["deriveBits"]).then(function(e){return d.deriveBits({name:"PBKDF2",salt:t,iterations:r,hash:{name:n}},e,i<<3)}).then(function(e){return h.from(e)})}function o(e,t){e.then(function(e){r.nextTick(function(){t(null,e)})},function(e){r.nextTick(function(){t(e)})})}var s,f=e("./precondition"),c=e("./default-encoding"),u=e("./sync"),h=e("safe-buffer").Buffer,d=i.crypto&&i.crypto.subtle,l={sha:"SHA-1","sha-1":"SHA-1",sha1:"SHA-1",sha256:"SHA-256","sha-256":"SHA-256",sha384:"SHA-384","sha-384":"SHA-384","sha-512":"SHA-512",sha512:"SHA-512"},p=[];t.exports=function(e,t,s,d,p,b){"function"==typeof p&&(b=p,p=void 0),p=p||"sha1";var y=l[p.toLowerCase()];if(!y||"function"!=typeof i.Promise)return r.nextTick(function(){var r;try{r=u(e,t,s,d,p)}catch(i){return b(i)}b(null,r)});if(f(e,t,s,d),"function"!=typeof b)throw new Error("No callback provided to pbkdf2");h.isBuffer(e)||(e=h.from(e,c)),h.isBuffer(t)||(t=h.from(t,c)),o(n(y).then(function(r){return r?a(e,t,s,d,y):u(e,t,s,d,p)}),b)}}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./default-encoding":139,"./precondition":140,"./sync":141,_process:143,"safe-buffer":167}],139:[function(e,t,r){(function(e){var r;if(e.browser)r="utf-8";else{var i=parseInt(e.version.split(".")[0].slice(1),10);r=i>=6?"utf-8":"binary"}t.exports=r}).call(this,e("_process"))},{_process:143}],140:[function(e,t,r){(function(e){function r(t,r){if("string"!=typeof t&&!e.isBuffer(t))throw new TypeError(r+" must be a buffer or string")}var i=Math.pow(2,30)-1;t.exports=function(e,t,n,a){if(r(e,"Password"),r(t,"Salt"),"number"!=typeof n)throw new TypeError("Iterations not a number");if(0>n)throw new TypeError("Bad iterations");if("number"!=typeof a)throw new TypeError("Key length not a number");if(0>a||a>i||a!==a)throw new TypeError("Bad key length")}}).call(this,{isBuffer:e("../../is-buffer/index.js")})},{"../../is-buffer/index.js":104}],141:[function(e,t,r){function i(e,t,r){var i=n(e),a="sha512"===e||"sha384"===e?128:64;t.length>a?t=i(t):t.length<a&&(t=h.concat([t,d],a));for(var o=h.allocUnsafe(a+l[e]),s=h.allocUnsafe(a+l[e]),f=0;a>f;f++)o[f]=54^t[f],s[f]=92^t[f];var c=h.allocUnsafe(a+r+4);o.copy(c,0,0,a),this.ipad1=c,this.ipad2=o,this.opad=s,this.alg=e,this.blocksize=a,this.hash=i,this.size=l[e]}function n(e){function t(t){return f(e).update(t).digest()}function r(e){return(new s).update(e).digest()}return"rmd160"===e||"ripemd160"===e?r:"md5"===e?o:t}function a(e,t,r,n,a){c(e,t,r,n),h.isBuffer(e)||(e=h.from(e,u)),h.isBuffer(t)||(t=h.from(t,u)),a=a||"sha1";var o=new i(a,e,t.length),s=h.allocUnsafe(n),f=h.allocUnsafe(t.length+4);t.copy(f,0,0,t.length);for(var d=0,p=l[a],b=Math.ceil(n/p),y=1;b>=y;y++){f.writeUInt32BE(y,t.length);for(var m=o.run(f,o.ipad1),g=m,v=1;r>v;v++){g=o.run(g,o.ipad2);for(var w=0;p>w;w++)m[w]^=g[w]}m.copy(s,d),d+=p}return s}var o=e("create-hash/md5"),s=e("ripemd160"),f=e("sha.js"),c=e("./precondition"),u=e("./default-encoding"),h=e("safe-buffer").Buffer,d=h.alloc(128),l={md5:16,sha1:20,sha224:28,sha256:32,sha384:48,sha512:64,rmd160:20,ripemd160:20};i.prototype.run=function(e,t){e.copy(t,this.blocksize);var r=this.hash(t);return r.copy(this.opad,this.blocksize),this.hash(this.opad)},t.exports=a},{"./default-encoding":139,"./precondition":140,"create-hash/md5":54,ripemd160:166,"safe-buffer":167,"sha.js":169}],142:[function(e,t,r){(function(e){"use strict";function r(t,r,i,n){if("function"!=typeof t)throw new TypeError('"callback" argument must be a function');var a,o,s=arguments.length;switch(s){case 0:case 1:return e.nextTick(t);case 2:return e.nextTick(function(){t.call(null,r)});case 3:return e.nextTick(function(){t.call(null,r,i)});case 4:return e.nextTick(function(){t.call(null,r,i,n)});default:for(a=new Array(s-1),o=0;o<a.length;)a[o++]=arguments[o];return e.nextTick(function(){t.apply(null,a)})}}!e.version||0===e.version.indexOf("v0.")||0===e.version.indexOf("v1.")&&0!==e.version.indexOf("v1.8.")?t.exports={nextTick:r}:t.exports=e}).call(this,e("_process"))},{_process:143}],143:[function(e,t,r){function i(){throw new Error("setTimeout has not been defined")}function n(){throw new Error("clearTimeout has not been defined")}function a(e){if(h===setTimeout)return setTimeout(e,0);if((h===i||!h)&&setTimeout)return h=setTimeout,setTimeout(e,0);try{return h(e,0)}catch(t){try{return h.call(null,e,0)}catch(t){return h.call(this,e,0)}}}function o(e){if(d===clearTimeout)return clearTimeout(e);if((d===n||!d)&&clearTimeout)return d=clearTimeout,clearTimeout(e);try{return d(e)}catch(t){try{return d.call(null,e)}catch(t){return d.call(this,e)}}}function s(){y&&p&&(y=!1,p.length?b=p.concat(b):m=-1,b.length&&f())}function f(){if(!y){var e=a(s);y=!0;for(var t=b.length;t;){for(p=b,b=[];++m<t;)p&&p[m].run();m=-1,t=b.length}p=null,y=!1,o(e)}}function c(e,t){this.fun=e,this.array=t}function u(){}var h,d,l=t.exports={};!function(){try{h="function"==typeof setTimeout?setTimeout:i}catch(e){h=i}try{d="function"==typeof clearTimeout?clearTimeout:n}catch(e){d=n}}();var p,b=[],y=!1,m=-1;l.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];b.push(new c(e,t)),1!==b.length||y||a(f)},c.prototype.run=function(){this.fun.apply(null,this.array)},l.title="browser",l.browser=!0,l.env={},l.argv=[],l.version="",l.versions={},l.on=u,l.addListener=u,l.once=u,l.off=u,l.removeListener=u,l.removeAllListeners=u,l.emit=u,l.prependListener=u,l.prependOnceListener=u,l.listeners=function(e){return[]},l.binding=function(e){throw new Error("process.binding is not supported")},l.cwd=function(){return"/"},l.chdir=function(e){throw new Error("process.chdir is not supported")},l.umask=function(){return 0}},{}],144:[function(e,t,r){r.publicEncrypt=e("./publicEncrypt"),r.privateDecrypt=e("./privateDecrypt"),r.privateEncrypt=function(e,t){return r.publicEncrypt(e,t,!0)},r.publicDecrypt=function(e,t){return r.privateDecrypt(e,t,!0)}},{"./privateDecrypt":146,"./publicEncrypt":147}],145:[function(e,t,r){function i(e){var t=a.allocUnsafe(4);return t.writeUInt32BE(e,0),t}var n=e("create-hash"),a=e("safe-buffer").Buffer;t.exports=function(e,t){for(var r,o=a.alloc(0),s=0;o.length<t;)r=i(s++),o=a.concat([o,n("sha1").update(e).update(r).digest()]);return o.slice(0,t)}},{"create-hash":53,"safe-buffer":167}],146:[function(e,t,r){function i(e,t){var r=e.modulus.byteLength(),i=h("sha1").update(l.alloc(0)).digest(),n=i.length;if(0!==t[0])throw new Error("decryption error");var o=t.slice(1,n+1),c=t.slice(n+1),u=f(o,s(c,n)),d=f(c,s(u,r-n-1));if(a(i,d.slice(0,n)))throw new Error("decryption error");for(var p=n;0===d[p];)p++;if(1!==d[p++])throw new Error("decryption error");return d.slice(p)}function n(e,t,r){for(var i=t.slice(0,2),n=2,a=0;0!==t[n++];)if(n>=t.length){a++;break}var o=t.slice(2,n-1);if(("0002"!==i.toString("hex")&&!r||"0001"!==i.toString("hex")&&r)&&a++,o.length<8&&a++,a)throw new Error("decryption error");return t.slice(n)}function a(e,t){e=l.from(e),t=l.from(t);var r=0,i=e.length;e.length!==t.length&&(r++,i=Math.min(e.length,t.length));for(var n=-1;++n<i;)r+=e[n]^t[n];return r}var o=e("parse-asn1"),s=e("./mgf"),f=e("./xor"),c=e("bn.js"),u=e("browserify-rsa"),h=e("create-hash"),d=e("./withPublic"),l=e("safe-buffer").Buffer;t.exports=function(e,t,r){var a;a=e.padding?e.padding:r?1:4;var s=o(e),f=s.modulus.byteLength();if(t.length>f||new c(t).cmp(s.modulus)>=0)throw new Error("decryption error");var h;h=r?d(new c(t),s):u(t,s);var p=l.alloc(f-h.length);if(h=l.concat([p,h],f),4===a)return i(s,h);if(1===a)return n(s,h,r);if(3===a)return h;throw new Error("unknown padding")}},{"./mgf":145,"./withPublic":148,"./xor":149,"bn.js":17,"browserify-rsa":40,"create-hash":53,"parse-asn1":136,"safe-buffer":167}],147:[function(e,t,r){function i(e,t){var r=e.modulus.byteLength(),i=t.length,n=f("sha1").update(p.alloc(0)).digest(),a=n.length,o=2*a;if(i>r-o-2)throw new Error("message too long");var d=p.alloc(r-i-o-2),l=r-a-1,b=s(a),y=u(p.concat([n,d,p.alloc(1,1),t],l),c(b,l)),m=u(b,c(y,a));return new h(p.concat([p.alloc(1),m,y],r))}function n(e,t,r){var i=t.length,n=e.modulus.byteLength();if(i>n-11)throw new Error("message too long");var o;return o=r?p.alloc(n-i-3,255):a(n-i-3),new h(p.concat([p.from([0,r?1:2]),o,p.alloc(1),t],n))}function a(e){for(var t,r=p.allocUnsafe(e),i=0,n=s(2*e),a=0;e>i;)a===n.length&&(n=s(2*e),a=0),t=n[a++],t&&(r[i++]=t);return r}var o=e("parse-asn1"),s=e("randombytes"),f=e("create-hash"),c=e("./mgf"),u=e("./xor"),h=e("bn.js"),d=e("./withPublic"),l=e("browserify-rsa"),p=e("safe-buffer").Buffer;t.exports=function(e,t,r){var a;a=e.padding?e.padding:r?1:4;var s,f=o(e);if(4===a)s=i(f,t);else if(1===a)s=n(f,t,r);else{if(3!==a)throw new Error("unknown padding");if(s=new h(t),s.cmp(f.modulus)>=0)throw new Error("data too long for modulus")}return r?l(s,f):d(s,f)}},{"./mgf":145,"./withPublic":148,"./xor":149,"bn.js":17,"browserify-rsa":40,"create-hash":53,"parse-asn1":136,randombytes:150,"safe-buffer":167}],148:[function(e,t,r){function i(e,t){return a.from(e.toRed(n.mont(t.modulus)).redPow(new n(t.publicExponent)).fromRed().toArray())}var n=e("bn.js"),a=e("safe-buffer").Buffer;t.exports=i},{"bn.js":17,"safe-buffer":167}],149:[function(e,t,r){t.exports=function(e,t){for(var r=e.length,i=-1;++i<r;)e[i]^=t[i];return e}},{}],150:[function(e,t,r){(function(r,i){"use strict";function n(){throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11")}function a(e,t){if(e>65536)throw new Error("requested too many random bytes");var n=new i.Uint8Array(e);e>0&&s.getRandomValues(n);var a=o.from(n.buffer);return"function"==typeof t?r.nextTick(function(){t(null,a)}):a}var o=e("safe-buffer").Buffer,s=i.crypto||i.msCrypto;s&&s.getRandomValues?t.exports=a:t.exports=n}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{_process:143,"safe-buffer":167}],151:[function(e,t,r){(function(t,i){"use strict";function n(){throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11")}function a(e,t){if("number"!=typeof e||e!==e)throw new TypeError("offset must be a number");if(e>b||0>e)throw new TypeError("offset must be a uint32");if(e>l||e>t)throw new RangeError("offset out of range");
}function o(e,t,r){if("number"!=typeof e||e!==e)throw new TypeError("size must be a number");if(e>b||0>e)throw new TypeError("size must be a uint32");if(e+t>r||e>l)throw new RangeError("buffer too small")}function s(e,t,r,n){if(!(d.isBuffer(e)||e instanceof i.Uint8Array))throw new TypeError('"buf" argument must be a Buffer or Uint8Array');if("function"==typeof t)n=t,t=0,r=e.length;else if("function"==typeof r)n=r,r=e.length-t;else if("function"!=typeof n)throw new TypeError('"cb" argument must be a function');return a(t,e.length),o(r,t,e.length),f(e,t,r,n)}function f(e,r,i,n){if(t.browser){var a=e.buffer,o=new Uint8Array(a,r,i);return p.getRandomValues(o),n?void t.nextTick(function(){n(null,e)}):e}if(n)return void h(i,function(t,i){return t?n(t):(i.copy(e,r),void n(null,e))});var s=h(i);return s.copy(e,r),e}function c(e,t,r){if("undefined"==typeof t&&(t=0),!(d.isBuffer(e)||e instanceof i.Uint8Array))throw new TypeError('"buf" argument must be a Buffer or Uint8Array');return a(t,e.length),void 0===r&&(r=e.length-t),o(r,t,e.length),f(e,t,r)}var u=e("safe-buffer"),h=e("randombytes"),d=u.Buffer,l=u.kMaxLength,p=i.crypto||i.msCrypto,b=Math.pow(2,32)-1;p&&p.getRandomValues||!t.browser?(r.randomFill=s,r.randomFillSync=c):(r.randomFill=n,r.randomFillSync=n)}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{_process:143,randombytes:150,"safe-buffer":167}],152:[function(e,t,r){t.exports=e("./lib/_stream_duplex.js")},{"./lib/_stream_duplex.js":153}],153:[function(e,t,r){"use strict";function i(e){return this instanceof i?(c.call(this,e),u.call(this,e),e&&e.readable===!1&&(this.readable=!1),e&&e.writable===!1&&(this.writable=!1),this.allowHalfOpen=!0,e&&e.allowHalfOpen===!1&&(this.allowHalfOpen=!1),void this.once("end",n)):new i(e)}function n(){this.allowHalfOpen||this._writableState.ended||o.nextTick(a,this)}function a(e){e.end()}var o=e("process-nextick-args"),s=Object.keys||function(e){var t=[];for(var r in e)t.push(r);return t};t.exports=i;var f=e("core-util-is");f.inherits=e("inherits");var c=e("./_stream_readable"),u=e("./_stream_writable");f.inherits(i,c);for(var h=s(u.prototype),d=0;d<h.length;d++){var l=h[d];i.prototype[l]||(i.prototype[l]=u.prototype[l])}Object.defineProperty(i.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(i.prototype,"destroyed",{get:function(){return void 0===this._readableState||void 0===this._writableState?!1:this._readableState.destroyed&&this._writableState.destroyed},set:function(e){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=e,this._writableState.destroyed=e)}}),i.prototype._destroy=function(e,t){this.push(null),this.end(),o.nextTick(t,e)}},{"./_stream_readable":155,"./_stream_writable":157,"core-util-is":51,inherits:103,"process-nextick-args":142}],154:[function(e,t,r){"use strict";function i(e){return this instanceof i?void n.call(this,e):new i(e)}t.exports=i;var n=e("./_stream_transform"),a=e("core-util-is");a.inherits=e("inherits"),a.inherits(i,n),i.prototype._transform=function(e,t,r){r(null,e)}},{"./_stream_transform":156,"core-util-is":51,inherits:103}],155:[function(e,t,r){(function(r,i){"use strict";function n(e){return L.from(e)}function a(e){return L.isBuffer(e)||e instanceof N}function o(e,t,r){return"function"==typeof e.prependListener?e.prependListener(t,r):void(e._events&&e._events[t]?O(e._events[t])?e._events[t].unshift(r):e._events[t]=[r,e._events[t]]:e.on(t,r))}function s(t,r){T=T||e("./_stream_duplex"),t=t||{};var i=r instanceof T;this.objectMode=!!t.objectMode,i&&(this.objectMode=this.objectMode||!!t.readableObjectMode);var n=t.highWaterMark,a=t.readableHighWaterMark,o=this.objectMode?16:16384;n||0===n?this.highWaterMark=n:i&&(a||0===a)?this.highWaterMark=a:this.highWaterMark=o,this.highWaterMark=Math.floor(this.highWaterMark),this.buffer=new F,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.destroyed=!1,this.defaultEncoding=t.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,t.encoding&&(K||(K=e("string_decoder/").StringDecoder),this.decoder=new K(t.encoding),this.encoding=t.encoding)}function f(t){return T=T||e("./_stream_duplex"),this instanceof f?(this._readableState=new s(t,this),this.readable=!0,t&&("function"==typeof t.read&&(this._read=t.read),"function"==typeof t.destroy&&(this._destroy=t.destroy)),void D.call(this)):new f(t)}function c(e,t,r,i,a){var o=e._readableState;if(null===t)o.reading=!1,b(e,o);else{var s;a||(s=h(o,t)),s?e.emit("error",s):o.objectMode||t&&t.length>0?("string"==typeof t||o.objectMode||Object.getPrototypeOf(t)===L.prototype||(t=n(t)),i?o.endEmitted?e.emit("error",new Error("stream.unshift() after end event")):u(e,o,t,!0):o.ended?e.emit("error",new Error("stream.push() after EOF")):(o.reading=!1,o.decoder&&!r?(t=o.decoder.write(t),o.objectMode||0!==t.length?u(e,o,t,!1):g(e,o)):u(e,o,t,!1))):i||(o.reading=!1)}return d(o)}function u(e,t,r,i){t.flowing&&0===t.length&&!t.sync?(e.emit("data",r),e.read(0)):(t.length+=t.objectMode?1:r.length,i?t.buffer.unshift(r):t.buffer.push(r),t.needReadable&&y(e)),g(e,t)}function h(e,t){var r;return a(t)||"string"==typeof t||void 0===t||e.objectMode||(r=new TypeError("Invalid non-string/buffer chunk")),r}function d(e){return!e.ended&&(e.needReadable||e.length<e.highWaterMark||0===e.length)}function l(e){return e>=V?e=V:(e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e++),e}function p(e,t){return 0>=e||0===t.length&&t.ended?0:t.objectMode?1:e!==e?t.flowing&&t.length?t.buffer.head.data.length:t.length:(e>t.highWaterMark&&(t.highWaterMark=l(e)),e<=t.length?e:t.ended?t.length:(t.needReadable=!0,0))}function b(e,t){if(!t.ended){if(t.decoder){var r=t.decoder.end();r&&r.length&&(t.buffer.push(r),t.length+=t.objectMode?1:r.length)}t.ended=!0,y(e)}}function y(e){var t=e._readableState;t.needReadable=!1,t.emittedReadable||(z("emitReadable",t.flowing),t.emittedReadable=!0,t.sync?C.nextTick(m,e):m(e))}function m(e){z("emit readable"),e.emit("readable"),E(e)}function g(e,t){t.readingMore||(t.readingMore=!0,C.nextTick(v,e,t))}function v(e,t){for(var r=t.length;!t.reading&&!t.flowing&&!t.ended&&t.length<t.highWaterMark&&(z("maybeReadMore read 0"),e.read(0),r!==t.length);)r=t.length;t.readingMore=!1}function w(e){return function(){var t=e._readableState;z("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&P(e,"data")&&(t.flowing=!0,E(e))}}function _(e){z("readable nexttick read 0"),e.read(0)}function S(e,t){t.resumeScheduled||(t.resumeScheduled=!0,C.nextTick(M,e,t))}function M(e,t){t.reading||(z("resume read 0"),e.read(0)),t.resumeScheduled=!1,t.awaitDrain=0,e.emit("resume"),E(e),t.flowing&&!t.reading&&e.read(0)}function E(e){var t=e._readableState;for(z("flow",t.flowing);t.flowing&&null!==e.read(););}function k(e,t){if(0===t.length)return null;var r;return t.objectMode?r=t.buffer.shift():!e||e>=t.length?(r=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.head.data:t.buffer.concat(t.length),t.buffer.clear()):r=x(e,t.buffer,t.decoder),r}function x(e,t,r){var i;return e<t.head.data.length?(i=t.head.data.slice(0,e),t.head.data=t.head.data.slice(e)):i=e===t.head.data.length?t.shift():r?A(e,t):j(e,t),i}function A(e,t){var r=t.head,i=1,n=r.data;for(e-=n.length;r=r.next;){var a=r.data,o=e>a.length?a.length:e;if(n+=o===a.length?a:a.slice(0,e),e-=o,0===e){o===a.length?(++i,r.next?t.head=r.next:t.head=t.tail=null):(t.head=r,r.data=a.slice(o));break}++i}return t.length-=i,n}function j(e,t){var r=L.allocUnsafe(e),i=t.head,n=1;for(i.data.copy(r),e-=i.data.length;i=i.next;){var a=i.data,o=e>a.length?a.length:e;if(a.copy(r,r.length-e,0,o),e-=o,0===e){o===a.length?(++n,i.next?t.head=i.next:t.head=t.tail=null):(t.head=i,i.data=a.slice(o));break}++n}return t.length-=n,r}function B(e){var t=e._readableState;if(t.length>0)throw new Error('"endReadable()" called on non-empty stream');t.endEmitted||(t.ended=!0,C.nextTick(I,t,e))}function I(e,t){e.endEmitted||0!==e.length||(e.endEmitted=!0,t.readable=!1,t.emit("end"))}function R(e,t){for(var r=0,i=e.length;i>r;r++)if(e[r]===t)return r;return-1}var C=e("process-nextick-args");t.exports=f;var T,O=e("isarray");f.ReadableState=s;var P=(e("events").EventEmitter,function(e,t){return e.listeners(t).length}),D=e("./internal/streams/stream"),L=e("safe-buffer").Buffer,N=i.Uint8Array||function(){},q=e("core-util-is");q.inherits=e("inherits");var U=e("util"),z=void 0;z=U&&U.debuglog?U.debuglog("stream"):function(){};var K,F=e("./internal/streams/BufferList"),H=e("./internal/streams/destroy");q.inherits(f,D);var W=["error","close","destroy","pause","resume"];Object.defineProperty(f.prototype,"destroyed",{get:function(){return void 0===this._readableState?!1:this._readableState.destroyed},set:function(e){this._readableState&&(this._readableState.destroyed=e)}}),f.prototype.destroy=H.destroy,f.prototype._undestroy=H.undestroy,f.prototype._destroy=function(e,t){this.push(null),t(e)},f.prototype.push=function(e,t){var r,i=this._readableState;return i.objectMode?r=!0:"string"==typeof e&&(t=t||i.defaultEncoding,t!==i.encoding&&(e=L.from(e,t),t=""),r=!0),c(this,e,t,!1,r)},f.prototype.unshift=function(e){return c(this,e,null,!0,!1)},f.prototype.isPaused=function(){return this._readableState.flowing===!1},f.prototype.setEncoding=function(t){return K||(K=e("string_decoder/").StringDecoder),this._readableState.decoder=new K(t),this._readableState.encoding=t,this};var V=8388608;f.prototype.read=function(e){z("read",e),e=parseInt(e,10);var t=this._readableState,r=e;if(0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&(t.length>=t.highWaterMark||t.ended))return z("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?B(this):y(this),null;if(e=p(e,t),0===e&&t.ended)return 0===t.length&&B(this),null;var i=t.needReadable;z("need readable",i),(0===t.length||t.length-e<t.highWaterMark)&&(i=!0,z("length less than watermark",i)),t.ended||t.reading?(i=!1,z("reading or ended",i)):i&&(z("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,t.reading||(e=p(r,t)));var n;return n=e>0?k(e,t):null,null===n?(t.needReadable=!0,e=0):t.length-=e,0===t.length&&(t.ended||(t.needReadable=!0),r!==e&&t.ended&&B(this)),null!==n&&this.emit("data",n),n},f.prototype._read=function(e){this.emit("error",new Error("_read() is not implemented"))},f.prototype.pipe=function(e,t){function i(e,t){z("onunpipe"),e===d&&t&&t.hasUnpiped===!1&&(t.hasUnpiped=!0,a())}function n(){z("onend"),e.end()}function a(){z("cleanup"),e.removeListener("close",c),e.removeListener("finish",u),e.removeListener("drain",y),e.removeListener("error",f),e.removeListener("unpipe",i),d.removeListener("end",n),d.removeListener("end",h),d.removeListener("data",s),m=!0,!l.awaitDrain||e._writableState&&!e._writableState.needDrain||y()}function s(t){z("ondata"),g=!1;var r=e.write(t);!1!==r||g||((1===l.pipesCount&&l.pipes===e||l.pipesCount>1&&-1!==R(l.pipes,e))&&!m&&(z("false write response, pause",d._readableState.awaitDrain),d._readableState.awaitDrain++,g=!0),d.pause())}function f(t){z("onerror",t),h(),e.removeListener("error",f),0===P(e,"error")&&e.emit("error",t)}function c(){e.removeListener("finish",u),h()}function u(){z("onfinish"),e.removeListener("close",c),h()}function h(){z("unpipe"),d.unpipe(e)}var d=this,l=this._readableState;switch(l.pipesCount){case 0:l.pipes=e;break;case 1:l.pipes=[l.pipes,e];break;default:l.pipes.push(e)}l.pipesCount+=1,z("pipe count=%d opts=%j",l.pipesCount,t);var p=(!t||t.end!==!1)&&e!==r.stdout&&e!==r.stderr,b=p?n:h;l.endEmitted?C.nextTick(b):d.once("end",b),e.on("unpipe",i);var y=w(d);e.on("drain",y);var m=!1,g=!1;return d.on("data",s),o(e,"error",f),e.once("close",c),e.once("finish",u),e.emit("pipe",d),l.flowing||(z("pipe resume"),d.resume()),e},f.prototype.unpipe=function(e){var t=this._readableState,r={hasUnpiped:!1};if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes?this:(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this,r),this);if(!e){var i=t.pipes,n=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var a=0;n>a;a++)i[a].emit("unpipe",this,r);return this}var o=R(t.pipes,e);return-1===o?this:(t.pipes.splice(o,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this,r),this)},f.prototype.on=function(e,t){var r=D.prototype.on.call(this,e,t);if("data"===e)this._readableState.flowing!==!1&&this.resume();else if("readable"===e){var i=this._readableState;i.endEmitted||i.readableListening||(i.readableListening=i.needReadable=!0,i.emittedReadable=!1,i.reading?i.length&&y(this):C.nextTick(_,this))}return r},f.prototype.addListener=f.prototype.on,f.prototype.resume=function(){var e=this._readableState;return e.flowing||(z("resume"),e.flowing=!0,S(this,e)),this},f.prototype.pause=function(){return z("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(z("pause"),this._readableState.flowing=!1,this.emit("pause")),this},f.prototype.wrap=function(e){var t=this,r=this._readableState,i=!1;e.on("end",function(){if(z("wrapped end"),r.decoder&&!r.ended){var e=r.decoder.end();e&&e.length&&t.push(e)}t.push(null)}),e.on("data",function(n){if(z("wrapped data"),r.decoder&&(n=r.decoder.write(n)),(!r.objectMode||null!==n&&void 0!==n)&&(r.objectMode||n&&n.length)){var a=t.push(n);a||(i=!0,e.pause())}});for(var n in e)void 0===this[n]&&"function"==typeof e[n]&&(this[n]=function(t){return function(){return e[t].apply(e,arguments)}}(n));for(var a=0;a<W.length;a++)e.on(W[a],this.emit.bind(this,W[a]));return this._read=function(t){z("wrapped _read",t),i&&(i=!1,e.resume())},this},Object.defineProperty(f.prototype,"readableHighWaterMark",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),f._fromList=k}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./_stream_duplex":153,"./internal/streams/BufferList":158,"./internal/streams/destroy":159,"./internal/streams/stream":160,_process:143,"core-util-is":51,events:86,inherits:103,isarray:105,"process-nextick-args":142,"safe-buffer":167,"string_decoder/":161,util:19}],156:[function(e,t,r){"use strict";function i(e,t){var r=this._transformState;r.transforming=!1;var i=r.writecb;if(!i)return this.emit("error",new Error("write callback called multiple times"));r.writechunk=null,r.writecb=null,null!=t&&this.push(t),i(e);var n=this._readableState;n.reading=!1,(n.needReadable||n.length<n.highWaterMark)&&this._read(n.highWaterMark)}function n(e){return this instanceof n?(s.call(this,e),this._transformState={afterTransform:i.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,e&&("function"==typeof e.transform&&(this._transform=e.transform),"function"==typeof e.flush&&(this._flush=e.flush)),void this.on("prefinish",a)):new n(e)}function a(){var e=this;"function"==typeof this._flush?this._flush(function(t,r){o(e,t,r)}):o(this,null,null)}function o(e,t,r){if(t)return e.emit("error",t);if(null!=r&&e.push(r),e._writableState.length)throw new Error("Calling transform done when ws.length != 0");if(e._transformState.transforming)throw new Error("Calling transform done when still transforming");return e.push(null)}t.exports=n;var s=e("./_stream_duplex"),f=e("core-util-is");f.inherits=e("inherits"),f.inherits(n,s),n.prototype.push=function(e,t){return this._transformState.needTransform=!1,s.prototype.push.call(this,e,t)},n.prototype._transform=function(e,t,r){throw new Error("_transform() is not implemented")},n.prototype._write=function(e,t,r){var i=this._transformState;if(i.writecb=r,i.writechunk=e,i.writeencoding=t,!i.transforming){var n=this._readableState;(i.needTransform||n.needReadable||n.length<n.highWaterMark)&&this._read(n.highWaterMark)}},n.prototype._read=function(e){var t=this._transformState;null!==t.writechunk&&t.writecb&&!t.transforming?(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform)):t.needTransform=!0},n.prototype._destroy=function(e,t){var r=this;s.prototype._destroy.call(this,e,function(e){t(e),r.emit("close")})}},{"./_stream_duplex":153,"core-util-is":51,inherits:103}],157:[function(e,t,r){(function(r,i,n){"use strict";function a(e){var t=this;this.next=null,this.entry=null,this.finish=function(){A(t,e)}}function o(e){return O.from(e)}function s(e){return O.isBuffer(e)||e instanceof P}function f(){}function c(t,r){B=B||e("./_stream_duplex"),t=t||{};var i=r instanceof B;this.objectMode=!!t.objectMode,i&&(this.objectMode=this.objectMode||!!t.writableObjectMode);var n=t.highWaterMark,o=t.writableHighWaterMark,s=this.objectMode?16:16384;n||0===n?this.highWaterMark=n:i&&(o||0===o)?this.highWaterMark=o:this.highWaterMark=s,this.highWaterMark=Math.floor(this.highWaterMark),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var f=t.decodeStrings===!1;this.decodeStrings=!f,this.defaultEncoding=t.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){g(r,e)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.bufferedRequestCount=0,this.corkedRequestsFree=new a(this)}function u(t){return B=B||e("./_stream_duplex"),L.call(u,this)||this instanceof B?(this._writableState=new c(t,this),this.writable=!0,t&&("function"==typeof t.write&&(this._write=t.write),"function"==typeof t.writev&&(this._writev=t.writev),"function"==typeof t.destroy&&(this._destroy=t.destroy),"function"==typeof t["final"]&&(this._final=t["final"])),void T.call(this)):new u(t)}function h(e,t){var r=new Error("write after end");e.emit("error",r),j.nextTick(t,r)}function d(e,t,r,i){var n=!0,a=!1;return null===r?a=new TypeError("May not write null values to stream"):"string"==typeof r||void 0===r||t.objectMode||(a=new TypeError("Invalid non-string/buffer chunk")),a&&(e.emit("error",a),j.nextTick(i,a),n=!1),n}function l(e,t,r){return e.objectMode||e.decodeStrings===!1||"string"!=typeof t||(t=O.from(t,r)),t}function p(e,t,r,i,n,a){if(!r){var o=l(t,i,n);i!==o&&(r=!0,n="buffer",i=o)}var s=t.objectMode?1:i.length;t.length+=s;var f=t.length<t.highWaterMark;if(f||(t.needDrain=!0),t.writing||t.corked){var c=t.lastBufferedRequest;t.lastBufferedRequest={chunk:i,encoding:n,isBuf:r,callback:a,next:null},c?c.next=t.lastBufferedRequest:t.bufferedRequest=t.lastBufferedRequest,t.bufferedRequestCount+=1}else b(e,t,!1,s,i,n,a);return f}function b(e,t,r,i,n,a,o){t.writelen=i,t.writecb=o,t.writing=!0,t.sync=!0,r?e._writev(n,t.onwrite):e._write(n,a,t.onwrite),t.sync=!1}function y(e,t,r,i,n){--t.pendingcb,r?(j.nextTick(n,i),j.nextTick(k,e,t),e._writableState.errorEmitted=!0,e.emit("error",i)):(n(i),e._writableState.errorEmitted=!0,e.emit("error",i),k(e,t))}function m(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0}function g(e,t){var r=e._writableState,i=r.sync,n=r.writecb;if(m(r),t)y(e,r,i,t,n);else{var a=S(r);a||r.corked||r.bufferProcessing||!r.bufferedRequest||_(e,r),i?I(v,e,r,a,n):v(e,r,a,n)}}function v(e,t,r,i){r||w(e,t),t.pendingcb--,i(),k(e,t)}function w(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"))}function _(e,t){t.bufferProcessing=!0;var r=t.bufferedRequest;if(e._writev&&r&&r.next){var i=t.bufferedRequestCount,n=new Array(i),o=t.corkedRequestsFree;o.entry=r;for(var s=0,f=!0;r;)n[s]=r,r.isBuf||(f=!1),r=r.next,s+=1;n.allBuffers=f,b(e,t,!0,t.length,n,"",o.finish),t.pendingcb++,t.lastBufferedRequest=null,o.next?(t.corkedRequestsFree=o.next,o.next=null):t.corkedRequestsFree=new a(t),t.bufferedRequestCount=0}else{for(;r;){var c=r.chunk,u=r.encoding,h=r.callback,d=t.objectMode?1:c.length;if(b(e,t,!1,d,c,u,h),r=r.next,t.bufferedRequestCount--,t.writing)break}null===r&&(t.lastBufferedRequest=null)}t.bufferedRequest=r,t.bufferProcessing=!1}function S(e){return e.ending&&0===e.length&&null===e.bufferedRequest&&!e.finished&&!e.writing}function M(e,t){e._final(function(r){t.pendingcb--,r&&e.emit("error",r),t.prefinished=!0,e.emit("prefinish"),k(e,t)})}function E(e,t){t.prefinished||t.finalCalled||("function"==typeof e._final?(t.pendingcb++,t.finalCalled=!0,j.nextTick(M,e,t)):(t.prefinished=!0,e.emit("prefinish")))}function k(e,t){var r=S(t);return r&&(E(e,t),0===t.pendingcb&&(t.finished=!0,e.emit("finish"))),r}function x(e,t,r){t.ending=!0,k(e,t),r&&(t.finished?j.nextTick(r):e.once("finish",r)),t.ended=!0,e.writable=!1}function A(e,t,r){var i=e.entry;for(e.entry=null;i;){var n=i.callback;t.pendingcb--,n(r),i=i.next}t.corkedRequestsFree?t.corkedRequestsFree.next=e:t.corkedRequestsFree=e}var j=e("process-nextick-args");t.exports=u;var B,I=!r.browser&&["v0.10","v0.9."].indexOf(r.version.slice(0,5))>-1?n:j.nextTick;u.WritableState=c;var R=e("core-util-is");R.inherits=e("inherits");var C={deprecate:e("util-deprecate")},T=e("./internal/streams/stream"),O=e("safe-buffer").Buffer,P=i.Uint8Array||function(){},D=e("./internal/streams/destroy");R.inherits(u,T),c.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=[];e;)t.push(e),e=e.next;return t},function(){try{Object.defineProperty(c.prototype,"buffer",{get:C.deprecate(function(){return this.getBuffer()},"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(e){}}();var L;"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(L=Function.prototype[Symbol.hasInstance],Object.defineProperty(u,Symbol.hasInstance,{value:function(e){return L.call(this,e)?!0:this!==u?!1:e&&e._writableState instanceof c}})):L=function(e){return e instanceof this},u.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe, not readable"))},u.prototype.write=function(e,t,r){var i=this._writableState,n=!1,a=!i.objectMode&&s(e);return a&&!O.isBuffer(e)&&(e=o(e)),"function"==typeof t&&(r=t,t=null),a?t="buffer":t||(t=i.defaultEncoding),"function"!=typeof r&&(r=f),i.ended?h(this,r):(a||d(this,i,e,r))&&(i.pendingcb++,n=p(this,i,a,e,t,r)),n},u.prototype.cork=function(){var e=this._writableState;e.corked++},u.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.finished||e.bufferProcessing||!e.bufferedRequest||_(this,e))},u.prototype.setDefaultEncoding=function(e){if("string"==typeof e&&(e=e.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((e+"").toLowerCase())>-1))throw new TypeError("Unknown encoding: "+e);return this._writableState.defaultEncoding=e,this},Object.defineProperty(u.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),u.prototype._write=function(e,t,r){r(new Error("_write() is not implemented"))},u.prototype._writev=null,u.prototype.end=function(e,t,r){var i=this._writableState;"function"==typeof e?(r=e,e=null,t=null):"function"==typeof t&&(r=t,t=null),null!==e&&void 0!==e&&this.write(e,t),i.corked&&(i.corked=1,this.uncork()),i.ending||i.finished||x(this,i,r)},Object.defineProperty(u.prototype,"destroyed",{get:function(){return void 0===this._writableState?!1:this._writableState.destroyed},set:function(e){this._writableState&&(this._writableState.destroyed=e)}}),u.prototype.destroy=D.destroy,u.prototype._undestroy=D.undestroy,u.prototype._destroy=function(e,t){this.end(),t(e)}}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("timers").setImmediate)},{"./_stream_duplex":153,"./internal/streams/destroy":159,"./internal/streams/stream":160,_process:143,"core-util-is":51,inherits:103,"process-nextick-args":142,"safe-buffer":167,timers:178,"util-deprecate":179}],158:[function(e,t,r){"use strict";function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n(e,t,r){e.copy(t,r)}var a=e("safe-buffer").Buffer,o=e("util");t.exports=function(){function e(){i(this,e),this.head=null,this.tail=null,this.length=0}return e.prototype.push=function(e){var t={data:e,next:null};this.length>0?this.tail.next=t:this.head=t,this.tail=t,++this.length},e.prototype.unshift=function(e){var t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length},e.prototype.shift=function(){if(0!==this.length){var e=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,e}},e.prototype.clear=function(){this.head=this.tail=null,this.length=0},e.prototype.join=function(e){if(0===this.length)return"";for(var t=this.head,r=""+t.data;t=t.next;)r+=e+t.data;return r},e.prototype.concat=function(e){if(0===this.length)return a.alloc(0);if(1===this.length)return this.head.data;for(var t=a.allocUnsafe(e>>>0),r=this.head,i=0;r;)n(r.data,t,i),i+=r.data.length,r=r.next;return t},e}(),o&&o.inspect&&o.inspect.custom&&(t.exports.prototype[o.inspect.custom]=function(){var e=o.inspect({length:this.length});return this.constructor.name+" "+e})},{"safe-buffer":167,util:19}],159:[function(e,t,r){"use strict";function i(e,t){var r=this,i=this._readableState&&this._readableState.destroyed,n=this._writableState&&this._writableState.destroyed;return i||n?(t?t(e):!e||this._writableState&&this._writableState.errorEmitted||o.nextTick(a,this,e),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(e||null,function(e){!t&&e?(o.nextTick(a,r,e),r._writableState&&(r._writableState.errorEmitted=!0)):t&&t(e)}),this)}function n(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)}function a(e,t){e.emit("error",t)}var o=e("process-nextick-args");t.exports={destroy:i,undestroy:n}},{"process-nextick-args":142}],160:[function(e,t,r){t.exports=e("events").EventEmitter},{events:86}],161:[function(e,t,r){"use strict";function i(e){if(!e)return"utf8";for(var t;;)switch(e){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return e;default:if(t)return;e=(""+e).toLowerCase(),t=!0}}function n(e){var t=i(e);if("string"!=typeof t&&(g.isEncoding===v||!v(e)))throw new Error("Unknown encoding: "+e);return t||e}function a(e){this.encoding=n(e);var t;switch(this.encoding){case"utf16le":this.text=d,this.end=l,t=4;break;case"utf8":this.fillLast=c,t=4;break;case"base64":this.text=p,this.end=b,t=3;break;default:return this.write=y,void(this.end=m)}this.lastNeed=0,this.lastTotal=0,this.lastChar=g.allocUnsafe(t)}function o(e){return 127>=e?0:e>>5===6?2:e>>4===14?3:e>>3===30?4:e>>6===2?-1:-2}function s(e,t,r){var i=t.length-1;if(r>i)return 0;var n=o(t[i]);return n>=0?(n>0&&(e.lastNeed=n-1),n):--i<r||-2===n?0:(n=o(t[i]),n>=0?(n>0&&(e.lastNeed=n-2),n):--i<r||-2===n?0:(n=o(t[i]),n>=0?(n>0&&(2===n?n=0:e.lastNeed=n-3),n):0))}function f(e,t,r){if(128!==(192&t[0]))return e.lastNeed=0,"";if(e.lastNeed>1&&t.length>1){if(128!==(192&t[1]))return e.lastNeed=1,"";if(e.lastNeed>2&&t.length>2&&128!==(192&t[2]))return e.lastNeed=2,""}}function c(e){var t=this.lastTotal-this.lastNeed,r=f(this,e,t);return void 0!==r?r:this.lastNeed<=e.length?(e.copy(this.lastChar,t,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(e.copy(this.lastChar,t,0,e.length),void(this.lastNeed-=e.length))}function u(e,t){var r=s(this,e,t);if(!this.lastNeed)return e.toString("utf8",t);this.lastTotal=r;var i=e.length-(r-this.lastNeed);return e.copy(this.lastChar,0,i),e.toString("utf8",t,i)}function h(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+"":t}function d(e,t){if((e.length-t)%2===0){var r=e.toString("utf16le",t);if(r){var i=r.charCodeAt(r.length-1);if(i>=55296&&56319>=i)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1],r.slice(0,-1)}return r}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=e[e.length-1],e.toString("utf16le",t,e.length-1)}function l(e){var t=e&&e.length?this.write(e):"";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return t+this.lastChar.toString("utf16le",0,r)}return t}function p(e,t){var r=(e.length-t)%3;return 0===r?e.toString("base64",t):(this.lastNeed=3-r,this.lastTotal=3,1===r?this.lastChar[0]=e[e.length-1]:(this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1]),e.toString("base64",t,e.length-r))}function b(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+this.lastChar.toString("base64",0,3-this.lastNeed):t}function y(e){return e.toString(this.encoding)}function m(e){return e&&e.length?this.write(e):""}var g=e("safe-buffer").Buffer,v=g.isEncoding||function(e){switch(e=""+e,e&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};r.StringDecoder=a,a.prototype.write=function(e){if(0===e.length)return"";var t,r;if(this.lastNeed){if(t=this.fillLast(e),void 0===t)return"";r=this.lastNeed,this.lastNeed=0}else r=0;return r<e.length?t?t+this.text(e,r):this.text(e,r):t||""},a.prototype.end=h,a.prototype.text=u,a.prototype.fillLast=function(e){return this.lastNeed<=e.length?(e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,e.length),void(this.lastNeed-=e.length))}},{"safe-buffer":167}],162:[function(e,t,r){t.exports=e("./readable").PassThrough},{"./readable":163}],163:[function(e,t,r){r=t.exports=e("./lib/_stream_readable.js"),r.Stream=r,r.Readable=r,r.Writable=e("./lib/_stream_writable.js"),r.Duplex=e("./lib/_stream_duplex.js"),r.Transform=e("./lib/_stream_transform.js"),r.PassThrough=e("./lib/_stream_passthrough.js")},{"./lib/_stream_duplex.js":153,"./lib/_stream_passthrough.js":154,"./lib/_stream_readable.js":155,"./lib/_stream_transform.js":156,"./lib/_stream_writable.js":157}],164:[function(e,t,r){t.exports=e("./readable").Transform},{"./readable":163}],165:[function(e,t,r){t.exports=e("./lib/_stream_writable.js")},{"./lib/_stream_writable.js":157}],166:[function(e,t,r){"use strict";function i(){d.call(this,64),this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520}function n(e,t){return e<<t|e>>>32-t}function a(e,t,r,i,a,o,s,f){return n(e+(t^r^i)+o+s|0,f)+a|0}function o(e,t,r,i,a,o,s,f){return n(e+(t&r|~t&i)+o+s|0,f)+a|0}function s(e,t,r,i,a,o,s,f){return n(e+((t|~r)^i)+o+s|0,f)+a|0}function f(e,t,r,i,a,o,s,f){return n(e+(t&i|r&~i)+o+s|0,f)+a|0}function c(e,t,r,i,a,o,s,f){return n(e+(t^(r|~i))+o+s|0,f)+a|0}var u=e("buffer").Buffer,h=e("inherits"),d=e("hash-base"),l=new Array(16),p=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],b=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],y=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],m=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11],g=[0,1518500249,1859775393,2400959708,2840853838],v=[1352829926,1548603684,1836072691,2053994217,0];
h(i,d),i.prototype._update=function(){for(var e=l,t=0;16>t;++t)e[t]=this._block.readInt32LE(4*t);for(var r=0|this._a,i=0|this._b,u=0|this._c,h=0|this._d,d=0|this._e,w=0|this._a,_=0|this._b,S=0|this._c,M=0|this._d,E=0|this._e,k=0;80>k;k+=1){var x,A;16>k?(x=a(r,i,u,h,d,e[p[k]],g[0],y[k]),A=c(w,_,S,M,E,e[b[k]],v[0],m[k])):32>k?(x=o(r,i,u,h,d,e[p[k]],g[1],y[k]),A=f(w,_,S,M,E,e[b[k]],v[1],m[k])):48>k?(x=s(r,i,u,h,d,e[p[k]],g[2],y[k]),A=s(w,_,S,M,E,e[b[k]],v[2],m[k])):64>k?(x=f(r,i,u,h,d,e[p[k]],g[3],y[k]),A=o(w,_,S,M,E,e[b[k]],v[3],m[k])):(x=c(r,i,u,h,d,e[p[k]],g[4],y[k]),A=a(w,_,S,M,E,e[b[k]],v[4],m[k])),r=d,d=h,h=n(u,10),u=i,i=x,w=E,E=M,M=n(S,10),S=_,_=A}var j=this._b+u+M|0;this._b=this._c+h+E|0,this._c=this._d+d+w|0,this._d=this._e+r+_|0,this._e=this._a+i+S|0,this._a=j},i.prototype._digest=function(){this._block[this._blockOffset++]=128,this._blockOffset>56&&(this._block.fill(0,this._blockOffset,64),this._update(),this._blockOffset=0),this._block.fill(0,this._blockOffset,56),this._block.writeUInt32LE(this._length[0],56),this._block.writeUInt32LE(this._length[1],60),this._update();var e=u.alloc?u.alloc(20):new u(20);return e.writeInt32LE(this._a,0),e.writeInt32LE(this._b,4),e.writeInt32LE(this._c,8),e.writeInt32LE(this._d,12),e.writeInt32LE(this._e,16),e},t.exports=i},{buffer:49,"hash-base":88,inherits:103}],167:[function(e,t,r){function i(e,t){for(var r in e)t[r]=e[r]}function n(e,t,r){return o(e,t,r)}var a=e("buffer"),o=a.Buffer;o.from&&o.alloc&&o.allocUnsafe&&o.allocUnsafeSlow?t.exports=a:(i(a,r),r.Buffer=n),i(o,n),n.from=function(e,t,r){if("number"==typeof e)throw new TypeError("Argument must not be a number");return o(e,t,r)},n.alloc=function(e,t,r){if("number"!=typeof e)throw new TypeError("Argument must be a number");var i=o(e);return void 0!==t?"string"==typeof r?i.fill(t,r):i.fill(t):i.fill(0),i},n.allocUnsafe=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return o(e)},n.allocUnsafeSlow=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return a.SlowBuffer(e)}},{buffer:49}],168:[function(e,t,r){function i(e,t){this._block=n.alloc(e),this._finalSize=t,this._blockSize=e,this._len=0}var n=e("safe-buffer").Buffer;i.prototype.update=function(e,t){"string"==typeof e&&(t=t||"utf8",e=n.from(e,t));for(var r=this._block,i=this._blockSize,a=e.length,o=this._len,s=0;a>s;){for(var f=o%i,c=Math.min(a-s,i-f),u=0;c>u;u++)r[f+u]=e[s+u];o+=c,s+=c,o%i===0&&this._update(r)}return this._len+=a,this},i.prototype.digest=function(e){var t=this._len%this._blockSize;this._block[t]=128,this._block.fill(0,t+1),t>=this._finalSize&&(this._update(this._block),this._block.fill(0));var r=8*this._len;if(4294967295>=r)this._block.writeUInt32BE(r,this._blockSize-4);else{var i=(4294967295&r)>>>0,n=(r-i)/4294967296;this._block.writeUInt32BE(n,this._blockSize-8),this._block.writeUInt32BE(i,this._blockSize-4)}this._update(this._block);var a=this._hash();return e?a.toString(e):a},i.prototype._update=function(){throw new Error("_update must be implemented by subclass")},t.exports=i},{"safe-buffer":167}],169:[function(e,t,r){var r=t.exports=function(e){e=e.toLowerCase();var t=r[e];if(!t)throw new Error(e+" is not supported (we accept pull requests)");return new t};r.sha=e("./sha"),r.sha1=e("./sha1"),r.sha224=e("./sha224"),r.sha256=e("./sha256"),r.sha384=e("./sha384"),r.sha512=e("./sha512")},{"./sha":170,"./sha1":171,"./sha224":172,"./sha256":173,"./sha384":174,"./sha512":175}],170:[function(e,t,r){function i(){this.init(),this._w=h,f.call(this,64,56)}function n(e){return e<<5|e>>>27}function a(e){return e<<30|e>>>2}function o(e,t,r,i){return 0===e?t&r|~t&i:2===e?t&r|t&i|r&i:t^r^i}var s=e("inherits"),f=e("./hash"),c=e("safe-buffer").Buffer,u=[1518500249,1859775393,-1894007588,-899497514],h=new Array(80);s(i,f),i.prototype.init=function(){return this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520,this},i.prototype._update=function(e){for(var t=this._w,r=0|this._a,i=0|this._b,s=0|this._c,f=0|this._d,c=0|this._e,h=0;16>h;++h)t[h]=e.readInt32BE(4*h);for(;80>h;++h)t[h]=t[h-3]^t[h-8]^t[h-14]^t[h-16];for(var d=0;80>d;++d){var l=~~(d/20),p=n(r)+o(l,i,s,f)+c+t[d]+u[l]|0;c=f,f=s,s=a(i),i=r,r=p}this._a=r+this._a|0,this._b=i+this._b|0,this._c=s+this._c|0,this._d=f+this._d|0,this._e=c+this._e|0},i.prototype._hash=function(){var e=c.allocUnsafe(20);return e.writeInt32BE(0|this._a,0),e.writeInt32BE(0|this._b,4),e.writeInt32BE(0|this._c,8),e.writeInt32BE(0|this._d,12),e.writeInt32BE(0|this._e,16),e},t.exports=i},{"./hash":168,inherits:103,"safe-buffer":167}],171:[function(e,t,r){function i(){this.init(),this._w=d,c.call(this,64,56)}function n(e){return e<<1|e>>>31}function a(e){return e<<5|e>>>27}function o(e){return e<<30|e>>>2}function s(e,t,r,i){return 0===e?t&r|~t&i:2===e?t&r|t&i|r&i:t^r^i}var f=e("inherits"),c=e("./hash"),u=e("safe-buffer").Buffer,h=[1518500249,1859775393,-1894007588,-899497514],d=new Array(80);f(i,c),i.prototype.init=function(){return this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520,this},i.prototype._update=function(e){for(var t=this._w,r=0|this._a,i=0|this._b,f=0|this._c,c=0|this._d,u=0|this._e,d=0;16>d;++d)t[d]=e.readInt32BE(4*d);for(;80>d;++d)t[d]=n(t[d-3]^t[d-8]^t[d-14]^t[d-16]);for(var l=0;80>l;++l){var p=~~(l/20),b=a(r)+s(p,i,f,c)+u+t[l]+h[p]|0;u=c,c=f,f=o(i),i=r,r=b}this._a=r+this._a|0,this._b=i+this._b|0,this._c=f+this._c|0,this._d=c+this._d|0,this._e=u+this._e|0},i.prototype._hash=function(){var e=u.allocUnsafe(20);return e.writeInt32BE(0|this._a,0),e.writeInt32BE(0|this._b,4),e.writeInt32BE(0|this._c,8),e.writeInt32BE(0|this._d,12),e.writeInt32BE(0|this._e,16),e},t.exports=i},{"./hash":168,inherits:103,"safe-buffer":167}],172:[function(e,t,r){function i(){this.init(),this._w=f,o.call(this,64,56)}var n=e("inherits"),a=e("./sha256"),o=e("./hash"),s=e("safe-buffer").Buffer,f=new Array(64);n(i,a),i.prototype.init=function(){return this._a=3238371032,this._b=914150663,this._c=812702999,this._d=4144912697,this._e=4290775857,this._f=1750603025,this._g=1694076839,this._h=3204075428,this},i.prototype._hash=function(){var e=s.allocUnsafe(28);return e.writeInt32BE(this._a,0),e.writeInt32BE(this._b,4),e.writeInt32BE(this._c,8),e.writeInt32BE(this._d,12),e.writeInt32BE(this._e,16),e.writeInt32BE(this._f,20),e.writeInt32BE(this._g,24),e},t.exports=i},{"./hash":168,"./sha256":173,inherits:103,"safe-buffer":167}],173:[function(e,t,r){function i(){this.init(),this._w=p,h.call(this,64,56)}function n(e,t,r){return r^e&(t^r)}function a(e,t,r){return e&t|r&(e|t)}function o(e){return(e>>>2|e<<30)^(e>>>13|e<<19)^(e>>>22|e<<10)}function s(e){return(e>>>6|e<<26)^(e>>>11|e<<21)^(e>>>25|e<<7)}function f(e){return(e>>>7|e<<25)^(e>>>18|e<<14)^e>>>3}function c(e){return(e>>>17|e<<15)^(e>>>19|e<<13)^e>>>10}var u=e("inherits"),h=e("./hash"),d=e("safe-buffer").Buffer,l=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],p=new Array(64);u(i,h),i.prototype.init=function(){return this._a=1779033703,this._b=3144134277,this._c=1013904242,this._d=2773480762,this._e=1359893119,this._f=2600822924,this._g=528734635,this._h=1541459225,this},i.prototype._update=function(e){for(var t=this._w,r=0|this._a,i=0|this._b,u=0|this._c,h=0|this._d,d=0|this._e,p=0|this._f,b=0|this._g,y=0|this._h,m=0;16>m;++m)t[m]=e.readInt32BE(4*m);for(;64>m;++m)t[m]=c(t[m-2])+t[m-7]+f(t[m-15])+t[m-16]|0;for(var g=0;64>g;++g){var v=y+s(d)+n(d,p,b)+l[g]+t[g]|0,w=o(r)+a(r,i,u)|0;y=b,b=p,p=d,d=h+v|0,h=u,u=i,i=r,r=v+w|0}this._a=r+this._a|0,this._b=i+this._b|0,this._c=u+this._c|0,this._d=h+this._d|0,this._e=d+this._e|0,this._f=p+this._f|0,this._g=b+this._g|0,this._h=y+this._h|0},i.prototype._hash=function(){var e=d.allocUnsafe(32);return e.writeInt32BE(this._a,0),e.writeInt32BE(this._b,4),e.writeInt32BE(this._c,8),e.writeInt32BE(this._d,12),e.writeInt32BE(this._e,16),e.writeInt32BE(this._f,20),e.writeInt32BE(this._g,24),e.writeInt32BE(this._h,28),e},t.exports=i},{"./hash":168,inherits:103,"safe-buffer":167}],174:[function(e,t,r){function i(){this.init(),this._w=f,o.call(this,128,112)}var n=e("inherits"),a=e("./sha512"),o=e("./hash"),s=e("safe-buffer").Buffer,f=new Array(160);n(i,a),i.prototype.init=function(){return this._ah=3418070365,this._bh=1654270250,this._ch=2438529370,this._dh=355462360,this._eh=1731405415,this._fh=2394180231,this._gh=3675008525,this._hh=1203062813,this._al=3238371032,this._bl=914150663,this._cl=812702999,this._dl=4144912697,this._el=4290775857,this._fl=1750603025,this._gl=1694076839,this._hl=3204075428,this},i.prototype._hash=function(){function e(e,r,i){t.writeInt32BE(e,i),t.writeInt32BE(r,i+4)}var t=s.allocUnsafe(48);return e(this._ah,this._al,0),e(this._bh,this._bl,8),e(this._ch,this._cl,16),e(this._dh,this._dl,24),e(this._eh,this._el,32),e(this._fh,this._fl,40),t},t.exports=i},{"./hash":168,"./sha512":175,inherits:103,"safe-buffer":167}],175:[function(e,t,r){function i(){this.init(),this._w=m,p.call(this,128,112)}function n(e,t,r){return r^e&(t^r)}function a(e,t,r){return e&t|r&(e|t)}function o(e,t){return(e>>>28|t<<4)^(t>>>2|e<<30)^(t>>>7|e<<25)}function s(e,t){return(e>>>14|t<<18)^(e>>>18|t<<14)^(t>>>9|e<<23)}function f(e,t){return(e>>>1|t<<31)^(e>>>8|t<<24)^e>>>7}function c(e,t){return(e>>>1|t<<31)^(e>>>8|t<<24)^(e>>>7|t<<25)}function u(e,t){return(e>>>19|t<<13)^(t>>>29|e<<3)^e>>>6}function h(e,t){return(e>>>19|t<<13)^(t>>>29|e<<3)^(e>>>6|t<<26)}function d(e,t){return t>>>0>e>>>0?1:0}var l=e("inherits"),p=e("./hash"),b=e("safe-buffer").Buffer,y=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591],m=new Array(160);l(i,p),i.prototype.init=function(){return this._ah=1779033703,this._bh=3144134277,this._ch=1013904242,this._dh=2773480762,this._eh=1359893119,this._fh=2600822924,this._gh=528734635,this._hh=1541459225,this._al=4089235720,this._bl=2227873595,this._cl=4271175723,this._dl=1595750129,this._el=2917565137,this._fl=725511199,this._gl=4215389547,this._hl=327033209,this},i.prototype._update=function(e){for(var t=this._w,r=0|this._ah,i=0|this._bh,l=0|this._ch,p=0|this._dh,b=0|this._eh,m=0|this._fh,g=0|this._gh,v=0|this._hh,w=0|this._al,_=0|this._bl,S=0|this._cl,M=0|this._dl,E=0|this._el,k=0|this._fl,x=0|this._gl,A=0|this._hl,j=0;32>j;j+=2)t[j]=e.readInt32BE(4*j),t[j+1]=e.readInt32BE(4*j+4);for(;160>j;j+=2){var B=t[j-30],I=t[j-30+1],R=f(B,I),C=c(I,B);B=t[j-4],I=t[j-4+1];var T=u(B,I),O=h(I,B),P=t[j-14],D=t[j-14+1],L=t[j-32],N=t[j-32+1],q=C+D|0,U=R+P+d(q,C)|0;q=q+O|0,U=U+T+d(q,O)|0,q=q+N|0,U=U+L+d(q,N)|0,t[j]=U,t[j+1]=q}for(var z=0;160>z;z+=2){U=t[z],q=t[z+1];var K=a(r,i,l),F=a(w,_,S),H=o(r,w),W=o(w,r),V=s(b,E),J=s(E,b),X=y[z],G=y[z+1],Z=n(b,m,g),Y=n(E,k,x),$=A+J|0,Q=v+V+d($,A)|0;$=$+Y|0,Q=Q+Z+d($,Y)|0,$=$+G|0,Q=Q+X+d($,G)|0,$=$+q|0,Q=Q+U+d($,q)|0;var ee=W+F|0,te=H+K+d(ee,W)|0;v=g,A=x,g=m,x=k,m=b,k=E,E=M+$|0,b=p+Q+d(E,M)|0,p=l,M=S,l=i,S=_,i=r,_=w,w=$+ee|0,r=Q+te+d(w,$)|0}this._al=this._al+w|0,this._bl=this._bl+_|0,this._cl=this._cl+S|0,this._dl=this._dl+M|0,this._el=this._el+E|0,this._fl=this._fl+k|0,this._gl=this._gl+x|0,this._hl=this._hl+A|0,this._ah=this._ah+r+d(this._al,w)|0,this._bh=this._bh+i+d(this._bl,_)|0,this._ch=this._ch+l+d(this._cl,S)|0,this._dh=this._dh+p+d(this._dl,M)|0,this._eh=this._eh+b+d(this._el,E)|0,this._fh=this._fh+m+d(this._fl,k)|0,this._gh=this._gh+g+d(this._gl,x)|0,this._hh=this._hh+v+d(this._hl,A)|0},i.prototype._hash=function(){function e(e,r,i){t.writeInt32BE(e,i),t.writeInt32BE(r,i+4)}var t=b.allocUnsafe(64);return e(this._ah,this._al,0),e(this._bh,this._bl,8),e(this._ch,this._cl,16),e(this._dh,this._dl,24),e(this._eh,this._el,32),e(this._fh,this._fl,40),e(this._gh,this._gl,48),e(this._hh,this._hl,56),t},t.exports=i},{"./hash":168,inherits:103,"safe-buffer":167}],176:[function(e,t,r){function i(){n.call(this)}t.exports=i;var n=e("events").EventEmitter,a=e("inherits");a(i,n),i.Readable=e("readable-stream/readable.js"),i.Writable=e("readable-stream/writable.js"),i.Duplex=e("readable-stream/duplex.js"),i.Transform=e("readable-stream/transform.js"),i.PassThrough=e("readable-stream/passthrough.js"),i.Stream=i,i.prototype.pipe=function(e,t){function r(t){e.writable&&!1===e.write(t)&&c.pause&&c.pause()}function i(){c.readable&&c.resume&&c.resume()}function a(){u||(u=!0,e.end())}function o(){u||(u=!0,"function"==typeof e.destroy&&e.destroy())}function s(e){if(f(),0===n.listenerCount(this,"error"))throw e}function f(){c.removeListener("data",r),e.removeListener("drain",i),c.removeListener("end",a),c.removeListener("close",o),c.removeListener("error",s),e.removeListener("error",s),c.removeListener("end",f),c.removeListener("close",f),e.removeListener("close",f)}var c=this;c.on("data",r),e.on("drain",i),e._isStdio||t&&t.end===!1||(c.on("end",a),c.on("close",o));var u=!1;return c.on("error",s),e.on("error",s),c.on("end",f),c.on("close",f),e.on("close",f),e.emit("pipe",c),e}},{events:86,inherits:103,"readable-stream/duplex.js":152,"readable-stream/passthrough.js":162,"readable-stream/readable.js":163,"readable-stream/transform.js":164,"readable-stream/writable.js":165}],177:[function(e,t,r){arguments[4][161][0].apply(r,arguments)},{dup:161,"safe-buffer":167}],178:[function(e,t,r){(function(t,i){function n(e,t){this._id=e,this._clearFn=t}var a=e("process/browser.js").nextTick,o=Function.prototype.apply,s=Array.prototype.slice,f={},c=0;r.setTimeout=function(){return new n(o.call(setTimeout,window,arguments),clearTimeout)},r.setInterval=function(){return new n(o.call(setInterval,window,arguments),clearInterval)},r.clearTimeout=r.clearInterval=function(e){e.close()},n.prototype.unref=n.prototype.ref=function(){},n.prototype.close=function(){this._clearFn.call(window,this._id)},r.enroll=function(e,t){clearTimeout(e._idleTimeoutId),e._idleTimeout=t},r.unenroll=function(e){clearTimeout(e._idleTimeoutId),e._idleTimeout=-1},r._unrefActive=r.active=function(e){clearTimeout(e._idleTimeoutId);var t=e._idleTimeout;t>=0&&(e._idleTimeoutId=setTimeout(function(){e._onTimeout&&e._onTimeout()},t))},r.setImmediate="function"==typeof t?t:function(e){var t=c++,i=arguments.length<2?!1:s.call(arguments,1);return f[t]=!0,a(function(){f[t]&&(i?e.apply(null,i):e.call(null),r.clearImmediate(t))}),t},r.clearImmediate="function"==typeof i?i:function(e){delete f[e]}}).call(this,e("timers").setImmediate,e("timers").clearImmediate)},{"process/browser.js":143,timers:178}],179:[function(e,t,r){(function(e){function r(e,t){function r(){if(!n){if(i("throwDeprecation"))throw new Error(t);i("traceDeprecation")?console.trace(t):console.warn(t),n=!0}return e.apply(this,arguments)}if(i("noDeprecation"))return e;var n=!1;return r}function i(t){try{if(!e.localStorage)return!1}catch(r){return!1}var i=e.localStorage[t];return null==i?!1:"true"===String(i).toLowerCase()}t.exports=r}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],180:[function(e,t,r){t.exports=function(e){return e&&"object"==typeof e&&"function"==typeof e.copy&&"function"==typeof e.fill&&"function"==typeof e.readUInt8}},{}],181:[function(e,t,r){(function(t,i){function n(e,t){var i={seen:[],stylize:o};return arguments.length>=3&&(i.depth=arguments[2]),arguments.length>=4&&(i.colors=arguments[3]),b(t)?i.showHidden=t:t&&r._extend(i,t),_(i.showHidden)&&(i.showHidden=!1),_(i.depth)&&(i.depth=2),_(i.colors)&&(i.colors=!1),_(i.customInspect)&&(i.customInspect=!0),i.colors&&(i.stylize=a),f(i,e,i.depth)}function a(e,t){var r=n.styles[t];return r?"["+n.colors[r][0]+"m"+e+"["+n.colors[r][1]+"m":e}function o(e,t){return e}function s(e){var t={};return e.forEach(function(e,r){t[e]=!0}),t}function f(e,t,i){if(e.customInspect&&t&&x(t.inspect)&&t.inspect!==r.inspect&&(!t.constructor||t.constructor.prototype!==t)){var n=t.inspect(i,e);return v(n)||(n=f(e,n,i)),n}var a=c(e,t);if(a)return a;var o=Object.keys(t),b=s(o);if(e.showHidden&&(o=Object.getOwnPropertyNames(t)),k(t)&&(o.indexOf("message")>=0||o.indexOf("description")>=0))return u(t);if(0===o.length){if(x(t)){var y=t.name?": "+t.name:"";return e.stylize("[Function"+y+"]","special")}if(S(t))return e.stylize(RegExp.prototype.toString.call(t),"regexp");if(E(t))return e.stylize(Date.prototype.toString.call(t),"date");if(k(t))return u(t)}var m="",g=!1,w=["{","}"];if(p(t)&&(g=!0,w=["[","]"]),x(t)){var _=t.name?": "+t.name:"";m=" [Function"+_+"]"}if(S(t)&&(m=" "+RegExp.prototype.toString.call(t)),E(t)&&(m=" "+Date.prototype.toUTCString.call(t)),k(t)&&(m=" "+u(t)),0===o.length&&(!g||0==t.length))return w[0]+m+w[1];if(0>i)return S(t)?e.stylize(RegExp.prototype.toString.call(t),"regexp"):e.stylize("[Object]","special");e.seen.push(t);var M;return M=g?h(e,t,i,b,o):o.map(function(r){return d(e,t,i,b,r,g)}),e.seen.pop(),l(M,m,w)}function c(e,t){if(_(t))return e.stylize("undefined","undefined");if(v(t)){var r="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(r,"string")}return g(t)?e.stylize(""+t,"number"):b(t)?e.stylize(""+t,"boolean"):y(t)?e.stylize("null","null"):void 0}function u(e){return"["+Error.prototype.toString.call(e)+"]"}function h(e,t,r,i,n){for(var a=[],o=0,s=t.length;s>o;++o)R(t,String(o))?a.push(d(e,t,r,i,String(o),!0)):a.push("");return n.forEach(function(n){n.match(/^\d+$/)||a.push(d(e,t,r,i,n,!0))}),a}function d(e,t,r,i,n,a){var o,s,c;if(c=Object.getOwnPropertyDescriptor(t,n)||{value:t[n]},c.get?s=c.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):c.set&&(s=e.stylize("[Setter]","special")),R(i,n)||(o="["+n+"]"),s||(e.seen.indexOf(c.value)<0?(s=y(r)?f(e,c.value,null):f(e,c.value,r-1),s.indexOf("\n")>-1&&(s=a?s.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+s.split("\n").map(function(e){return"   "+e}).join("\n"))):s=e.stylize("[Circular]","special")),_(o)){if(a&&n.match(/^\d+$/))return s;o=JSON.stringify(""+n),o.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(o=o.substr(1,o.length-2),o=e.stylize(o,"name")):(o=o.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),o=e.stylize(o,"string"))}return o+": "+s}function l(e,t,r){var i=0,n=e.reduce(function(e,t){return i++,t.indexOf("\n")>=0&&i++,e+t.replace(/\u001b\[\d\d?m/g,"").length+1},0);return n>60?r[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+r[1]:r[0]+t+" "+e.join(", ")+" "+r[1]}function p(e){return Array.isArray(e)}function b(e){return"boolean"==typeof e}function y(e){return null===e}function m(e){return null==e}function g(e){return"number"==typeof e}function v(e){return"string"==typeof e}function w(e){return"symbol"==typeof e}function _(e){return void 0===e}function S(e){return M(e)&&"[object RegExp]"===j(e)}function M(e){return"object"==typeof e&&null!==e}function E(e){return M(e)&&"[object Date]"===j(e)}function k(e){return M(e)&&("[object Error]"===j(e)||e instanceof Error)}function x(e){return"function"==typeof e}function A(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||"undefined"==typeof e}function j(e){return Object.prototype.toString.call(e)}function B(e){return 10>e?"0"+e.toString(10):e.toString(10)}function I(){var e=new Date,t=[B(e.getHours()),B(e.getMinutes()),B(e.getSeconds())].join(":");return[e.getDate(),P[e.getMonth()],t].join(" ")}function R(e,t){return Object.prototype.hasOwnProperty.call(e,t)}var C=/%[sdj%]/g;r.format=function(e){if(!v(e)){for(var t=[],r=0;r<arguments.length;r++)t.push(n(arguments[r]));return t.join(" ")}for(var r=1,i=arguments,a=i.length,o=String(e).replace(C,function(e){if("%%"===e)return"%";if(r>=a)return e;switch(e){case"%s":return String(i[r++]);case"%d":return Number(i[r++]);case"%j":try{return JSON.stringify(i[r++])}catch(t){return"[Circular]"}default:return e}}),s=i[r];a>r;s=i[++r])o+=y(s)||!M(s)?" "+s:" "+n(s);return o},r.deprecate=function(e,n){function a(){if(!o){if(t.throwDeprecation)throw new Error(n);t.traceDeprecation?console.trace(n):console.error(n),o=!0}return e.apply(this,arguments)}if(_(i.process))return function(){return r.deprecate(e,n).apply(this,arguments)};if(t.noDeprecation===!0)return e;var o=!1;return a};var T,O={};r.debuglog=function(e){if(_(T)&&(T=t.env.NODE_DEBUG||""),e=e.toUpperCase(),!O[e])if(new RegExp("\\b"+e+"\\b","i").test(T)){var i=t.pid;O[e]=function(){var t=r.format.apply(r,arguments);console.error("%s %d: %s",e,i,t)}}else O[e]=function(){};return O[e]},r.inspect=n,n.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},n.styles={special:"cyan",number:"yellow","boolean":"yellow",undefined:"grey","null":"bold",string:"green",date:"magenta",regexp:"red"},r.isArray=p,r.isBoolean=b,r.isNull=y,r.isNullOrUndefined=m,r.isNumber=g,r.isString=v,r.isSymbol=w,r.isUndefined=_,r.isRegExp=S,r.isObject=M,r.isDate=E,r.isError=k,r.isFunction=x,r.isPrimitive=A,r.isBuffer=e("./support/isBuffer");var P=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];r.log=function(){console.log("%s - %s",I(),r.format.apply(r,arguments))},r.inherits=e("inherits"),r._extend=function(e,t){if(!t||!M(t))return e;for(var r=Object.keys(t),i=r.length;i--;)e[r[i]]=t[r[i]];return e}}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./support/isBuffer":180,_process:143,inherits:103}],182:[function(require,module,exports){function Context(){}var indexOf=function(e,t){if(e.indexOf)return e.indexOf(t);for(var r=0;r<e.length;r++)if(e[r]===t)return r;return-1},Object_keys=function(e){if(Object.keys)return Object.keys(e);var t=[];for(var r in e)t.push(r);return t},forEach=function(e,t){if(e.forEach)return e.forEach(t);for(var r=0;r<e.length;r++)t(e[r],r,e)},defineProp=function(){try{return Object.defineProperty({},"_",{}),function(e,t,r){Object.defineProperty(e,t,{writable:!0,enumerable:!1,configurable:!0,value:r})}}catch(e){return function(e,t,r){e[t]=r}}}(),globals=["Array","Boolean","Date","Error","EvalError","Function","Infinity","JSON","Math","NaN","Number","Object","RangeError","ReferenceError","RegExp","String","SyntaxError","TypeError","URIError","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","eval","isFinite","isNaN","parseFloat","parseInt","undefined","unescape"];Context.prototype={};var Script=exports.Script=function(e){return this instanceof Script?void(this.code=e):new Script(e)};Script.prototype.runInContext=function(e){if(!(e instanceof Context))throw new TypeError("needs a 'context' argument.");var t=document.createElement("iframe");t.style||(t.style={}),t.style.display="none",document.body.appendChild(t);var r=t.contentWindow,i=r.eval,n=r.execScript;!i&&n&&(n.call(r,"null"),i=r.eval),forEach(Object_keys(e),function(t){r[t]=e[t]}),forEach(globals,function(t){e[t]&&(r[t]=e[t])});var a=Object_keys(r),o=i.call(r,this.code);return forEach(Object_keys(r),function(t){(t in e||-1===indexOf(a,t))&&(e[t]=r[t])}),forEach(globals,function(t){t in e||defineProp(e,t,r[t])}),document.body.removeChild(t),o},Script.prototype.runInThisContext=function(){return eval(this.code)},Script.prototype.runInNewContext=function(e){var t=Script.createContext(e),r=this.runInContext(t);return e&&forEach(Object_keys(t),function(r){e[r]=t[r]}),r},forEach(Object_keys(Script.prototype),function(e){exports[e]=Script[e]=function(t){var r=Script(t);return r[e].apply(r,[].slice.call(arguments,1))}}),exports.isContext=function(e){return e instanceof Context},exports.createScript=function(e){return exports.Script(e)},exports.createContext=Script.createContext=function(e){var t=new Context;return"object"==typeof e&&forEach(Object_keys(e),function(r){t[r]=e[r]}),t}},{}]},{},[1]);
},
"/calculator-html/compare_expressions" : function(require, module, exports){
"use strict";
const ids = require("./ids_dom_elements");
const pathnames = require("./pathnames");
const InputPanelData = require("./initialize_buttons").InputPanelData;
const storage = require("./storage").storage;
const miscellaneous = require("./miscellaneous_frontend");
const equationEditor = require("./equation_editor");
const submit = require("./submit_requests");
const jsonToHtml = require("./json_to_html");
const answerProcessing = require("./answer_processing");

class CompareExpressions {
  constructor() {
    /**@type{boolean} */
    this.initialized = false;
    /**@type{InputPanelData|null} */
    this.givenPanel = null;
    /**@type{InputPanelData|null} */
    this.desiredPanel = null;
    /**@type{HTMLElement} */
    this.resultUserFriendly = document.getElementById(ids.domElements.pages.compareExpressions.resultUserFriendly);
    /**@type{HTMLElement} */
    this.resultBoxRaw = document.getElementById(ids.domElements.pages.compareExpressions.resultRaw);
    /**@type{HTMLElement} */
    this.resultBoxFormatted = document.getElementById(ids.domElements.pages.compareExpressions.resultFormatted);
    /**@type{HTMLElement} */
    this.calculatorLink = document.getElementById(ids.domElements.pages.compareExpressions.calculatorLink);
    /**@type{string} */
    this.givenData = "";
    /**@type{string} */
    this.desiredData = "";
  }

  selectPage() {
    if (this.initialized) {
      return;
    }
    let button = document.getElementById(ids.domElements.pages.compareExpressions.buttonCompare);
    if (button === null) {
      return;
    }
    button.addEventListener("click", () => {
      this.compare();
    });

    this.initialized = true;
    this.givenPanel = new InputPanelData({
      idEquationEditorElement: ids.domElements.pages.compareExpressions.givenEquationEditor,
      problemId: "",
      idButtonContainer: ids.domElements.pages.compareExpressions.givenPanel,
      idPureLatex: ids.domElements.pages.compareExpressions.givenRawInput,
      flagCalculatorPanel: false,
      flagAnswerPanel: false,
      buttonsPerLine: 8,
    });
    this.givenPanel.initialize();

    this.desiredPanel = new InputPanelData({
      idEquationEditorElement: ids.domElements.pages.compareExpressions.desiredEquationEditor,
      problemId: "",
      idButtonContainer: ids.domElements.pages.compareExpressions.desiredPanel,
      idPureLatex: ids.domElements.pages.compareExpressions.desiredRawInput,
      flagCalculatorPanel: false,
      flagAnswerPanel: false,
      buttonsPerLine: 8,
    });
    this.desiredPanel.initialize();

    if (storage.variables.compare.given.getValue() !== "") {
      this.givenPanel.equationEditor.writeLatex(storage.variables.compare.given.getValue());
      this.givenPanel.equationEditor.writeLatexToInput();
    }
    if (storage.variables.compare.desired.getValue() !== "") {
      this.desiredPanel.equationEditor.writeLatex(storage.variables.compare.desired.getValue());
      this.desiredPanel.equationEditor.writeLatexToInput();
    }
  }

  storeData() {
    let givenContainer = document.getElementById(ids.domElements.pages.compareExpressions.givenRawInput);
    this.givenData = givenContainer.value;
    let desiredContainer = document.getElementById(ids.domElements.pages.compareExpressions.desiredRawInput);
    this.desiredData = desiredContainer.value;
  }

  compare() {
    this.storeData();
    storage.variables.compare.given.setAndStore(this.givenData, true);
    storage.variables.compare.desired.setAndStore(this.desiredData, true);
    this.doCompare();
  }

  doCompare() {
    let debug = storage.variables.flagDebug.isTrue();
    submit.submitGET({
      url: pathnames.addresses.compareExpressions(this.givenData, this.desiredData, debug),
      callback: (input) => {
        this.writeResult(input);
      },
      progress: ids.domElements.pages.compareExpressions.progress,
      panelOptions: {
        dontCollapsePanel: true,
      },
    });
  }

  writeResult(
    /**@type{string} */
    input,
  ) {
    try {
      let result = miscellaneous.jsonUnescapeParse(input);
      let resultHTML = answerProcessing.answerProcessing.htmlUserFriendlyResult(result);
      this.resultUserFriendly.innerHTML = resultHTML;
      this.writeCalculatorLink();
      this.resultBoxRaw.textContent = JSON.stringify(result);
      jsonToHtml.writeJSONtoDOMComponent(result, this.resultBoxFormatted);
      equationEditor.typeset(this.resultBoxFormatted);
    } catch (e) {
      this.resultBoxRaw.innerHTML = `<b style='color:red'>${e}</b><br>${input}`;
    }
  }

  writeCalculatorLink() {
    let url = pathnames.addresses.calculatorComputation(
      `CompareExpressionsJSON(${this.givenData},${this.desiredData})`,
    );
    this.calculatorLink.innerHTML = `<a href=${url} target="_blank">calculator link</a>`;
  }
}

const compareExpressions = new CompareExpressions();

module.exports = {
  compareExpressions,
};

},
"/calculator-html/configuration" : function(require, module, exports){
"use strict";
let ids = require("./ids_dom_elements");

class Configuration {
  constructor() {
    /**@type{boolean} */
    this.calculatorDefaultsEnabled = false;
    if (document.getElementById(ids.domElements.calculatorDefaultsEnabled) !== null) {
      this.calculatorDefaultsEnabled = true;
    }
  }
}

let configuration = new Configuration();
module.exports = {
  configuration,
}
},
"/calculator-html/answer_processing" : function(require, module, exports){
"use strict";
let pathnames = require("./pathnames");


class AnswerProcessing {
  constructor() {
  }

  getFirstValueFromKeys(
    input,
    /**@type{string[]} */
    keys,
  ) {
    for (let i = 0; i < keys.length; i++) {
      let candidate = input[keys[i]];
      if (candidate !== undefined && candidate !== null && candidate !== "") {
        return candidate;
      }
    }
    return "";
  }

  getAllValuesOfGivenKeys(
    input,
    /**@type{string[]} */
    labels,
  ) {
    let result = [];
    for (let i = 0; i < labels.length; i++) {
      let candidate = input[labels[i]];
      if (candidate !== undefined && candidate !== null && candidate !== "") {
        result.push(candidate);
      }
    }
    return result.join("<br>");
  }

  htmlUserFriendlyResult(input) {
    let resultHTML = this.htmlUserFriendlyResultComparisonErrorsOnly(input);
    if (resultHTML !== "") {
      return resultHTML;
    }
    resultHTML += this.getAllValuesOfGivenKeys(input, [pathnames.urlFields.result.resultHtml]);
    let commentsAndCrashes = [
      pathnames.urlFields.result.comments,
      pathnames.urlFields.result.commentsGlobal,
      pathnames.urlFields.result.crashReport,
    ];
    resultHTML += this.getAllValuesOfGivenKeys(input, commentsAndCrashes);
    return resultHTML;
  }

  htmlUserFriendlyResultComparisonErrorsOnly(input) {
    let syntaxErrors = this.getFirstValueFromKeys(input, [
      pathnames.urlFields.result.syntaxErrors,
      pathnames.urlFields.result.syntaxErrorsExtra
    ]);
    if (syntaxErrors !== "") {
      return `<b style='color:red'>?</b><br>${syntaxErrors}`;
    }
    let errorTags = [
      pathnames.urlFields.result.error,
      pathnames.urlFields.result.comparison.errorEvaluation,
      pathnames.urlFields.result.comparison.errorInAnswer,
    ];
    let errorsEvaluation = this.getAllValuesOfGivenKeys(input, errorTags);
    if (errorsEvaluation !== "") {
      return `<b style='color:red'>?</b><br>${errorsEvaluation}`;
    }
    return "";
  }
}

let answerProcessing = new AnswerProcessing();

module.exports = {
  answerProcessing,
}
},
"/calculator-html/hard_coded_problems" : function(require, module, exports){
const equationEditor = require("./equation_editor");
const AnswerPanel = require("./answer_panel").AnswerPanel;
const initializeButtons = require("./initialize_buttons");
const submit = require("./submit_requests");
const miscellaneous = require("./miscellaneous_frontend");
const answerProcessing = require("./answer_processing");
const pathnames = require("./pathnames");

class HardCodedProblemCollection {
  constructor() {
    /**@type{HardCodedProblem} */
    this.problems = [];
  }
  create(
    /**@type{HTMLElement[]|string[]} */
    elements,
    /**@type{string} */
    server,
  ) {
    if (!Array.isArray(elements)) {
      elements = [elements];
    }
    for (let i = 0; i < elements.length; i++) {
      let incoming = new HardCodedProblem(elements[i], server);
      this.problems.push(incoming);
      incoming.create();
    }
    initializeButtons.initializeAccordionButtons();
  }
}

class HardCodedProblem {
  constructor(
    /**@type{HTMLElement|string} */
    element,
    /**@type{string} */
    server,
  ) {
    if (typeof element === "string") {
      element = document.getElementById(element);
    }
    /**@type{HTMLElement} */
    this.element = element;
    this.calculatorServer = server;
    /**@type{AnswerPanel[]} */
    this.answers = [];
  }

  create() {
    let answersElements = this.element.querySelectorAll("answer");
    for (let i = 0; i < answersElements.length; i++) {
      let answer = new HardCodedAnswer(
        answersElements[i],
        answersElements[i].textContent,
        this.calculatorServer,
      );
      this.answers.push(answer);
      answer.writeToElement();
    }
    equationEditor.typeset(this.element, "", false, false, false);
  }
}

class HardCodedAnswer {
  constructor(
    /**@type{HTMLElement} */
    element,
    /**@type{string} */
    desiredAnswer,
    /**@type{string} */
    calculatorServer,
  ) {
    /**@type{HTMLElement} */
    this.element = element;
    /**@type{string} */
    this.calculatorServer = calculatorServer;
    /**@type{boolean} Whether the problem should have an answer/solution button. */
    this.forReal = false;
    let forRealString = this.element.getAttribute("forReal");
    if (forRealString === "true") {
      this.forReal = true;
    }
    /**@type{string} */
    this.buttonOptions = this.element.getAttribute("buttons");
    /**@type{string} */
    this.desiredAnswer = desiredAnswer;
    /**@type{AnswerPanel|null} */
    this.answerPanel = null;
    /**@type{HTMLElement|null} */
    this.pureLatexElement = null;
    /**@type{HTMLElement|null} */
    this.buttonSubmitHardCoded = null;
    /**@type{HTMLElement|null} */
    this.equationEditor = null;
    /**@type{HTMLElement|null} */
    this.panelWithButtons = null;
    /**@type{HTMLElement|null} */
    this.verificationSpan = null;
    /**@type{HTMLElement|null} */
    this.solutionSpan = null;
  }

  writeToElement() {
    this.element.textContent = "";
    this.element.style.display = "";
    // non-null non-undefined means create answer button
    let idButtonAnswer = "";
    if (this.forReal) {
      idButtonAnswer = null;
    }
    this.answerPanel = new AnswerPanel({
      forReal: this.forReal,
      generateInterpretButton: false,
      mathQuillPanelOptions: this.buttonOptions,
      dontBootstrapButtons: true,
      idButtonAnswer: idButtonAnswer,
      valueChangeHandler: () => {
        this.handleLatexChange();
      }
    });
    this.answerPanel.writeToElement(this.element);
    this.answerPanel.buttonSubmit.addEventListener("click", () => {
      this.submitAnswer();
    });
    if (!this.forReal) {
      this.answerPanel.buttonAnswer.addEventListener("click", () => {
        this.giveUp();
      });
    }

  }

  submitAnswer() {
    let givenData = this.answerPanel.panel.equationEditor.rootNode.toLatex();
    let urlRelative = pathnames.addresses.compareExpressions(
      givenData, this.desiredAnswer, false,
    );
    let url = this.calculatorServer + urlRelative;
    submit.submitGET({
      url: url,
      callback: (input) => {
        this.writeResult(input, givenData);
      },
    });
  }

  writeResult(
    input,
    /**@type{string} */
    givenData,
  ) {
    try {
      let result = miscellaneous.jsonUnescapeParse(input);
      let resultHTML = answerProcessing.answerProcessing.htmlUserFriendlyResult(result);
      resultHTML += `<br>Your answer: \\(${givenData}\\)`;
      this.answerPanel.verificationSpan.innerHTML = resultHTML;
      equationEditor.typeset(this.answerPanel.verificationSpan);
    } catch (e) {
      this.answerPanel.verificationSpan.innerHTML = `<b style='color:red'>${e}</b><br>${input}`;
    }
  }

  giveUp() {
    this.answerPanel.verificationSpan.innerHTML = `\\(${this.desiredAnswer}\\)`;
    equationEditor.typeset(this.answerPanel.verificationSpan, "", false, false, false);
  }

  handleLatexChange() {
    this.answerPanel.pureLatexElement.value = initializeButtons.processMathQuillLatex(
      this.answerPanel.panel.equationEditor.rootNode.toLatex(),
    );
  }
}

function create(
  /**@type{HTMLElement[]|string[]} */
  elements,
  /**@type{string} */
  server,
) {
  hardCodedProblems.create(elements, server);
}

let hardCodedProblems = new HardCodedProblemCollection();

module.exports = {
  create,
  hardCodedProblems,
};
},
"/calculator-html/answer_panel" : function(require, module, exports){
const miscellaneous = require("./miscellaneous_frontend");
const submitRequests = require("./submit_requests");
const initializeButtons = require("./initialize_buttons");
const InputPanelData = require("./initialize_buttons").InputPanelData;
const pathnames = require("./pathnames");
const ids = require("./ids_dom_elements");
const answerProcessing = require("./answer_processing").answerProcessing;
const typeset = require("./math_typeset");

class AnswerPanel {
  constructor(
    /**@type{{
     * forReal:boolean,
     * generateInterpretButton:boolean,
     * mathQuillPanelOptions:string,
     * dontBootstrapButtons:boolean,
     * valueChangeHandler:function,
     * idButtonAnswer:string}}*/
    input,
  ) {
    this.input = input;
    /**@type{HTMLElement|null} */
    this.element = null;
    /**@type{boolean} */
    this.flagForReal = false;
    if (input["forReal"] === true) {
      this.flagForReal = true;
    }
    this.idPureLatex = input.idPureLatex;
    this.problemId = input.problemId;
    /**@type{boolean} */
    this.flagGenerateInterpretButton = true;
    if (input.generateInterpretButton === false) {
      this.flagGenerateInterpretButton = false;
    }
    this.flagDontBootstrapButtons = false;
    if (input.dontBootstrapButtons === true) {
      this.flagDontBootstrapButtons = true;
    }
    /**@type{boolean} */
    this.layoutVertical = true;

    /**@type {InputPanelData|null} */
    this.panel = null;
    /**@type{HTMLTableElement|null} */
    this.table = null;
    /**@type{HTMLElement|null} */
    this.buttonContainerMath = null;
    /**@type{HTMLElement|null} */
    this.pureLatexElement = null;
    /**@type{HTMLElement|null} */
    this.verificationSpan = null;
    /**@type{HTMLElement|null} */
    this.solutionSpan = null;
    /**@type{HTMLElement|null} */
    this.buttonInterpret = null;
    /**@type{HTMLElement|null} */
    this.buttonSubmit = null;
    /**@type{HTMLElement|null} */
    this.buttonAnswer = null;
    /**@type{HTMLElement|null} */
    this.buttonSolution = null;
    /**@type{HTMLElement|null} */
    this.buttonDetails = null;
    /**@type{HTMLElement|null} */
    this.spanAnswerHighlight = null;
    /**@type{HTMLElement|null} */
    this.editorSpan = null;
    /**@type{HTMLElement|null} */
    this.editorEnclosure = null;
  }

  writeToElement(
    /**@type{HTMLElement} */
    element,
  ) {
    this.element = element;
    this.element.textContent = "";
    this.createTable();
    this.input.equationEditorContainer = this.editorSpan;
    this.input.buttonContainer = this.buttonContainerMath;
    this.input.pureLatexElement = this.pureLatexElement;
    if (!this.flagDontBootstrapButtons) {
      this.input.valueChangeHandler = () => {
        this.callbackLatexChange();
      };
    }
    this.panel = new InputPanelData(this.input);
    this.panel.initialize();
  }

  createTable() {
    this.layoutVertical = true;
    if (this.input.properties !== undefined) {
      if (this.input.properties.layout === "horizontal") {
        this.layoutVertical = true;
      }
    }
    this.onePanelComputeHtmlElements();
    this.table = document.createElement("table");
    if (this.layoutVertical === true) {
      /**@type{HTMLTableRowElement} */
      let row = this.table.insertRow();
      row.insertCell().appendChild(this.onePanelQuestionAndAnswerField());
      row.insertCell().appendChild(this.buttonContainerMath);
      row.insertCell().appendChild(this.onePanelButtonsVerticalLayout());
      let cell = row.insertCell();
      cell.appendChild(this.buttonDetails);
      cell.appendChild(this.pureLatexElement);
    } else {
      let row = this.table.insertRow();
      row.insertCell().appendChild(this.onePanelQuestionAndAnswerField());
      row.insertCell().appendChild(this.onePanelButtonsHorizontalLayout());
      row.insertCell().appendChild(this.buttonContainerMath);
      row.insertCell().appendChild(this.pureLatexElement);
    }
    this.element.appendChild(this.table);
    this.element.appendChild(this.verificationSpan);
    if (this.solutionSpan !== null) {
      this.element.appendChild(this.solutionSpan);
    }
    if (this.flagDontBootstrapButtons) {
      return;
    }
    this.pureLatexElement.addEventListener('keyup', () => {
      this.editLaTeX();
    });
    if (this.buttonInterpret !== null) {
      this.buttonInterpret.addEventListener('click', () => {
        this.submitPreview();
      });
    }
    this.buttonSubmit.addEventListener('click', () => {
      this.submitAnswers();
    });
    if (this.flagForReal !== true && this.buttonAnswer !== null) {
      this.buttonAnswer.addEventListener('click', () => {
        this.submitGiveUp();
      });
    }
    if (
      this.buttonSolution !== null
    ) {
      this.buttonSolution.addEventListener('click', () => {
        this.showSolution();
      });
    }
  }

  onePanelComputeHtmlElements() {
    if (this.flagForReal === true) {
      this.buttonAnswer = null;
      this.htmlButtonSolution = null;
    } else {
      if (this.input.idButtonAnswer !== undefined && this.input.idButtonAnswer !== null) {
        this.buttonAnswer = document.createElement("button");
        this.buttonAnswer.textContent = "Answer";
        this.buttonAnswer.className = "buttonAnswer";
      }
      if (this.input.idButtonSolution !== null && this.input.idButtonSolution !== undefined) {
        this.buttonSolution = document.createElement("button");
        this.buttonSolution.textContent = "Solution";
        this.buttonSolution.className = "buttonSolution";
      }
    }
    this.buttonSubmit = document.createElement("button");
    this.buttonSubmit.className = "buttonSubmit";
    this.buttonSubmit.textContent = "Submit";
    if (this.flagGenerateInterpretButton) {
      this.buttonInterpret = document.createElement("button");
      this.buttonInterpret.className = "buttonPreview";
      this.buttonInterpret.textContent = "Interpret";
    }
    this.buttonDetails = document.createElement("button");
    this.buttonDetails.className = "accordion";
    this.buttonDetails.textContent = "details";
    this.pureLatexElement = document.createElement("textarea");
    this.pureLatexElement.className = "calculatorAnswer";
    this.buttonContainerMath = document.createElement("div");
    this.buttonContainerMath.className = "mqButtonPanel";
    this.buttonContainerMath.setAttribute("buttons", this.input.mathQuillPanelOptions);
    this.editorEnclosure = document.createElement("div");
    this.editorEnclosure.className = "calculatorMQfieldEnclosure";
    this.editorSpan = document.createElement("span");
    this.spanAnswerHighlight = document.createElement("span");
    if (
      this.input.answerHighlight !== undefined &&
      this.input.answerHighlight !== null
    ) {
      this.spanAnswerHighlight.innerHTML = this.input.answerHighlight;
    }
    this.editorEnclosure.appendChild(this.editorSpan);
    this.verificationSpan = document.createElement("span");
    if (this.input.previousAnswers !== undefined && this.input.previousAnswers !== "") {
      this.verificationSpan.innerHTML = this.input.previousAnswers;
    } else {
      if (this.layoutVertical === true) {
        this.verificationSpan.innerHTML = `<b style = "color:brown">Waiting for answer [unlimited tries]</b>`;
      }
    }
    if (this.flagForReal !== true && this.input.idSpanSolution !== undefined && this.input.idSpanSolution !== null) {
      this.solutionSpan = document.createElement("span");
    }
  }

  /**@returns{HTMLElement} */
  onePanelQuestionAndAnswerField() {
    let result = document.createElement("table");
    let row = result.insertRow();
    row.insertCell().appendChild(this.spanAnswerHighlight);
    let cell = row.insertCell();
    cell.appendChild(this.editorEnclosure);
    cell.className = "tableCellMQfield";
    return result;
  }

  /**@returns{HTMLElement} */
  onePanelButtonsVerticalLayout() {
    let result = document.createElement("table");
    result.insertRow().insertCell().appendChild(this.buttonSubmit);
    if (this.flagGenerateInterpretButton) {
      result.insertRow().insertCell().appendChild(this.buttonInterpret);
    }
    if (this.flagForReal !== true) {
      if (this.buttonAnswer !== null) {
        result.insertRow().insertCell().appendChild(this.buttonAnswer);
      }
      if (this.buttonSolution !== null) {
        result.insertRow().insertCell().appendChild(this.buttonSolution);
      }
    }
    return result;
  }

  /**@returns{HTMLElement} */
  onePanelButtonsHorizontalLayout() {
    let result = document.createElement("table");
    let row = result.insertRow();
    row.insertCell().appendChild(this.buttonSubmit);
    if (this.flagGenerateInterpretButton) {
      row.insertCell().appendChild(this.buttonInterpret);
    }
    if (this.flagForReal !== true) {
      if (this.buttonAnswer !== null) {
        row.insertCell().appendChild(this.buttonAnswer);
      }
      if (this.buttonSolution !== null) {
        row.insertCell().appendChild(this.buttonSolution);
      }
    }
    return result;
  }

  submitOrPreviewAnswersCallback(outputComponent, input) {
    if (typeof outputComponent === "string") {
      outputComponent = document.getElementById(outputComponent);
    }
    let inputParsed = miscellaneous.jsonUnescapeParse(input);
    let resultHtml = "";
    if (inputParsed.error !== undefined && inputParsed.error !== null && inputParsed.error !== "") {
      resultHtml += `<b style = 'color:red'>Error.</b> ${inputParsed.error}`;
    }
    if (
      inputParsed.resultHtml !== "" &&
      inputParsed.resultHtml !== undefined &&
      inputParsed.resultHtml !== null
    ) {
      if (resultHtml !== "") {
        resultHtml += "<br>";
      }
      resultHtml += inputParsed.resultHtml;
    }
    let timeComputation = inputParsed.timeComputation;
    if (timeComputation !== null && timeComputation !== undefined) {
      if (resultHtml !== "") {
        resultHtml += "<br>";
      }
      resultHtml += `<br><span style='font-size:x-small;float:right'>Computation time: ${timeComputation} ms</span>`;
    }
    resultHtml += answerProcessing.htmlUserFriendlyResultComparisonErrorsOnly(inputParsed);
    resultHtml += miscellaneous.htmlFromCommentsAndErrors(inputParsed);
    outputComponent.innerHTML = resultHtml;
    let spanVerification = this.verificationSpan;
    let scripts = spanVerification.getElementsByTagName('script');
    let theHead = document.getElementsByTagName('head')[0];
    for (let i = 0; i < this.numInsertedJavascriptChildren; i++) {
      theHead.removeChild(theHead.lastChild);
    }
    this.numInsertedJavascriptChildren = 0;
    for (let i = 0; i < scripts.length; i++) {
      let scriptChild = document.createElement('script');
      scriptChild.innerHTML = scripts[i].innerHTML;
      scriptChild.type = 'text/javascript';
      theHead.appendChild(scriptChild);
      this.numInsertedJavascriptChildren++;
    }
    this.javascriptInsertionAlreadyCalled = true;
    typeset.typesetter.typesetSoft(outputComponent, "");
  }

  submitOrPreviewAnswers(
    /**@type{string} */
    requestQuery,
  ) {
    clearTimeout(this.timerForPreviewAnswers);
    let studentAnswer = this.panel.getPureLatexElement().value;
    let theURL = "";
    theURL += `${pathnames.urls.calculatorAPI}?${requestQuery}&`;
    theURL += `calculatorAnswer${this.idPureLatex}=${encodeURIComponent(studentAnswer)}&`;
    theURL += `${pathnames.urlFields.problem.fileName}=${this.problemId}&`;
    submitRequests.submitGET({
      url: theURL,
      progress: ids.domElements.spanProgressReportGeneral,
      callback: this.submitOrPreviewAnswersCallback.bind(this, this.verificationSpan),
    });
  }

  showSolution() {
    let request = "";
    let thePage = window.calculator.mainPage;
    let currentProblem = thePage.getProblemById(this.problemId);
    if (!this.flagForReal) {
      if (thePage.isLoggedIn()) {
        request += `${pathnames.urlFields.request}=${pathnames.urlFields.problemSolution}&`;
      } else {
        request += `${pathnames.urlFields.request}=${pathnames.urlFields.problemSolutionNoLogin}&`;
      }
      if (currentProblem.randomSeed !== undefined) {
        request += `${pathnames.urlFields.randomSeed}=${currentProblem.randomSeed}&`;
      }
    }
    this.submitOrPreviewAnswers(request);
  }

  submitAnswers() {
    let request = "";
    let thePage = window.calculator.mainPage;
    let currentProblem = thePage.getProblemById(this.problemId);
    if (thePage.isLoggedIn()) {
      if (this.flagForReal) {
        request = `${pathnames.urlFields.request}=${pathnames.urlFields.submitAnswers}`;
      } else {
        request += `${pathnames.urlFields.request}=${pathnames.urlFields.submitExercise}&`;
        if (currentProblem.randomSeed !== undefined) {
          request += `${pathnames.urlFields.randomSeed}=${currentProblem.randomSeed}&`;
        }
      }
    } else {
      request += `${pathnames.urlFields.request}=${pathnames.urlFields.submitExerciseNoLogin}&`;
      if (currentProblem.randomSeed !== undefined) {
        request += `${pathnames.urlFields.randomSeed}=${currentProblem.randomSeed}&`;
      }
    }
    this.submitOrPreviewAnswers(request);
  }

  submitGiveUp() {
    let thePage = window.calculator.mainPage;
    let currentProblem = thePage.getProblemById(this.problemId);
    let theRequest = "";
    if (thePage.isLoggedIn()) {
      theRequest += `${pathnames.urlFields.request}=${pathnames.urlFields.problemGiveUp}&`;
    } else {
      theRequest += `${pathnames.urlFields.request}=${pathnames.urlFields.problemGiveUpNoLogin}&`;
    }
    if (currentProblem.randomSeed === undefined) {
      throw ("Random seed not supposed to be undefined. ");
    }
    theRequest += `${pathnames.urlFields.randomSeed}=${currentProblem.randomSeed}&`;
    this.submitOrPreviewAnswers(theRequest);
  }

  submitPreview() {
    let thePage = window.calculator.mainPage;
    let theRequest = "";
    let currentProblem = thePage.getProblemById(this.problemId);
    if (thePage.isLoggedIn()) {
      if (this.flagForReal) {
        theRequest += `${pathnames.urlFields.request}=${pathnames.urlFields.submitAnswersPreview}&`;
      } else {
        theRequest += `${pathnames.urlFields.request}=${pathnames.urlFields.submitExercisePreview}&`;
        theRequest += `${pathnames.urlFields.randomSeed}=${currentProblem.randomSeed}&`;
      }
    } else {
      theRequest += `${pathnames.urlFields.request}=${pathnames.urlFields.submitExercisePreviewNoLogin}&`;
      theRequest += `${pathnames.urlFields.randomSeed}=${currentProblem.randomSeed}&`;
    }
    this.submitOrPreviewAnswers(theRequest);
  }

  submitPreviewWithTimeOut() {
    clearTimeout(this.timerForPreviewAnswers);
    this.timerForPreviewAnswers = setTimeout(this.submitPreview.bind(this), 4000);
  }

  callbackLatexChange() {
    this.pureLatexElement.value = initializeButtons.processMathQuillLatex(this.panel.equationEditor.rootNode.toLatex());
    this.submitPreviewWithTimeOut();
    return;
  }
}

module.exports = {
  AnswerPanel,
};
},
};
theJSContent['/calculator-html/browserifier'](null, null, null);

}) ();
