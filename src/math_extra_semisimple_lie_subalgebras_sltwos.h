#ifndef header_math_extra_semisimple_lie_subalgebras_sltwos_ALREADY_INCLUDED
#define header_math_extra_semisimple_lie_subalgebras_sltwos_ALREADY_INCLUDED

#include "math_extra_algebraic_numbers.h"
#include "math_extra_semisimple_lie_algebras.h"
#include "math_extra_semisimple_lie_algebras_root_subalgebras.h"
#include "math_general.h"
#include "math_polynomials.h"

class CartanElementCandidate {
  friend std::ostream& operator<<(
    std::ostream& output, const CartanElementCandidate& element
  ) {
    output << element.toString();
    return output;
  }
public:
  ElementSemisimpleLieAlgebra<AlgebraicNumber> h;
  Matrix<AlgebraicNumber> adjointAction;
  ElementSemisimpleLieAlgebra<AlgebraicNumber> e;
  ElementSemisimpleLieAlgebra<AlgebraicNumber> f;
  static unsigned int hashFunction(const CartanElementCandidate& input) {
    return input.h.hashFunction();
  }
  int hashFunction() const {
    return this->h.hashFunction();
  }
  bool operator==(const CartanElementCandidate& other) const {
    return this->h == other.h;
  }
  AlgebraicNumber scalarProductKilling(const CartanElementCandidate& other)
  const;
  Rational scalarProductKillingMustBeRational(
    const CartanElementCandidate& other
  ) const;
  std::string toString() const;
  CartanElementCandidate operator-(const CartanElementCandidate& other) const {
    CartanElementCandidate result;
    result.h = this->h - other.h;
    result.adjointAction = this->adjointAction - other.adjointAction;
    return result;
  }
};

// Represents a reductive Lie subalgebra that is either a
// simple component or a 1-dimensional subalgebra
// generated by a semisimple element.
class SimpleSubalgebraComponent {
  Rational computeSimpleRootScalarProductAmbientKilling(int i, int j) const;
  // A helper method for determining whether dual element to
  // a root space is simple.
  bool isSimpleIndex(int i);
  friend std::ostream& operator<<(
    std::ostream& output, const SimpleSubalgebraComponent& element
  ) {
    output << element.toString();
    return output;
  }
public:
  SemisimpleLieAlgebra* owner;
  AlgebraicClosureRationals* algebraicClosure;
  // Elements of the cartan scaled so they act on their root spaces by
  // a scalar of \pm 2.
  List<CartanElementCandidate> dualsToRoots;
  List<Vector<AlgebraicNumber> > dualsToRootsAlgebraic;
  // Defining semisimple elment.
  // This is the element whose eigenvalues and eigenspaces
  // were used to compute the dualsToRoots
  CartanElementCandidate definingSemisimpleElement;
  HashedList<CartanElementCandidate> postiveDualsOfRootSpaces;
  List<CartanElementCandidate> simpleDualsOfRootSpaces;
  List<CartanElementCandidate> simpleDualsOfRootSpacesAmbientAdjoint;
  DynkinDiagramRootSubalgebra dynkinDiagramComputer;
  Matrix<Rational> coSymmetricCartanMatrixCentralizerAmbientKilling;
  DynkinType simpleType;
  // The killing square of the shortest Cartan element.
  // The shortest Cartan element corresponds to the longest root
  // of the root system.
  Rational killingSquareProductShortestDual;
  // A label for this centralizer to be used in internal printouts
  // to help us with debugging when the simpleType is not computed yet.
  std::string label;
  void initialize(
    SemisimpleLieAlgebra* inputOwner,
    AlgebraicClosureRationals* inputAlgebraicClosure,
    const CartanElementCandidate& inputDefiningSemisimpleElement
  );
  bool isLinkedTo(const CartanElementCandidate& maybeBelongsToComponent) const;
  std::string toString() const;
  bool compute();
  SimpleSubalgebraComponent();
};

class CentralizerComputer {
  SemisimpleLieAlgebra* owner;
  AlgebraicClosureRationals* algebraicClosureRationals;
  bool intersectAmbientCartanWithCentralizer();
  bool trySemisimpleElement(ElementSemisimpleLieAlgebra<Rational>& candidate);
  bool findSemisimpleElementEigenvalues();
  // Computes the root spaces of the candidate semisimple element.
  bool computeRootSpaces();
  bool computeRootSpaceForNonZeroEigenvalue(const AlgebraicNumber& eigenvalue);
  // Computes the dynkin type of the centralizer
  // from the dualsOfRootSpaces.
  bool computeTypes();
  // Computes the bases of the reductive components of
  // the centralizer from the dualsOfRootSpaces.
  void computeReductiveComponentsBases();
  void mergeOneRootSpaceCandidate(const CartanElementCandidate& candidate);
  // Combines reductive components currently being grown
  // into a single reductive component.
  void mergeReductiveComponents(
    List<int>& indicesOfComponentsToBeMergedSorted
  );
public:
  std::string label;
  List<ElementSemisimpleLieAlgebra<Rational> > generatorsToCentralize;
  List<ElementSemisimpleLieAlgebra<Rational> > centralizerBasis;
  List<ElementSemisimpleLieAlgebra<AlgebraicNumber> >
  centralizerBasisOverAlgebraicNumbers;
  List<ElementSemisimpleLieAlgebra<Rational> >
  centralizerIntersectedWithAmbientCartan;
  // A semisimple element of the centalizer whose centralizer can serve as a
  // Cartan subalgebra.
  CartanElementCandidate semisimpleElement;
  List<ElementSemisimpleLieAlgebra<Rational> > centralizerCartan;
  // A computational structure to find the eigenvalues and eigenspaces of the
  // preceding element.
  MatrixEigenvalueFinder semisimpleElementAdjointEigenvalueFinder;
  // Elements of the Cartan. When the elements have
  // defining sl(2)-root spaces,
  // the elements are scaled so they act by a scalar of \pm 2.
  // If the element has no defining sl(2)-triple and therefore
  // is an element of the toral part of the centralizer, then
  // the scale is arbitrary.
  List<CartanElementCandidate> dualsOfRootSpaces;
  List<SimpleSubalgebraComponent> simpleComponents;
  DynkinType typeIfKnown;
  bool flagTypeComputed;
  bool flagBasisComputed;
  bool flagCartanSelected;
  void getCentralizerElementFromCoordinates(
    Vector<AlgebraicNumber>& vector,
    ElementSemisimpleLieAlgebra<AlgebraicNumber>& output
  );
  void initialize(
    SemisimpleLieAlgebra* inputOwner,
    AlgebraicClosureRationals* inputAlgebraicClosure
  );
  void makeCartanCandidate(
    ElementSemisimpleLieAlgebra<AlgebraicNumber>& inputH,
    ElementSemisimpleLieAlgebra<AlgebraicNumber>& inputE,
    ElementSemisimpleLieAlgebra<AlgebraicNumber>& inputF,
    CartanElementCandidate& output
  );
  void makeCartanCandidate(
    ElementSemisimpleLieAlgebra<Rational>& inputH,
    ElementSemisimpleLieAlgebra<Rational>& inputE,
    ElementSemisimpleLieAlgebra<Rational>& inputF,
    CartanElementCandidate& output
  );
  CentralizerComputer();
  std::string toString() const;
  bool compute();
};

// The sl(2)-subalgebra candidate from which the sl(2) is to be realized.
// Contains internal information about the computation,
// intermediate systems of equations, etc.
class SlTwoSubalgebraCandidate {
  // Returns a list of arbitrarily chosen small numbers that, when
  // chosen as arbitrary coefficients for forming the element f
  // result in an H, E, F triple.
  // The numbers were found by quick manual experimentation with small integers
  // of approximate value less than 20 and running the calculator to
  // inspect if so formed H, F elements extend to H, E, F-triples.
  static List<Rational> fArbitraryCoefficients(
    char type, int rank, const Rational& hElementLength
  );
public:
  // Owner semisimple Lie algebra.
  SemisimpleLieAlgebra* owner;
  // sl(2)-subalgebra container.
  SlTwoSubalgebras* container;
  // Algebraic closure. Not needed over the complex numbers
  // as sl(2)'s are realizable
  // as rational linear combinations of the Chevalley generators.
  // However, we need this for real form computations.
  AlgebraicClosureRationals* algebraicClosure;
  Rational lengthHSquared;
  Vector<Rational> candidateH;
  ElementSemisimpleLieAlgebra<AlgebraicNumber> hAlgebraic;
  Vectors<Rational> participatingPositiveRoots;
  Vectors<Rational> rootsWithScalar2WithH;
  Vectors<Rational> preferredAmbientSimpleBasis;
  ElementSemisimpleLieAlgebra<Rational> hElement;
  // One possible element e for which [e, f] = h
  // [h, e] = 2e.
  ElementSemisimpleLieAlgebra<Rational> eElement;
  // One possible element f for which [e, f] = h
  // [h, f] = -2f.
  ElementSemisimpleLieAlgebra<Rational> fElement;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > eUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > fUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > eArbitraryUnknown;
  // Mathematically equal to the previous.
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > hPolynomialRational;
  // Mathematically equal to the previous.
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  hPolynomialAlgebraic;
  // Arbitrarily chosen coefficients of the F element over the rationals.
  // This arbitrary choice of F allows to reduce
  // the polynomial system needed to realize the E and F
  // to a linear one.
  // The rationale for this arbitrary choice:
  // 1) Speed (linear systems are easer to solve than polynomial systems).
  // 2) Algorithmic simplicity. When this function was first designed,
  // we did not have machinery for solving polynomial systems
  // so this used to be an algorithmic necessity.
  //
  // Here, we recall that the element H is known and computed by algorithms
  // following Dynkin.
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > fArbitrary;
  // The matrix of the linear system given by systemToSolveArbitrary.
  Matrix<Rational> systemArbitraryMatrix;
  // The column-vector of the linear system given by systemToSolveArbitrary.
  Matrix<Rational> systemArbitraryColumnVector;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> >
  eBracketFMinusHArbitraryUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > eBracketFMinusHUnknown;
  // An element of the form x_1 g_{k_1} + ... + x_s g_{k_s} where
  // x_1, ..., x_s are unknowns and g_{?} are the Chevalley generators
  // of the root spaces given by participatingPositiveRoots.
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  eKostantSekiguchiUnknown;
  // An element of the form x_1 g_{-k_1} + ... + x_s g_{-k_s} where
  // x_1, ..., x_s are unknowns and g_{-?} are the Chevalley generators
  // of the root spaces given by the negatives of the
  // participatingPositiveRoots.
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  fKostantSekiguchiUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  eBracketFMinusHUnknownKostantSekiguchi;
  // The polynomial system required to solve to find a Kostant-sekiguchi triple
  // e, f, h.
  // Here, we assume that theta(h) = - h is already satisfied.
  PolynomialSubstitution<AlgebraicNumber> systemToSolveKostantSekiguchi;
  // The polynomial (actually, linear) system required to solve for
  // eArbitraryUnknown.
  PolynomialSubstitution<Rational> systemToSolveArbitrary;
  // The polynomial system required to solve to find e, f.
  PolynomialSubstitution<Rational> systemToSolve;
  // Fix one Cartan involution theta for which theta(h) = -h.
  //
  // The following element has all properties that the rational element e has,
  // as well as the following additional property:
  //
  // 1) e - f is invariant with respect the cartan involution, i.e.,
  // theta(e-f)=e-f.
  //
  // An h, e, f-triple as above is called a Kostant-Sekiguchi sl(2)-triple.
  ElementSemisimpleLieAlgebra<AlgebraicNumber> eKostantSekiguchi;
  // F element of the Kostant-Sekiguchi sl(2)-triple.
  ElementSemisimpleLieAlgebra<AlgebraicNumber> fKostantSekiguchi;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> > eMinusFUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  involutionAppliedToEMinusF;
  // Initializes the h,e,f computation with f arbitrarily chosen.
  // See the preceding comments on why f is chosen arbitrarily.
  void initializeUnknownTriples(const Vector<Rational>& targetH);
  bool attemptExtendingHFtoHEFWithRespectToSubalgebra(
    Vectors<Rational>& rootsWithCharacteristic2,
    Selection& zeroCharacteristics,
    Vectors<Rational>& simpleBasisSubalgebras,
    Vector<Rational>& h,
    bool computeRealForm,
    AlgebraicClosureRationals* inputAlgebraicClosure
  );
  SemisimpleLieAlgebra& getOwnerSemisimpleAlgebra();
  void initializeHEFSystemFromFCoefficients(
    const Vector<Rational>& targetH,
    LinearMapSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >*
    cartanInvolutionPreservedByEMinusF
  );
  void initializeHEFSystemFromFCoefficientsPartTwo();
  void computeLieBracketsUnknowns();
  void computePolynomialSystems();
  const WeylGroupData& getOwnerWeyl() const;
  bool attemptRealizingKostantSekiguchi();
  bool checkConsistencyParticipatingRoots(const Vector<Rational>& targetH);
  void adjoinKostantSekiguchiRelationsToPolynomialSystem(
    LinearMapSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >*
    cartanInvolutionPreservedByEMinusF
  );
  static Rational fArbitraryCoefficient(
    int coefficientIndex, char type, int rank, const Rational& hElementLength
  );
};

class SlTwoSubalgebra {
public:
  friend std::ostream& operator<<(
    std::ostream& output, const SlTwoSubalgebra& sl2
  ) {
    output << sl2.toString();
    return output;
  }
  SemisimpleLieAlgebra* owner;
  SlTwoSubalgebras* container;
  AlgebraicClosureRationals* algebraicClosure;
  CharacterSemisimpleLieAlgebraModule<Rational>
  moduleDecompositionAmbientSubalgebra;
  List<int> moduleDimensions;
  int indexInContainer;
  int dimensionCentralizer;
  Rational dimensionCentralizerToralPart;
  bool flagCentralizerIsRegular;
  bool flagTryToComputeCentralizerFully;
  List<int> indicesContainingRootSubalgebras;
  List<int> indicesMinimalContainingRootSubalgebras;
  Vectors<Rational> participatingPositiveRoots;
  // Mathematically equal to the previous.
  ElementSemisimpleLieAlgebra<AlgebraicNumber> hAlgebraic;
  // Used to check our work over the rationals
  ElementSemisimpleLieAlgebra<Rational> hBracketE;
  ElementSemisimpleLieAlgebra<Rational> hBracketF;
  ElementSemisimpleLieAlgebra<Rational> eBracketF;
  // The following describes an optional Cartan involution.
  // A map \theta is a Cartan involution if the following hold.
  // \theta is linear
  // \theta^2 = id.
  // \theta is a lie bracket automorphism, i.e., [\theta(a), \theta(b)] =
  // \theta([a,b]).
  // Here, if theta is not null, we request that it
  // correspond to the maximally compact real form and have the property
  // \theta(h) = -h.
  // TODO(tmilev): does the property above need to be tweaked when
  // we compute outside of the maximally compact real form?
  LinearMapSemisimpleLieAlgebra<Rational>* cartanInvolutionPreservedByEMinusF;
  // Same as hKostantSekiguchi but with polynomial coefficients.
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  hKnownKostantSekiguchi;
  List<CharacterSemisimpleLieAlgebraModule<Rational> >
  moduleDecompositionMinimalContainingRootSubalgebras;
  Vector<Rational> hElementCorrespondingToCharacteristic;
  Vectors<Rational> hCommutingRootSpaces;
  DynkinDiagramRootSubalgebra diagramM;
  int dynkinsEpsilon;
  bool flagDeallocated;
  // A list of desired scalar product of the h element with the simple roots.
  // The terminology comes from Dynkin's paper on semisimple Lie subalgebras.
  Vector<Rational> hCharacteristic;
  Vectors<Rational> preferredAmbientSimpleBasis;
  Matrix<Rational> systemArbitraryMatrix;
  Matrix<Rational> systemArbitraryColumnVector;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  hPolynomialAlgebraic;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > fArbitrary;
  ElementSemisimpleLieAlgebra<Rational> hElement;
  ElementSemisimpleLieAlgebra<Rational> eElement;
  ElementSemisimpleLieAlgebra<Rational> fElement;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > eArbitraryUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > eUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > fUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<Rational> > eBracketFMinusHUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  eKostantSekiguchiUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  fKostantSekiguchiUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  eBracketFMinusHUnknownKostantSekiguchi;
  PolynomialSubstitution<Rational> systemToSolve;
  PolynomialSubstitution<AlgebraicNumber> systemToSolveKostantSekiguchi;
  ElementSemisimpleLieAlgebra<AlgebraicNumber> eKostantSekiguchi;
  ElementSemisimpleLieAlgebra<AlgebraicNumber> fKostantSekiguchi;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> > eMinusFUnknown;
  ElementSemisimpleLieAlgebra<Polynomial<AlgebraicNumber> >
  involutionAppliedToEMinusF;
  Rational lengthHSquared;
  CentralizerComputer centralizerComputer;
  void fromSlTwoSubalgebraCandidate(SlTwoSubalgebraCandidate& input);
  void initialize();
  SlTwoSubalgebra() {
    this->flagDeallocated = false;
    this->initialize();
  }
  ~SlTwoSubalgebra() {
    this->flagDeallocated = true;
  }
  void computeDynkinTypeEmbedded(DynkinType& output) const;
  bool checkConsistency() const;
  SlTwoSubalgebras& getContainerSl2s() {
    if (this->container == nullptr) {
      global.fatal
      << "Attempt to "
      << "access the container list of "
      << "a non-initialized sl(2)-subalgebra. "
      << global.fatal;
    }
    return *this->container;
  }
  const WeylGroupData& getOwnerWeyl() const;
  SemisimpleLieAlgebra& getOwnerSemisimpleAlgebra() {
    if (this->owner == nullptr) {
      global.fatal
      << "Attempt to access "
      << "the ambient Lie algebra of a "
      << "non-initialized sl(2)-subalgebra. "
      << global.fatal;
    }
    return *this->owner;
  }
  std::string toStringTriple(FormatExpressions* format) const;
  std::string toStringTripleStandardRealization() const;
  std::string toStringTripleVerification(FormatExpressions* format) const;
  std::string toStringCentralizer() const;
  std::string toStringTripleUnknowns(FormatExpressions* format) const;
  std::string toStringTripleUnknownsPolynomialSystem(
    FormatExpressions* format = nullptr
  ) const;
  template <typename Coefficient>
  std::string toStringPolynomialSystem(
    const PolynomialSubstitution<Coefficient>& system,
    FormatExpressions* format = nullptr
  ) const;
  std::string toStringTripleArbitrary(FormatExpressions* format) const;
  std::string toStringTripleArbitraryMatrix() const;
  std::string toStringDynkinType() const;
  std::string toString(FormatExpressions* format = nullptr) const;
  std::string toStringKostantSekiguchiTripleInternals(
    FormatExpressions* format
  ) const;
  std::string toStringKostantSekiguchiTriple(FormatExpressions* format) const;
  std::string toStringKostantSekiguchiTripleStandardRealization() const;
  void toHTML(std::string& filePath);
  void toStringModuleDecompositionMinimalContainingRegularSubalgebras(
    bool useLatex, bool useHtml, SlTwoSubalgebras& owner, std::string& output
  ) const;
  std::string toStringMinimalContainingRootSubalgebras(
    const std::string& displayPathAlgebra
  ) const;
  std::string toStringContainingRootSubalgebras(
    const std::string& displayPathAlgebra
  ) const;
  void computeModuleDecompositionsition(
    const Vectors<Rational>& positiveRootsContainingRegularSubalgebra,
    int dimensionContainingRegularSubalgebra,
    CharacterSemisimpleLieAlgebraModule<Rational>& outputHighestWeights,
    List<int>& outputModuleDimensions
  );
  Rational getDynkinIndex() const;
  bool checkIndicesMinimalContainingRootSubalgebras() const;
  void computeModuleDecompositionsitionAmbientLieAlgebra();
  bool attemptToComputeCentralizer();
  bool moduleDecompositionFitsInto(const SlTwoSubalgebra& other) const;
  static bool moduleDecompositionLeftFitsIntoRight(
    const CharacterSemisimpleLieAlgebraModule<Rational>& moduleDecompoLeft,
    const CharacterSemisimpleLieAlgebraModule<Rational>& moduleDecompoRight
  );
  // the below is outdated, must be deleted as soon as equivalent code is
  // written.
  void computeDynkinsEpsilon(WeylGroupData& weyl);
  bool operator==(const SlTwoSubalgebra& right) const;
  bool operator>(const SlTwoSubalgebra& right) const;
  unsigned int hashFunction() const;
  static inline unsigned int hashFunction(const SlTwoSubalgebra& input) {
    return input.hashFunction();
  }
  void computeModuleDecompositionMinimalContainingRegularSubalgebras(
    SlTwoSubalgebras& owner
  );
  void makeReportPrecomputations(
    RootSubalgebra& minimalContainingRegularSubalgebra
  );
};

class SlTwoSubalgebras {
  friend class SemisimpleSubalgebras;
  SemisimpleLieAlgebra* owner;
public:
  static std::string descriptionHCharacteristic;
  static std::string descriptionModuleDecompositionOverSl2;
  static std::string descriptionHRealization;
  static std::string descriptionMinimalContainingRegularSubalgebras;
  HashedList<SlTwoSubalgebra> allSubalgebras;
  List<List<int> > indicesSl2sContainedInRootSubalgebras;
  List<int> indicesSl2DecompositionFormulas;
  Vectors<Rational> unsuitableHs;
  int indexZeroWeight;
  RootSubalgebras rootSubalgebras;
  ~SlTwoSubalgebras() {}
  SlTwoSubalgebras(): owner(nullptr) {}
  SlTwoSubalgebras(SemisimpleLieAlgebra& inputOwner): owner(&inputOwner) {}
  bool operator==(const SlTwoSubalgebras& other) const {
    if (this->owner == nullptr) {
      return other.owner == nullptr;
    }
    if (other.owner == nullptr) {
      return false;
    }
    return this->getOwner() == other.getOwner();
  }
  bool checkConsistency() const;
  bool checkMinimalContainingRootSubalgebras() const;
  void checkInitialization() const;
  WeylGroupData& getOwnerWeyl() const {
    return this->getOwner().weylGroup;
  }
  SemisimpleLieAlgebra& getOwner() const {
    this->checkInitialization();
    return *this->owner;
  }
  void computeModuleDecompositionsitionsOfAmbientLieAlgebra();
  void reset(SemisimpleLieAlgebra& inputOwners);
  bool containsSl2WithGivenH(Vector<Rational>& elementH, int* outputIndex);
  void writeHTML(FormatExpressions* format = nullptr);
  std::string toString(FormatExpressions* format = nullptr);
  std::string toHTMLSummaryTable(FormatExpressions* format = nullptr);
  std::string toHTMLSummary(FormatExpressions* format = nullptr);
  std::string toStringModuleDecompositionMinimalContainingRegularSubalgebras(
    bool useLatex, bool useHtml
  );
  void computeRootSubalgebraContainers();
  void computeOneRootSubalgebraContainers(SlTwoSubalgebra& output);
  void computeCentralizers();
};

#endif // header_math_extra_semisimple_lie_subalgebras_sltwos_ALREADY_INCLUDED
