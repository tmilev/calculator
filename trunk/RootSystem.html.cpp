#include<sstream>
void static_html2(std::stringstream& output){
output << " <html>\n";
output << " <head> \n";
output << " <title>\n";
output << " Root systems\n";
output << " </title>\n";
output << " </head>\n";
output << " <body>\n";
}
void static_html3(std::stringstream& output){
output << " <!>\n";
output << " <!--Option-->\n";
output << " <select name=\"textType\" id=\"textType\" onchange=\"initRecompute();\">\n";
output << "   <option>A</option>\n";
output << "   <option selected=\"1\">B</option>\n";
output << "   <option>C</option>\n";
output << "   <option>D</option>\n";
output << "   <option>E</option>\n";
output << "   <option>F</option>\n";
output << "   <option>G</option>\n";
output << " </select>\n";
output << " <select name=\"textDim\" id=\"textDim\" onchange=\"initRecompute();\">\n";
output << "   <option>1</option>\n";
output << "   <option>2</option>\n";
output << "   <option selected=\"1\">3</option>\n";
output << "   <option>4</option>\n";
output << "   <option>5</option>\n";
output << "   <option>6</option>\n";
output << "   <option>7</option>\n";
output << "   <option>8</option>\n";
output << " </select>\n";
output << " <script type=\"text/javascript\"> \n";
output << " function switchMenu(obj){ var el = document.getElementById(obj);	if ( el.style.display != \"none\" ) { el.style.display = 'none'; } else { el.style.display = '';}}\n";
output << " </script>\n";
}
void static_html4(std::stringstream& output){
output << " <!>\n";
output << " \n";
output << " \n";
output << " <script type=\"text/javascript\" \n";
output << " src=\"http://ajax.googleapis.com/ajax/libs/dojo/1.4/dojo/dojo.xd.js\"  \n";
output << " djConfig = \"parseOnLoad: true\"></script>\n";
output << " <div style=\"width:400;height:400;border:solid 1px\" id=\"canvasMain\" onmousemove=\"mouseMoveRedraw(event.clientX, event.clientY);\" onmousedown=\"\n";
output << " clickCanvasMain(event.clientX, event.clientY);\n";
output << " //changeBasis(1, 50, 50); drawOnCanvasMain();\" onmouseup=\"ButtonIsDown=false; selectedBasisIndex=-1;\"></div>\n";
output << " <br>\n";
output << " The basis vectors correspond to the vertices of the Dynkin diagram.<br>\n";
output << " You can drag the center and the basis vectors.<button onclick=\"switchMenu('rotationExplanation')\">More info</button>\n";
output << " <br>\n";
output << " <div id=\"rotationExplanation\" style=\"display: none\">\n";
output << " The i^th vector corresponds to the i^th node of the Dynkin diagram of the root system.<br>\n";
output << " The nodes are labeled in Bourbaki order.<br>\n";
output << " Let the two dimensional plane we project onto be spanned by vectors e_1 and e_2.<br>\n";
output << " Let v be a basis vector which you drag, with orthogonal projection in the (e_1,e_2) plane equal to v' <br>\n";
output << " and with orthogonal complement v'':=v-v'.<br>\n";
output << " When you drag a basis vector v, you do two things.<br>\n";
output << " 1) You rotate e_1 and e_2 in the (e_1,e_2) plane, to match the rotation angle given by your mouse pointer<br>\n";
output << " 2) Then you apply a rotation in the (v,v'')-plane that preserves the orthogonal complement of the (v,v'')-plane <br> \n";
output << " such as to match the length of v' determined by your mouse pointer. <br>\n";
output << " Note that this operation is not defined if v lies in the (e_1, e_2) plane. <br>\n";
output << " If the above is the case, you will not be able to modify the length of v'. <br>  \n";
output << " <textarea id=\"debugField\" cols=\"128\" rows=\"15\">\n";
output << " </textarea><br>\n";
output << " </div><br>\n";
output << " The root system in simple basis coordinates follows. <br>\n";
output << " \n";
output << " \n";
output << " <textarea id=\"outputField\">\n";
output << " </textarea>\n";
output << " \n";
output << " <script type=\"text/javascript\">\n";
output << " var CartanSymmetric;\n";
output << " var InvertedCartan;\n";
output << " var theRootSystem;\n";
output << " var theRootSystemLongLength;\n";
output << " var theRootSystemLengths;\n";
output << " var theRootSystemSize;\n";
output << " var theRootSystemHashes;\n";
output << " var theRootSystemHashesSizes;\n";
output << " var HashSize=1000;\n";
output << " var theWeylLetter;\n";
output << " var theWeylDim;\n";
output << " var VectorE1;\n";
output << " var VectorE2;\n";
output << " \n";
output << " function generateRootSystemFromWeylLetterAndDim(WeylLetter, WeylDim)\n";
output << " { if (WeylLetter!=\"A\" && WeylLetter!=\"B\" && WeylLetter!=\"C\" && WeylLetter!=\"D\" && WeylLetter!=\"E\" && WeylLetter!=\"F\" && WeylLetter!=\"G\" )\n";
output << "     return;\n";
output << "   if (WeylDim>9 || WeylDim<1)\n";
output << "     return;\n";
output << "   makeCartanArbitrary(WeylLetter, WeylDim);\n";
output << "   InvertedCartan=invertMatrix(CartanSymmetric);\n";
output << "   VectorE1= new Array(theWeylDim);\n";
output << "   VectorE2= new Array(theWeylDim);\n";
output << "   for (var i=0; i<theWeylDim; i++)\n";
output << "   { VectorE1[i]=(i+1)*(i+1)+1;\n";
output << "     VectorE2[i]=i*3+1;\n";
output << "   }\n";
output << "   AddVectorTimes(VectorE1, VectorE2, -getScalarProduct(VectorE1, VectorE2)/getScalarProduct(VectorE2, VectorE2));\n";
output << "   MultiplyVector(VectorE1, Math.sqrt(1/(getScalarProduct(VectorE1, VectorE1))));\n";
output << "   MultiplyVector(VectorE2, Math.sqrt(1/(getScalarProduct(VectorE2, VectorE2))));\n";
output << "   GenerateRootSystem();\n";
output << "   theRootSystemLengths= new Array(theRootSystem.length);\n";
output << "   theRootSystemLongLength= getScalarProduct(theRootSystem[0], theRootSystem[0]);\n";
output << "   for (var i=0; i<theRootSystemSize; i++)\n";
output << "   { theRootSystemLengths[i]= getScalarProduct(theRootSystem[i], theRootSystem[i]);\n";
output << "     if (theRootSystemLengths[i]>theRootSystemLongLength)\n";
output << "       theRootSystemLongLength=theRootSystemLengths[i];\n";
output << "   }\n";
output << "   ComputeProjections();\n";
output << " }\n";
output << " \n";
output << " function ComputeProjections()\n";
output << " { for (var i=0; i<theWeylDim; i++)\n";
output << "   { Basis[i][0]=GraphicsUnit*getScalarProduct(VectorE1, theRootSystem[i]);\n";
output << "     Basis[i][1]=GraphicsUnit*getScalarProduct(VectorE2, theRootSystem[i]);\n";
output << "   }\n";
output << " }\n";
output << " \n";
output << " function MultiplyVector(output, coeff)\n";
output << " { for (var i=0; i<output.length; i++)\n";
output << "     output[i]*=coeff;\n";
output << " }\n";
output << " \n";
output << " function AddVectorTimes(output, inputVector, coeff)\n";
output << " { for (var i=0; i<output.length; i++)\n";
output << "     output[i]+=inputVector[i]*coeff;\n";
output << " }\n";
output << " \n";
output << " function makeCartanArbitrary(WeylLetter, WeylDim)\n";
output << " { theWeylLetter=WeylLetter;\n";
output << "   theWeylDim= WeylDim;\n";
output << "   if (theWeylLetter==\"E\")\n";
output << "   { if (theWeylDim<6)\n";
output << "       theWeylDim=6;\n";
output << "     if (theWeylDim>8)\n";
output << "       theWeylDim=8;\n";
output << "   }\n";
output << "   if (theWeylLetter==\"G\")\n";
output << "     theWeylDim=2;\n";
output << "   if (theWeylLetter==\"F\")\n";
output << "     theWeylDim=4;\n";
output << "   makeCartanAn(theWeylDim);\n";
output << "   if (theWeylLetter==\"B\")\n";
output << "   { CartanSymmetric[theWeylDim-1][theWeylDim-1]=1;\n";
output << "   }\n";
output << "   if (theWeylLetter==\"C\")\n";
output << "   {CartanSymmetric[theWeylDim-1][theWeylDim-1]=4;\n";
output << "    CartanSymmetric[theWeylDim-1][theWeylDim-2]=-2;\n";
output << "    CartanSymmetric[theWeylDim-2][theWeylDim-1]=-2;\n";
output << "   }\n";
output << "   if (theWeylLetter==\"F\")\n";
output << "   { CartanSymmetric[0][0]=2 ; CartanSymmetric[0][1]=-1;\n";
output << "     CartanSymmetric[1][0]=-1; CartanSymmetric[1][1]=2 ; CartanSymmetric[1][2]=-2;\n";
output << "     CartanSymmetric[2][1]=-2; CartanSymmetric[2][2]=4 ; CartanSymmetric[2][3]=-2;\n";
output << "     CartanSymmetric[3][2]=-2; CartanSymmetric[3][3]=4 ;\n";
output << "   }\n";
output << "   if (theWeylLetter==\"D\")\n";
output << "   { CartanSymmetric[theWeylDim-2][theWeylDim-1]=0;\n";
output << "     CartanSymmetric[theWeylDim-1][theWeylDim-2]=0;\n";
output << "     CartanSymmetric[theWeylDim-3][theWeylDim-1]=-1;\n";
output << "     CartanSymmetric[theWeylDim-1][theWeylDim-3]=-1;\n";
output << "   }\n";
output << "   if (theWeylLetter==\"E\")\n";
output << "   { CartanSymmetric[0][1]=0; CartanSymmetric[1][0]=0;\n";
output << "     CartanSymmetric[1][2]=0; CartanSymmetric[2][1]=0;\n";
output << "     CartanSymmetric[0][2]=-1; CartanSymmetric[2][0]=-1;\n";
output << "     CartanSymmetric[1][3]=-1; CartanSymmetric[3][1]=-1;\n";
output << "   }  \n";
output << "   if (theWeylLetter==\"G\")\n";
output << "   { CartanSymmetric[0][0]=6; CartanSymmetric[0][1]=-3;\n";
output << "     CartanSymmetric[1][0]=-3; CartanSymmetric[1][1]=2;\n";
output << "   }\n";
output << "   document.getElementById(\"textDim\").value=theWeylDim;\n";
output << "   document.getElementById(\"textType\").value=theWeylLetter;  \n";
output << " }\n";
output << " \n";
output << " function makeCartanAn(WeylDim)\n";
output << " { CartanSymmetric= new Array(WeylDim);\n";
output << "   for (var i=0; i<WeylDim; i++)\n";
output << "   { CartanSymmetric[i]= new Array(WeylDim);\n";
output << "     for (var j=0; j<WeylDim; j++)\n";
output << "       CartanSymmetric[i][j]=0;\n";
output << "     CartanSymmetric[i][i]=2;\n";
output << "     if (i<WeylDim-1)\n";
output << "       CartanSymmetric[i][i+1]=-1;\n";
output << "     if (i>0)\n";
output << "       CartanSymmetric[i][i-1]=-1;\n";
output << "   }\n";
output << " }\n";
output << " \n";
output << " function ClearRootSystem()\n";
output << " { theRootSystemHashes= new Array(HashSize);\n";
output << "   theRootSystemHashesSizes= new Array(HashSize);\n";
output << "   theRootSystem= new Object(Array(HashSize));\n";
output << "   for (var i=0; i<HashSize; i++)\n";
output << "   { theRootSystemHashesSizes[i]=0;\n";
output << "     theRootSystemHashes[i]= new Array();\n";
output << "   }\n";
output << "   theRootSystemSize=0;\n";
output << " }\n";
output << " \n";
output << " function HashFunctionRoot(theRoot, theWeylDim)\n";
output << " { var result=0;\n";
output << "   for (var i=0; i<theWeylDim; i++)\n";
output << "     result+=(i+6)*(6+1)*theRoot[i];\n";
output << "   result= result % HashSize;\n";
output << "   if (result<0)\n";
output << "     result+=HashSize;\n";
output << "   return result;\n";
output << " }\n";
output << " \n";
output << " function getRootIndex(theRoot, theWeylDim)\n";
output << " { var theHash = HashFunctionRoot(theRoot, theWeylDim);\n";
output << "   var hashArraySize=theRootSystemHashesSizes[theHash];\n";
output << "   for (var i=0; i<hashArraySize; i++)\n";
output << "   { theIndex=theRootSystemHashes[theHash][i];\n";
output << "     if (AreEqualRoots(theRootSystem[theIndex], theRoot, theWeylDim))\n";
output << "       return theIndex;\n";
output << "   }\n";
output << "   return -1;\n";
output << " }\n";
output << " \n";
output << " function AreEqualRoots(root1, root2, theDim)\n";
output << " { for (var i=0; i<theDim; i++)\n";
output << "     if (root1[i]!=root2[i])\n";
output << "       return false;\n";
output << "   return true;\n";
output << " }\n";
output << " \n";
output << " function addToRootSystemNoRepetition(theRoot)\n";
output << " { var theIndex=getRootIndex(theRoot, theWeylDim);\n";
output << "   if (theIndex==-1)\n";
output << "   { theRootSystem[theRootSystemSize]=new Array(theWeylDim);\n";
output << "     for (var i=0; i<theWeylDim; i++)\n";
output << "       theRootSystem[theRootSystemSize][i]=theRoot[i];\n";
output << "     var theHashIndex=HashFunctionRoot(theRoot, theWeylDim);\n";
output << "     var theHashSize=theRootSystemHashesSizes[theHashIndex];\n";
output << "     theRootSystemHashes[theHashIndex][theHashSize]=theRootSystemSize;\n";
output << "     theRootSystemHashesSizes[theHashIndex]++;\n";
output << "     theRootSystemSize++;\n";
output << "   }\n";
output << "   return false;\n";
output << " }\n";
output << " \n";
output << " function getScalarProduct(root1, root2)\n";
output << " { var result=0; \n";
output << "   for (var i=0; i<theWeylDim; i++)\n";
output << "     for (var j=0; j<theWeylDim; j++)\n";
output << "       result+= root1[i]*root2[j]*CartanSymmetric[i][j];\n";
output << "   \n";
output << "   return result;\n";
output << " }\n";
output << " \n";
output << " function ActOnARootGenIndex(theIndex, input, output)\n";
output << " { for (i=0; i<theWeylDim; i++)\n";
output << "     output[i]= input[i];\n";
output << "   theScalarProduct=getScalarProduct(theRootSystem[theIndex], input);\n";
output << "   output[theIndex]-= theScalarProduct*2/getScalarProduct(theRootSystem[theIndex],theRootSystem[theIndex]);\n";
output << "   return output;\n";
output << " }\n";
output << " \n";
output << " function GenerateRootSystem()\n";
output << " { var theOutputRoot= new Object(Array(theWeylDim));\n";
output << "   ClearRootSystem();\n";
output << "   for (var j=0; j<theWeylDim; j++)\n";
output << "   { for (var i=0; i<theWeylDim; i++)\n";
output << "       theOutputRoot[i]=0;\n";
output << "     theOutputRoot[j]=1;\n";
output << "     addToRootSystemNoRepetition(theOutputRoot);\n";
output << "   }\n";
output << "   for (var l=0; l<theRootSystemSize; l++)\n";
output << "   { for (var j=0; j<theWeylDim; j++)\n";
output << "     { theOutputRoot=ActOnARootGenIndex(j, theRootSystem[l], theOutputRoot);\n";
output << "       addToRootSystemNoRepetition(theOutputRoot);\n";
output << "     }\n";
output << "   }\n";
output << "   WriteRootSystem();\n";
output << "   drawOnCanvasMain();\n";
output << " }\n";
output << " \n";
output << " function WriteRootSystem()\n";
output << " { var output = document.getElementById(\"outputField\");\n";
output << "   output.value=\"\";\n";
output << "   output.rows=theRootSystemSize;\n";
output << "   var tempS;\n";
output << "   for (var i=0; i<theRootSystemSize; i++)\n";
output << "   { tempS=\"(\";\n";
output << "     for (var j=0; j<theWeylDim; j++)\n";
output << "     { tempS=tempS+theRootSystem[i][j];\n";
output << "       if (j!=theWeylDim-1)\n";
output << "         tempS=tempS+\",\";\n";
output << "     }\n";
output << "     tempS=tempS+\")\";\n";
output << "     output.value+=tempS;\n";
output << "     if (i!=theRootSystemSize-1)\n";
output << "       output.value+=\"\\n\";\n";
output << "   }  \n";
output << " }\n";
output << " </script>\n";
output << " \n";
output << " <script type=\"text/javascript\">\n";
output << " var NumElements=0;\n";
output << " var node;\n";
output << " var surface;\n";
output << " var MaxNumCoords=8;\n";
output << " var Basis= new Array(MaxNumCoords);\n";
output << " var Xshift=200;\n";
output << " var Yshift=200;\n";
output << " var selectedBasisIndex=-1;//-2 = center of coord system is selected\n";
output << " var GraphicsUnit=80;\n";
output << " var clickTolerance=5;\n";
output << " var RootsArray;\n";
output << " var ZeroRoot;\n";
output << " var ButtonIsDown=false;\n";
output << " var DebugString;\n";
output << " for (tempCounter=0; tempCounter<MaxNumCoords; tempCounter++)\n";
output << "   Basis[tempCounter]= new Array(2);\n";
output << " tempCounter=0;\n";
output << " Basis[tempCounter][0]=0.3;  Basis[tempCounter][1]=0; tempCounter++; \n";
output << " Basis[tempCounter][0]=0.4;    Basis[tempCounter][1]=-0.1; tempCounter++; \n";
output << " Basis[tempCounter][0]=0.4;   Basis[tempCounter][1]=0.1; tempCounter++; \n";
output << " Basis[tempCounter][0]=-0.8;  Basis[tempCounter][1]=1.4; tempCounter++; \n";
output << " Basis[tempCounter][0]=1.6;  Basis[tempCounter][1]=0.9; tempCounter++; \n";
output << " Basis[tempCounter][0]=1.6;  Basis[tempCounter][1]=0.8; tempCounter++; \n";
output << " Basis[tempCounter][0]=1.5;  Basis[tempCounter][1]=0.8; tempCounter++; \n";
output << " Basis[tempCounter][0]=1.4;  Basis[tempCounter][1]=0.8; tempCounter++; \n";
output << " for (tempCounter=0; tempCounter<MaxNumCoords; tempCounter++)\n";
output << " { Basis[tempCounter][0]*= GraphicsUnit;\n";
output << "   Basis[tempCounter][1]*= GraphicsUnit;\n";
output << " } \n";
output << " \n";
output << " function ptsWithinClickTolerance(x1, y1, x2, y2)\n";
output << " { if (x1-x2>clickTolerance || x2-x1>clickTolerance || y1-y2>clickTolerance || y2-y1>clickTolerance )\n";
output << "     return false;\n";
output << "   return true;\n";
output << " }\n";
output << " \n";
output << " function clickCanvasMain(cx,cy)\n";
output << " { var divPosX=0;\n";
output << "   var divPosY=0;\n";
output << "   var thePointer= canvasMain;\n";
output << "   while(thePointer)\n";
output << "   { divPosX += thePointer.offsetLeft;\n";
output << "     divPosY += thePointer.offsetTop;\n";
output << "     thePointer = thePointer.offsetParent;\n";
output << "   }\n";
output << "   var posx=(cx-divPosX+document.body.scrollLeft-Xshift);\n";
output << "   var posy=-(cy-divPosY+document.body.scrollTop-Yshift);\n";
output << "   selectedBasisIndex=-1;\n";
output << "   if (ptsWithinClickTolerance(posx,posy,0,0))\n";
output << "     selectedBasisIndex=-2;\n";
output << "   for (i=0;i<MaxNumCoords;i++)\n";
output << "   { if (ptsWithinClickTolerance(posx, posy, Basis[i][0], Basis[i][1]))\n";
output << "       selectedBasisIndex=i;\n";
output << "   }\n";
output << " }\n";
output << " \n";
output << " function RotateOutOfPlane(input, orthoBasis1, orthoBasis2, oldTanSquared, newTanSquared)\n";
output << " { var projection= dojo.clone(orthoBasis1);\n";
output << "   var vComponent= dojo.clone(input);\n";
output << "   var scal1= getScalarProduct(orthoBasis1, input);\n";
output << "   var scal2= getScalarProduct(orthoBasis2, input);\n";
output << "   MultiplyVector(projection, scal1);\n";
output << "   AddVectorTimes(projection, orthoBasis2, scal2);\n";
output << "   AddVectorTimes(vComponent, projection, -1);\n";
output << "   DebugString+=\"\\ngetScalarProd=\"+getScalarProduct(projection, vComponent);\n";
output << "   var oldAngle=Math.atan(Math.sqrt(oldTanSquared));\n";
output << "   var newAngle=Math.atan(Math.sqrt(newTanSquared));\n";
output << "   if (isNaN(oldAngle) || isNaN(newAngle))\n";
output << "     return input;\n";
output << "   var angleChange=-oldAngle+newAngle;  \n";
output << "   projection=dojo.clone(orthoBasis1);\n";
output << "   MultiplyVector(projection,              Math.cos(angleChange)*scal1-Math.sin(angleChange)*scal2);\n";
output << "   AddVectorTimes(projection, orthoBasis2, Math.sin(angleChange)*scal1+Math.sin(angleChange)*scal2);\n";
output << "   var result= vComponent;\n";
output << "   AddVectorTimes(result, projection, 1);  \n";
output << "   return result;\n";
output << " }\n";
output << " \n";
output << " function ScaleToUnitLength(vector)\n";
output << " { MultiplyVector(vector, 1/Math.sqrt(getScalarProduct(vector,vector)));\n";
output << " }\n";
output << " \n";
output << " function RootToString(theRoot)\n";
output << " {  var output=\"(\";\n";
output << "   for (var i=0; i<theWeylDim; i++)\n";
output << "   { output=output+ theRoot[i].toFixed(2);\n";
output << "     if (i!=theWeylDim-1)\n";
output << "      output+=\",\";\n";
output << "   }\n";
output << "   output+=\")\";\n";
output << "   return output;\n";
output << " }\n";
output << " \n";
output << " function getQuadrantFromXandY(theX, theY)\n";
output << " { if (theX>0 && theY>=0)\n";
output << "     return 1;\n";
output << "   if (theX<=0 && theY>0)\n";
output << "     return 2;\n";
output << "   if (theX<0 && theY<=0)\n";
output << "     return 3;\n";
output << "   return 4;\n";
output << " }\n";
output << " \n";
output << " function getAngleFromXandY(x, y, neighborX, neighborY)\n";
output << " { var result;\n";
output << "   if (x!=0)\n";
output << "    result= Math.atan(y/x);\n";
output << "   else \n";
output << "     if (y>0)\n";
output << "       result= Math.PI/2;\n";
output << "     else\n";
output << "       result= -Math.PI/2;\n";
output << "   return result;     \n";
output << " }\n";
output << " \n";
output << " function changeBasis(selectedIndex, newX, newY)\n";
output << " { if (newX==0 && newY==0)\n";
output << "     return;\n";
output << "   DebugString=\"\";\n";
output << "   var selectedRoot=theRootSystem[selectedIndex];\n";
output << "   var selectedRootLength=getScalarProduct(selectedRoot,selectedRoot);  \n";
output << "   var oldX=Basis[selectedIndex][0]/GraphicsUnit;\n";
output << "   var oldY=Basis[selectedIndex][1]/GraphicsUnit; \n";
output << "   newX/=GraphicsUnit;\n";
output << "   newY/=GraphicsUnit;\n";
output << "   var oldAngle= getAngleFromXandY(oldX, oldY, newX, newY);\n";
output << "   var newAngle= getAngleFromXandY(newX, newY, oldX, oldY);    \n";
output << "   var AngleChange= -newAngle+oldAngle;\n";
output << "   var epsilon=0.000015;\n";
output << "   while (AngleChange>=Math.PI/2+epsilon)\n";
output << "   { AngleChange-=Math.PI;}\n";
output << "   while (AngleChange<=-Math.PI/2-epsilon)\n";
output << "   { AngleChange+=Math.PI;}\n";
output << "   DebugString+=\"\\nold angle:\"+ oldAngle.toFixed(2);\n";
output << "   DebugString+=\"\\nnew angle: \"+newAngle.toFixed(2);\n";
output << "   var NewVectorE1=dojo.clone(VectorE1);\n";
output << "   var NewVectorE2= dojo.clone(VectorE2);\n";
output << "   MultiplyVector(NewVectorE1, Math.cos(AngleChange));\n";
output << "   AddVectorTimes(NewVectorE1, VectorE2, Math.sin(AngleChange));\n";
output << "   MultiplyVector(NewVectorE2, Math.cos(AngleChange));\n";
output << "   AddVectorTimes(NewVectorE2, VectorE1, -Math.sin(AngleChange));\n";
output << "   VectorE1=NewVectorE1;\n";
output << "   VectorE2=NewVectorE2;\n";
output << "   var RootTimesE1=getScalarProduct(selectedRoot, VectorE1);\n";
output << "   var RootTimesE2=getScalarProduct(selectedRoot, VectorE2);\n";
output << "   var vOrthogonal=dojo.clone(selectedRoot);\n";
output << "   var vProjection=dojo.clone(VectorE1); \n";
output << "   MultiplyVector(vProjection, RootTimesE1);\n";
output << "   AddVectorTimes(vProjection, VectorE2, RootTimesE2);\n";
output << "   AddVectorTimes(vOrthogonal, vProjection, -1);\n";
output << "   var oldRatioProjectionOverHeightSquared = (oldX*oldX+oldY*oldY)/ (selectedRootLength-oldX*oldX-oldY*oldY);\n";
output << "   var newRatioProjectionOverHeightSquared = (newX*newX+newY*newY)/ (selectedRootLength-newX*newX-newY*newY);\n";
output << "   DebugString+=\"\\noldRatio: \"+oldRatioProjectionOverHeightSquared;\n";
output << "   DebugString+=\"\\nnewRatio: \"+newRatioProjectionOverHeightSquared;\n";
output << "   if (getScalarProduct(vOrthogonal, vOrthogonal)>epsilon || getScalarProduct(vOrthogonal, vOrthogonal)<-epsilon)\n";
output << "   { ScaleToUnitLength(vProjection);\n";
output << "     ScaleToUnitLength(vOrthogonal);\n";
output << "     DebugString+=\"\\nscaled vOrthogonal=\"+RootToString(vOrthogonal)+\"->\"+getScalarProduct(vOrthogonal,vOrthogonal);\n";
output << "     DebugString+=\"\\nscaled vProjection=\"+RootToString(vProjection)+\"->\"+getScalarProduct(vProjection,vProjection); \n";
output << "     DebugString+=\"\\ntheScalarProd: \"+getScalarProduct(vOrthogonal, vProjection);  \n";
output << "     VectorE1=RotateOutOfPlane(VectorE1, vProjection, vOrthogonal, oldRatioProjectionOverHeightSquared, newRatioProjectionOverHeightSquared);\n";
output << "     VectorE2=RotateOutOfPlane(VectorE2, vProjection, vOrthogonal, oldRatioProjectionOverHeightSquared, newRatioProjectionOverHeightSquared);\n";
output << "   }\n";
output << "   AddVectorTimes(VectorE2, VectorE1, -getScalarProduct(VectorE1, VectorE1)*getScalarProduct(VectorE1, VectorE2));\n";
output << "   ScaleToUnitLength(VectorE1);\n";
output << "   ScaleToUnitLength(VectorE2);\n";
output << "   \n";
output << "   DebugString+=\"\\ne1=\"+RootToString(VectorE1);\n";
output << "   DebugString+=\"\\ne2=\"+RootToString(VectorE2);\n";
output << "   DebugString+=\"\\ne1*e2=\"+getScalarProduct(VectorE1, VectorE2);  \n";
output << "   ComputeProjections();\n";
output << " }\n";
output << " \n";
output << " function fixE1AndE2andComputeProjections()\n";
output << " { var tempE1= new Array(theWeylDim);\n";
output << "   var tempE2= new Array(theWeylDim);\n";
output << "   for (var i=0; i<theWeylDim; i++)\n";
output << "   { tempE1[i]=Basis[i][0];\n";
output << "     tempE2[i]=Basis[i][1];\n";
output << "   }\n";
output << "   VectorE1=matrixActOnRow(InvertedCartan, tempE1);\n";
output << "   VectorE2=matrixActOnRow(InvertedCartan, tempE2);\n";
output << "   var tempLength1=getScalarProduct(VectorE1, VectorE1);\n";
output << "   var tempLength2=getScalarProduct(VectorE2, VectorE2);\n";
output << "   \n";
output << " }\n";
output << " \n";
output << " function matrixActOnRow(theMatrix, theRow)\n";
output << " { var output=new Array(theRow.length);\n";
output << "   for (var i=0; i<theMatrix.length; i++)\n";
output << "   { output[i]=0;\n";
output << "     for (var j=0; j<theMatrix.length; j++)\n";
output << "       output[i]+=theMatrix[j][i]*theRow[j];\n";
output << "   }\n";
output << "   return output;\n";
output << " }\n";
output << " \n";
output << " function swapTwoRows(theMatrix, index1, index2)\n";
output << " { var temp;\n";
output << "   for (var i=0; i<theMatrix.length; i++)\n";
output << "   { temp=theMatrix[index1][i];\n";
output << "     theMatrix[index1][i]=theMatrix[index2][i];\n";
output << "     theMatrix[index2][i]=temp;\n";
output << "   }\n";
output << " }\n";
output << " \n";
output << " function addToRowRowTimesCoeff(theMatrix, indexModified, indexOther, coeff)\n";
output << " { for (var i=0; i<theMatrix.length; i++)\n";
output << "     theMatrix[indexModified][i]+=coeff*theMatrix[indexOther][i];\n";
output << " }\n";
output << " \n";
output << " function multiplyRowBy(theMatrix, rowIndex, coeff)\n";
output << " { for (var i=0; i<theMatrix.length; i++)\n";
output << "     theMatrix[rowIndex][i]*=coeff;\n";
output << " }\n";
output << " \n";
output << " function findPivot(theMatrix, columnIndex, minPossibleAnswer)\n";
output << " { for (var i=minPossibleAnswer; i<theMatrix.length; i++)\n";
output << "     if (theMatrix[i][columnIndex]!=0)\n";
output << "       return i;\n";
output << "   return -1;\n";
output << " }\n";
output << " \n";
output << " function getIdentityMatrix(dimension)\n";
output << " { var answer= new Array(dimension);\n";
output << "   for (var i=0; i<dimension; i++)\n";
output << "   { answer[i]= new Array(dimension);\n";
output << "     for (var j=0; j<dimension; j++)\n";
output << "       if (i==j)\n";
output << "         answer[i][j]=1;\n";
output << "       else\n";
output << "         answer[i][j]=0;\n";
output << "   }\n";
output << "   return answer;\n";
output << " }\n";
output << " \n";
output << " function invertMatrix(theInputMatrix)\n";
output << " { var theMatrix= dojo.clone(theInputMatrix);\n";
output << "   var theDim=theMatrix.length;\n";
output << "   var answer= getIdentityMatrix(theDim);\n";
output << "   for (var i=0; i<theDim; i++)\n";
output << "   { var thePivotIndex=findPivot(theMatrix, i, i);\n";
output << "     if (thePivotIndex==-1)\n";
output << "       return;\n";
output << "     swapTwoRows(answer, thePivotIndex, i);\n";
output << "     swapTwoRows(theMatrix, thePivotIndex, i);\n";
output << "     multiplyRowBy(answer, i, 1/theMatrix[i][i]);    \n";
output << "     multiplyRowBy(theMatrix, i, 1/theMatrix[i][i]);\n";
output << "     for (var j=0; j<theDim; j++)\n";
output << "       if (i!=j)\n";
output << "       { addToRowRowTimesCoeff(answer, j, i, -theMatrix[j][i]);\n";
output << "         addToRowRowTimesCoeff(theMatrix, j, i, -theMatrix[j][i]);\n";
output << "       }\n";
output << "   }\n";
output << "   return answer;\n";
output << " }\n";
output << " \n";
output << " function solveTwoByTwoSystem(a11, a12, a21, a22, coeff1, coeff2)\n";
output << " { var answer= new Array(2);\n";
output << "   var theDeterminant=a11*a22-a21*a12;\n";
output << "   answer[0]=(coeff1*a22-coeff2*a12)/theDeterminant;\n";
output << "   answer[1]=(a11*coeff2-a21*coeff1)/theDeterminant;\n";
output << "   return answer;\n";
output << " } \n";
output << "  \n";
output << " function mouseMoveRedraw(cx, cy)\n";
output << " { if (selectedBasisIndex!=-1)\n";
output << "   { var divPosX=0;\n";
output << "     var divPosY=0;\n";
output << "     var thePointer= canvasMain;\n";
output << "     while(thePointer)\n";
output << "     { divPosX += thePointer.offsetLeft;\n";
output << "       divPosY += thePointer.offsetTop;\n";
output << "       thePointer = thePointer.offsetParent;\n";
output << "     }\n";
output << "     var posx=(cx-divPosX+document.body.scrollLeft-Xshift);\n";
output << "     var posy=-(cy-divPosY+document.body.scrollTop-Yshift);\n";
output << "     if (selectedBasisIndex==-2)\n";
output << "     { Xshift=(cx-divPosX+document.body.scrollLeft);\n";
output << "       Yshift=(cy-divPosY+document.body.scrollTop);\n";
output << "     }\n";
output << " 		else\n";
output << "     {	//posx=50; posy=50;\n";
output << "       changeBasis(selectedBasisIndex, posx, posy);\n";
output << "     }\n";
output << "     drawOnCanvasMain();\n";
output << "   }\n";
output << " }\n";
output << " \n";
output << " function getCoord(thePoint, Coord)\n";
output << " { var result=Number(0);\n";
output << "   for (var counterI=0; counterI<theWeylDim; counterI++)\n";
output << "     result= result+ thePoint[counterI]*Basis[counterI][Coord];\n";
output << "   result=Math.floor(result);\n";
output << "   return result;\n";
output << " }\n";
output << " \n";
output << " function drawLineBetweenZeroAndRoot(theRoot)\n";
output << " { xCoord1=getCoord(ZeroRoot,0)+Xshift;\n";
output << "   yCoord1=-getCoord(ZeroRoot,1)+Yshift;\n";
output << "   xCoord2=getCoord(theRoot,0)+Xshift;\n";
output << "   yCoord2=-getCoord(theRoot,1)+Yshift;\n";
output << "   var theColor;\n";
output << "   if (getScalarProduct(theRoot, theRoot)==theRootSystemLongLength)\n";
output << "     theColor =\"blue\";\n";
output << "   else\n";
output << "     theColor =\"#C0C0FF\"; \n";
output << "   surface.createLine({ x1 : xCoord1, y1 : yCoord1, x2 : xCoord2, y2 : yCoord2 }).setStroke({color : theColor});\n";
output << " }\n";
output << " \n";
output << " function drawCircleAtRoot(theRoot)\n";
output << " { xCoord1=getCoord(theRoot,0)+Xshift;\n";
output << "   yCoord1=-getCoord(theRoot,1)+Yshift;\n";
output << "   surface.createEllipse({ cx : xCoord1, cy : yCoord1, rx : 2, ry : 2 }).setStroke({color : \"red\"});\n";
output << " }\n";
output << " \n";
output << " function drawTextAtRoot(theRoot, theText)\n";
output << " { xCoord1=getCoord(theRoot,0)+Xshift;\n";
output << "   yCoord1=-getCoord(theRoot,1)+Yshift;\n";
output << "   var tempText=surface.createText({x: xCoord1, y: yCoord1, text: theText});\n";
output << "   tempText.setFont({family : \"Arial\", size : \"9pt\"});\n";
output << "   tempText.setStroke(\"black\");\n";
output << " }\n";
output << " \n";
output << " function drawOnCanvasMain()\n";
output << " {//	alert(\"paint\");\n";
output << "   surface.clear();\n";
output << "   ZeroRoot= new Array(theWeylDim);\n";
output << "   var tempRoot=new Array(theWeylDim);\n";
output << "   surface.createLine({ x1 : Xshift, y1 : Yshift, x2 : Xshift, y2 : Yshift-GraphicsUnit }).setStroke({color : \"#EFEFEF\"});\n";
output << "   surface.createLine({ x1 : Xshift, y1 : Yshift, x2 : Xshift+GraphicsUnit, y2 : Yshift }).setStroke({color : \"#EFEFEF\"});\n";
output << "   for (var i=0; i<theWeylDim; i++)\n";
output << "   { ZeroRoot[i]=0;\n";
output << "     tempRoot[i]=0;\n";
output << "   }\n";
output << "   for (var i=0; i<theWeylDim; i++)\n";
output << "   { tempRoot[i]=1;\n";
output << "     drawCircleAtRoot(tempRoot);\n";
output << "     drawTextAtRoot(tempRoot, i+1);\n";
output << "     tempRoot[i]=0;\n";
output << "   }\n";
output << "   for (var CounterK=0; CounterK<theRootSystemSize; CounterK++)\n";
output << "     drawLineBetweenZeroAndRoot(theRootSystem[CounterK]);  \n";
output << "   var debugLog = document.getElementById(\"debugField\");\n";
output << "   debugLog.value=DebugString;\n";
output << " }\n";
output << " \n";
output << " function initDojo()\n";
output << " { node = dojo.byId(canvasMain);\n";
output << "   surface = dojox.gfx.createSurface(node, 400, 400);\n";
output << "   initRecompute();\n";
output << " }\n";
output << " \n";
output << " function initRecompute()\n";
output << " { var tempWeylLetter=document.getElementById(\"textType\").value;\n";
output << "   var tempWeylDim=document.getElementById(\"textDim\").value;\n";
output << "   tempWeylDim=Number(tempWeylDim);\n";
output << "   tempWeylLetter=tempWeylLetter.toUpperCase();\n";
output << "   generateRootSystemFromWeylLetterAndDim(tempWeylLetter, tempWeylDim); \n";
output << "   drawOnCanvasMain();\n";
output << " }\n";
output << " dojo.require(\"dojox.gfx\");\n";
output << " dojo.addOnLoad(initDojo);\n";
output << " </script>\n";
}
void static_html5(std::stringstream& output){
output << " <!>\n";
output << " </body>\n";
output << " </html>\n";
output << " \n";
output << " \n";
}
