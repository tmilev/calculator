// The current file is licensed under the license terms found in the main header file "calculator.h".
// For additional information refer to the file "calculator.h".
#include "general_lists.h"
#include "math_general_implementation.h"
#include "math_general.h"
#include "math_general_polynomial_computations_basic_implementation.h"
#include "math_extra_algebraic_numbers.h"
#include "math_extra_universal_enveloping.h"
#include "math_extra_semisimple_Lie_algebras_root_subalgebras.h"
#include "math_extra_semisimple_Lie_algebras_implementation.h"
#include "math_extra_finite_groups_implementation.h"
#include "math_extra_universal_enveloping_implementation.h" // undefined reference to `ElementUniversalEnveloping<RationalFunctionOld>::makeZero(SemisimpleLieAlgebra&)'

std::string MonomialWeylAlgebra::toString(FormatExpressions* theFormat) const {
  if (this->isConstant()) {
    return "1";
  }
  std::stringstream out;
  FormatExpressions tempFormat;
  if (theFormat == nullptr) {
    tempFormat.polyDefaultLetter = "\\partial";
  } else {
    tempFormat.polyDefaultLetter = theFormat->WeylAlgebraDefaultLetter;
    tempFormat.polynomialAlphabet = theFormat->weylAlgebraLetters;
  }
  std::string firstS = this->polynomialPart.toString(theFormat);
  std::string secondS = this->differentialPart.toString(&tempFormat);
  if (firstS != "1") {
    out << firstS;
  }
  if (secondS != "1") {
    out << secondS;
  }
  return out.str();
}

Vector<Rational> SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms::GetRho() {
  Vector<Rational> result;
  this->RootsOfBorel.sum(result, this->AmbientWeyl->getDimension());
  result /= 2;
  return result;
}

void SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms::getMatrixOfElement(
  const ElementSubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms& input, Matrix<Rational>& outputMatrix
) const {
  Vectors<Rational> startBasis, imageBasis;
  startBasis.makeEiBasis(this->AmbientWeyl->getDimension());
  this->actByElement(input, startBasis, imageBasis);
  outputMatrix.assignVectorsToRows(imageBasis);
  outputMatrix.transpose();
}

bool SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms::ComputeSubGroupFromGeneratingReflections(
  Vectors<Rational>* inputRoots,
  List<Vectors<Rational> >* inputExternalAutos,
  int UpperLimitNumElements,
  bool recomputeAmbientRho
) {
  MacroRegisterFunctionWithName("SubgroupWeylGroupAutomorphisms::SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms");
  this->checkInitialization();
  HashedList<Vector<Rational> > orbitRho;
  this->truncated = false;
  this->allElements.clear();
  orbitRho.clear();
  if (this->AmbientWeyl->cartanSymmetric.numberOfRows < 1) {
    return false;
  }
  if (recomputeAmbientRho) {
    this->AmbientWeyl->ComputeRho(false);
  }
  this->simpleRootsInner.setSize(0);
  if (inputRoots != nullptr) {
    this->simpleRootsInner = *inputRoots;
  }
  if (inputExternalAutos != nullptr) {
    this->ExternalAutomorphisms = *inputExternalAutos;
  }
  this->AmbientWeyl->TransformToSimpleBasisGenerators(this->simpleRootsInner, this->AmbientWeyl->RootSystem);
  this->ComputeRootSubsystem();
  ElementSubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms currentElement;
  currentElement.owner = this;
  Vector<Rational> vectorGeneratingFaithfulOrbit;
  vectorGeneratingFaithfulOrbit = this->AmbientWeyl->rho;
  //We desire that the stabilizer of vectorGeneratingFaithfulOrbit
  //is trivial, i.e., the orbit generated by that vector will have as many
  //elements as the subgroup.
  //This is guaranteed if the vector has trivial stabilizer in the
  //ambient Weyl group + outer automorphisms.
  //The rho element (half sum of positive roots divided by 2)
  //almost meets the requirements: it has no stabilizer in the Weyl group
  //but unfortunately is not stabilized by the outer automorphisms.
  //To circumvent the issue, we make the following dirty hack
  //which will work on any simple Weyl group. A proper fix
  //requires some math work and we postpone it to the future.
  vectorGeneratingFaithfulOrbit *= 50; // scale rho by 50
  vectorGeneratingFaithfulOrbit[0].AddInteger(1); // <- slightly perturb the first coordinate.
  //This perturbation breaks the outer automorphism invariance for all
  //simple Weyl group of simple Lie algebras.
  //This needs needs improvement for non-simple groups.
  orbitRho.addOnTop(vectorGeneratingFaithfulOrbit);
  this->allElements.addOnTop(currentElement);
  Vector<Rational> currentRoot;
  for (int i = 0; i < this->allElements.size; i ++) {
    for (int j = 0; j < this->simpleRootsInner.size; j ++) {
      this->AmbientWeyl->ReflectBetaWRTAlpha(this->simpleRootsInner[j], orbitRho[i], false, currentRoot);
      if (!orbitRho.contains(currentRoot)) {
        orbitRho.addOnTop(currentRoot);
        currentElement = this->allElements[i];
        currentElement.multiplyOnTheRightBySimpleRootInner(j);
        this->allElements.addOnTop(currentElement);
      }
    }
    for (int j = 1; j < this->ExternalAutomorphisms.size; j ++) {
      orbitRho[i].getCoordinatesInBasis(this->ExternalAutomorphisms[j], currentRoot);
      if (!orbitRho.contains(currentRoot)) {
        orbitRho.addOnTop(currentRoot);
        currentElement = this->allElements[i];
        currentElement.multiplyOnTheRightByOuterAutomorphism(j);
        this->allElements.addOnTop(currentElement);
      }
    }
    if (UpperLimitNumElements > 0) {
      if (this->allElements.size >= UpperLimitNumElements) {
        this->truncated = true;
        return false;
      }
    }
  }
  return true;
}

std::string DrawOperations::typeCircleAtVector = "circleAtVector";
std::string DrawOperations::typePath = "path";
std::string DrawOperations::typeSegment = "segment";
std::string DrawOperations::typeSegment2DFixed = "segment2DFixed";
std::string DrawOperations::typeTextAtVector = "text";
std::string DrawOperations::typeText2DFixed = "text2DFixed";
std::string DrawOperations::typeFilledShape = "filledShape";
std::string DrawOperations::typeHighlightGroup = "highlightGroup";

std::string DrawOperations::fieldColor = "color";
std::string DrawOperations::fieldOperation = "operation";
std::string DrawOperations::fieldPoints = "points";
std::string DrawOperations::fieldLocation = "location";
std::string DrawOperations::fieldRadius = "radius";
std::string DrawOperations::fieldPenStyle = "penStyle";
std::string DrawOperations::fieldText = "text";
std::string DrawOperations::fieldLabels = "labels";
std::string DrawOperations::fieldLineWidth = "lineWidth";
std::string DrawOperations::fieldFrameId = "frameId";
std::string DrawOperations::fieldFrameIndex = "frameIndex";

void DrawOperations::drawCircleAtVectorBufferRational(
  const Vector<Rational>& input, const std::string& color, double radius, const std::string& frameId, int frameIndex
) {
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeCircleAtVector;
  theOperation[DrawOperations::fieldLocation] = input.getVectorDouble();
  theOperation[DrawOperations::fieldRadius] = radius;
  theOperation[DrawOperations::fieldColor] = color;
  if (frameId != "") {
    theOperation[DrawOperations::fieldFrameId] = frameId;
    theOperation[DrawOperations::fieldFrameIndex] = frameIndex;
  }
  //theOperation[DrawOperations::fieldPenStyle] = DrawOperations::fieldPenStyle;
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawCircleAtVectorBufferDouble(
  const Vector<double>& input, const std::string& color, double radius
) {
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeCircleAtVector;
  theOperation[DrawOperations::fieldLocation] = input;
  theOperation[DrawOperations::fieldRadius] = radius;
  theOperation[DrawOperations::fieldColor] = color;
  //theOperation[DrawOperations::fieldPenStyle] = DrawOperations::fieldPenStyle;
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawLineBetweenTwoVectorsBufferRational(
  const Vector<Rational>& vector1, const Vector<Rational>& vector2, const std::string& color, double lineWidth
) {
  this->drawLineBetweenTwoVectorsBufferDouble(vector1.getVectorDouble(), vector2.getVectorDouble(), color, lineWidth);
}

void DrawOperations::drawPath(
  const Vectors<Rational>& theVectors,
  const std::string& color,
  double lineWidth,
  const std::string& frameId,
  int frameIndex
) {
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typePath;
  Vectors<double> vectorsDouble;
  theVectors.GetVectorsDouble(vectorsDouble);
  theOperation[DrawOperations::fieldPoints] = vectorsDouble;
  theOperation[DrawOperations::fieldFrameId] = frameId;
  theOperation[DrawOperations::fieldFrameIndex] = frameIndex;
  if (color != "") {
    theOperation[DrawOperations::fieldColor] = color;
  }
  if (lineWidth != 1.0) {
    theOperation[DrawOperations::fieldLineWidth] = lineWidth;
  }
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawLineBetweenTwoVectorsBufferDouble(
  const Vector<double>& vector1, const Vector<double>& vector2, const std::string& color, double lineWidth
) {
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeSegment;
  theOperation[DrawOperations::fieldPoints] = JSData::token::tokenArray;
  theOperation[DrawOperations::fieldPoints][0] = vector1;
  theOperation[DrawOperations::fieldPoints][1] = vector2;
  if (color != "") {
    theOperation[DrawOperations::fieldColor] = color;
  }
  if (lineWidth != 1.0) {
    theOperation[DrawOperations::fieldLineWidth] = lineWidth;
  }
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawFilledShape(
  const List<Vector<double> >& theCorners, uint32_t thePenStyle, int ColorIndex, int fillColorIndex, double lineWidth
) {
  (void) thePenStyle;
  (void) ColorIndex;
  (void) fillColorIndex;
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeFilledShape;
  theOperation[DrawOperations::fieldPoints] = JSData::token::tokenArray;
  for (int i = 0; i < theCorners.size; i ++) {
    theOperation[DrawOperations::fieldPoints][i] = theCorners[i];
  }
  if (lineWidth != 1.0) {
    theOperation[DrawOperations::fieldLineWidth] = lineWidth;
  }
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawTextAtVectorBufferRational(
  const Vector<Rational>& input, const std::string& inputText, const std::string& color, int fontSize
) {
  (void) color;
  (void) fontSize;
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeTextAtVector;
  theOperation[DrawOperations::fieldLocation] = input.getVectorDouble();
  theOperation[DrawOperations::fieldText] = inputText;
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawTextAtVectorBufferDouble(
  const Vector<double>& input, const std::string& inputText, int ColorIndex, int theFontSize, int theTextStyle
) {
  (void) ColorIndex;
  (void) theFontSize;
  (void) theTextStyle;
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeTextAtVector;
  theOperation[DrawOperations::fieldLocation] = input;
  theOperation[DrawOperations::fieldText] = inputText;
  this->theOperations.addOnTop(theOperation);
}

void DrawingVariables::drawLineDirectly(
  double X1, double Y1, double X2, double Y2, uint32_t thePenStyle, int ColorIndex, double lineWidth
) {
  this->theBuffer.drawLineBuffer(X1, Y1, X2, Y2, thePenStyle, ColorIndex, lineWidth);
}

void DrawOperations::drawHighlightGroup(
  Vectors<double>& highlightGroup, List<std::string>& labels, const std::string& color, int radius
) {
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeHighlightGroup;
  theOperation[DrawOperations::fieldPoints] = highlightGroup;
  theOperation[DrawOperations::fieldLabels] = labels;
  theOperation[DrawOperations::fieldColor] = color;
  theOperation[DrawOperations::fieldRadius] = radius;
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawLineBuffer(
  double X1, double Y1, double X2, double Y2, uint32_t thePenStyle, int ColorIndex, double lineWidth
) {
  (void) thePenStyle;
  (void) ColorIndex;
  (void) lineWidth;
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeSegment2DFixed;
  theOperation[DrawOperations::fieldPoints].theType = JSData::token::tokenArray;
  theOperation[DrawOperations::fieldPoints][0][0] = X1;
  theOperation[DrawOperations::fieldPoints][0][1] = Y1;
  theOperation[DrawOperations::fieldPoints][1][0] = X2;
  theOperation[DrawOperations::fieldPoints][1][1] = Y2;
  this->theOperations.addOnTop(theOperation);
}

void DrawOperations::drawTextBuffer(
  double X1, double Y1, const std::string& inputText, int ColorIndex, int theFontSize, int theTextStyle
) {
  (void) theFontSize;
  (void) ColorIndex;
  (void) theTextStyle;
  JSData theOperation;
  theOperation[DrawOperations::fieldOperation] = DrawOperations::typeSegment2DFixed;
  theOperation[DrawOperations::fieldLocation].theType = JSData::token::tokenArray;
  theOperation[DrawOperations::fieldLocation][0] = X1;
  theOperation[DrawOperations::fieldLocation][1] = Y1;
  theOperation[DrawOperations::fieldText] = inputText;
  this->theOperations.addOnTop(theOperation);
}

int DrawingVariables::GetActualPenStyleFromFlagsAnd(int inputPenStyle) {
  if (inputPenStyle == this->PenStyleInvisible) {
    return this->PenStyleInvisible;
  }
  if (inputPenStyle == this->PenStyleDashed) {
    return this->PenStyleDashed;
  }
  if (inputPenStyle == this->PenStyleDotted) {
    return this->PenStyleDotted;
  }
  if (inputPenStyle == this->PenStyleNormal) {
    return this->PenStyleNormal;
  }
  if (!this->flagDrawingInvisibles) {
    if (
      inputPenStyle == this->PenStyleLinkToOriginPermanentlyZeroChamber ||
      inputPenStyle == this->PenStyleLinkToOriginZeroChamber ||
      inputPenStyle == this->PenStyleZeroChamber ||
      inputPenStyle == this->PenStylePermanentlyZeroChamber
    ) {
      return this->PenStyleInvisible;
    }
  }
  if (
    inputPenStyle == this->PenStyleLinkToOrigin ||
    inputPenStyle == this->PenStyleLinkToOriginPermanentlyZeroChamber ||
    inputPenStyle == this->PenStyleLinkToOriginZeroChamber
  ) {
    if (this->flagDrawingLinkToOrigin) {
      return this->PenStyleDashed;
    } else {
      return this->PenStyleInvisible;
    }
  }
  if (inputPenStyle == this->PenStylePermanentlyZeroChamber || inputPenStyle == this->PenStyleZeroChamber) {
    return this->PenStyleDotted;
  }
  return this->PenStyleNormal;
}

int DrawingVariables::GetActualTextStyleFromFlagsAnd(int inputTextStyle) {
  if (inputTextStyle == this->TextStyleInvisible) {
    return this->TextStyleInvisible;
  }
  if (inputTextStyle == this->TextStyleNormal) {
    return this->TextStyleNormal;
  }
  if (!this->flagDrawChamberIndices && (
      inputTextStyle == this->TextStyleChamber ||
      inputTextStyle == this->TextStylePermanentlyZeroChamber ||
      inputTextStyle == this->TextStyleZeroChamber
  )) {
    return this->TextStyleInvisible;
  }
  if (!this->flagDrawingInvisibles && (
    inputTextStyle == this->TextStylePermanentlyZeroChamber || inputTextStyle == this->TextStyleZeroChamber
  )) {
    return this->TextStyleInvisible;
  }
  return this->TextStyleNormal;
}

void DrawingVariables::drawLineBuffer(
  double X1, double Y1, double X2, double Y2, uint32_t thePenStyle, int ColorIndex, double lineWidth
) {
  this->theBuffer.drawLineBuffer(X1, Y1, X2, Y2, thePenStyle, ColorIndex, lineWidth);
}

void DrawingVariables::drawTextBuffer(double X1, double Y1, const std::string& inputText, int color) {
  this->theBuffer.drawTextBuffer(X1, Y1, inputText, color, this->fontSizeNormal, this->TextStyleNormal);
}

void DrawingVariables::drawString(
  drawElementInputOutput& theDrawData, const std::string& input, int theFontSize, int theTextStyle
) {
  theDrawData.outputHeight = 0; theDrawData.outputWidth = 0;
  if (input == "") {
    return;
  }
  for (unsigned int i = 0; i < input.size(); i ++) {
    std::string tempS;
    tempS = input.at(i);
    this->theBuffer.drawTextBuffer(
      theDrawData.outputWidth + theDrawData.TopLeftCornerX,
      theDrawData.outputHeight + theDrawData.TopLeftCornerY,
      tempS,
      0,
      theFontSize,
      theTextStyle
    );
    theDrawData.outputWidth += static_cast<int>(static_cast<double>(theFontSize) / 1.15);
  }
}

void SemisimpleLieAlgebra::computeOneAutomorphism(Matrix<Rational>& outputAuto, bool useNegativeRootsFirst) {
  global.fatal << "Not implemented yet!!!!!" << global.fatal;
  RootSubalgebra theRootSA;
//  theRootSA.initialize(*this);
  int theDimension = this->theWeyl.cartanSymmetric.numberOfRows;
  theRootSA.genK.makeEiBasis(theDimension);
  SubgroupWeylGroupAutomorphismsGeneratedByRootReflectionsAndAutomorphisms theAutos;
  theRootSA.generateAutomorphismsPreservingBorel(theAutos);
  Matrix<Rational> mapOnRootSpaces;
  int theAutoIndex = theAutos.ExternalAutomorphisms.size > 1 ? 1 : 0;
  /*if (this->theWeyl.WeylLetter == 'D' && theDimension ==4)
    theAutoIndex =2;
*/
  mapOnRootSpaces.assignVectorsToRows(theAutos.ExternalAutomorphisms[theAutoIndex]);
  mapOnRootSpaces.transpose();
//  mapOnRootSpaces.ComputeDebugString();
//  Matrix<Rational>  theDet =mapOnRootSpaces;
//  Rational tempRat;
//  theDet.computeDeterminantOverwriteMatrix(tempRat);
  Selection NonExplored;
  int numRoots = this->theWeyl.RootSystem.size;
  NonExplored.initialize(numRoots);
  NonExplored.MakeFullSelection();
  Vector<Rational> domainRoot, rangeRoot;

  this->computeChevalleyConstants();
  List<ElementSemisimpleLieAlgebra<Rational> > Domain, Range;
  Range.setSize(numRoots + theDimension);
  Domain.setSize(numRoots + theDimension);
  ElementSemisimpleLieAlgebra<Rational> tempElt;
  for (int i = 0; i < theDimension; i ++) {
    domainRoot.makeEi(theDimension, i);
    mapOnRootSpaces.actOnVectorColumn(domainRoot, rangeRoot);
    tempElt.makeCartanGenerator(domainRoot, *this);
    Domain[numRoots + i] = tempElt;
    tempElt.makeCartanGenerator(rangeRoot, *this);
    Range[numRoots + i] = tempElt;
    for (int i = 0; i < 2; i ++, domainRoot.minus(), rangeRoot.minus()) {
      int theIndex = this->theWeyl.RootSystem.getIndex(rangeRoot);
      tempElt.makeGGenerator(rangeRoot, *this);
      Range[theIndex] = tempElt;
      tempElt.makeGGenerator(domainRoot, *this);
      Domain[theIndex] = tempElt;
      NonExplored.RemoveSelection(theIndex);
    }
  }
  Vector<Rational> left, right;
  while (NonExplored.cardinalitySelection > 0) {
    for (int i = 0; i < NonExplored.cardinalitySelection; i ++) {
      int theIndex = NonExplored.elements[i];
      const Vector<Rational>& current = this->theWeyl.RootSystem[theIndex];
      for (int j = 0; j < theDimension; j ++) {
        left.makeEi(theDimension, j);
        for (int k = 0; k < 2; k ++, left.minus()) {
          right = current - left;
          if (this->theWeyl.isARoot(right)) {
            int leftIndex = this->theWeyl.RootSystem.getIndex(left);
            int rightIndex = this->theWeyl.RootSystem.getIndex(right);
            if (!NonExplored.selected[rightIndex]) {
              ElementSemisimpleLieAlgebra<Rational>& leftDomainElt = Domain[leftIndex];
              ElementSemisimpleLieAlgebra<Rational>& rightDomainElt = Domain[rightIndex];
              this->lieBracket(leftDomainElt, rightDomainElt, Domain[theIndex]);
              ElementSemisimpleLieAlgebra<Rational>& leftRangeElt = Range[leftIndex];
              ElementSemisimpleLieAlgebra<Rational>& rightRangeElt = Range[rightIndex];
              this->lieBracket(leftRangeElt, rightRangeElt, Range[theIndex]);
              NonExplored.RemoveSelection(theIndex);
            }
          }
        }
      }
    }
  }
  Vectors<Rational> vectorsLeft, vectorsRight;
  vectorsLeft.setSize(Range.size);
  vectorsRight.setSize(Range.size);
  if (!useNegativeRootsFirst) {
    for (int i = 0; i < Range.size; i ++) {
      Range[i].elementToVectorNegativeRootSpacesFirst(vectorsRight[i]);
      Domain[i].elementToVectorNegativeRootSpacesFirst(vectorsLeft[i]);
    }
  } else {
    for (int i = 0; i < Range.size; i ++) {
      Range[i].elementToVectorNegativeRootSpacesFirst(vectorsRight[i]);
      Domain[i].elementToVectorNegativeRootSpacesFirst(vectorsLeft[i]);
    }
  }
  outputAuto.makeLinearOperatorFromDomainAndRange(vectorsLeft, vectorsRight);
}

bool SemisimpleLieAlgebra::isInTheWeightSupport(Vector<Rational>& theWeight, Vector<Rational>& highestWeight) {
  Vector<Rational> correspondingDominant = theWeight;
  this->theWeyl.RaiseToDominantWeight(correspondingDominant);
  Vector<Rational> theDiff = highestWeight - correspondingDominant;
  if (!theDiff.isPositiveOrZero())
    return false;
  return true;
}

void SemisimpleLieAlgebra::createEmbeddingFromFDModuleHaving1dimWeightSpaces(Vector<Rational>& theHighestWeight) {
  (void) theHighestWeight;
  /*Vectors<Rational> weightSupport;
  this->GenerateWeightSupport(theHighestWeight, weightSupport);
  int highestWeight, distanceToHW;
  this->EmbeddingsRootSpaces.setSize(this->theWeyl.RootSystem.size);
  int theDimension = this->theWeyl.cartanSymmetric.numberOfRows;
  List<bool> Explored;
  Explored.initializeFillInObject(this->theWeyl.RootSystem.size, false);
  int numExplored = 0;
  for (int i = 0; i < this->theWeyl.RootSystem.size; i ++) {
    Vector<Rational>& current = this->theWeyl.RootSystem.theObjects[i];
    if (current.SumCoordinates() ==1 || current.SumCoordinates() == - 1) {
      numExplored++;
      Explored.theObjects[i] = true;
      Matrix<Rational> & currentMat = this->EmbeddingsRootSpaces.theObjects[i];
      currentMat.initialize(weightSupport.size, weightSupport.size);
      currentMat.makeZero();
      for (int j = 0; j<weightSupport.size; j ++) {
        int indexTarget = weightSupport.getIndex(current +weightSupport.theObjects[j]);
        if (indexTarget != - 1) {
          highestWeight = - 1+ this->getLengthStringAlongAlphaThroughBeta(current, weightSupport.theObjects[j], distanceToHW, weightSupport);
          if (current.isNegativeOrZero())
            currentMat.elements[indexTarget][j] =1;
          else
            currentMat.elements[indexTarget][j] =(highestWeight-distanceToHW+ 1)*distanceToHW;
        }
      }
    }
  }
  Vectors<Rational> simpleBasis;
  simpleBasis.makeEiBasis(theDimension);
  while (numExplored< this->theWeyl.RootSystem.size) {
    for (int i = 0; i < this->theWeyl.RootSystem.size; i ++)
      if (Explored.theObjects[i])
        for (int j = 0; j < this->theWeyl.RootSystem.size; j ++)
          if (Explored.theObjects[j]) {
            Vector<Rational> tempRoot = this->theWeyl.RootSystem.theObjects[i] + this->theWeyl.RootSystem.theObjects[j];
            if (this->theWeyl.isARoot(tempRoot)) {
              int index = this->theWeyl.RootSystem.getIndex(tempRoot);
              if (!Explored.theObjects[index]) {
                Explored.theObjects[index] = true;
                numExplored++;
                this->EmbeddingsRootSpaces.theObjects[index] = this->EmbeddingsRootSpaces.theObjects[i];
                this->EmbeddingsRootSpaces.theObjects[index].lieBracketWith(this->EmbeddingsRootSpaces.theObjects[j]);
              }
            }
          }
  }
  this->EmbeddingsCartan.setSize(theDimension);
  for (int i = 0; i < theDimension; i ++) {
    Matrix<Rational> & current = this->EmbeddingsCartan.theObjects[i];
    current.initialize(weightSupport.size, weightSupport.size);
    current.makeZero();
    Vector<Rational> tempRoot;
    tempRoot.makeEi(theDimension, i);
    for (int j = 0; j<weightSupport.size; j ++)
      current.elements[j][j] = this->theWeyl.RootScalarCartanRoot(tempRoot, weightSupport.theObjects[j]);
  }*/
}

int SemisimpleLieAlgebra::getLengthStringAlongAlphaThroughBeta(Vector<Rational>& alpha, Vector<Rational>& beta, int& distanceToHighestWeight, Vectors<Rational>& weightSupport) {
  Vector<Rational> tempRoot = beta;
  for (int i = 0; ; i ++) {
    tempRoot += alpha;
    if (!weightSupport.contains(tempRoot)) {
      distanceToHighestWeight = i;
      break;
    }
  }
  for (int i = 0; ; i ++) {
    tempRoot -= alpha;
    if (!weightSupport.contains(tempRoot)) {
      return i;
    }
  }
//  global.fatal << global.fatal;
//  return - 1;
}

bool HomomorphismSemisimpleLieAlgebra::ComputeHomomorphismFromImagesSimpleChevalleyGenerators() {
  MacroRegisterFunctionWithName("HomomorphismSemisimpleLieAlgebra::ComputeHomomorphismFromImagesSimpleChevalleyGenerators");
  this->theDomain().computeChevalleyConstants();
  this->theRange().computeChevalleyConstants();
  int theDomainDimension = this->theDomain().theWeyl.cartanSymmetric.numberOfRows;
  Selection NonExplored;
  int numRoots = this->theDomain().theWeyl.RootSystem.size;
  NonExplored.initialize(numRoots);
  NonExplored.MakeFullSelection();
  List<ElementSemisimpleLieAlgebra<Rational> > tempDomain, tempRange;
  tempDomain.setSize(numRoots+theDomainDimension);
  tempRange.setSize(numRoots+theDomainDimension);
  Vector<Rational> tempRoot;
  for (int i = 0; i < theDomainDimension; i ++) {
    tempRoot.makeEi(theDomainDimension, i);
    for (int j = 0; j < 2; j ++, tempRoot.minus()) {
      int index = this->theDomain().theWeyl.RootSystem.getIndex(tempRoot);
      tempDomain[index].makeZero();
      ChevalleyGenerator tempGen;
      tempGen.makeGenerator(this->theDomain(), this->theDomain().getGeneratorFromRoot(tempRoot));
      tempDomain[index].addMonomial(tempGen, 1);
      tempRange[index] = this->imagesSimpleChevalleyGenerators[i +j*theDomainDimension];
      NonExplored.RemoveSelection(index);
    }
  }
  Vector<Rational> right;
  while (NonExplored.cardinalitySelection > 0) {
    for (int i = 0; i < NonExplored.cardinalitySelection; i ++) {
      int theIndex = NonExplored.elements[i];
      const Vector<Rational>& current = this->theDomain().theWeyl.RootSystem[theIndex];
      for (int j = 0; j < NonExplored.MaxSize; j ++) {
        if (!NonExplored.selected[j]) {
          const Vector<Rational>& left = this->theDomain().theWeyl.RootSystem[j];
          right = current - left;
          if (this->theDomain().theWeyl.isARoot(right)) {
            int leftIndex = this->theDomain().theWeyl.RootSystem.getIndex(left);
            int rightIndex = this->theDomain().theWeyl.RootSystem.getIndex(right);
            if (!NonExplored.selected[rightIndex]) {
              ElementSemisimpleLieAlgebra<Rational>& leftDomainElt = tempDomain[leftIndex];
              ElementSemisimpleLieAlgebra<Rational>& rightDomainElt = tempDomain[rightIndex];
              this->theDomain().lieBracket(leftDomainElt, rightDomainElt, tempDomain[theIndex]);
              ElementSemisimpleLieAlgebra<Rational>& leftRangeElt = tempRange[leftIndex];
              ElementSemisimpleLieAlgebra<Rational>& rightRangeElt = tempRange[rightIndex];
              this->theRange().lieBracket(leftRangeElt, rightRangeElt, tempRange[theIndex]);
              NonExplored.RemoveSelection(theIndex);
              break;
            }
          }
        }
      }
    }
  }
  for (int i = 0; i < theDomainDimension; i ++) {
    tempRoot.makeEi(theDomainDimension, i);
    int leftIndex = this->theDomain().theWeyl.RootSystem.getIndex(tempRoot);
    int rightIndex = this->theDomain().theWeyl.RootSystem.getIndex(- tempRoot);
    this->theDomain().lieBracket(tempDomain[leftIndex], tempDomain[rightIndex], tempDomain[numRoots + i]);
    this->theRange().lieBracket(tempRange[leftIndex], tempRange[rightIndex], tempRange[numRoots + i]);
  }
  Vectors<Rational> vectorsLeft, vectorsRight;
  vectorsLeft.setSize(tempDomain.size);
  vectorsRight.setSize(tempDomain.size);
  for (int i = 0; i < tempRange.size; i ++) {
    tempDomain[i].elementToVectorNegativeRootSpacesFirst(vectorsLeft[i]);
    tempRange[i].elementToVectorNegativeRootSpacesFirst(vectorsRight[i]);
  }
  Matrix<Rational> tempMat;
  tempMat.makeLinearOperatorFromDomainAndRange(vectorsLeft, vectorsRight);
  Vector<Rational> imageRoot;
  this->domainAllChevalleyGenerators.setSize(tempDomain.size);
  this->imagesAllChevalleyGenerators.setSize(tempDomain.size);
  for (int i = 0; i < this->theDomain().getNumberOfGenerators(); i ++) {
    this->domainAllChevalleyGenerators[i].makeGenerator(i, this->theDomain());
  }
  for (int i = 0; i < this->imagesAllChevalleyGenerators.size; i ++) {
    this->domainAllChevalleyGenerators[i].elementToVectorNegativeRootSpacesFirst(tempRoot);
    tempMat.actOnVectorColumn(tempRoot, imageRoot);
    this->imagesAllChevalleyGenerators[i].assignVectorNegRootSpacesCartanPosRootSpaces(imageRoot, this->theRange());
  }
  return true;
}

void HomomorphismSemisimpleLieAlgebra::ProjectOntoSmallCartan(Vectors<Rational>& input, Vectors<Rational>& output) {
  output.setSize(input.size);
  for (int i = 0; i < input.size; i ++) {
    this->ProjectOntoSmallCartan(input[i], output[i]);
  }
}

void HomomorphismSemisimpleLieAlgebra::ProjectOntoSmallCartan(Vector<Rational>& input, Vector<Rational>& output) {
  Matrix<Rational> invertedSmallCartan;
  invertedSmallCartan = this->theDomain().theWeyl.cartanSymmetric;
  invertedSmallCartan.invert();
  int theSmallDimension = this->theDomain().theWeyl.cartanSymmetric.numberOfRows;
  output.makeZero(theSmallDimension);
  for (int i = 0; i < theSmallDimension; i ++) {
    output[i] = this->theRange().theWeyl.RootScalarCartanRoot(
      this->imagesAllChevalleyGenerators[this->theDomain().theWeyl.RootsOfBorel.size + i].getCartanPart(), input
    );
  }
  invertedSmallCartan.actOnVectorColumn(output, output);
}

bool HomomorphismSemisimpleLieAlgebra::applyHomomorphism(
  const MonomialUniversalEnveloping<RationalFunction<Rational> >& input,
  const RationalFunction<Rational>& theCoeff,
  ElementUniversalEnveloping<RationalFunction<Rational> >& output
) {
  ElementUniversalEnveloping<RationalFunction<Rational> > tempElt;
  output.makeZero(this->theRange());
  RationalFunction<Rational> polyOne;
  polyOne = theCoeff.one();
  output.makeConstant(theCoeff, this->theRange());
  for (int i = 0; i < input.generatorsIndices.size; i ++) {
    if (input.generatorsIndices[i] >= this->imagesAllChevalleyGenerators.size) {
      return false;
    }
    tempElt.assignElementLieAlgebra(
      this->imagesAllChevalleyGenerators[input.generatorsIndices[i]],
      this->theRange(),
      polyOne
    );
    RationalFunction<Rational>& thePower = input.Powers[i];
    int theIntegralPower;
    if (!thePower.isSmallInteger(&theIntegralPower)) {
      return false;
    }
    for (int j = 0; j < theIntegralPower; j ++) {
      output *= tempElt;
    }
  }
  return true;
}

void HomomorphismSemisimpleLieAlgebra::applyHomomorphism(
  const ElementSemisimpleLieAlgebra<Rational>& input,
  ElementSemisimpleLieAlgebra<Rational>& output
) {
  if (&output == &input) {
    global.fatal << "Output required to be different from input. " << global.fatal;
  }
  output.makeZero();
  for (int i = 0; i < input.size(); i ++) {
    int currentIndex = input[i].theGeneratorIndex;
    output += this->imagesAllChevalleyGenerators[currentIndex] * input.coefficients[i];
  }
}

void HomomorphismSemisimpleLieAlgebra::GetMapSmallCartanDualToLargeCartanDual(Matrix<Rational>& output) {
  output.initialize(this->theRange().getRank(), this->theDomain().getRank());
  ElementSemisimpleLieAlgebra<Rational> domainElt, imageElt;
  for (int i = 0; i < this->theDomain().getRank(); i ++) {
    domainElt.makeCartanGenerator(Vector<Rational>::GetEi(this->theDomain().getRank(), i), this->theDomain());
    this->applyHomomorphism(domainElt, imageElt);
    output.assignVectorToColumnKeepOtherColsIntactNoInit(i, imageElt.getCartanPart());
  }
}

bool HomomorphismSemisimpleLieAlgebra::applyHomomorphism(
  const ElementUniversalEnveloping<RationalFunction<Rational> >& input,
  ElementUniversalEnveloping<RationalFunction<Rational> >& output
) {
  if (&output == &input) {
    global.fatal << "Output must be different from input. " << global.fatal;
  }
  output.makeZero(this->theRange());
  ElementUniversalEnveloping<RationalFunction<Rational> > tempElt;
  for (int i = 0; i < input.size(); i ++) {
    if (!this->applyHomomorphism(input[i], input.coefficients[i], tempElt)) {
      return false;
    }
    output += tempElt;
  }
  return true;
}

void HomomorphismSemisimpleLieAlgebra::MakeGinGWithId(
  char theWeylLetter, int theWeylDim, MapReferences<DynkinType, SemisimpleLieAlgebra>& ownerOfAlgebras
) {
  MacroRegisterFunctionWithName("HomomorphismSemisimpleLieAlgebra::MakeGinGWithId");
  DynkinType theType;
  theType.MakeSimpleType(theWeylLetter, theWeylDim);
  this->domainAlg = &ownerOfAlgebras.getValueCreateNoInit(theType);
  this->rangeAlg = this->domainAlg;
  this->domainAlg->theWeyl.MakeArbitrarySimple(theWeylLetter, theWeylDim);
  this->theDomain().computeChevalleyConstants();
  int numPosRoots = this->theDomain().theWeyl.RootsOfBorel.size;
  this->imagesAllChevalleyGenerators.setSize(numPosRoots * 2 + theWeylDim);
  this->domainAllChevalleyGenerators.setSize(numPosRoots * 2 + theWeylDim);
  this->imagesSimpleChevalleyGenerators.setSize(theWeylDim * 2);
  for (int i = 0; i < 2 * numPosRoots + theWeylDim; i ++) {
    ElementSemisimpleLieAlgebra<Rational>& tempElt1 = this->imagesAllChevalleyGenerators[i];
    ElementSemisimpleLieAlgebra<Rational>& tempElt2 = this->domainAllChevalleyGenerators[i];
    tempElt2.makeGenerator(i, this->theDomain());
    tempElt1.makeGenerator(i, this->theRange());
  }
  for (int i = 0; i < theWeylDim; i ++) {
    ElementSemisimpleLieAlgebra<Rational>& tempElt1 = this->imagesSimpleChevalleyGenerators[i];
    tempElt1.makeGenerator(i, this->theRange());
    ElementSemisimpleLieAlgebra<Rational>& tempElt2 = this->imagesSimpleChevalleyGenerators[theWeylDim + i];
    tempElt2.makeGenerator(i + numPosRoots, this->theRange());
  }
}

void HomomorphismSemisimpleLieAlgebra::toString(std::string& output, bool useHtml) {
  std::stringstream out;
  if (this->CheckClosednessLieBracket()) {
    out << "Lie bracket closes, everything is good!";
  } else {
    out << "The Lie bracket is incorrect!";
  }
  if (useHtml) {
    out << "<br>";
  }
  out << "Images simple Chevalley generators:\n\n";
  if (useHtml) {
    out << "<br>";
  }
  for (int i = 0; i < this->imagesSimpleChevalleyGenerators.size; i ++) {
    out << this->imagesSimpleChevalleyGenerators[i].toString(&global.theDefaultFormat.getElement()) << "\n\n";
    if (useHtml) {
      out << "<br>";
    }
  }
  out << "Maps of Chevalley generators:\n\n";
  for (int i = 0; i < this->domainAllChevalleyGenerators.size; i ++) {
    out << "<br>" << this->domainAllChevalleyGenerators[i].toString(&global.theDefaultFormat.getElement())
    << " \\mapsto " << this->imagesAllChevalleyGenerators[i].toString(&global.theDefaultFormat.getElement());
  }
  output = out.str();
}

class SlTwoInSlN;

void HomomorphismSemisimpleLieAlgebra::GetRestrictionAmbientRootSystemToTheSmallercartanSubalgebra(Vectors<Rational>& output) {
  List<Vector<Rational> >& theRootSystem= this->theRange().theWeyl.RootSystem;
  int rankSA = this->theDomain().theWeyl.getDimension();
  Matrix<Rational> tempMat;
  tempMat = this->theDomain().theWeyl.cartanSymmetric;
  tempMat.invert();
  int numPosRootsDomain = this->theDomain().theWeyl.RootsOfBorel.size;
  output.setSize(theRootSystem.size);
  Vector<Rational> theScalarProducts;
  theScalarProducts.setSize(rankSA);
  for (int i = 0; i < theRootSystem.size; i ++) {
    for (int j = 0; j < rankSA; j ++) {
      ElementSemisimpleLieAlgebra<Rational>& currentH = this->imagesAllChevalleyGenerators[j + numPosRootsDomain];
      theScalarProducts[j] = this->theRange().theWeyl.RootScalarCartanRoot(currentH.getCartanPart(), theRootSystem[i]);
    }
    tempMat.actOnVectorColumn(theScalarProducts, output[i]);
  }
  this->ImagesCartanDomain.setSize(rankSA);
  for (int i = 0; i < rankSA; i ++) {
    this->ImagesCartanDomain[i] = this->imagesAllChevalleyGenerators[i +numPosRootsDomain].getCartanPart();
  }
}

bool HomomorphismSemisimpleLieAlgebra::CheckClosednessLieBracket() {
  ElementSemisimpleLieAlgebra<Rational> tempElt;
  Vectors<Rational> tempRoots;
  Vector<Rational> tempRoot;
  tempRoots.setSize(this->imagesAllChevalleyGenerators.size);
  for (int i = 0; i < tempRoots.size; i ++) {
    this->imagesAllChevalleyGenerators[i].elementToVectorNegativeRootSpacesFirst(tempRoots[i]);
  }
  for (int i = 0; i < this->imagesAllChevalleyGenerators.size; i ++) {
    for (int j = 0; j < this->imagesAllChevalleyGenerators.size; j ++) {
      this->theRange().lieBracket(this->imagesAllChevalleyGenerators[i], this->imagesAllChevalleyGenerators[j], tempElt);
      tempElt.elementToVectorNegativeRootSpacesFirst(tempRoot);
      if (!tempRoots.linearSpanContainsVector(tempRoot)) {
        return false;
      }
    }
  }
  return true;
}

void ChevalleyGenerator::checkConsistencyWithOther(const ChevalleyGenerator& other) const {
  if (this->owner != other.owner) {
    global.fatal << "Attempt to compare Chevalley generators of different Lie algebras. " << global.fatal;
  }
}

bool ChevalleyGenerator::checkInitialization() const {
  if (this->owner == nullptr) {
    global.fatal << "Attempt to use a non-initialized Chevalley generator. " << global.fatal;
    return false;
  }
  return true;
}

std::string ChevalleyGenerator::toString(FormatExpressions* inputFormat) const {
  this->checkInitialization();
  return this->owner->getStringFromChevalleyGenerator(this->theGeneratorIndex, inputFormat);
}

bool ChevalleyGenerator::operator>(const ChevalleyGenerator& other) const {
  return this->theGeneratorIndex>other.theGeneratorIndex;
}

std::string SemisimpleLieAlgebra::getStringFromChevalleyGenerator(
  int theIndex, FormatExpressions* thePolynomialFormat
) const {
  std::stringstream out;
  MemorySaving<FormatExpressions> tempFormat;
  if (thePolynomialFormat == nullptr) {
    thePolynomialFormat = &tempFormat.getElement();
  }
  if (this->isGeneratorFromCartan(theIndex)) {
    out << thePolynomialFormat->chevalleyHgeneratorLetter << "_{" << theIndex-this->getNumberOfPositiveRoots() + 1 << "}";
  } else {
    out << thePolynomialFormat->chevalleyGgeneratorLetter << "_{";
    if (theIndex >= this->getNumberOfPositiveRoots()) {
      out << theIndex - this->getNumberOfPositiveRoots() - this->getRank() + 1;
    } else {
      out << theIndex - this->getNumberOfPositiveRoots();
    }
    out << "}";
  }
  return out.str();
}

void SemisimpleLieAlgebra::orderNilradicalFirstTotalWeightDescending(const Selection& parSelZeroMeansLeviPart) {
  MacroRegisterFunctionWithName("SemisimpleLieAlgebra::orderNilradicalFirstTotalWeightDescending");
  Vector<Rational> tempVect;
  tempVect = parSelZeroMeansLeviPart;
  for (int i = 0; i < this->getNumberOfGenerators(); i ++) {
    if (this->getWeightOfGenerator(i).ScalarEuclidean(tempVect) < 0) {
      this->UEGeneratorOrderIncludingCartanElts[i] = - i - this->getNumberOfGenerators() * 5;
    }
  }
}

void SemisimpleLieAlgebra::orderNilradicalFirstTotalWeightAscending(const Selection& parSelZeroMeansLeviPart) {
  MacroRegisterFunctionWithName("SemisimpleLieAlgebra::orderNilradicalFirstTotalWeightDescending");
  Vector<Rational> tempVect;
  tempVect = parSelZeroMeansLeviPart;
  for (int i = 0; i < this->getNumberOfGenerators(); i ++) {
    if (this->getWeightOfGenerator(i).ScalarEuclidean(tempVect) < 0) {
      this->UEGeneratorOrderIncludingCartanElts[i] = i - this->getNumberOfGenerators() * 5;
    }
  }
}

void SemisimpleLieAlgebra::orderNilradicalNilWeightAscending(const Selection& parSelZeroMeansLeviPart) {
  Vector<Rational> tempVect;
  tempVect = parSelZeroMeansLeviPart;
  for (int i = 0; i < this->getNumberOfGenerators(); i ++) {
    Rational translationCoeff = this->getWeightOfGenerator(i).ScalarEuclidean(tempVect) * this->getNumberOfPositiveRoots();
    if (translationCoeff < 0) {
      this->UEGeneratorOrderIncludingCartanElts[i] = i + translationCoeff.numeratorShort * this->getNumberOfGenerators() * 5;
    }
  }
}

void SemisimpleLieAlgebra::orderNilradicalNilWeightDescending(const Selection& parSelZeroMeansLeviPart) {
  Vector<Rational> tempVect;
  tempVect = parSelZeroMeansLeviPart;
  for (int i = 0; i < this->getNumberOfGenerators(); i ++) {
    Rational translationCoeff = this->getWeightOfGenerator(i).ScalarEuclidean(tempVect) * this->getNumberOfPositiveRoots();
    if (translationCoeff < 0) {
      this->UEGeneratorOrderIncludingCartanElts[i] = - i + translationCoeff.numeratorShort * this->getNumberOfGenerators() * 5;
    }
  }
}

void SemisimpleLieAlgebra::orderNilradical(const Selection& parSelZeroMeansLeviPart, bool useNilWeight, bool ascending) {
  MacroRegisterFunctionWithName("SemisimpleLieAlgebra::orderNilradical");
  if (useNilWeight) {
    if (ascending) {
      this->orderNilradicalNilWeightAscending(parSelZeroMeansLeviPart);
    } else {
      this->orderNilradicalNilWeightDescending(parSelZeroMeansLeviPart);
    }
  } else {
    if (ascending) {
      this->orderNilradicalFirstTotalWeightAscending(parSelZeroMeansLeviPart);
    } else {
      this->orderNilradicalFirstTotalWeightDescending(parSelZeroMeansLeviPart);
    }
  }
}

bool SemisimpleLieAlgebra::hasComputedStructureConstants() {
  return this->ChevalleyConstants.numberOfRows == this->theWeyl.theDynkinType.GetRootSystemSize();
}

void SemisimpleLieAlgebra::orderSSalgebraForHWbfComputation() {
  int numPosRoots = this->getNumberOfPositiveRoots();
  for (int i = 0; i < numPosRoots; i ++) {
    this->UEGeneratorOrderIncludingCartanElts[i] = - 1;
  }
}

void SemisimpleLieAlgebra::orderStandardAscending() {
  int numGens = this->getNumberOfGenerators();
  for (int i = 0; i < numGens; i ++) {
    this->UEGeneratorOrderIncludingCartanElts[i] = i;
  }
}

void SemisimpleLieAlgebra::orderStandardDescending() {
  int numGens = this->getNumberOfGenerators();
  for (int i = 0; i < numGens; i ++) {
    this->UEGeneratorOrderIncludingCartanElts[i] = numGens - i - 1;
  }
}

bool SemisimpleLieAlgebra::areOrderedProperly(int leftIndex, int rightIndex) {
  return this->UEGeneratorOrderIncludingCartanElts[leftIndex] <= this->UEGeneratorOrderIncludingCartanElts[rightIndex];
}

int SemisimpleLieAlgebra::getRootIndexFromDisplayIndex(int theIndex) {
  int numPosRoots = this->theWeyl.RootsOfBorel.size;
  if (theIndex < 0) {
    return theIndex + numPosRoots;
  }
  if (theIndex > 0) {
    return theIndex + numPosRoots - 1;
  }
  return - 1;
}

int SemisimpleLieAlgebra::GetDisplayIndexFromRootIndex(int theIndex) const {
  int numPosRoots = this->theWeyl.RootsOfBorel.size;
  if (theIndex >= numPosRoots) {
    return theIndex - numPosRoots + 1;
  }
  if (theIndex < numPosRoots) {
    return theIndex - numPosRoots;
  }
  return - 10000000;
}

int SemisimpleLieAlgebra::getGeneratorFromRootIndex(int theIndex) const {
  if (theIndex < 0 || theIndex >= this->theWeyl.RootSystem.size) {
    return - 1;
  }
  int theDimension = this->theWeyl.cartanSymmetric.numberOfRows;
  int numPosRoots = this->theWeyl.RootsOfBorel.size;
  if (theIndex >= numPosRoots) {
    return theIndex + theDimension;
  }
  return theIndex;
}

int SemisimpleLieAlgebra::getRootIndexFromGenerator(int theIndex) const {
  int numPosRoots = this->theWeyl.RootsOfBorel.size;
  int theDimension = this->theWeyl.cartanSymmetric.numberOfRows;
  if (theIndex < numPosRoots) {
    return theIndex;
  }
  if (theIndex >= numPosRoots + theDimension) {
    return theIndex - theDimension;
  }
  return - 1;
}

void HtmlRoutines::replaceEqualitiesAndAmpersandsBySpaces(std::string& inputOutput) {
  for (unsigned i = 0; i < inputOutput.size(); i ++) {
    if (inputOutput[i] == '=' || inputOutput[i] == '&') {
      inputOutput[i] = ' ';
    }
  }
}

bool VectorPartition::initialize(const Vectors<Rational>& inputPartitioningRoots, const Vector<Rational>& inputRoot) {
  MacroRegisterFunctionWithName("VectorPartition::initialize");
  for (int i = 0; i < inputPartitioningRoots.size; i ++) {
    if (!inputPartitioningRoots[i].isPositive()) {
      return false;
    }
  }
  this->PartitioningRoots = inputPartitioningRoots;
  if (this->PartitioningRoots.size == 0) {
    return false;
  }
  if (this->goalVector.isEqualToZero()) {
    return false;
  }
  this->goalVector = inputRoot;
  this->currentPartition.initializeFillInObject(this->PartitioningRoots.size, 0);
  this->currentPartitionSum.makeZero(this->goalVector.size);
  return true;
}

Vector<Rational> VectorPartition::GetPartitionSum() {
  Vector<Rational> result;
  result.makeZero(this->goalVector.size);
  for (int i = 0; i < this->currentPartition.size; i ++) {
    result += this->PartitioningRoots[i] * this->currentPartition[i];
  }
  return result;
}

void VectorPartition::BeefUpPartition() {
  MacroRegisterFunctionWithName("VectorPartition::BeefUpPartition");
  Vector<Rational> remainder = this->goalVector-this->currentPartitionSum;
  while ((remainder-*this->PartitioningRoots.lastObject()).isPositiveOrZero()) {
    (*this->currentPartition.lastObject()) ++;
    this->currentPartitionSum += *(this->PartitioningRoots.lastObject());
    remainder -= *this->PartitioningRoots.lastObject();
  }
}

bool VectorPartition::NudgePartition() {
  MacroRegisterFunctionWithName("VectorPartition::NudgePartition");
  int indexFirstNonZero = - 1;
  for (int i = this->currentPartition.size - 1; i >= 0; i --) {
    if (this->currentPartition[i] != 0) {
      indexFirstNonZero = i;
      break;
    }
  }
  if (indexFirstNonZero == - 1) {
    global.fatal << "Error: an internal check has failed in VectorPartition::incrementReturnFalseIfPastLast." << global.fatal;
  }
  if (indexFirstNonZero == 0) {
    return false;
  }
  this->currentPartition[indexFirstNonZero - 1] ++;
  this->currentPartitionSum += this->PartitioningRoots[indexFirstNonZero - 1];
  this->currentPartitionSum -= this->PartitioningRoots[indexFirstNonZero] * this->currentPartition[indexFirstNonZero];
  this->currentPartition[indexFirstNonZero] = 0;
  return true;
}

bool VectorPartition::incrementReturnFalseIfPastLast() {
  MacroRegisterFunctionWithName("VectorPartition::incrementReturnFalseIfPastLast");
  if (this->currentPartitionSum == this->goalVector) {
    this->NudgePartition();
  }
  while (true) {
    this->BeefUpPartition();
    if (this->currentPartitionSum == this->goalVector) {
      return true;
    }
    if (!this->NudgePartition()) {
      return false;
    }
  }
  // return false;
}

std::string VectorPartition::ToStringPartitioningVectors() {
  MacroRegisterFunctionWithName("VectorPartition::ToStringPartitioningVectors");
  std::stringstream out;
  for (int i = 0; i < this->PartitioningRoots.size; i ++) {
    out << "e_{" << i + 1 << "}=" << this->PartitioningRoots[i].toString() << "<br>";
  }
  out << "<hr>";
  out << "Looking for partitions of: " << this->goalVector.toString();
  out << "<hr>";
  return out.str();
}

std::string VectorPartition::ToStringOnePartition(const List<int>& currentPartition) {
  Vector<Rational> theV;
  theV = currentPartition;
  return theV.toStringLetterFormat("e");
}

std::string VectorPartition::ToStringAllPartitions(bool useHtml) {
  MacroRegisterFunctionWithName("VectorPartition::toString");
  std::stringstream out;
  out << this->goalVector.toString() << "\n\n";
  if (useHtml) {
    out << "<br>";
  }
  for (int i = 0; i < this->thePartitions.size; i ++) {
    out << "=";
    out << this->ToStringOnePartition(this->thePartitions[i]);
    out << "\n\n";
    if (useHtml) {
      out << "<br>\n";
    }
  }
  return out.str();
}

void RootIndexToPoly(int theIndex, SemisimpleLieAlgebra& theAlgebra, Polynomial<Rational>& output) {
  int theRank = theAlgebra.theWeyl.cartanSymmetric.numberOfRows;
  int numPosRoots = theAlgebra.theWeyl.RootsOfBorel.size;
  output.makeDegreeOne(theRank + numPosRoots, theIndex + theRank, Rational(1));
}

template <class Coefficient>
void ElementUniversalEnveloping<Coefficient>::assignFromCoordinateFormWithRespectToBasis(
  List<ElementUniversalEnveloping<Coefficient> >& theBasis, Vector<Coefficient>& input, SemisimpleLieAlgebra& owner
) {
  this->makeZero(owner);
  ElementUniversalEnveloping<Coefficient> tempElt;
  for (int i = 0; i < input.size; i ++) {
    if (!input[i].isEqualToZero()) {
      tempElt.operator=(theBasis[i]);
      tempElt.operator*=(input[i]);
      this->operator+=(tempElt);
    }
  }
}

bool SemisimpleLieAlgebraOrdered::checkInitialization() const {
  if (this->theOwner == nullptr) {
    global.fatal << "Use of semisimple Lie algebra without an owner. " << global.fatal;
  }
  if (this->theOwner->flagDeallocated) {
    global.fatal << "Use after free of semisimple Lie algebra. ";
  }
  return true;
}

void SemisimpleLieAlgebraOrdered::getLinearCombinationFrom(
  ElementSemisimpleLieAlgebra<Rational>& input, Vector<Rational>& theCoeffs
) {
  this->checkInitialization();
  theCoeffs.makeZero(this->theOwner->getNumberOfGenerators());
  for (int i = 0; i < input.size(); i ++) {
    int theIndex = input[i].theGeneratorIndex;
    theCoeffs[this->theOwner->getGeneratorFromRootIndex(theIndex)] = input.coefficients[i];
  }
  int numPosRoots = this->theOwner->getNumberOfPositiveRoots();
  Vector<Rational> tempH = input.getCartanPart();
  for (int i = 0; i < this->theOwner->getRank(); i ++) {
    theCoeffs[numPosRoots + i] = tempH[i];
  }
  this->ChevalleyGeneratorsInCurrentCoords.actOnVectorColumn(theCoeffs);
}

int SemisimpleLieAlgebraOrdered::getDisplayIndexFromGeneratorIndex(int GeneratorIndex) {
  int numPosRoots = this->theOwner->getNumberOfPositiveRoots();
  int posRootsPlusRank = numPosRoots + this->theOwner->getRank();
  if (GeneratorIndex >= posRootsPlusRank) {
    return GeneratorIndex - posRootsPlusRank + 1;
  }
  if (GeneratorIndex >= numPosRoots) {
    return GeneratorIndex + 1;
  }
  return - numPosRoots + GeneratorIndex;
}

void SemisimpleLieAlgebraOrdered::initialize(
  List<ElementSemisimpleLieAlgebra<Rational> >& inputOrder, SemisimpleLieAlgebra& owner
) {
  global.fatal << "not implemented" << global.fatal;
  if (inputOrder.size != owner.getNumberOfGenerators()) {
    return;
  }
  this->theOwner = &owner;
  this->theOrder = inputOrder;
  this->ChevalleyGeneratorsInCurrentCoords.initialize(owner.getNumberOfGenerators(), owner.getNumberOfGenerators());
  this->ChevalleyGeneratorsInCurrentCoords.makeZero();
  Vector<Rational> coordsInCurrentBasis;
  ElementSemisimpleLieAlgebra<Rational> currentElt;
  for (int i = 0; i < owner.getNumberOfGenerators(); i ++) {
    currentElt.makeGenerator(i, owner);
    currentElt.getCoordinatesInBasis(this->theOrder, coordsInCurrentBasis);
    for (int j = 0; j < coordsInCurrentBasis.size; j ++) {
      this->ChevalleyGeneratorsInCurrentCoords.elements[j][i] = coordsInCurrentBasis[j];
    }
  }
}

void SemisimpleLieAlgebraOrdered::initDefaultOrder(SemisimpleLieAlgebra& owner) {
  List<ElementSemisimpleLieAlgebra<Rational> > defaultOrder;
  defaultOrder.setSize(owner.getNumberOfGenerators());
  for (int i = 0; i < defaultOrder.size; i ++) {
    ElementSemisimpleLieAlgebra<Rational>& currentElt = defaultOrder[i];
    currentElt.makeGenerator(i, owner);
  }
  this->initialize(defaultOrder, owner);
}

template <class Coefficient>
bool ElementSemisimpleLieAlgebra<Coefficient>::isCoefficientOneChevalleyGenerator() {
  if (this->size == 1) {
    return this->coefficients[0] == 1;
  }
  return false;
}

void HomomorphismSemisimpleLieAlgebra::GetWeightsWrtKInSimpleCoordsK(
  Vectors<Rational>& outputWeights, List<ElementSemisimpleLieAlgebra<Rational> >& inputElts
) {
  outputWeights.setSize(inputElts.size);
  Rational tempRat;
  ElementSemisimpleLieAlgebra<Rational> tempLieElement;
  for (int i = 0; i < inputElts.size; i ++) {
    Vector<Rational>& currentWeight = outputWeights[i];
    currentWeight.makeZero(this->theDomain().getRank());
    ElementSemisimpleLieAlgebra<Rational>& currentLieElt = inputElts[i];
    for (int j = 0; j < this->theDomain().getRank(); j ++) {
      this->theRange().lieBracket(
        this->imagesAllChevalleyGenerators[j + this->theDomain().getNumberOfPositiveRoots()],
        currentLieElt,
        tempLieElement
      );
      if (!currentLieElt.isProportionalTo(tempLieElement, tempRat)) {
        global.fatal << "Lie algebra elements not proportional as expected. " << global.fatal;
      }
      currentWeight[j] = tempRat;
    }
  }
  Matrix<Rational> tempMat = this->theDomain().theWeyl.cartanSymmetric;
  tempMat.invert();
  tempMat.actOnVectorsColumn(outputWeights);
}

template <class Coefficient>
void ElementSemisimpleLieAlgebra<Coefficient>::getBasisFromSpanOfElements(
  List<ElementSemisimpleLieAlgebra>& theElements,
  List<ElementSemisimpleLieAlgebra>& outputTheBasis
) {
  Vectors<Rational> theRootForm;
  theRootForm.setSize(theElements.size);
  for (int i = 0; i < theElements.size; i ++) {
    ElementSemisimpleLieAlgebra& currentElt = theElements[i];
    currentElt.elementToVectorNegativeRootSpacesFirst(theRootForm[i]);
  }
//  int theRank = 0; int numRoots = 0;
//  if (theElements.size > 0)
//  { theRank = theElements.theObjects[0].Hcomponent.size;
//    numRoots = theElements.theObjects[0].coeffsRootSpaces.size;
//  }
  theRootForm.chooseABasis();
  outputTheBasis.setSize(theRootForm.size);
  for (int i = 0; i < theRootForm.size; i ++) {
    ElementSemisimpleLieAlgebra& currentElt = outputTheBasis[i];
    currentElt.assignVectorNegRootSpacesCartanPosRootSpaces(
      theRootForm[i], (*currentElt.ownerArray)[currentElt.indexOfOwnerAlgebra]
    );
  }

}

template <class Coefficient>
bool ElementSemisimpleLieAlgebra<Coefficient>::needsParenthesisForMultiplication() const {
  return this->size > 1;
}

void SlTwoInSlN::ClimbDownFromHighestWeightAlongSl2String(
  Matrix<Rational>& input, Matrix<Rational>& output, Rational& outputCoeff, int generatorPower
) {
  MacroRegisterFunctionWithName("SlTwoInSlN::ClimbDownFromHighestWeightAlongSl2String");
  if (&input == &output) {
    global.fatal << "Input coincides with output. " << global.fatal;
  }
  Rational currentWeight;
  Matrix<Rational>::lieBracket(this->theH, input, output);
  bool tempBool = input.isProportionalTo(output, currentWeight);
  if (!tempBool) {
    global.comments << "<br>Climbing down does not work as expected!";
  }
  Rational RaiseCoeff;
  RaiseCoeff.makeZero();
  outputCoeff.makeOne();
  output = input;
  for (int i = 0; i < generatorPower; i ++) {
    RaiseCoeff += currentWeight;
    currentWeight -= 2;
    outputCoeff *= RaiseCoeff;
    Matrix<Rational>::lieBracket(this->theF, output, output);
  }
}

std::string SlTwoInSlN::ElementModuleIndexToString(int input, bool useHtml) {
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class =\"math\">";
    endMath = "</span>";
    newLine = "<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  Matrix<Rational>& currentHW = this->theHighestWeightVectors.theObjects[input];
  int currentEtaHw = this->theGmodKModules.theObjects[input].size - 1;
  //currentEtaHw-= currentEtaHw/2;
  int firstNonZeroRow = - 1, firstNonZeroColumn = - 1;
  bool found = false;
  for (int i = 0; i < currentHW.numberOfRows; i ++) {
    if (found) {
      break;
    }
    for (int j = 0; j < currentHW.numberOfColumns; j ++) {
      if (!currentHW.elements[i][j].isEqualToZero()) {
        firstNonZeroColumn = j;
        firstNonZeroRow = i;
        found = true;
        break;
      }
    }
  }
  int sRow, kRow, sColumn, kColumn;
  this->GetIsPlusKIndexingFrom(firstNonZeroRow, sRow, kRow);
  this->GetIsPlusKIndexingFrom(firstNonZeroColumn, sColumn, kColumn);
  std::stringstream out;
  out << "V_{";
  if (currentEtaHw != 0) {
    if (currentEtaHw != 1) {
      out << currentEtaHw;
    }
    out << "\\frac\\eta 2";
  }
  if (sRow != sColumn) {
    out << "-\\zeta_" << sColumn << "+\\zeta_" << sRow;
  }
  out << "}";
  return out.str();
}

void SlTwoInSlN::GetIsPlusKIndexingFrom(int input, int& s, int& k) {
  s = 0;
  k = input;
  if (input >= this->theDimension || input < 0) {
    return;
  }
  for (int offset = 0; offset <= input; offset += this->thePartition[s - 1]) {
    k = input - offset;
    s ++;
  }
}

std::string SlTwoInSlN::ElementMatrixToTensorString(const Matrix<Rational>& input, bool useHtml) {
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class =\"math\">";
    endMath = "</span>";
    newLine ="<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  std::stringstream out;
  std::string tempS;
  bool found = false;
  for (int i = 0; i < input.numberOfRows; i ++) {
    for (int j = 0; j < input.numberOfColumns; j ++) {
      if (!input.elements[i][j].isEqualToZero()) {
        tempS = input.elements[i][j].toString();
        if (tempS == "- 1" || tempS == "-1") {
          tempS = "-";
        }
        if (tempS == "1") {
          tempS = "";
          if (found) {
            out << "+";
          }
        } else {
          if (found) {
            if (tempS[0] != '-') {
              out << "+";
            }
          }
        }
        found = true;
        out << tempS;
        int sI, kI, sJ, kJ;
        this->GetIsPlusKIndexingFrom(i, sI, kI);
        this->GetIsPlusKIndexingFrom(j, sJ, kJ);
        out << "v_{i_{" << sI << "}";
        if (kI != 0) {
          out << "+" << kI;
        }
        out << "}\\otimes v^*_{i_{" << sJ << "}";
        if (kJ != 0) {
          out  << "+" << kJ;
        }
        out << "}";
      }
    }
  }
  return out.str();
}

void SlTwoInSlN::ExtractHighestWeightVectorsFromVector(
  Matrix<Rational>& input, List<Matrix<Rational> >& outputDecompositionOfInput, List<Matrix<Rational> >& outputTheHWVectors
) {
  outputDecompositionOfInput.size = 0;
  outputTheHWVectors.size = 0;
  Matrix<Rational> remainder;
  remainder = input;
  Matrix<Rational> component, highestWeightVector, tempMat;
  Rational theCoeff, tempRat;
  int largestPowerNotKillingInput;
  while (!remainder.isEqualToZero() ) {
    this->ClimbUpFromVector(remainder, highestWeightVector, largestPowerNotKillingInput);
    this->ClimbDownFromHighestWeightAlongSl2String(highestWeightVector, component, theCoeff, largestPowerNotKillingInput);
    for (int i = 0; i < this->theProjectors.size; i ++) {
      Matrix<Rational>& currentProjector = this->theProjectors[i];
      tempMat = highestWeightVector;
      tempMat.multiplyOnTheLeft(currentProjector);
      if (!tempMat.isEqualToZero()) {
        tempMat.findFirstNonZeroElementSearchEntireRow(tempRat);
        tempMat /= tempRat;
        outputTheHWVectors.addOnTop(tempMat);
      }
    }
    global.fatal << "Extract highest vector not fully implemented yet. " << global.fatal;
    component /= theCoeff;
    outputDecompositionOfInput.addOnTop(component);
    remainder -= component;
  }
  //remainder.makeZero();
//  for (int i = 0; i <outputVectors.size; i ++)
//    remainder.Add(outputVectors.theObjects[i]);

}

void SlTwoInSlN::ClimbUpFromVector(Matrix<Rational>& input, Matrix<Rational>& outputLastNonZero, int& largestPowerNotKillingInput) {
  Matrix<Rational>  tempMat;
  if (&input == &outputLastNonZero) {
    global.fatal << "Input not allowed to coincide with the output. " << global.fatal;
  }
  outputLastNonZero = input;
  largestPowerNotKillingInput = 0;
  for (
    Matrix<Rational>::lieBracket(this->theE, outputLastNonZero, tempMat);
    !tempMat.isEqualToZero();
    Matrix<Rational>::lieBracket(this->theE, outputLastNonZero, tempMat)
  ) {
    largestPowerNotKillingInput ++;
    outputLastNonZero = tempMat;
  }
}

std::string SlTwoInSlN::GetNotationString(bool useHtml) {
  std::stringstream out;
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class =\"math\">";
    endMath = "</span>";
    newLine ="<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  out << newLine << "Let the starting index of the j-th block be " << beginMath << "i_j" << endMath;
  out << "." << newLine << "In particular let: ";
  int offset = 1;
  for (int i = 0; i < this->thePartition.size; i ++) {
    out << beginMath << "i_" << i + 1 << "=" << offset << endMath << " ";
    out << " (size of block = " << this->thePartition[i] << "), ";
    offset += this->thePartition[i];
  }
  out << newLine << "Let " << beginMath << "\\eta" << endMath << " be the weight corresponding to h.";
  out << newLine << "Let " << beginMath << "\\zeta_{j}" << endMath << " be the weight corresponding to the j-th block";
  return out.str();
}

std::string SlTwoInSlN::initFromModuleDecomposition(List<int>& decompositionDimensions, bool useHtml, bool computePairingTable) {
  std::stringstream out;
  this->thePartition = decompositionDimensions;
  this->thePartition.quickSortDescending();
  this->theDimension = 0;
  for (int i = 0; i < this->thePartition.size; i ++) {
    this->theDimension += this->thePartition[i];
  }
  theH.initialize(this->theDimension, this->theDimension);
  theH.makeZero();
  theE.initialize(this->theDimension, this->theDimension);
  theE.makeZero();
  theF.initialize(this->theDimension, this->theDimension);
  theF.makeZero();
  this->theProjectors.setSize(this->thePartition.size);
  int currentOffset = 0;
  std::string beginMath, endMath, newLine;
  if (useHtml) {
    beginMath = "<span class =\"math\">";
    endMath = "</span>";
    newLine = "<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  for (int i = 0; i < this->thePartition.size; i ++) {
    this->theProjectors[i].initialize(this->theDimension, this->theDimension);
    this->theProjectors[i].makeZero();
    for (int j = 0; j < this->thePartition[i]; j ++) {
      theH.elements[currentOffset + j][currentOffset + j] = this->thePartition[i] - 1 - 2 * j;
      this->theProjectors[i].elements[currentOffset + j][currentOffset + j] = 1;
      if (j != this->thePartition[i] - 1) {
        theF.elements[currentOffset + j + 1][currentOffset + j] = 1;
        theE.elements[currentOffset + j][currentOffset + j + 1] = (j + 1) * (this->thePartition[i] - j - 1);
      }
    }
    currentOffset += this->thePartition[i];
  }
  out << newLine << beginMath << "h =" << this->ElementMatrixToTensorString(this->theH, useHtml) << "="
  << this->theH.toStringWithBlocks(this->thePartition) << endMath;
  out << newLine << beginMath << "e =" << this->ElementMatrixToTensorString(this->theE, useHtml) << "="
  << this->theE.toStringWithBlocks(this->thePartition) << endMath;
  out << newLine << beginMath << "f =" << this->ElementMatrixToTensorString(this->theF, useHtml) << "="
  << this->theF.toStringWithBlocks(this->thePartition) << endMath;
  Matrix<Rational>  tempMat;
  tempMat.initialize(this->theDimension, this->theDimension);
  List<Matrix<Rational> > Decomposition, theHwCandidatesBeforeProjection, theHwCandidatesProjected;
  this->theHighestWeightVectors.size = 0;
  this->theGmodKModules.size = 0;
  for (int i = 0; i < this->theDimension; i ++) {
    for (int j = 0; j < this->theDimension; j ++) {
      tempMat.makeZero();
      tempMat.elements[i][j] = 1;
      this->ExtractHighestWeightVectorsFromVector(tempMat, Decomposition, theHwCandidatesBeforeProjection);
      theHwCandidatesProjected.size = 0;
      for (int k = 0; k < theHwCandidatesBeforeProjection.size; k ++) {
        for (int l = 0; l < this->theProjectors.size; l ++) {
          tempMat = theHwCandidatesBeforeProjection[k];
          tempMat.multiplyOnTheLeft(this->theProjectors[l]);
          if (!tempMat.isEqualToZero()) {
            theHwCandidatesProjected.addOnTop(tempMat);
          }
        }
      }
      for (int k = 0; k < theHwCandidatesProjected.size; k ++) {
        if (this->GetModuleIndexFromHighestWeightVector(theHwCandidatesProjected[k]) == - 1) {
          Matrix<Rational>& currentHighest = theHwCandidatesProjected[k];
          this->theHighestWeightVectors.addOnTop(currentHighest);
          this->theGmodKModules.expandOnTop(1);
          List<Matrix<Rational> >& currentMod = *this->theGmodKModules.lastObject();
          currentMod.size = 0;
          for (
            tempMat = currentHighest;
            !tempMat.isEqualToZero();
            Matrix<Rational>::lieBracket(this->theF, tempMat, tempMat)
          ) {
            currentMod.addOnTop(tempMat);
          }
        }
      }
    }
  }
  out << this->GetNotationString(useHtml);
  out << newLine << "...and the highest weights of the module decomposition are ("
  << this->theHighestWeightVectors.size << " modules):";
  for (int i = 0; i < this->theHighestWeightVectors.size; i ++) {
    out << newLine << beginMath << this->ElementMatrixToTensorString(theHighestWeightVectors[i], useHtml)
    << endMath << ", highest weight of ";
    out << beginMath << this->ElementModuleIndexToString(i, useHtml) << endMath;
  }
  if (computePairingTable) {
    out << this->initPairingTable(useHtml);
  }
  return out.str();
}

std::string SlTwoInSlN::initPairingTable(bool useHtml) {
  std::stringstream out;
  this->PairingTable.setSize(this->theHighestWeightVectors.size);
  for (int i = 0; i < this->PairingTable.size; i ++) {
    this->PairingTable[i].setSize(this->theHighestWeightVectors.size);
    for (int j = 0; j < this->PairingTable[i].size; j ++) {
      List<int>& currentPairing = this->PairingTable[i][j];
      out << this->PairTwoIndices(currentPairing, i, j, useHtml);
    }
  }
  return out.str();
}

std::string SlTwoInSlN::PairTwoIndices(List<int>& output, int leftIndex, int rightIndex, bool useHtml) {
  std::string beginMath, endMath, newLine;
  FormatExpressions latexFormat;
  latexFormat.flagUseLatex = true;
  latexFormat.flagUseHTML = false;
  if (useHtml) {
    beginMath = "<span class =\"math\">";
    endMath = "</span>";
    newLine = "<br>";
  } else {
    beginMath = "$";
    endMath = "$";
    newLine = "\n\n\n";
  }
  std::stringstream out;
  output.size = 0;
  List<Matrix<Rational> >& leftElements = this->theGmodKModules[leftIndex];
  List<Matrix<Rational> >& rightElements = this->theGmodKModules[rightIndex];
  Matrix<Rational> tempMat;
  List<Matrix<Rational> > HighestWeightsContainingModules;
  List<Matrix<Rational> > tempDecomposition;
  for (int i = 0; i < leftElements.size; i ++) {
    for (int j = 0; j < rightElements.size; j ++) {
      Matrix<Rational>& leftElt = leftElements[i];
      Matrix<Rational>& rightElt = rightElements[j];
      Matrix<Rational>::lieBracket(leftElt, rightElt, tempMat);
      if (!tempMat.isEqualToZero()) {
        this->ExtractHighestWeightVectorsFromVector(tempMat, tempDecomposition, HighestWeightsContainingModules);
        for (int k = 0; k < HighestWeightsContainingModules.size; k ++) {
          output.addOnTopNoRepetition(this->GetModuleIndexFromHighestWeightVector(HighestWeightsContainingModules[k]));
          if (this->GetModuleIndexFromHighestWeightVector(HighestWeightsContainingModules[k]) == - 1) {
            global.comments << newLine << beginMath << "[" << leftElt.toString(&latexFormat) << ", "
            << rightElt.toString(&latexFormat) << "] =" << tempMat.toString(&latexFormat) << endMath;
          }
        }
      }
    }
  }
  out << newLine << beginMath << this->ElementModuleIndexToString(leftIndex, useHtml) << endMath << " and "
  << beginMath << this->ElementModuleIndexToString(rightIndex, useHtml) << endMath << " pair to: ";
  for (int i = 0; i <output.size; i ++) {
    out << beginMath << this->ElementModuleIndexToString(output[i], useHtml) << endMath;
    if (i != output.size - 1) {
      out << beginMath << "\\oplus" << endMath;
    }
  }
  if (output.size > 0) {
    out << "  hw vectors: ";
    for (int i = 0; i < output.size; i ++) {
      out << beginMath << this->ElementMatrixToTensorString(this->theHighestWeightVectors[output[i]], useHtml)
      << endMath << ",";
    }
  }
  return out.str();
}

void MonomialP::makeEi(int LetterIndex, int Power, int ExpectedNumVars) {
  (void) ExpectedNumVars;
  this->makeOne();
  if (Power == 0) {
    return;
  }
  this->setVariable(LetterIndex, Power);
}

void MonomialP::setVariable(int variableIndex, const Rational& power) {
  if (variableIndex >= this->monBody.size) {
    this->setSize(variableIndex + 1);
  }
  this->monBody[variableIndex] = power;
  this->trimTrailingZeroes();
}

void MonomialP::multiplyByVariable(int variableIndex, const Rational& variablePower) {
  if (variablePower.isEqualToZero()) {
    return;
  }
  if (variableIndex >= this->monBody.size) {
    this->setSize(variableIndex);
  }
  this->monBody[variableIndex] += variablePower;
  this->trimTrailingZeroes();
}

const Rational& MonomialP::operator[](int i) const {
  if (i < 0 || i >= this->monBody.size) {
    global.fatal << "This is a programming error: requested exponent "
    << "of monomial variable with index "
    << i << " which is out of range (size = "
    << this->monBody.size
    << "). " << global.fatal;
  }
  return this->monBody[i];
}

Rational MonomialP::operator()(int i) const {
  if (i < 0) {
    global.fatal << "This is a programming error: "
    << "requested exponent of monomial variable "
    << "with index " << i << " which is negative. " << global.fatal;
  }
  if (i >= this->monBody.size) {
    return 0;
  }
  return this->monBody[i];
}

bool MonomialP::hasPositiveOrZeroExponents() const {
  for (int i = 0; i < this->monBody.size; i ++) {
    if (this->monBody[i].isNegative()) {
      return false;
    }
  }
  return true;
}

void MonomialP::exponentMeBy(const Rational& theExp) {
  for (int i = 0; i < this->monBody.size; i ++) {
    this->monBody[i] *= theExp;
  }
}

bool MonomialP::operator>(const MonomialP& other) const {
  return MonomialP::greaterThan_totalDegree_leftLargerWins(*this, other);
}

bool MonomialP::isDivisibleBy(const MonomialP& other) const {
  for (int i = other.monBody.size - 1; i >= this->monBody.size; i --) {
    if (other.monBody[i] > 0) {
      return false;
    }
  }
  int upperLimit = MathRoutines::minimum(this->monBody.size, other.monBody.size);
  for (int i = 0; i < upperLimit; i ++) {
    if (this->monBody[i] < other.monBody[i]) {
      return false;
    }
  }
  return true;
}

bool MonomialP::operator==(const MonomialP& other) const {
  for (int i = other.monBody.size - 1; i >= this->monBody.size; i --) {
    if (other.monBody[i] != 0) {
      return false;
    }
  }
  for (int i = this->monBody.size - 1; i >= other.monBody.size; i --) {
    if (this->monBody[i] != 0) {
      return false;
    }
  }
  int highestIndex = MathRoutines::minimum(this->minimalNumberOfVariables(), other.minimalNumberOfVariables()) - 1;
  for (int i = highestIndex; i >= 0; i --) {
    if (this->monBody[i] != other.monBody[i]) {
      return false;
    }
  }
  return true;
}

bool MonomialP::greaterThan_totalDegree_rightSmallerWins(
  const MonomialP& left, const MonomialP& right
) {
  if (left == right) {
    return false;
  }
  if (left.totalDegree() > right.totalDegree()) {
    return true;
  }
  if (left.totalDegree() < right.totalDegree()) {
    return false;
  }
  return !MonomialP::greaterThan_rightLargerWins(left, right);
}

// "Graded lexicographic" order.
bool MonomialP::greaterThan_totalDegree_leftLargerWins(
  const MonomialP& left, const MonomialP& right
) {
  if (left.totalDegree() > right.totalDegree()) {
    return true;
  }
  if (left.totalDegree() < right.totalDegree()) {
    return false;
  }
  return left.greaterThan_leftLargerWins(right);
}


bool MonomialP::greaterThan_rightLargerWins(const MonomialP& other) const {
  for (int i = other.monBody.size - 1; i >= this->monBody.size; i --) {
    if (other.monBody[i] > 0) {
      return false;
    }
    if (other.monBody[i] < 0) {
      return true;
    }
  }
  for (int i = this->monBody.size - 1; i >= other.monBody.size; i --) {
    if (this->monBody[i] > 0) {
      return true;
    }
    if (this->monBody[i] < 0) {
      return false;
    }
  }
  int highestIndex = MathRoutines::minimum(
    this->minimalNumberOfVariables(), other.minimalNumberOfVariables()
  ) - 1;
  for (int i = highestIndex; i >= 0; i --) {
    if (this->monBody[i] > other.monBody[i]) {
      return true;
    }
    if (this->monBody[i] < other.monBody[i]) {
      return false;
    }
  }
  return false;
}

List<MonomialP>::Comparator& MonomialP::orderDefault() {
  static List<MonomialP>::Comparator result(MonomialP::greaterThan_totalDegree_leftLargerWins);
  return result;
}

List<MonomialP>::Comparator& MonomialP::orderForGreatestCommonDivisor() {
  static List<MonomialP>::Comparator result(MonomialP::greaterThan_rightLargerWins);
  return result;
}

List<MonomialP>::Comparator& MonomialP::orderDegreeThenLeftLargerWins() {
  static List<MonomialP>::Comparator result(MonomialP::greaterThan_totalDegree_leftLargerWins);
  return result;
}

bool MonomialP::greaterThan_leftLargerWins(const MonomialP &other) const {
  int commonSize = MathRoutines::minimum(
    this->minimalNumberOfVariables(), other.minimalNumberOfVariables()
  );
  for (int i = 0; i < commonSize; i ++) {
    if (this->monBody[i] > other.monBody[i]) {
      return true;
    }
    if (this->monBody[i] < other.monBody[i]) {
      return false;
    }
  }
  for (int i = this->monBody.size; i < other.monBody.size; i ++) {
    if (other.monBody[i] > 0) {
      return false;
    }
    if (other.monBody[i] < 0) {
      return true;
    }
  }
  for (int i = other.monBody.size; i < this->monBody.size; i ++) {
    if (this->monBody[i] > 0) {
      return true;
    }
    if (this->monBody[i] < 0) {
      return false;
    }
  }
  return false;
}

void MonomialP::trimTrailingZeroes() {
  for (int i = this->monBody.size - 1; i >= 0; i --) {
    if (this->monBody[i] != 0) {
      break;
    }
    this->monBody.setSize(this->monBody.size - 1);
  }
}

bool MonomialP::hasSmallIntegralPositivePowers(int* whichtotalDegree) const {
  for (int i = 0; i < this->monBody.size; i ++) {
    if (!this->monBody[i].isIntegerFittingInInt(nullptr)) {
      return false;
    }
    if (this->monBody[i] < 0) {
      return false;
    }
  }
  return this->totalDegree().isIntegerFittingInInt(whichtotalDegree);
}

void MonomialP::raiseToPower(const Rational& thePower) {
  for (int i = 0; i < this->monBody.size; i ++) {
    this->monBody[i] *= thePower;
  }
  this->trimTrailingZeroes();
}

void MonomialP::operator*=(const MonomialP& other) {
  this->setSize(MathRoutines::maximum(this->monBody.size, other.monBody.size));
  for (int i = 0; i < other.monBody.size; i ++) {
    this->monBody[i] += other.monBody[i];
  }
  this->trimTrailingZeroes();
}

void MonomialP::operator/=(const MonomialP& other) {
  this->setSize(MathRoutines::maximum(this->monBody.size, other.monBody.size));
  for (int i = 0; i < other.monBody.size; i ++) {
    this->monBody[i] -= other.monBody[i];
  }
  this->trimTrailingZeroes();
}

void MonomialP::setSize(int variableCount) {
  if (variableCount < 0) {
    variableCount = 0;
  }
  int oldSize = this->monBody.size;
  this->monBody.setSize(variableCount);
  for (int i = oldSize; i < this->monBody.size; i ++) {
    this->monBody[i] = 0;
  }
}

bool Cone::isInCone(const Vector<Rational>& point) const {
  if (this->flagIsTheZeroCone) {
    return point.isEqualToZero();
  }
  Rational tempRat;
  for (int i = 0; i < this->Normals.size; i ++) {
    tempRat = point.ScalarEuclidean(this->Normals[i]);
    if (tempRat.isNegative()) {
      return false;
    }
  }
  return true;
}

std::string MonomialP::toString(FormatExpressions* theFormat) const {
  std::stringstream out;
  MemorySaving<FormatExpressions> tempFormat;
  if (theFormat == nullptr) {
    theFormat = &tempFormat.getElement();
  }
  if (this->isConstant()) {
    return "1";
  }
  for (int i = 0; i < this->monBody.size; i ++) {
    if (!(this->monBody[i].isEqualToZero())) {
      out << theFormat->GetPolyLetter(i);
      if (!(this->monBody[i] == 1)) {
        out << "^{" << this->monBody[i] << "}";
      } else {
        out << " ";
      }
    }
  }
  return out.str();
}
